<!DOCTYPE html><html class="appearance-auto" lang="chinese"><head><meta charset="UTF-8"><title>Pytorch--基础指北_肆</title><meta name="description" content="YOU CAN REDO"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-E0GBC11CTD', 'neonexusx.github.io');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + '1c102c8d6549c8317b34036a36f85904';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Pytorch ——基础指北_肆



软件环境：
配套代码下载地址：
基础知识：

一点Python

Python的面向对象
Python的self关键字
Python创建实例对象
Python类的方法
Python访问类的属性和方法
Python内置类和属性
Python基础方法
Python类的实例化与self参数

self参数
实例化的初始化方法
初始化的同时设置初始值


Pyhton的继承
Pthony的__ call__方法
单下划线、双下划线、头尾双下划线的说明




Pytorch API 实现基础模型

nn.Module

nn.Module的使用
什么是batch_size，什么是features？
torch.optim类
如何构造和使用optimizer？
model的参数.."><script src="//unpkg.com/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">NeoNexus's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Pytorch--基础指北_肆</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Pytorch ——基础指北_肆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">软件环境：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">配套代码下载地址：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">基础知识：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">一点Python</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">Python的面向对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">Python的self关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">Python创建实例对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">Python类的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">Python访问类的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">Python内置类和属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">Python基础方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">Python类的实例化与self参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">self参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">实例化的初始化方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">初始化的同时设置初始值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">Pyhton的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">Pthony的__ call__方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">单下划线、双下划线、头尾双下划线的说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">Pytorch API 实现基础模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">nn.Module</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">nn.Module的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">什么是batch_size，什么是features？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">torch.optim类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">如何构造和使用optimizer？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">model的参数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">optimizer的使用：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">损失函数类的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">如何使用内置的loss函数的类来进行计算？</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Pytorch"><i class="tag post-item-tag">Pytorch</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Pytorch--基础指北_肆</h1><time class="has-text-grey" datetime="2024-09-27T16:00:00.000Z">2024-09-28</time><article class="mt-2 post-content"><h1><span id="pytorch-基础指北_肆">Pytorch ——基础指北_肆</span></h1>
<img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;">
<!-- toc -->
<ul>
<li><a href="#%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83">软件环境：</a></li>
<li><a href="#%E9%85%8D%E5%A5%97%E4%BB%A3%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80">配套代码下载地址：</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识：</a>
<ul>
<li><a href="#%E4%B8%80%E7%82%B9python">一点Python</a>
<ul>
<li><a href="#python%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">Python的面向对象</a></li>
<li><a href="#python%E7%9A%84self%E5%85%B3%E9%94%AE%E5%AD%97">Python的self关键字</a></li>
<li><a href="#python%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1">Python创建实例对象</a></li>
<li><a href="#python%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">Python类的方法</a></li>
<li><a href="#python%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">Python访问类的属性和方法</a></li>
<li><a href="#python%E5%86%85%E7%BD%AE%E7%B1%BB%E5%92%8C%E5%B1%9E%E6%80%A7">Python内置类和属性</a></li>
<li><a href="#python%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95">Python基础方法</a></li>
<li><a href="#python%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%8Eself%E5%8F%82%E6%95%B0">Python类的实例化与self参数</a>
<ul>
<li><a href="#self%E5%8F%82%E6%95%B0">self参数</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95">实例化的初始化方法</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%80%BC">初始化的同时设置初始值</a></li>
</ul>
</li>
<li><a href="#pyhton%E7%9A%84%E7%BB%A7%E6%89%BF">Pyhton的继承</a></li>
<li><a href="#pthony%E7%9A%84__-call__%E6%96%B9%E6%B3%95">Pthony的__ call__方法</a></li>
<li><a href="#%E5%8D%95%E4%B8%8B%E5%88%92%E7%BA%BF-%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF-%E5%A4%B4%E5%B0%BE%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E8%AF%B4%E6%98%8E">单下划线、双下划线、头尾双下划线的说明</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pytorch-api-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B">Pytorch API 实现基础模型</a>
<ul>
<li><a href="#nnmodule">nn.Module</a>
<ul>
<li><a href="#nnmodule%E7%9A%84%E4%BD%BF%E7%94%A8">nn.Module的使用</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFbatch_size%E4%BB%80%E4%B9%88%E6%98%AFfeatures">什么是batch_size，什么是features？</a></li>
<li><a href="#torchoptim%E7%B1%BB">torch.optim类</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0%E5%92%8C%E4%BD%BF%E7%94%A8optimizer">如何构造和使用optimizer？</a></li>
<li><a href="#model%E7%9A%84%E5%8F%82%E6%95%B0"><strong>model</strong>的参数：</a></li>
<li><a href="#optimizer%E7%9A%84%E4%BD%BF%E7%94%A8">optimizer的使用：</a></li>
<li><a href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8">损失函数类的使用</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E7%9A%84loss%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97">如何使用内置的loss函数的类来进行计算？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>[TOC]</p>
<h2><span id="软件环境">软件环境：</span></h2>
<ul>
<li><strong>pytorch 1.10</strong></li>
<li><strong>pycharm</strong></li>
</ul>
<h2><span id="配套代码下载地址">配套代码下载地址：</span></h2>
<p><a target="_blank" rel="noopener" href="https://gitee.com/jszszzy/pytorch-study">gitee-pytorch</a></p>
<h2><span id="基础知识">基础知识：</span></h2>
<h3><span id="一点python">一点Python</span></h3>
<h4><span id="python的面向对象">Python的面向对象</span></h4>
<pre><code class="language-python">class ClassName:
   '类的帮助信息'#类文档字符串
   class_suite #类体
</code></pre>
<p>类的帮助信息可以通过ClassName.__ doc __查看。</p>
<p><strong>class_suite</strong> 由类成员，方法，数据属性组成。</p>
<h4><span id="python的self关键字">Python的self关键字</span></h4>
<p><strong>self</strong>代表类的实例，而非类。常用于在类的定义中指代对象。</p>
<h4><span id="python创建实例对象">Python创建实例对象</span></h4>
<p>实例化类其他编程语言中一般用关键字 <strong>new</strong>，但是在 <strong>Python</strong> 中并没有这个关键字，类的实例化类似函数调用方式。以下使用类的名称 <strong>Employee</strong> 来实例化，并通过 <strong>init</strong> 方法接收参数。</p>
<pre><code class="language-python">对象变量 = 类名()
</code></pre>
<h4><span id="python类的方法">Python类的方法</span></h4>
<p>在类的内部，使用 <strong>def</strong> 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数。</p>
<h4><span id="python访问类的属性和方法">Python访问类的属性和方法</span></h4>
<p>可以使用点号 <strong>.</strong> 来访问对象的属性。使用如下类的名称访问类变量:</p>
<pre><code class="language-python">emp1.displayEmployee()
emp2.displayEmployee()
print "Total Employee %d" % Employee.empCount
</code></pre>
<h4><span id="python内置类和属性">Python内置类和属性</span></h4>
<ul>
<li><strong>dict</strong> : 类的属性（包含一个字典，由类的数据属性组成）</li>
<li><strong>doc</strong> :类的文档字符串</li>
<li><strong>name</strong>: 类名</li>
<li><strong>module</strong>: 类定义所在的模块（类的全名是’<strong>main</strong>.<strong>className</strong>’，如果类位于一个导入模块<strong>mymod</strong>中，那么<strong>className</strong>.<strong>module</strong> 等于 <strong>mymod</strong>）</li>
<li><strong>bases</strong> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</li>
</ul>
<h4><span id="python基础方法">Python基础方法</span></h4>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法名</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td><code>__new__(self)</code></td>
<td>方法</td>
<td><strong>创建对象</strong>时，会被 <strong>自动</strong> 调用</td>
</tr>
<tr>
<td>02</td>
<td><code>__ init__ ( self [,args...] )</code></td>
<td>方法</td>
<td><strong>对象被初始化</strong>时，会被 <strong>自动</strong> 调用</td>
</tr>
<tr>
<td>03</td>
<td><code>__del__(self)</code></td>
<td>方法</td>
<td><strong>对象被从内存中销毁</strong>前，会被 <strong>自动</strong> 调用</td>
</tr>
<tr>
<td>04</td>
<td><code>__str__(self)</code></td>
<td>方法</td>
<td>返回<strong>对象的描述信息</strong>，<code>print</code> 函数输出使用</td>
</tr>
</tbody>
</table>
<h4><span id="python类的实例化与self参数">Python类的实例化与self参数</span></h4>
<h5><span id="self参数">self参数</span></h5>
<ul>
<li>在 <strong>类的外部</strong>，通过 <code>变量名.</code> 访问对象的 <strong>属性和方</strong></li>
<li><strong>调用方法时</strong>，程序员不需要传递 <code>self</code> 参数</li>
<li>在方法内部，<code>self</code> 就表示 <strong>当前调用方法的对象自己</strong>，可以通过 <code>self.</code> <strong>访问对象的属性和方法</strong></li>
</ul>
<h5><span id="实例化的初始化方法">实例化的初始化方法</span></h5>
<ul>
<li>当使用 <code>类名()</code> 创建对象时，会 自动执行以下操作：
<ol>
<li>为对象在内存中 <strong>分配空间</strong> —— 创建对象</li>
<li>为对象的属性 <strong>设置初始值</strong> —— 初始化方法(<code>init</code>)</li>
</ol>
</li>
<li>这个 <strong>初始化方法</strong> 就是 <code>__init__</code> 方法，<code>__init__</code> 是对象的<strong>内置方法</strong></li>
</ul>
<h5><span id="初始化的同时设置初始值">初始化的同时设置初始值</span></h5>
<ul>
<li>
<p>在开发中，如果希望在 创建对象的同时，就设置对象的属性，可以对 初始化方法进行</p>
<p>改造：</p>
<ol>
<li>把希望设置的属性值，定义成 <code>__init__</code> 方法的参数</li>
<li>在方法内部使用 <code>self.属性 = 形参</code> 接收外部传递的参数</li>
<li>在创建对象时，使用 <code>类名(属性1, 属性2...)</code> 调用</li>
</ol>
</li>
</ul>
<h4><span id="pyhton的继承">Pyhton的继承</span></h4>
<p>继承的语法：</p>
<pre><code class="language-python">class 派生类名（基类名）
</code></pre>
<p>子类不重写 <strong>__ init__</strong>，实例化子类时，会自动调用父类定义的 <strong>__ init__</strong>。</p>
<p>重写了**__ init__** 时，实例化子类，就不会调用父类已经定义的 <strong>__ init__</strong>，如果重写了要继承父类的方法时可以使用<strong>super</strong>关键字来继承：</p>
<pre><code class="language-python">super(子类，self).__init__(参数1，参数2，....)
</code></pre>
<p>super并不是一个函数，是一个类名，形如super(B, self)事实上调用了super类的初始化函数，产生了一个super对象；</p>
<p>super类的初始化函数并没有做什么特殊的操作，只是简单记录了类类型和具体实例；</p>
<p>也可以这样：</p>
<pre><code class="language-python">父类名称.__init__(self,参数1，参数2，...)
</code></pre>
<p>举个例子：</p>
<pre><code class="language-python">class Father(object):
    def __init__(self, name):
        self.name=name
        print ( "name: %s" %( self.name))
    def getName(self):
        return 'Father ' + self.name
 
class Son(Father):
    def __init__(self, name):
        super(Son, self).__init__(name)
        print ("hi")
        self.name =  name
    def getName(self):
        return 'Son '+self.name
 
if __name__=='__main__':
    son=Son('runoob')
    print ( son.getName() )
</code></pre>
<p>输出结果：</p>
<pre><code class="language-python">name: runoob
hi
Son runoob
</code></pre>
<h4><span id="pthony的__-call__方法">Pthony的__ call__方法</span></h4>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/python/">Python</a> 类中一个非常特殊的实例方法，即 <strong>call</strong>()。该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。</p>
<h4><span id="单下划线-双下划线-头尾双下划线的说明">单下划线、双下划线、头尾双下划线的说明</span></h4>
<ul>
<li><strong>__ foo __</strong>: 定义的是特殊方法，一般是系统定义名字 ，类似 <strong>__ init__()</strong> 之类的。</li>
<li><strong>_ foo</strong>: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 <strong>from module import *</strong></li>
<li><strong>__foo</strong>: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</li>
</ul>
<h2><span id="pytorch-api-实现基础模型">Pytorch API 实现基础模型</span></h2>
<h3><span id="nnmodule">nn.Module</span></h3>
<p><code>nn.Module</code> 是<code>troch.nn</code>提供的一个类，是pytorch中我们自己定义网络的一个基类。通过整个基类来实现网络可以调用预先实现好的算法,不需要我们考虑太多就可以快速构建和训练。</p>
<h5><span id="nnmodule的使用">nn.Module的使用</span></h5>
<p>1、首先要继承，继承后需要调用super的init方法（重写父类初始化方法），通过调用super的init方法来继承父类中的init的参数</p>
<pre><code class="language-python">from torch import nn
class Lr(nn.Module):
    def __init__(self):
        super(Lr, self).__init__()  #继承父类init的参数
        self.linear = nn.Linear(1, 1) 
</code></pre>
<p>2、<code>farward</code>方法必须实现，用来定义我们的网络的向前计算的过程。</p>
<pre><code class="language-python">	def forward(self, x):
        out = self.linear(x)
        return out
</code></pre>
<p>在讨论这一段代码前我们可以先考虑一个问题：</p>
<h5><span id="什么是batch_size什么是features">什么是batch_size，什么是features？</span></h5>
<ul>
<li>batc_size是指一次训练所取得样本数，每次经过一个batc_size就更新一次参数。</li>
<li>features这里指的是二维数组的列，指的是特征的数量。</li>
<li>样本数量：指的是二维数组的行，就是样本数量。</li>
</ul>
<p>如果一次送进去一列就是features=1，那么batch_size=样本数量。</p>
<p>回到我们的代码，<code>nn.Linear</code>为torch预定义好的线性模型（本质上是一个类），也被称为<strong>全链接层</strong>，传入的参数为输入的数量，输出的数量(in_features, out_features),你可以注意到输入的参数是不算batch_size的行大小，只考虑features的大小。</p>
<p>你可能会疑问，为什么 <strong>self.linear(x)</strong> 是直接调用的对象然后加一个括号？你如果学过<strong>java</strong>就知道方法属于实例，调用方法应该是这样的<code>linear.__ call__</code>,这里举例调用的<code>__call__</code>方法实际上就是等于<code>linear(x)</code>，没错你如果略过了上文的<strong>Pthony的__ call__方法</strong>回去一看便知。</p>
<p><code>nn.Module</code>定义了<code>__call__</code>方法，实现的就是调用<code>forward</code>方法，即<code>Lr</code>的实例，能够直接被传入参数调用，实际上调用的是<code>forward</code>方法并传入参数。</p>
<h5><span id="torchoptim类">torch.optim类</span></h5>
<p><strong>optimizer</strong>类的设计是为了针对<strong>nn.Module</strong>类来实现参数的更新而设计的，可以简单地理解为自动梯度下降器，自动对<strong>nn.Module</strong>中的参数来实现梯度下降等算法来进行更新。</p>
<h5><span id="如何构造和使用optimizer">如何构造和使用optimizer？</span></h5>
<p>要构造一个optimizer需要的参数（先拿常规的SGD来说）有两个分别是：</p>
<pre><code class="language-python">sgd = opt.SGD(params , lr)#params 是需要更新的参数，lr是学习率
</code></pre>
<p>这样就完成了一个针对params的梯度下降优化器。那么如何使用这个梯度下降优化器呢？</p>
<p><strong>sgd</strong>的<strong>step</strong>方法就是起到参数更新的作用，当然在参数更新之前需要先将上一次的梯度置零，其同样也帮我们内置好了<strong>zero_grad</strong>方法，实现一键清零。具体的例子会在下边说明，读到这里你会有一个疑问model的参数怎么获取？</p>
<h5><span id="model的参数"><strong>model</strong>的参数：</span></h5>
<p>获取<strong>model</strong>的参数：</p>
<p>本文中所创建的<strong>model</strong>类型是基于其现有的线性模型所产生的，要获取模型的参数（这里就是<strong>w</strong>和<strong>b</strong>），直接调用<strong>model</strong>的<strong>parameters</strong>方法即可获取所需的参数。</p>
<h5><span id="optimizer的使用">optimizer的使用：</span></h5>
<pre><code class="language-python">myModel = MyLinear()
#首先创建一个基于SGD的优化器，然后将上面的model的参数传入，完成初始化构造：
optimizer = opt.SGD(myModel.parameters(), learningrate)
# 参数更新前清零梯度
optimizer.zero_grad()
#参数更新
optimizer.step()
</code></pre>
<p>但你会发现其实缺少了一个步骤，在上一节中我们知道如果神经网络的结尾是一个loss函数就需要从loss开始反向转播来求取梯度，求出梯度以后再进行梯度下降，这里缺少了梯度下降的过程，那么如何计算出loss并进行梯度计算呢？这里就要介绍另一个类：loss。</p>
<h5><span id="损失函数类的使用">损失函数类的使用</span></h5>
<p>在torch中预置了许多loss的计算函数比如：</p>
<p>求取均方误差的：</p>
<pre><code class="language-python">nn.MSELoss()#常用于回归问题
</code></pre>
<p>求取交叉熵损失的：</p>
<pre><code class="language-python">nn.CrossEntropyLoss()#常用于分类问题
</code></pre>
<h5><span id="如何使用内置的loss函数的类来进行计算">如何使用内置的loss函数的类来进行计算？</span></h5>
<p>对于一个<strong>loss 函数</strong>类来说，需要知道的参数就是<strong>预测值</strong>和<strong>真实值</strong>，对于回归问题我们只需要传入这两个参数就可通过loss函数对象计算出loss函数的结果，其实本质上<strong>loss 函数类</strong>和前边的<strong>nn.Module</strong>一样都是一个类的实例化对象，<strong>nn.Moudule</strong>需要运行的时候（前向传播）调用的是其<code>__call__</code>方法， 通过<strong>call</strong>方法来调用<strong>forward</strong>方法实现前向传播，同理那么<strong>loss 函数类</strong>也是不是可以通过相同的办法实现呢？当然可以我们直接调用其对象传入参数就可以完成计算。当计算出<strong>loss</strong>以后如何进行反向传播呢？<strong>loss</strong>函数类返回的也是一个<strong>torch</strong>我们直接调用<strong>backward</strong>方法即可。</p>
<pre><code class="language-python">lossFun = nn.MSELoss() #构造一个loss类
loss = lossFun(y, y_predicet) #计算loss
loss.backward() #反向传播计算梯度
</code></pre>
<p>通过这样完成了一次训练，根据训练次数和步长进行迭代训练，代码如下：</p>
<pre><code class="language-python">import torch
import torch.nn as nn
import torch.optim as opt
import numpy as np
import matplotlib.pyplot as plt

# 0、准备数据
sample_number = 500
learninGrate = 0.001
trainTimes = 20000
x = torch.rand([sample_number, 1])
y = x * 3 + 0.8


# 1、定义模型
class MyLinear(nn.Module):
    def __init__(self):
        # 继承父类的init
        super(MyLinear, self).__init__()
        self.linear = nn.Linear(1, 1)

    def forward(self, x):
        out = self.linear(x)
        return out


# 2、实例模型，优化器类的实例
myModel = MyLinear()
optimizer = opt.SGD(myModel.parameters(), lr=learninGrate)
lossFun = nn.MSELoss()
# 3、训练
for i in range(trainTimes):
    y_predicet = myModel(x)
    optimizer.zero_grad()
    loss = lossFun(y, y_predicet)
    loss.backward()
    optimizer.step()
    if (i % 100 == 0):
        print(loss)
        print("W :", list(myModel.parameters())[0])
        print("B :", list(myModel.parameters())[1])

</code></pre>
<p>有意思的W和B是generator类的，这样就无法直接获得，需要通过list强制转化，关于generator类会放在下节再将。</p>
<p>输出：</p>
<pre><code class="language-shell">loss：tensor(5.5467e-08, grad_fn=&lt;MseLossBackward0&gt;)
W : Parameter containing:
tensor([[2.9992]], requires_grad=True)
B : Parameter containing:
tensor([0.8004], requires_grad=True)
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2024/09/28/pytorch_3/" title="Pytorch--基础指北_叁"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: Pytorch--基础指北_叁</span></a><a class="button is-default" href="/2024/09/28/pytorch_2/" title="Pytorch ——基础指北_贰"><span class="has-text-weight-semibold">下一页: Pytorch ——基础指北_贰</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container" id="vcomments" data-comment_valine_id="hUPsiqArOXp6TNWbIGsRugoz-gzGzoHsz" data-comment_valine_key="bMOEIPDsFffDM5KYhZcZFDwr"></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/NeoNexusX"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> NeoNexus 2025</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>Puravida & FreeWill</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script><script type="text/javascript">window.MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    displayMath: [['$$', '$$']],
    processEscapes: true,
    tags: 'ams' // 如果需要支持自动编号
 },
  options: {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    enableMenu: true,
  },
  startup: {
    ready: () => {
      MathJax.startup.defaultReady();
      MathJax.startup.promise.then(() => {
        // 处理公式渲染完成后的回调函数
        document.querySelectorAll('.MathJax').forEach((el) => {
          el.parentNode.classList.add('has-jax');
        });
      });
    }
  }
};</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script src="https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js"></script><script>function initMermaid() {
  if (window.mermaid) {
    mermaid.initialize({ theme: 'forest' });
  }
}</script></body></html>