<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://neonexusx.github.io/atom.xml" rel="self"/>
  
  <link href="http://neonexusx.github.io/"/>
  <updated>2025-03-13T08:28:38.624Z</updated>
  <id>http://neonexusx.github.io/</id>
  
  <author>
    <name>NeoNexus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux Bash Shell 脚本入门（3）——Linux常用命令介绍</title>
    <link href="http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%203/"/>
    <id>http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%203/</id>
    <published>2025-03-12T10:37:00.000Z</published>
    <updated>2025-03-13T08:28:38.624Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux-bash-shell-脚本入门3linux常用命令介绍">Linux Bash Shell 脚本入门（3）——Linux常用命令介绍</span></h1><p>[TOC]</p><!-- toc --><ul><li><a href="#%E9%80%9A%E8%BF%87man%E6%9D%A5%E4%BA%86%E8%A7%A3%E4%BB%BB%E4%BD%95%E5%91%BD%E4%BB%A4">通过man来了解任何命令</a><ul><li><a href="#%E6%B5%8F%E8%A7%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">浏览文件系统</a><ul><li><a href="#l%E7%9A%84%E9%95%BF%E5%88%97%E8%A1%A8%E4%BF%A1%E6%81%AF">l的长列表信息</a></li><li><a href="#%E8%BF%87%E6%BB%A4%E8%BE%93%E5%87%BA%E5%88%97%E8%A1%A8">过滤输出列表</a></li></ul></li></ul></li><li><a href="#%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95">复制文件和目录</a></li><li><a href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9">删除文件和文件夹</a><ul><li><a href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9">删除文件夹</a></li></ul></li><li><a href="#%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6">链接文件</a><ul><li><a href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E8%BD%AF%E8%BF%9E%E6%8E%A5">符号链接（软连接）</a></li><li><a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5">硬链接</a></li><li><a href="#%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A1%AC%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB">软连接和硬连接的区别</a></li></ul></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6">查看文件</a><ul><li><a href="#cat%E5%91%BD%E4%BB%A4">cat命令</a></li><li><a href="#%E5%8F%AA%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9">只查看文件部分内容</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%9C%AB%E5%B0%BEtail%E5%91%BD%E4%BB%A4">查看文件末尾（tail命令）</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8head%E5%91%BD%E4%BB%A4">查看文件头部（head命令）</a></li></ul></li></ul></li></ul><!-- tocstop --><img src="https://s2.loli.net/2025/03/12/U4dGpMnVZgOzsvA.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1741776068525" style="zoom:67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1695021721029" style="zoom: 50%;"><h2><span id="通过man来了解任何命令">通过man来了解任何命令</span></h2><p>man命令可以访问linux系统的手册页，尤其是当你想要弄清命令行参数的时候，就可以查看对应的命令介绍来了解。</p><p>这对刚入门的新手是非常友好的，这里简单介绍一下man命令的使用以及效果，man使用格式如下：</p><pre><code class="language-sh">man  command-name</code></pre><p>我们最常用的ls命令来举例：</p><pre><code class="language-bash">man ls</code></pre><img src="https://s2.loli.net/2024/04/20/VGBnDJ6O9lhTWHq.png" alt="image-20240420160532398" style="zoom:67%;"><p>当使用man手册的时候实际上是linux的pager程序来显示的，分页显示是一种实用工具，能够逐页逐行显示文本，只需要使用<strong>Space</strong>来进行翻页或者<strong>Enter</strong>逐行查看，假设你使用仿真终端支持箭头翻阅,也可以使用<strong>箭头向前或者向后</strong>滚动手册页的内容，至于什么是仿真终端和真的终端有什么区别，详见上一篇。</p><p>向下翻页我们可以看到<strong>DESCRIPTION</strong>这一小节，浏览手册不是按部就班的学习而是作为快速参考来使用的，<strong>DESCRIPTION</strong>小节描述了这个命令的一般性描述。每一小节都有一定的内容，我们常用的小节有：</p><ul><li>SYNOPSIS：命令的语法</li><li>DESCRIPTION ：命令的一般性描述</li><li>OPTIONS ： 命令选项的描述</li></ul><p>一般来说命令的使用遵循：</p><pre><code class="language-bash">COMMAND-NAME [OPTION] ... [ARGUMENT]...</code></pre><p>OPTION 是用于修改命令的行为选项，可添加的OPTION 通常不只有一个，<code>[ ]</code>表明这内容不是必须的，<code>...</code>表明可以一次指定多个OPTION， <code>[ARGUMENT]</code>是传递给命令的参数，以指明命令的操作对象，从中括号可以看出，ARGUMENT也不是必选的，同时可以指定多个ARGUMENT来使用。</p><p>为了完整介绍命令的格式，我们再找来tar来举个例子，tar是用来归档和压缩的命令：</p><pre><code>tar {A|c|d|r|t|u|x}[GnSkUWOmpsMBiajJzZhPlRvwo] [ARG...]</code></pre><p><code>{ }</code>这一部分是必须的，大括号 <code>{ }</code> 通常表示一组选项或者占位符，用于表示替换选项或参数的选择，所以使用的时候必须要带上至少一个参数，后边的<code>[ ]</code>表明<code>GnSkUWOmpsMBiajJzZhPlRvwo</code>是作为可选参数被加入到命令之中的，相对的<code>A|c|d|r|t|u|x</code>是必选的，如果仔细看后边的<code>[ARG...]</code>也比较神奇，推测省略号是否在外面这两种写法没有太大区别，在全网也没有找到合适的解释，这里就暂且认为二者一致。</p><h3><span id="浏览文件系统">浏览文件系统</span></h3><p>我们使用ls的时候常常只是ls但是默认的ls显示的内容常常具有误导性，我们举个例子：</p><pre><code class="language-bash">Neo@Bionet:~$ ls cudnn-local-repo-ubuntu2204-9.0.0   Downloads   Public            snap              thinclient_drives Desktop                             Music       PycharmProjects  'Sunlogin Files'   Videos Documents                           Pictures    Share_Space       Templates         WorkSpaceNeo@Bionet:~$ ls -aFltotal 1420drwxr-x--- 41 Neo  Neo    4096  4月 20 14:43  ./drwxr-xr-x 45 root root   4096  4月 18 19:03  ../drwxrwxr-x  3 Neo  Neo    4096  3月 25 12:27  .anaconda/drwxrwxr-x  3 Neo  Neo    4096  3月 25 12:03  .astropy/-rw-------  1 Neo  Neo   27327  4月 20 16:09  .bash_history............................etc-rw-r--r--  1 Neo  Neo   24921  4月  3 15:03  .xorgxrdp.18.log.old</code></pre><p>ls带参数和不带参数二者有巨大的区别，我们通过man可以看到参数的意思如下：</p><pre><code class="language-bash">   -a, --all          do not ignore entries starting with .             -F, --classify          append indicator (one of */=&gt;@|) to entries             -l     use a long listing format      -h, --human-readable          with -l and -s, print sizes like 1K 234M 2G etc.</code></pre><ul><li>F 会在目录名之后添加/。在可执行文件之后添加*，以帮助用户区分对应的内容，但是对于彩色终端不同类型的文件有不同的颜色，所以这个可以省略</li><li>a 会显示隐藏文件</li><li>l 会以长列表的形式列出来所有文件及其信息。</li><li>h 会将显示的大小修改为人类可读的类型</li></ul><p>对于使用来说：</p><pre><code class="language-bash">ls -alh</code></pre><p>已经完全够用，且方便记忆。</p><h4><span id="l的长列表信息">l的长列表信息</span></h4><p>让我们来解析一下这里面的内容：</p><pre><code class="language-bash">drwxrwxr-x  3 Neo  Neo    4096  3月 25 12:27  .anaconda/</code></pre><ul><li>第1字母，d代表了文件的类型，比如目录（d），文件是（-）、链接文件（l）、字符设备（c）、块设备（b）。</li><li>第2-10的字母和数字，代表了读写权限，这一部分内容会留到权限篇章介绍，具体可先参看下图。</li><li>第11位的数字，代表了文件的硬链接数目，参看链接小节的内容。</li><li>后边的一组字符，代表了文件的属主。</li><li>后边的一组字符，代表了文件的属组。</li><li>然后是文件的大小，以字节的形式表示，这里表示目录本身的索引信息占据了4096个字节，并不是代表目录占据了4096字节。</li><li>文件的上次修改时间。</li><li>文件名或者目录名。</li></ul><img src="https://s2.loli.net/2024/03/24/oRCPZhtelAB8xuX.png" alt="image-20240324211953007" style="zoom:80%;"><h4><span id="过滤输出列表">过滤输出列表</span></h4><p>ls 默认情况下会显示所有非隐藏文件，但是有时候文件太多，我们就需要使用过滤器来实现过滤，过滤器是一个字符串，可用作简单的文本匹配，可将其作为命令行参数，放置在选项之后使用，举个例子：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ ls -alh pytorch221_cuda122-rw------- 1 root root 13G  3月 26 14:02 pytorch221_cuda122</code></pre><p>其基本格式如下：</p><pre><code class="language-bash">ls -alh Filename</code></pre><p>当然其威力不仅仅于此，对于filename，其支持标准通配符（wildcard），我们可以尝试如下例子：</p><pre><code class="language-bash">ls -alh pytor*</code></pre><p>当然效果上，我们可以看到：</p><img src="https://s2.loli.net/2024/04/20/cpw8xHgXouyKflU.png" alt="image-20240420203626775" style="zoom: 80%;"><p>也会将对应的文件显示出来，通配符也包括<code>？、[ ]、!</code> ,效果如下：</p><img src="https://s2.loli.net/2024/04/20/SHL1FUPydMYzukT.png" alt="image-20240420203943906" style="zoom:80%;"><p>当然匹配符有很多，这里就不再一一赘述。</p><img src="https://s2.loli.net/2024/04/20/Z98N1QBwkSfFdVU.png" alt="image-20240420204333227" style="zoom:80%;"><pre><code class="language-bash">Neo@Bionet:~/Desktop$ ls -alhitotal 13G26083455 drwxr-xr-x  2 Neo  Neo  4.0K  4月 20 22:23 .26083329 drwxr-x--- 43 Neo  Neo  4.0K  4月 20 22:28 ..26088183 -rw-r--r--  1 root root    7  4月 20 21:28 1.txt26086399 -rw-r--r--  1 root root    7  4月 20 21:33 2.txt26083364 -rwxrwxrwx  1 root root 1.4K  4月 20 18:39 creatematlab.sh26088522 -rwxrwxrwx  1 root root  571  4月  1 11:58 c.sh26084449 -rwxrwxrwx  1 Neo  Neo  1.7K  4月 11 17:16 devel_level.df26083390 lrwxrwxrwx  1 Neo  Neo    32  4月 20 22:23 ln_createusr -&gt; /home/some_scripts/createuser.sh26084386 -rw-------  1 root root  13G  3月 26 14:02 pytorch221_cuda122</code></pre><p><code>ls -alhi</code>中的i显示了inode编号，<strong>文件或目录的inode编号是内核分配给文件系统中每一个对象的唯一标识</strong>。</p><h2><span id="复制文件和目录">复制文件和目录</span></h2><p>cp命令是将文件和目录从文件系统的一个位置复制到另一个位置，其最基本的用法如下：</p><pre><code class="language-bash">cp --helpUsage: cp [OPTION]... [-T] SOURCE DEST  or:  cp [OPTION]... SOURCE... DIRECTORY  or:  cp [OPTION]... -t DIRECTORY SOURCE...Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.</code></pre><p>可以看到cp支持的表达式如下：</p><pre><code class="language-bash">cp [OPTION]... [-T] SOURCE DEST</code></pre><p>通常情况下，如果 <code>cp</code> 命令的目标路径是一个目录，则会将源文件复制到目标目录中。但是，如果你希望将源文件复制到一个普通文件中，并且目标路径可能会被解释为目录，那么你可以使用 <code>-T</code> 选项来强制 <code>cp</code> 将目标路径视为普通文件。</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ sudo cp -T 1.txt 2.txt</code></pre><p>需要注意的是这里的的复制指的是将1的内容直接覆盖到2上。如果需要强制询问是否需要覆盖已有文件：</p><pre><code class="language-bash">$ sudo cp -Ti  1.txt 2.txtcp: overwrite '2.txt'? y</code></pre><p>回答y之后就会覆盖，任何不是y的回答都取消覆盖。</p><pre><code class="language-bash">cp -Ri Share_Space/ newshare/</code></pre><p>会直接将<code>Share_Space/</code>的内容直接复制到新的文件夹<code>newshare/</code>当中，递归的包含所有的内容。</p><p>当然cp也支持使用通配符，举个例子，我们使用cp命令将当前目录下的所有sh脚本复制到路径/home/some_scripts/下中：</p><pre><code class="language-bash">:~/Desktop$ sudo cp -i ./*.sh /home/some_scripts/cp: overwrite '/home/some_scripts/creatematlab.sh'? ncp: overwrite '/home/some_scripts/createuser.sh'? ncp: overwrite '/home/some_scripts/c.sh'? n</code></pre><p>此操作会将桌面的所有sh脚本复制过去，因为我已经提前复制了，所以会一个一个询问是否要覆盖。</p><h2><span id="删除文件和文件夹">删除文件和文件夹</span></h2><p>linux中最常用且最危险的命令莫过于rm了。在linux中删除被叫做移除（removing）。bash shell 中用于删除文件的命令是rm。rm命令的基本格式非常简单：</p><pre><code class="language-bash">SYNOPSIS       rm [OPTION]... [FILE]...</code></pre><p>举个例子，我们查看当前目录下面的内容，并尝试删除一个文件：</p><p><img src="https://s2.loli.net/2024/05/03/CfWec4gY7jP3lDh.png" alt="image-20240503220346917"></p><p>可以看到有一个Dockerfile.swp文件这是一个缓存的交换文件，并没有什么用，我们将其删除：</p><pre><code class="language-bash">rm -i .Dockefile.swp</code></pre><p>删除之后我们可以看到：</p><p><img src="https://s2.loli.net/2024/05/03/bTzZSFigO7I3QaK.png" alt="image-20240503220637952"></p><p>此处加入i参数目的是为了提醒自己要删除对应的文件了，shell的删除命令并不存在垃圾箱这种东西，如果一旦不小心删除那么就永远也找不回来了，所以要养成加入i参数的好习惯。</p><p>rm的文件参数同时也支持通配符，也就是说可以通过rm一次性删除很多文件，这是非常有用的，当你想删除某一类文件的时候就可以使用：</p><pre><code class="language-bash">rm -i *.sh</code></pre><p>此操作会删除所有的sh脚本文件。</p><h3><span id="删除文件夹">删除文件夹</span></h3><p>对于非空目录rmdir命令足以，但是大多数情况下，目录中都有内容，我们就必须使用rm命令来实现了。</p><pre><code class="language-bash">rm -ri 目录名或路径 </code></pre><p><code>-r/R</code>（没错此处Rr效果是一样的）参数会向下进入到目录中将其内容全部删除，在这个过程中会一个一个询问你是否删除，如果不想这样，且确认数据真的没有用处了，我们可以选择<code>-rf</code>参数。</p><p>效果如下，有以下文件夹：</p><p><img src="https://s2.loli.net/2024/05/03/mcAO758vHoQZ2gI.png" alt="image-20240503223624129"></p><p>使用命令进入删除：</p><p><img src="https://s2.loli.net/2024/05/03/G3W4wgqejYERMJp.png" alt="image-20240503223554291"></p><h2><span id="链接文件">链接文件</span></h2><p>链接文件可以说是linux系统的优势，如果需要在系统中维护同一个文件的两个或者多个副本的时候可以使用单个物理副本+多个虚拟副本(链接)的方法代替创建多个物理副本，链接是目录中指向文件真实位置的占位符，在linux中有两种类型的文件链接：</p><ul><li>符号链接（软连接）</li><li>硬链接</li></ul><p>创建链接的命令如下：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ ln --helpUsage: ln [OPTION]... [-T] TARGET LINK_NAME  or:  ln [OPTION]... TARGET  or:  ln [OPTION]... TARGET... DIRECTORY  or:  ln [OPTION]... -t DIRECTORY TARGET...In the 1st form, create a link to TARGET with the name LINK_NAME.In the 2nd form, create a link to TARGET in the current directory.In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.Create hard links by default, symbolic links with --symbolic</code></pre><p>可以看到不仅可以创造针对文件的链接，也可以创造针对目录的链接。</p><h3><span id="符号链接软连接">符号链接（软连接）</span></h3><p>符号链接是一个实实在在的文件，只不过文件的内容是指向的是虚拟文件系统中的另一个地方的文件，这两个以符号方式连接在一起的文件彼此的内容并不相同。</p><p>举个例子，我们将刚刚复制的脚本在桌面删除，然后以不同的方式链接回来看看。</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ sudo rm ./createuser.sh Neo@Bionet:~/Desktop$ ln -s /home/some_scripts/createuser.sh ./ln_createusr# 链接完成之后，显示当前实际上是一个链接文件：Neo@Bionet:~/Desktop$ ls -alhlrwxrwxrwx  1 Neo  Neo    32  4月 20 22:23 ln_createusr -&gt; /home/some_scripts/createuser.sh# 源文件并没有任何变换：Neo@Bionet:~/Desktop$ ls -alh /home/some_scripts/createuser.sh -rwxr-xr-x 1 root root 859  4月 20 22:07 /home/some_scripts/createuser.sh</code></pre><p>可以看到通过命令：</p><pre><code class="language-bash">ln -s /home/some_scripts/createuser.sh ./ln_createusr</code></pre><p>我们创造了一个从对应目录下的文件的软连接到桌面的一个新文件叫<code>ln_createusr</code>。</p><p>使用ls来查看的时候其文件名部分被替换成了<code>ln_createusr -&gt; /home/some_scripts/createuser.sh</code>的内容，而不是本身的文件名，这里的 <code>-&gt;</code>代表了该文件是连接到文件<code>/home/some_scripts/createuser.sh</code>的一个符号链接。</p><p>我们通过上文中两个 <code>ls -alh</code>文件看到，两个文件的大小并不相同，源文件有859个字节，而链接文件只有32个字节</p><p>而我们尝试打开链接文件，可以看到：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ vim ./ln_createusr </code></pre><img src="https://s2.loli.net/2024/04/20/SUrzaQJtpcmqbwk.png" alt="image-20240420224944397" style="zoom:67%;"><p>显示内容和源文件保持一致。当我们尝试修改的时候因为源文件权限的问题，无法修改：</p><img src="https://s2.loli.net/2024/04/20/YwyBM5mHhdxNeJV.png" alt="image-20240420225031627" style="zoom:67%;"><p>当我们修改权限以后：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ sudo chmod 777 /home/some_scripts/createuser.sh </code></pre><p>文件就可以正常修改了，这里说明链接文件的权限取决于源文件，二者的权限保持一致。</p><h3><span id="硬链接">硬链接</span></h3><p>硬链接创建的是一个独立的虚拟文件，其中包含了原始文件的信息和位置，但是二者本质上是同一个文件，这是和符号链接的最大区别。</p><p>我们再举一个例子：同样将上文中复制的文件从桌面删除再以硬连接的方式连接回来。</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ rm ./creatematlab.sh     Neo@Bionet:~/Desktop$ sudo ln /home/some_scripts/creatematlab.sh  ln_creatematlabNeo@Bionet:~/Desktop$ ls -alhi109051906 -rwxr-xr-x  2 root root 1.4K  4月 20 22:07 ln_creatematlabNeo@Bionet:~/Desktop$ ls -alhi /home/some_scripts/creatematlab.sh 109051906 -rwxr-xr-x 2 root root 1.4K  4月 20 22:07 /home/some_scripts/creatematlab.sh</code></pre><p>通过<code>sudo ln /home/some_scripts/creatematlab.sh  ln_creatematlab</code>创建链接之后，我们可以看到：</p><p>二者共用一个inode号码，说明二者是一个文件。省略参数的情况下，其意思是默认在当前目录这里创建一个名字一样的硬链接，虽然下图创建失败了，但是其详细展示了创建的内容：</p><p><img src="https://s2.loli.net/2024/05/03/txdviqWJwUNMjRz.png" alt="image-20240503213411568"></p><h3><span id="软连接和硬连接的区别">软连接和硬连接的区别</span></h3><ol><li><strong>软连接（Symbolic Link）</strong>：<ul><li>软连接类似于Windows系统中的快捷方式（Shortcut）。</li><li>它是一个特殊的文件，包含了对另一个文件或目录的引用路径。</li><li>软连接不依赖于原始文件的文件名，即使原始文件被移动或重命名，软连接依然有效。</li><li>软连接可以跨文件系统，即可以链接到不同文件系统中的文件。</li><li>删除原始文件会导致软连接失效，因为它只是指向原始文件的一个路径。</li></ul></li><li><strong>硬连接（Hard Link）</strong>：<ul><li>硬连接直接指向文件的物理位置，即文件的inode节点。</li><li>硬连接与原始文件共享同一个inode，因此它们实际上是同一个文件。</li><li>硬连接不能跨文件系统，只能在同一文件系统中创建。</li><li>硬连接不能链接到目录，只能链接到文件。</li><li>删除原始文件不会影响硬连接，因为只要有一个硬连接存在，文件内容就不会被删除。</li></ul></li></ol><p>硬链接（Hard Link）不会占用两倍的空间。实际上，硬链接与原始文件共享相同的存储空间，它们指向同一个inode节点。这意味着，无论有多少个硬链接指向同一个文件，它们都只占用原始文件所占用的存储空间。</p><p>在UNIX和类UNIX系统中，文件的内容和文件的元数据（如文件名、权限、所有者等）是分开存储的。文件的内容存储在数据块中，而元数据存储在inode节点中。硬链接和原始文件都指向同一个inode节点，因此它们共享相同的数据块。</p><p>举个例子我想查看如何使用 tar 命令进行归档的压缩和解压就可以使用：</p><pre><code class="language-shell">man tar</code></pre><p>效果如下：</p><img src="https://s2.loli.net/2024/04/20/jqhmYyKxe3lD5gT.png" alt="image-20240420145521695" style="zoom:67%;"><img src="https://s2.loli.net/2024/04/20/W4yvErVod9tN58c.png" alt="image-20240420150802190" style="zoom:67%;"><p>这里tar的语法描述如下：</p><pre><code class="language-shell">SYNOPSIS   Traditional usage       tar {A|c|d|r|t|u|x}[GnSkUWOmpsMBiajJzZhPlRvwo] [ARG...]          UNIX-style usage       tar -A [OPTIONS] ARCHIVE ARCHIVE.......       tar -x [-f ARCHIVE] [OPTIONS] [MEMBER...]   GNU-style usage       tar --create [--file ARCHIVE] [OPTIONS] [FILE...].......       tar {--extract|--get} [-f ARCHIVE] [OPTIONS] [MEMBER...]</code></pre><p>这一部分描述了常用的方式：</p><pre><code class="language-bash">Traditional usage       tar {A|c|d|r|t|u|x}[GnSkUWOmpsMBiajJzZhPlRvwo] [ARG...]</code></pre><p>参数了解之后，可以看看这些参数有什么用：</p><p>关于参数的内容linux的运行手册有的内容非常多而且不一致，我们可以换个方式来快速查看， 大多数命令都支持-h选项来实现，更快速的信息获取：</p><pre><code class="language-shell">Neo@Bionet:~/Desktop$ tar --helpUsage: tar [OPTION...] [FILE]...GNU 'tar' saves many files together into a single tape or disk archive, and canrestore individual files from the archive.Examples:  tar -cf archive.tar foo bar  # Create archive.tar from files foo and bar.  tar -tvf archive.tar         # List all files in archive.tar verbosely.  tar -xf archive.tar          # Extract all files from archive.tar. Main operation mode:  -A, --catenate, --concatenate   append tar files to an archive  -c, --create               create a new archive      --delete               delete from the archive (not on mag tapes!)  -d, --diff, --compare      find differences between archive and file system  -r, --append               append files to the end of an archive      --test-label           test the archive volume label and exit  -t, --list                 list the contents of an archive  -u, --update               only append files newer than copy in archive  -x, --extract, --get       extract files from an archive Operation modifiers:      --check-device         check device numbers when creating incremental                             archives (default)  -g, --listed-incremental=FILE   handle new GNU-format incremental backup  -G, --incremental          handle old GNU-format incremental backup      --hole-detection=TYPE  technique to detect holes      --ignore-failed-read   do not exit with nonzero on unreadable files      --level=NUMBER         dump level for created listed-incremental archive      --no-check-device      do not check device numbers when creating                             incremental archives</code></pre><p>获取的信息，截取了一部分，这样就避免了翻页程序过于正式的效果，反而看清楚该如何使用命令。</p><p>我们找到解压的参数 <code>-x</code>作为主参数，同时浏览一下常用的vf参数是什么意思：</p><p><code>-f, --file=ARCHIVE         use archive file or device ARCHIVE</code></p><h2><span id="查看文件">查看文件</span></h2><p>查看文件是linux最重要的特性，有了这些查看命令的支持，相较于windows那些操作系统，在有大文件的时候linux不仅能打开，并且能快速查看当中的内容。</p><p>当你手头有一个很大的文本文件，你可能会想看一看到底是什么，linux有几个经典的命令来实现这个操作，我们只介绍当中比较常用的命令。</p><h3><span id="cat命令">cat命令</span></h3><p>cat命令是最基础的文件探查命令，当你查找资料的时候经常能看到，所以这里介绍一下：</p><p>我们有一个test文件里面包含多行的内容：</p><img src="https://s2.loli.net/2024/05/03/f6vskCKxOaSPNY9.png" alt="image-20240503230813839" style="zoom: 80%;"><p>我们使用cat来查看一下：</p><pre><code class="language-bash">cat -n test</code></pre><p>效果如下：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop$ cat -n test     1123456     212345     31234     4123     512     61     7     8</code></pre><p>这里就没有什么特别的，其显示的内容就是对应的信息，其中有多种变形的参数，这里<code>-n</code>代表显示行号，同时还有<code>-b</code>选项只给有文本的行加上行号，效果如下：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop$ cat -b test     1123456     212345     31234     4123     512     61neo@NeoNeuxs:~/Desktop$ </code></pre><p>对于cat来说当其应对大文件尤其是超大文件的时候他会不停的刷新模拟终端的内容来显示，我们无法查看到底有什么，为了解决这个问题我们可以使用less。</p><p>less命令提供了非常多的实用特性，能够实现文本文件中的前后翻动，还有一些高级搜索功能。最主要的是less能够实现在完全读取文件之前，显示文件的部分内容，cat和more是无法实现的，为了验证这个功能我们来找一个大的文件来进行操作，</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop/PTM/Dataset/uniprot$ less ./uniprotkb_AND_reviewed_true_AND_model_o_2024_04_25.tsv </code></pre><p>uniprotkb是一个蛋白质库，其中记录了许多蛋白质序列，我们使用less来查看里面的内容，显示如下：</p><p><img src="https://s2.loli.net/2024/05/03/abhLBQX83YleS9O.png" alt="image-20240503232813500"></p><p>由于数据的每一行都非长的长，当达到屏幕极限的时候就会换行，less是按页来显示的，我们可以通过键盘的pgup、pgdn，或者空格来翻页查看，其加载速度并不取决于文件大小而在于每一页的内容，这样当你使用vcode、等编辑器无法一下打开查看信息的时候就是less大发神威的时候，如下图，此文件达到了100多MB,算是比较小的，但是使用其他文件阅读器打开还是比较慢，less在一瞬间就可以打开，并查看其中的内容。</p><img src="https://s2.loli.net/2024/05/03/BlaurX6792TROQf.png" alt="image-20240503233216985" style="zoom:67%;"><p><img src="https://s2.loli.net/2024/05/03/J8RSrN1jftEz9Ls.png" alt="image-20240503233340449"></p><h3><span id="只查看文件部分内容">只查看文件部分内容</span></h3><p>你需要查看的文件有时候经常位于文件的开头或者结尾，当文件很大的时候，你就只能干等着cat或more来载入整个文件，当然linux也提供了专门的命令来解决这个问题，下面就会介绍 tail、head命令。</p><h4><span id="查看文件末尾tail命令">查看文件末尾（tail命令）</span></h4><p>tail命令会显示文件的末尾的内容，默认情况下会显示文件末尾的最后10行，我们还是使用刚才的文件来检测：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop/PTM/Dataset/uniprot$ tail ./dbPTM_PhosphorylationZO3_HUMANO95049919Phosphorylation18669648KKFMRVHDAESSDEDGYDWGPZO3_HUMANO95049920Phosphorylation18669648KFMRVHDAESSDEDGYDWGPAZO3_HUMANO95049925Phosphorylation18669648HDAESSDEDGYDWGPATDL--ZRAB2_HUMANO95218-29Phosphorylation18669648--MSTKNFRVSDGDWICPDKKZRAB2_HUMANO95218-2114Phosphorylation18669648GGFNERENVEYIEREESDGEYZRAB2_HUMANO95218-2120Phosphorylation18669648ENVEYIEREESDGEYDEFGRKZRAB2_HUMANO95218-2153Phosphorylation18669648SILKEVEDKESEGEEEDEDEDZRAB2_HUMANO95218-2181Phosphorylation18669648EDEDEDDADLSKYNLDASEEEZRAB2_HUMANO95218-2183Phosphorylation18669648EDEDDADLSKYNLDASEEEDSZRAB2_HUMANO95218-2188Phosphorylation18669648ADLSKYNLDASEEEDSNKKKS</code></pre><p><code>-n</code>可以显示指定行数，效果如下：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop/PTM/Dataset/uniprot$ tail -n 1 ./dbPTM_PhosphorylationZRAB2_HUMANO95218-2188Phosphorylation18669648ADLSKYNLDASEEEDSNKKKS</code></pre><p><strong>tail最重要的参数是<code>-f</code>其可以实现在线刷新的效果，当有新的数据写到文件的时候会自动刷新。</strong></p><h4><span id="查看文件头部head命令">查看文件头部（head命令）</span></h4><p>head命令的使用方式几乎和tail一样，只不过显示的内容是头部的，相同的命令参数-n也可以指定当前显示的行数。</p><p><img src="https://s2.loli.net/2024/05/04/CqGdyjZbElXwSum.png" alt="image-20240504003518940"></p>]]></content>
    
    
    <summary type="html">man/cp/tar/ls/ln/cat/tail/head/less command introducation</summary>
    
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Bash Shell 脚本入门（1）——Linux内核功能介绍</title>
    <link href="http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/"/>
    <id>http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/</id>
    <published>2025-03-12T10:37:00.000Z</published>
    <updated>2025-03-13T08:28:14.583Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux-bash-shell-脚本入门1linux内核功能介绍">Linux Bash Shell 脚本入门（1）——Linux内核功能介绍</span></h1><p>[TOC]</p><!-- toc --><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#linux%E5%88%9D%E6%8E%A2">Linux初探</a><ul><li><a href="#linux%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84">Linux系统架构</a></li><li><a href="#linux-%E5%86%85%E6%A0%B8">linux 内核</a><ul><li><a href="#%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">系统内存管理</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86">软件程序管理</a></li><li><a href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86">硬件设备管理</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">文件管理系统</a></li></ul></li></ul></li></ul><!-- tocstop --><img src="https://s2.loli.net/2025/03/12/ns1Fc3hg9ztLBpY.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1741766727606" style="zoom:67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1695021721029" style="zoom: 50%;"><h2><span id="前言">前言</span></h2><p>本文为《Linux命令行与shell脚本编程大全》第四版的读书笔记，突发奇想想看看这本书，实际上是图书馆关于Linux的书正好就这一本了，没想到看起来还不错，遂借出来看看。</p><p>Linux算是接触的比较多了，虽然接触了很多但是并不明白其原理和架构是怎么样的，整本书包含了部分linux架构的内容，重点在于shell脚本编写实战，这个非常重要，能够书写bash脚本，在某些时候能达到事半功倍的效果，同时对系统的维护工作也是有益的。</p><h2><span id="linux初探">Linux初探</span></h2><h3><span id="linux系统架构">Linux系统架构</span></h3><p>Linux系统有很多版本，我们常见的是Ubuntu、Debian等等，这些版本大同小异，但最关键的系统架构是几乎一致的，一般发行版的linux系统由四部分组成：</p><ul><li>Linux内核</li><li>GNU工具</li><li>图形化桌面环境</li><li>应用软件</li></ul><p>每一部分都有各自的职责，实际上是一个层次结构的关系，如下图所示：</p><pre class="mermaid">graph TB;A("应用程序软件") &lt;--&gt; E("窗口管理软件")E&lt;--&gt; B("GNU系统工具")  C &lt;--&gt; E("窗口管理软件(图形化桌面环境)")B &lt;--&gt; C("Linux内核")C &lt;--&gt; D("计算机硬件")</pre><h3><span id="linux-内核">linux 内核</span></h3><p>linux系统的核心就是linux内核，创始人linus在赫尔辛基大学上学的时候就开发了第一版linux内核，目前他主要负责编写和审阅linux内核的代码，时至今日linux的开发仍遵循这一思路，只不过不仅仅是linus一个人来进行，目前有一组开发人员负责这项任务。</p><p>内核主要负责的功能有：</p><ul><li>系统内存管理</li><li>软件程序管理</li><li>硬件设备管理</li><li>文件系统管理</li></ul><h4><span id="系统内存管理">系统内存管理</span></h4><p>linux系统的内存管理，不仅仅在于物理内存，还可以创建并管理虚拟内存，内核通过硬盘上称为交换空间来实现虚拟内存，内核通过在实际物理内存和虚拟内存之间不停的交换，来使系统的内存容量扩大到远大于物理内存的大小，内核会将内存划分为若干页，内核会将每个内存页面置于物理内存或者交换内存之中。内核会维护一张内存页面表，指明那些页面位于物理内存，那些页面被交换到了磁盘。</p><p>内核会记录哪些内存页面正在使用中，自动把一段时间为访问的内存页面复制到交换区域（这操作称为换出，swapping out），当程序要访问一个已经被换出的内存页面，内核就会将物理内存中的另一个页面换出来为其腾出空间，然后从交换空间实行换入操作（swapping in）。显然，这个过程取决于硬盘的读写性能上限和当前的运行状态中是否有较高的读写占用，一般来说这个换入和换出的操作会拖慢程序的运行速度，只要linux系统在运行这个过程就不会停止，因为内核会将长时间不用的内存页面换出，即使当前还有内存可以使用。</p><p>关于系统的交换分区和交换文件的设置，可以参考本人另一篇文章：<a href="https://www.cnblogs.com/NeoNexus/p/17999581">Ubuntu22.04 &amp; Win11 双系统hibernate冷切换实现</a>，里面详细讲述了交换文件和交换分区的内容，并由此为引子实现了双系统的冷切换操作。</p><h4><span id="软件程序管理">软件程序管理</span></h4><p>Linux下运行的程序被称为进程，进程可以在前台运行，显示在屏幕之上，也可以后台运行，隐藏到幕后。内核控制Linux系统如何管理运行在系统中的所有进程。</p><p>内核通过创建init进程来启动系统中所有的其他进程，当内核启动的时候，它会将init进程载入到虚拟内存。内核启动进程的时候，会在虚拟内存中分配一块专有区域，来存储进程用到的数据和代码。</p><p>在linux中，有很多init进程实现的方式，目前最流行的有一下两种：</p><ul><li>SysVinit：Linux最初使用的就是这种方法，该方法基于Unix System V初始方法，目前很多发行版已经不再使用了，但在一些旧的Linux发行版中还能找到其身影。</li><li>systemd：systemd初始化方法诞生于2010年，systemd不仅包含初始化过程，同时包含进程管理的功能。</li></ul><p>关于SysVinit初始化方法已经被淘汰，这里就主要介绍systemd的方法，systemd进步在于能够依据不同的事件启动进程，比如一下事件：</p><ul><li>系统启动时</li><li>连接到特定的硬件设备时</li><li>服务启动时</li><li>建立好网络连接时</li><li>计时器到期时</li></ul><p>systemd方法通过将事件与单元文件（Unit file）链接来决定运行哪些进程，每个单元文件定义了特定事件发生时要启动的程序。</p><p>Unit 文件是 systemd 管理资源的基本单位，定义了如何控制一个**服务（Service）、设备（Device）、挂载点（Mount）、定时器（Timer）**等。</p><ul><li>每个 Unit 文件对应一种资源，例如：<ul><li><code>nginx.service</code>（服务）</li><li><code>home.mount</code>（挂载点）</li><li><code>graphical.target</code>（目标）</li></ul></li></ul><p>systemctl程序允许启动、停止和列出系统中当前运行的单元文件。</p><pre><code class="language-shell">systemctl list-units --type=service</code></pre><img src="https://s2.loli.net/2024/02/11/H57EPWd2tYDxXkG.png" alt="image-20240211125107649" style="zoom:80%;"><p>systemd方法将单元文件划归为目标（target），目标定义了Linux系统的特定状态，在某个目标（target）中就包含了很多单元文件（Unit file），需要注意的是target文件本身就是一种Unit文件类型，二者并不是从属关系的存在。</p><p>比如在系统启动的时候，default.target单元定义了要启动的所有单元文件，可以使用systemctl命令查看当前默认目标：</p><pre><code class="language-shell">neo@NeoNeuxs:/etc$ systemctl get-defaultgraphical.target</code></pre><p>graphical.target单元文件定义了多用户图形 环境运行时要启动的进程。</p><p>这里我们使用systemctl 来启动一个服务，这里的服务是一个云盘的挂载软件：</p><pre><code class="language-shell">systemctl enable --now clouddrive.serviceFailed to enable unit: Unit file clouddrive.service does not exist.</code></pre><p>可以看到报错，没有找到对应的service的Unit单元文件。</p><h4><span id="硬件设备管理">硬件设备管理</span></h4><p>所谓硬件设备管理，就是通过对应的硬件的驱动，来完成硬件和内核的数据交互。</p><p>Linux系统将硬件设备视为一种特殊文件，称为设备文件。设备文件分为3种：</p><ul><li>字符设备文件：对应每次只能处理一个字符的设备，大多数类型的调制解调器和终端是作为字符设备文件创建的。</li><li>块设备文件：对应于每次以块的形式处理数据的设备，比如硬盘。</li><li>网络设备文件：对应于采用数据包发送和接受数据的设备，包含网卡和本地的网络回环设备。网络回环对应的是linux系统允许以常规网络编程的方式同自身通信一般地址127.0.0.1</li></ul><p>Linux会为每一个设备创建一种节点的特殊文件，与设备所有的通信都是通过设备节点完成的，每个节点都有一个唯一的数值对，来供linux内核标识，数值对包括一个主设备号和一个次设备号，类似的设备会被划分到主设备号下面，次设备号用于标识主设备下某个特定的设备。</p><p>例如，如果你有多个SATA硬盘，它们会共享相同的主设备号，但每个硬盘会有不同的次设备号来区分。</p><h4><span id="文件管理系统">文件管理系统</span></h4><p>Linux内核支持多种类型数据的读取，同时支持读写其他操作系统的的文件系统，内核必须在编译时就加入对所有要用到的文件系统的支持。常见的文件系统有：</p><ul><li>EXT1-4: ext是Linux扩展文件系统，最早的Linux文件系统，后续推出了ext2、ext3、ext4,ext4是目前常用的文件系统，支持高级日志功能。</li><li>EXFAT：扩展windos文件系统，常用于大容量移动设备。</li><li>NTFS：NTFS（New Technology File System）是由Microsoft开发的一个文件系统，最初在Windows NT 3.1中引入，并在后续的Windows操作系统中得到广泛应用，包括Windows 2000、Windows XP、Windows Vista、Windows 7、Windows 8、Windows 10以及Windows Server系列。NTFS替代了之前的FAT（File Allocation Table）和HPFS（High Performance File System）文件系统，提供了许多改进和新特性</li><li>SMB：最初由IBM开发，后来由Microsoft进一步扩展和标准化，成为Windows网络环境中文件和打印服务的核心协议。SMB工作在客户端/服务器模型上，允许客户端（通常是计算机或移动设备）通过发送请求消息给服务器（通常是文件服务器或打印服务器）来访问网络上的资源。服务器接收到请求后，处理请求并返回相应的响应给客户端。因此常被用来作为网络硬盘的功能。</li></ul><p>内核采用虚拟文件系统作为和各种文件系统互相交互的接口，linux内核与其他类型的文件系统之间的通信提供了一个标准接口，当文件系统被挂载和使用的时候，VFS会在内存中缓存相关信息。</p>]]></content>
    
    
    <summary type="html">Linux内核功能介绍</summary>
    
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Bash Shell 脚本入门（2）——GNU</title>
    <link href="http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%202/"/>
    <id>http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%202/</id>
    <published>2025-03-12T10:37:00.000Z</published>
    <updated>2025-03-13T08:28:13.087Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux-bash-shell-脚本入门2gnu">Linux Bash Shell 脚本入门（2）——GNU</span></h1><p>[TOC]</p><!-- toc --><ul><li><a href="#gnu%E4%B8%8Elinux">GNU与Linux</a><ul><li><a href="#gnu">GNU</a><ul><li><a href="#gnu%E7%9A%84%E7%BB%84%E6%88%90">GNU的组成</a></li></ul></li><li><a href="#shell">Shell</a></li><li><a href="#gnome%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83">GNOME桌面环境</a><ul><li><a href="#x-window-%E8%BD%AF%E4%BB%B6">X Window 软件</a></li></ul></li><li><a href="#gnome">GNOME</a></li></ul></li></ul><!-- tocstop --><img src="https://s2.loli.net/2025/03/12/FvsRHCyO4QK9Tlb.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1741775577228" style="zoom:67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1695021721029" style="zoom: 50%;"><p>可点击内容，大部分来自维基百科，可以点击了解详情。</p><h2><span id="gnu与linux">GNU与Linux</span></h2><h3><span id="gnu">GNU</span></h3><p>GNU操作系统起源于<a href="https://zh.m.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83">GNU计划</a>，由<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>在<a href="https://zh.m.wikipedia.org/wiki/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%B8%E9%99%A2">麻省理工学院</a>人工智能实验室发起，希望发展出一套完整的开放源代码操作系统来取代Unix，计划中的操作系统，名为GNU。</p><p><img src="https://s2.loli.net/2022/08/12/jQLouxXq39ZigGR.png" alt="246px-Heckert_GNU_white.svg"></p><p>GNU的商标是一个<a href="https://zh.m.wikipedia.org/wiki/%E7%89%9B%E7%BE%9A">牛羚</a>头。原先版本是Etienne Suvasa所设计，而今比较流行的粗体版本则是Aurelio Heckert所设计。</p><p><strong>GNU</strong>是一个<a href="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BB%9F%E9%AB%94">自由</a>的<a href="https://zh.m.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1">操作系统</a>，其内容软件完全以<a href="https://zh.m.wikipedia.org/wiki/GPL">GPL</a>方式发布（什么是GPL下文会介绍）。这套操作系统是<a href="https://zh.m.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83">GNU计划</a>的主要目标，名称来自GNU’s Not Unix!的<a href="https://zh.m.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E7%B8%AE%E5%AF%AB">递归缩写</a>，因为GNU的设计类似<a href="https://zh.m.wikipedia.org/wiki/Unix">Unix</a>，但它不包含具著作权的Unix代码。</p><p>读到这里你可能会难以理解，我从来没听说过GNU操作系统，像是Linux，Unix这种都是很有名的，但GNU到底是什么？</p><p>1983年9月27日，<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>在 net.unix-wizards 和 net.usoft<a href="https://zh.m.wikipedia.org/wiki/%E6%96%B0%E8%81%9E%E7%BE%A4%E7%B5%84">新闻组</a>中公布这项GNU计划。斯托曼的目标是成立一个完全自由的操作系统，他希望电脑用户是能够“自由使用”的。</p><p>为什么要在这里强调自由使用呢？因为在20世纪60年代和70年代 - 大多数人都能自由学习软件的源代码，自由地与他人分享的软件，可自由修改软件，自由发布软件修改后的版本。也就是说早些年软件几乎不存在著作权，每个人都可以自由地使用和修改。</p><p>1984年1月5日，理查德正式开始开发软件，为了防止这些软件将来可能被主张所有权，影响到Free Software的发展，斯托曼辞去了在实验室的工作。</p><p>理查德·斯托曼使用<a href="https://zh.m.wikipedia.org/w/index.php?title=%E4%B8%8D%E5%85%BC%E5%AE%B9%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1&amp;action=edit&amp;redlink=1">不兼容分时系统</a>（英语：<a href="https://en.wikipedia.org/wiki/Incompatible_Timesharing_System">Incompatible Timesharing System</a>） (ITS)<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-intervention-6">[6]</a>（一种早期的操作系统，使用<a href="https://zh.m.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">汇编语言</a>撰写，因其所运行的被称为 <a href="https://zh.m.wikipedia.org/wiki/PDP-10">PDP-10</a>的电脑系统架构停止发展而变得过时）的经验，决定了需要设计一种可移植系统。由此，会议决定，将开发新的系统，并使用 <a href="https://zh.m.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">C</a> 和<a href="https://zh.m.wikipedia.org/wiki/Lisp">Lisp</a>作为系统编程语言。<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-8">[8]</a> GNU将与UNIX兼容。<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-9">[9]</a> 当时，UNIX已经是一个流行的专有操作系统。而Unix的设计是模块化的，所以它可以被逐步分块的实现。</p><p>Unix在学术机构和大型企业中得到了广泛的应用，当时的UNIX拥有者<a href="https://zh.m.wikipedia.org/wiki/AT%26T">AT&amp;T</a>公司以低廉甚至免费的许可将Unix源码授权给学术机构做研究或教学之用，许多机构在此源码基础上加以扩展和改进，形成了所谓的“Unix变种”，这些变种反过来也促进了Unix的发展。</p><p>后来<a href="https://zh.m.wikipedia.org/wiki/AT%26T">AT&amp;T</a>意识到了Unix的商业价值，不再将Unix源码授权给学术机构，并对之前的Unix及其变种声明了著作权权利。BSD在Unix的历史发展中具有相当大的影响力，被很多商业厂家采用，成为很多商用Unix的基础。其不断增大的影响力终于引起了AT&amp;T的关注，于是开始了一场持久的著作权官司，至此人们意识到我们需要一个完全免费的操作系统。</p><p>1984年，开始发展编辑器<a href="https://zh.m.wikipedia.org/wiki/Emacs">Emacs</a>等软件。1985年，发表<a href="https://zh.m.wikipedia.org/wiki/GNU%E5%AE%A3%E8%A8%80">GNU宣言</a>。1989年，发表<a href="https://zh.m.wikipedia.org/zh-cn/GNU_General_Public_License">GNU通用公共许可协议</a>。这个公共开源许可协议，你如果开源过项目一定见过，它叫GPL协议，GPL是<a href="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BB%9F%E4%BB%B6">自由软件</a>和<a href="https://zh.m.wikipedia.org/wiki/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6">开源软件</a>的最流行许可证<a href="https://zh.m.wikipedia.org/zh-cn/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81#cite_note-18">[18]</a>。到2004年4月，GPL已占<a href="https://zh.m.wikipedia.org/w/index.php?title=Freshmeat&amp;action=edit&amp;redlink=1&amp;variant=zh-cn">Freshmeat</a>（英语：<a href="https://en.wikipedia.org/wiki/Freshmeat">Freshmeat</a>）上所列的自由软件的约75%，<a href="https://zh.m.wikipedia.org/wiki/SourceForge">SourceForge</a>的约68%。类似的，2001年一项关于<a href="https://zh.m.wikipedia.org/wiki/Red_Hat_Linux">Red Hat Linux</a> 7.1的调查显示一般的代码都以GPL发布。著名的GPL自由软件包括<a href="https://zh.m.wikipedia.org/wiki/Emacs">Emacs</a>，<a href="https://zh.m.wikipedia.org/wiki/Linux">Linux</a>核心（并非所有<a href="https://zh.m.wikipedia.org/wiki/Linux%E7%99%BC%E8%A1%8C%E7%89%88">Linux发行版</a>的核心都是开源的）和<a href="https://zh.m.wikipedia.org/wiki/GCC">GCC</a>。</p><p>我们回到GNU的操作系统来，因为许多必要的软件需要从零开始写起来，但是有很多已经存在的第三方组件如 <a href="https://zh.m.wikipedia.org/wiki/TeX">TeX</a>、<a href="https://zh.m.wikipedia.org/wiki/X_Window_System">X Window System</a><a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-internethist-4">[4]</a>和<a href="https://zh.m.wikipedia.org/wiki/Mach">Mach</a>微内核等等都可以进行利用，其中GNU最关键系统内核，是在<a href="https://zh.m.wikipedia.org/zh-cn/GNU_Mach">GNU Mach</a><a href="https://zh.m.wikipedia.org/wiki/%E5%BE%AE%E5%85%A7%E6%A0%B8">微内核</a>基础上进行开发，<strong>理查德·马修·斯托曼</strong>认为可以借此加速操作系统的开发，但因为一直不确定<a href="https://zh.m.wikipedia.org/wiki/%E5%8D%A1%E5%86%85%E5%9F%BA%E6%A2%85%E9%9A%86%E5%A4%A7%E5%AD%A6">卡内基梅隆大学</a>何时要将核心源代码发布，造成计划延宕三年。他在之后承认这是个错误。</p><p>下图是大佬的照片：</p><img src="https://s3.bmp.ovh/imgs/2022/08/12/b0dde8c65ef4b8b8.jpg" alt="Richard_Stallman_at_LibrePlanet_2019" style="zoom: 33%;"><p>除了上述的第三方组件外，大多数的GNU软件是由许多志愿者，在他们的空闲时间，或由公司、教育机构和非营利性组织赞助下撰写。</p><p>到 1990 年代初期，操作系统中所需的许多程序（例如库、<a href="https://en.wikipedia.org/wiki/Compiler">编译器</a>、<a href="https://en.wikipedia.org/wiki/Text_editor">文本编辑器</a>、<a href="https://en.wikipedia.org/wiki/Shell_(computing)#Command-line_shells">命令行 shell</a>和<a href="https://en.wikipedia.org/wiki/Windowing_system">窗口系统</a>）已完成，尽管一些底层元素如称为<a href="https://en.wikipedia.org/wiki/GNU_Hurd">GNU Hurd的</a><a href="https://en.wikipedia.org/wiki/Device_driver">设备驱动程序</a>、<a href="https://en.wikipedia.org/wiki/Daemon_(computer_software)">守护进程</a>和<a href="https://en.wikipedia.org/wiki/Kernel_(computer_science)">内核</a>都停滞不前且不完整。</p><p>1991年，Linux出现。1993年，<a href="https://zh.m.wikipedia.org/wiki/FreeBSD">FreeBSD</a>发布。FreeBSD就是当年与Unix著作权持有公司达成协议重写的免费版Unix，所有GNU计划中，运行于用户空间的软件，都可以在Linux或FreeBSD上使用。许多开发者转向于Linux或FreeBSD。其中，Linux成为常见的GNU计划软件运行平台。<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>主张，Linux操作系统使用了许多GNU计划软件，应正名为<a href="https://zh.m.wikipedia.org/wiki/GNU/Linux">GNU/Linux</a>，但没有得到Linux社群的一致认同，形成<a href="https://zh.m.wikipedia.org/wiki/GNU/Linux%E5%91%BD%E5%90%8D%E7%88%AD%E8%AD%B0">GNU/Linux命名争议</a>。</p><p><a href="https://zh.m.wikipedia.org/wiki/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9">林纳斯·托瓦兹</a>（Linus）开始在<a href="https://zh.m.wikipedia.org/wiki/MINIX">MINIX</a>上开发<a href="https://zh.m.wikipedia.org/wiki/Linux%E5%85%A7%E6%A0%B8">Linux内核</a>，为<a href="https://zh.m.wikipedia.org/wiki/MINIX">MINIX</a>写的软件也可以在<a href="https://zh.m.wikipedia.org/wiki/Linux%E5%85%A7%E6%A0%B8">Linux内核</a>上使用。1991年Linus[<a href="https://zh.m.wikipedia.org/zh-cn/Linux#cite_note-16">16]</a>后来使用GNU软件代替MINIX的软件，因为使用从GNU系统来的源代码可以自由使用，这对Linux的发展有益。同时在GPL的规定下，使用GNU GPL协议的源代码可以被其他项目所使用，只要这些项目使用同样的协议发布源码。</p><p>对于GNU来说没有构成自己的操作系统是失败的，但是这个失败确实促进了行业进步与发展，<a href="https://zh.m.wikipedia.org/zh-cn/%E6%9E%97%E7%B4%8D%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E8%8C%B2">林纳斯·托瓦兹</a>曾说过如果GNU内核在1991年时可以用，他不会自己去写一个。实际上现在GNU代指的是当年发展下来的一系列软件。</p><h4><span id="gnu的组成">GNU的组成</span></h4><p>该系统的基本组成包括</p><ul><li>GNU编译器套装（<a href="https://zh.m.wikipedia.org/wiki/GCC">GCC</a>）</li><li>GNU的C库（<a href="https://zh.m.wikipedia.org/wiki/Glibc">glibc</a>）</li><li>GNU核心工具组（<a href="https://zh.m.wikipedia.org/wiki/Coreutils">coreutils</a>）</li><li>GNU调试器（<a href="https://zh.m.wikipedia.org/wiki/GDB">GDB</a>）</li><li>GNU<a href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">编程语言</a>工具程序（<a href="https://zh.m.wikipedia.org/wiki/Binutils">binutils</a>）</li><li><a href="https://zh.m.wikipedia.org/w/index.php?title=GNU_Bash">GNU Bash</a> shell<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-linuxinterface-10">[10]</a></li><li>GNOME桌面环境</li></ul><p>GNU开发人员已经转向GNU应用程序和工具的Linux 移植 ，现在也广泛应用在其它操作系统中使用，上文我们提到的MinGW实际上叫Minimalist GNU for Windows，也就是向Windows移植的GNU最小套件，是将<a href="https://zh.wikipedia.org/wiki/GCC">GCC</a>编译器和<a href="https://zh.wikipedia.org/wiki/GNU_Binutils">GNU Binutils</a>移植到Win32平台下的产物，包括一系列头文件（<a href="https://zh.wikipedia.org/wiki/Windows_API">Win32API</a>）、<a href="https://zh.wikipedia.org/wiki/%E9%9D%9C%E6%85%8B%E9%80%A3%E7%B5%90%E5%87%BD%E5%BC%8F%E5%BA%AB">库</a>和<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a>。另有可用于产生32位及64位Windows可执行文件的<a href="https://zh.wikipedia.org/wiki/Mingw-w64"><strong>MinGW-w64</strong></a>项目，是从原本MinGW产生的分支。</p><h3><span id="shell">Shell</span></h3><p>shell是种特殊的交互工具，为用户提供了启动程序，管理文件系统中的文件及运行在Linux系统中的进程的途径。shell的核心就是命令行提示符，负责shell的交互部分，允许用户输入文本命令，然后解释命令并在内核中执行。</p><p>常见的命令被用来复制、移动、重命名文件等，你用鼠标实现的操作，在shell中都可以实现，除此之外，shell也允许在命令行提示符中输入程序的名称，他会将程序名称传递给内核以启动程序。</p><p>同时也允许，将多个shell命令放入文件中作为程序执行。这些文件成为shell脚本。凡是能在命令行中执行的命令都可以放入shell脚本中作为一组命令执行。</p><p>linux中所有发行版的默认几乎都是bash shell，bash shell 是<a href="https://zh.m.wikipedia.org/w/index.php?title=GNU_Bash">GNU Bash</a> shell<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-linuxinterface-10">[10]</a> ，目的是为了替代老版本Unix系统中的Unix shell，Bash shell名字的由来非常有意思，其名字来源于一个谐音梗 Bourne Again Shell （念作 born again）的缩写，Linux 中当然不仅仅包括GNU的 Bash Shell 也包含其他的shell比如：</p><ul><li>ash：轻量级别的shell,适合运行在内存受限的环境中，比如嵌入式等。</li><li>korn：一种与Born Shell兼容的shell,但支持一些高级特性，浮点运算等。</li><li>tcsh：一种包含了一些C语言特性引入到shell脚本的shell。</li><li>zsh：一种结合了bash、korn、tcsh的特性的shell。</li></ul><p>关于shell的内容会在以后的内容中详细介绍，这里就不再赘述。</p><h3><span id="gnome桌面环境">GNOME桌面环境</span></h3><p>随着Linux系统的发展，最初的操作系统文本界面到图形化的发展，操作系统不仅仅服务于计算机开发人员，逐渐走向大众化，用户不再满足于陈旧的文本命令行交互，图形化的操作界面的日渐强烈，当然完成工作的方式不只有一种，Linux一直以来都以此为闻名。图形化桌面更是如此。Linux有多种图形化桌面可供选择。接下来会介绍一种属于GNU项目的桌面环境。</p><h4><span id="x-window-软件">X Window 软件</span></h4><p>有两个基本要素决定了你的视频环境，显卡和显示器，显卡如何让显示器显示就需要软件来实现，Linux中负责这一部分的就是X Window，X Window是图形现实的核心部分，控制Linux应用如何在显示器上呈现漂亮的窗口和图形。X Window System，通常简称为X11或X，是一个基于位图的显示系统，用于在位图显示器上提供图形用户界面（GUI）。</p><p>X Window System的关键特性包括：</p><ul><li><strong>网络透明性</strong>：X Window系统设计之初就考虑到了网络支持，允许应用程序的图形界面可以在网络上的任何地方显示，实现了客户端与服务器之间的通信。这意味着，一个运行在网络中某台计算机上的应用程序可以将其图形界面显示在连接到同一网络的另一台计算机上。</li><li><strong>客户端-服务器架构</strong>：在X Window系统中，"服务器"是运行在用户机器上的程序，它管理屏幕、键盘、鼠标等输入输出设备。"客户端"是指任何请求服务器服务的程序，比如图形应用程序。这里的“服务器”和“客户端”的概念与常规意义上的网络服务和使用者相反。</li><li><strong>设备和网络独立性</strong>：X Window系统与具体的硬件设备和网络协议无关，可以在各种不同的硬件和网络环境中运行。</li><li><strong>灵活性和扩展性</strong>：X Window提供了基本的框架和协议，开发者可以在其之上构建各种窗口管理器和桌面环境，如GNOME、KDE等，这使得用户界面可以高度定制化。</li></ul><p>尽管X Window本身不是驱动程序，但它依赖于底层的硬件驱动程序来进行图形渲染和设备输入输出操作。例如，X服务器需要与显卡的驱动程序交互，以控制屏幕上的图形显示。因此，为了使X Window系统正常工作，相应的硬件设备（如显卡、键盘、鼠标等）需要有正确安装的驱动程序。</p><p>Linux中能够实现  X window的软件不止有一种，Linux中最常见用的有：</p><ul><li>wayland</li><li><a href="http://X.org">X.org</a></li></ul><p>X.org基于最初的Unix X Windos System版本11 ，后来大家把他简称为X11,属于常用的两种的比较老的版本，新版的linux正在向wayland迁移，虽然这样说，但是目前Ubuntu22.04默认的还是X11:</p><img src="https://s2.loli.net/2024/02/11/hdk7HJRvCAWS5Zz.png" alt="image-20240211210131407" style="zoom: 67%;"><p>在首次安装Ubuntu的时X11会检测显卡和显示器，然后创建一个含有必要信息的X Window配置文件。在安装过程中，安装程序会检测一次显示器，以确定所支持的视频模式。有时这会造成显示器黑屏几秒。由于显卡和显示器的种类繁多，因此这个过程可能需要花费一点时间。</p><p>核心的X Window 软件能够生常图形化现实环境，但仅此而已。尽管这已足以运行单独的应用程序，但在日常的计算机使用中并不是特别有用，因为毕竟没有提供桌面环境，用户无法知道该如何启动程序，操作文件，为此需要在此基础上建立一个桌面环境。</p><p>注意一下，下图驱动部分是Nouveau 驱动，是X11的下层驱动：</p><p><img src="https://s2.loli.net/2024/02/11/HRAUjEODPgsiutK.png" alt="image-20240211211054589"></p><p>至于想搞明白每一个环节的具体工作可以参考：</p><h3><span id="gnome">GNOME</span></h3><img src="https://s2.loli.net/2024/02/11/IkGQJ24R6WjDlVH.png" alt="image-20240211215028684" style="zoom:67%;"><p>Gnome桌面工作在Xorg-Server的上层，提供给用户相应的桌面环境，其全称是（GNU Network object model enviroment，GNU网络对象模型环境）是另一个流行的Linux桌面环境，GNOME于1990年首次发布，现已成为许多Linux发行版默认的桌面环境。</p><p>随着发展GNOME已经度过了很多个版本，可以通过以下命令来查看当前的GNOME版本：</p><pre><code class="language-shell">neo@NeoNeuxs:~/Desktop$ gnome-shell --versionGNOME Shell 42.9</code></pre><p>GNOME桌面环境又被称为GNOME-Shell，为什么会有shell这个单词呢？</p><p>“Shell”（壳）在这里的含义与其在计算机科学中的一般含义相似，指的是一个提供用户界面的软件层，用户可以通过这个界面与系统的更深层次的功能进行交互，在操作系统中，"shell"通常指的是提供与用户交互的界面，这可以是命令行界面（CLI）或图形用户界面（GUI）。GNOME Shell 是后者的一个例子，它提供了一个图形界面供用户启动程序、管理窗口、切换任务等。</p><p>一个新版的Gnome-shell如下：</p><p><img src="https://s2.loli.net/2024/02/11/7lv8XCqNnodGhca.png" alt="Snipaste_2024-02-11_22-25-07"></p><p>参考：</p>]]></content>
    
    
    <summary type="html">GNU 介绍 GNOME桌面环境介绍 Shell介绍</summary>
    
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>JaP Photo Album (Part Two) -- 上野、渋谷、池袋、秋叶原</title>
    <link href="http://neonexusx.github.io/2025/03/12/JaP_Photo_Album(2)%20/"/>
    <id>http://neonexusx.github.io/2025/03/12/JaP_Photo_Album(2)%20/</id>
    <published>2025-03-12T09:45:34.576Z</published>
    <updated>2025-03-12T09:45:34.576Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="jap影集贰上野-渋谷-池袋-秋叶原">JaP影集（贰）–上野、渋谷、池袋、秋叶原</span></h1><p>不做任何评价，没有政治观点，屏蔽所有人物信息。</p><img src="https://s2.loli.net/2024/10/04/k5V3S6I7TJhj1ex.png" alt="image-20241004204650666" style="zoom:50%;"><p>[TOC]</p><h2><span id="东京">东京</span></h2><h3><span id="上野">上野</span></h3><p>本来去上野去买羽毛球拍，最后都没货了。路过了很饿，就先吃饭了。所以这次从拉面开始：</p><p>具体位置我也忘记了，在御徒町駅北口 コインロッカー附近，附近很多吃的。</p><img src="https://s2.loli.net/2024/10/04/amGvEQTAYPIdhCt.jpg" alt="IMG_20240219_140241" style="zoom:80%;"><p>由于是下雨天，没有很多人，在东京几乎每一家店外国人走进去服务员都能接待，我吃着的时候来了一个老外，吃的老香了，少见的放了豆芽的拉面，大块的五花肉好像是经过油炸的，汤味道很浓厚适合重口味的来品尝，趁着店员忙做饭偷拍了两张，记录下做饭的过程。</p><p>标记的地方貌似是熬好的汤底，有中预制菜的感觉，不过算便宜的了，要什么自行车～</p><p><img src="https://s2.loli.net/2024/10/04/6rSIDgL4UtnlA2o.png" alt="image-20241004185214492"></p><p>御徒町駅北口出来不远的地方就是<strong>摩利支天徳大寺</strong>，说着很大其实是个小破庙，我记得里面好像祭祀的是个人骑着猪，由于不方便拍照，就没记录下来：</p><p>去Google街景找了一下：</p><p><img src="https://s2.loli.net/2024/10/04/6RVN4otEnq2XxYj.png" alt="image-20241004185718218"></p><p>庙里面有很多许愿牌：</p><p><img src="https://s2.loli.net/2024/10/04/kFSgqAIoYhsaVO2.png" alt="image-20241004185935831"></p><p>大多数都是发财考试，还有个世界和平～，看来大家愿望都差不多。</p><p>走之前使用胶片相机拍了两张，由于是阴天效果并不太好，可以和google街景做一个对比：</p><p><img src="https://s2.loli.net/2024/10/04/quvx84rE9jbXzZn.png" alt="image-20241004190053444"></p><p><img src="https://s2.loli.net/2024/10/04/Zk5sWcT98eI3it6.png" alt="image-20241004190152957"></p><p>路过的杂货店，对面就是车站（也是使用胶片拍摄，一点都没有违和感）：</p><p>二木果子就在阿美橫町，二战后，该处是贩卖美军物资的黑市，“阿美”一词即相信源自美国。由于当时有许多售卖饴的店家聚集于此，故又名“饴横丁”。 近年货品种类已经包罗万有，除了糖果外，亦有售卖食品、衣饰、钟表、化妆品、日本土产等，除了本地居民光顾之外，也成为外国观光客造访的景点。</p><p><img src="https://s2.loli.net/2024/10/04/YLWF1AoKa6QCyU3.png" alt="image-20241004190245977"></p><p>在车站拍摄，日本的电车几乎承担了大部分公共交通运输，车站几乎都一模一样，有的车站年龄比我大多了，最早的地铁是80年代就有了，使用胶片拍摄也是一点违和感都没有：</p><p><img src="https://s2.loli.net/2024/10/04/nYEH3lLjzbMWTq5.png" alt="image-20241004190635932"></p><p><img src="https://s2.loli.net/2024/10/04/mjlMCD2oVRahczB.png" alt="image-20241004190613269"></p><h2><span id="渋谷">渋谷</span></h2><p>渋谷站出门：</p><p><img src="https://s2.loli.net/2024/10/04/X2SvsQBTz381fuO.png" alt="image-20241004191422673"></p><p>一些街景，全部都是各种商店，年轻人的聚集地。</p><p><img src="https://s2.loli.net/2024/10/04/AEYMIijTXwlVRKz.jpg" alt="IMG_6213"></p><p><img src="https://s2.loli.net/2024/10/04/3YlChBPHxEKLRpg.jpg" alt="IMG_6214"></p><p><img src="https://s2.loli.net/2024/10/04/3YlChBPHxEKLRpg.jpg" alt></p><p><img src="https://s2.loli.net/2024/10/04/Nco48qrCLWjwGIm.jpg" alt="IMG_6216"></p><p>东京骑自行车的还真不少：</p><p><img src="https://s2.loli.net/2024/10/04/qirM6JDXU79x2hw.jpg" alt="IMG_20240220_190701"></p><p><img src="https://s2.loli.net/2024/10/04/ZfSOiUVFm1WYdkb.jpg" alt="IMG_20240220_190717"></p><p><img src="https://s2.loli.net/2024/10/04/WDGrbCKoV1SMqOU.jpg" alt="IMG_20240220_190748"></p><p>某个路牌上贴满了贴纸：</p><p><img src="https://s2.loli.net/2024/10/04/MISoA5VbnGwCE1N.jpg" alt="IMG_20240221_231723"></p><p>抓拍到消防车，但是被挡住了：</p><p><img src="https://s2.loli.net/2024/10/04/uh3tP4ZvwgFBUxs.jpg" alt="IMG_6219"></p><p>MODI Store：</p><p>Chiikawa在日本真是爆火：</p><p><img src="https://s2.loli.net/2024/10/04/jXx3qYN1CSVgezJ.jpg" alt="IMG_20240220_171355"></p><p><img src="https://s2.loli.net/2024/10/04/Fobkuny9saRBvN6.jpg" alt="IMG_20240220_171351"></p><p>当时以为是炸鸡皮店，吃了以后才发现其实是素鸡皮，甜甜的配上啤酒好吃，怪不得那么便宜～</p><p><img src="https://s2.loli.net/2024/10/04/zvkT2efW68HlXgE.png" alt="image-20241004193611112"></p><h2><span id="池袋">池袋</span></h2><p>池袋这里我拍摄了很多胶片，但是由于当天天气并不好，并且受到X光影响，损失了很多照片。抢救下来只剩下：</p><p>欠曝下只剩闪烁的广告牌：</p><p><img src="https://s2.loli.net/2024/10/04/sKdQ357btieFCME.png" alt="image-20241004193123193"></p><p><img src="https://s2.loli.net/2024/10/04/sIzTPH7QqO2lvia.png" alt="image-20241004193142825"></p><p><img src="https://s2.loli.net/2024/10/04/YsApyJu3M4QTK8k.png" alt="image-20241004193155598"></p><p><img src="https://s2.loli.net/2024/10/04/7hivCYl5BdokMV1.png" alt="image-20241004193206737"></p><p><img src="https://s2.loli.net/2024/10/04/KZY3RxD9ptfWUrQ.png" alt="image-20241004193219574"></p><p><img src="https://s2.loli.net/2024/10/04/oG9BcwCYdvJQUhb.png" alt="image-20241004193246146"></p><p><img src="https://s2.loli.net/2024/10/04/zN1PZBWcGQXsFph.png" alt="image-20241004193233077"></p><p>来池袋主要是为了买EVA周边，买了很多这里就不放图片了。</p><h2><span id="秋叶原">秋叶原</span></h2><p>秋叶原<strong>AKIBA</strong>，秋叶原最初以旧品店和家电量贩店为中心，之后电子游戏浪潮时大量游戏店来到此地，伴随而生的爱好店与动漫店陆续开业。近年因都市再开发，秋叶原站周围兴建许多复合大楼，访客年龄与客层呈现多样化。同时随着动漫的发展，秋叶原也成为了二次元爱好者的聚集地。</p><p><img src="https://s2.loli.net/2024/10/04/jkIpYAaVQmb3U6r.png" alt="image-20241004201037015"></p><p>秋叶原的广告牌，特殊的咖啡厅，这算是一种包容？</p><p><img src="https://s2.loli.net/2024/10/04/axEi78fkUDgPbR2.jpg" alt="IMG_20240218_150026"></p><p>原神入侵全世界：</p><p><img src="https://s2.loli.net/2024/10/04/9b7yrYuE85w6Pos.jpg" alt="IMG_20240218_163423"></p><p>可以看到马路这个时候是不走车的，变成了步行街</p><p><img src="https://s2.loli.net/2024/10/04/7wIzYQGxqJc98eE.jpg" alt="IMG_20240218_163353"></p><p>很多大商场都是免税的，也就是所有物品九折：</p><p><img src="https://s2.loli.net/2024/10/04/1NKCLVDkayA4g9O.jpg" alt="IMG_20240218_153853"></p><p>日本本国的商品价格优势非常大，但是电子产品尤其是台湾和大陆产出的，完全没有优势，都不如京东便宜，所以完全没必要买日行。这样的电子配件在国内不值钱，来日本翻了三倍。</p><p><img src="https://s2.loli.net/2024/10/04/nByxAegtOGwU8bZ.jpg" alt="IMG_20240218_142612"></p><p>![](<img src="https://s2.loli.net/2024/10/04/1aw35AgFLMqyJVs.jpg" alt="wx_camera_1708239123844"></p><p>找了些酒，价格都不错，可惜飞机带上去比较困难：</p><p><img src="https://s2.loli.net/2024/10/04/ALFsUoPNbe8KrC3.jpg" alt="IMG_20240218_151933"></p><p>在派对吃饭的时候，看到了个有趣的贴纸：</p><p><img src="https://s2.loli.net/2024/10/04/u6Ge7x4whkbDIXU.jpg" alt="IMG_20240218_181611"></p><p><img src="https://s2.loli.net/2024/10/04/EwaLFYrfeWx3lqA.jpg" alt="IMG_20240218_181614"></p><p>派对1个小时，终于吃上了饭，店里面竟然还有中文菜单，由于不让拍照，只能厨房非常井然有序，那种西餐的厨房一样，主厨安排一切，牛肉非常好吃，价格也不贵。一定要去，和牛盖饭：</p><p><img src="https://s2.loli.net/2024/10/04/e9Tgrmhbq3VHoGX.png" alt="image-20241004202944243"></p><p><img src="https://s2.loli.net/2024/10/04/g1y2dSmRDhz54tn.jpg" alt="IMG_20240218_190020"></p><p>大多数成人商店都是不允许拍照的，以下内容为18禁：</p><p><img src="https://s2.loli.net/2024/10/04/ZcUGY8zlLgeHCER.jpg" alt="IMG_20240218_140310"></p><p><img src="https://s2.loli.net/2024/10/04/64xqz5fmp2OIWdk.jpg" alt="IMG_20240218_171512"></p><p>电器街剪影：</p><p><img src="https://s2.loli.net/2024/10/04/Jy25w6pWL3fveaN.png" alt="image-20241004194150843"></p><p>日本的电车和地铁很相似，但是由于其轨道经常走上地面，把城市建筑都分割开来，所以和地铁区别还是很大的</p><p><img src="https://s2.loli.net/2024/10/04/w8JqpiahkyGNTjl.png" alt="image-20241004200332930"></p><p>秋叶原有很多商店都是在楼上的，每一栋楼上边都有很多不同的商店。</p><p><img src="https://s2.loli.net/2024/10/04/ft4mKQjp5rieqJI.png" alt="image-20241004200352296"></p><p><img src="https://s2.loli.net/2024/10/04/yQM8ASecRmGXzNk.png" alt="image-20241004200640182"></p><p><img src="https://s2.loli.net/2024/10/04/Z2AmNqcUa4Oi63j.png" alt="image-20241004200812913"></p><p><img src="https://s2.loli.net/2024/10/04/jbPOYvLVfyJg6ae.png" alt="image-20241004200702735"></p><p>在马路中间赶快拍了一张：</p><p><img src="https://s2.loli.net/2024/10/04/jbJ9K3gMFI5NXAv.png" alt="image-20241004200851005"></p><p>日本人很喜欢的招牌夸张hhh，世界曲目最多的ktv：</p><p><img src="https://s2.loli.net/2024/10/04/wucJjUX8WeRKDmd.png" alt="image-20241004200757599"></p><p>夜晚的车站：</p><p><img src="https://s2.loli.net/2024/10/04/UHed74OAiyw3k6z.png" alt="image-20241004200946249"></p>]]></content>
    
    
    <summary type="html">日本影集贰，不包含任何评论，图片较大，耐心等待。</summary>
    
    
    
    <category term="JAP" scheme="http://neonexusx.github.io/categories/JAP/"/>
    
    
    <category term="JAP" scheme="http://neonexusx.github.io/tags/JAP/"/>
    
  </entry>
  
  <entry>
    <title>JaP Photo Album (Part One) -- Asakusa</title>
    <link href="http://neonexusx.github.io/2025/03/12/JaP_Photo_Album(1)/"/>
    <id>http://neonexusx.github.io/2025/03/12/JaP_Photo_Album(1)/</id>
    <published>2025-03-12T09:45:34.576Z</published>
    <updated>2025-03-12T09:45:34.576Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="jap影集壹浅草">JaP影集（壹）–浅草</span></h1><p>不做任何评价，没有政治观点，屏蔽所有人物信息。</p><img src="https://s2.loli.net/2024/10/03/1wLtRXqNyoTaH2M.png" alt="image-20241003015854172" style="zoom:80%;"><p>[TOC]</p><h2><span id="东京">东京</span></h2><p>成田机场至东京市中心路上的广告，其实是个很魔性的视频我只拍了结尾：</p><img src="https://s2.loli.net/2024/10/02/hwA1o2YdsqcpxGj.jpg" alt="IMG_6151" style="zoom: 50%;"><p>和某国一样多的肛肠科广告，当然目的还是拍摄很多的太阳能板和日本帅哥：</p><img src="https://s2.loli.net/2024/10/03/t5FfVXugaC1TEne.jpg" alt="IMG_6154" style="zoom:80%;"><h3><span id="浅草寺周围及浅草寺">浅草寺周围及浅草寺</span></h3><p>浅草寺正大门：</p><p>雷门是公元942年为祈求天下太平和五谷丰登而建造的。几经火灾焚毁，后于1960年重建。雷门<a href="https://baike.baidu.com/item/%E6%AD%A3%E9%97%A8/8500116?fromModule=lemma_inlink">正门</a>入口处左右威风凛凛的风神和雷神二将，镇守着浅草寺。</p><img src="https://s2.loli.net/2024/10/03/iMDg6vj53AQFnKR.jpg" alt="IMG_6156" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/ZQGOdluv9KEARXj.jpg" alt="IMG_6157" style="zoom:80%;"><p>浅草寺西南角有一座五重塔，仅次于京都<a href="https://baike.baidu.com/item/%E4%B8%9C%E5%AF%BA/1865740?fromModule=lemma_inlink">东寺</a>的五重塔，为日本第二高佛塔，正午12点左右：</p><img src="https://s2.loli.net/2024/10/03/cKr1XMoAfql6ZYF.jpg" alt="IMG_6158" style="zoom:80%;"><p>由于我居住在浅草寺周围，所以有难得一见的夜景：</p><img src="https://s2.loli.net/2024/10/03/JOc2vbNEdlHnh9a.jpg" alt="IMG_20240217_204658" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/nKmWSAqkfjrI35o.jpg" alt="IMG_20240217_204701" style="zoom:80%;"><p>正门拍摄的人和正门的大灯笼：</p><img src="https://s2.loli.net/2024/10/03/xm2PLWDpyQAqs7o.jpg" alt="IMG_20240217_204834" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/1cRSbwU6mLjAdlH.jpg" alt="IMG_20240217_204804" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/HxvUW6ubA3dlB2Q.jpg" alt="IMG_20240217_205633" style="zoom:80%;"><p>五重塔正门：</p><img src="https://s2.loli.net/2024/10/03/3Ow5BinSpUdhgfF.jpg" alt="IMG_20240217_205044" style="zoom:80%;"><p>浅草寺售卖的御守，护身符：</p><img src="https://s2.loli.net/2024/10/03/VMRJZnHdbrItoy5.jpg" alt="IMG_20240219_121837" style="zoom:80%;"><p>浅草寺有名的出抽签，投入100就可以选一个：</p><img src="https://s2.loli.net/2024/10/03/x43KT8ogEvktJ7H.jpg" alt="IMG_20240222_123720" style="zoom: 80%;"><p>如果抽到不好的签需要邦上去，但是我抽了两次（五天路过又来了一次），都是吉：</p><img src="https://s2.loli.net/2024/10/03/7x6TCyAbK4BuV89.jpg" alt="IMG_20240222_124247" style="zoom:80%;"><p>浅草周围的商业圈和卖场夜晚：</p><img src="https://s2.loli.net/2024/10/03/nuziZBa9Wd8jICm.jpg" alt="IMG_20240218_224417" style="zoom:80%;"><p>需要说明的是，这里正好是地铁站，福州等也有很类似的商业街。</p><img src="https://s2.loli.net/2024/10/03/AfRxPXqnzOLt1KD.jpg" alt="IMG_20240218_224850" style="zoom:80%;"><p>浅草五丁目：</p><img src="https://s2.loli.net/2024/10/03/awKCQROzqVxSn3U.jpg" alt="IMG_6169" style="zoom:80%;"><p>浅草五丁目，一路向前就是浅草寺：</p><img src="https://s2.loli.net/2024/10/03/uaFxLvIG8s4jKTr.jpg" alt="IMG_6170" style="zoom:80%;"><p>路过的日共海报：</p><img src="https://s2.loli.net/2024/10/03/CAjgESHDUXBr169.jpg" alt="IMG_6168" style="zoom:80%;"><p>浅草寺后广场，可以看到晴空塔：</p><p>受拍摄设备限制，比较糊：</p><img src="https://s2.loli.net/2024/10/03/heHKdntbCyTf4k8.jpg" alt="IMG_20240219_204823" style="zoom:80%;"><p>我住在浅草寺后面的居民区，晚上有人在维修道路，可以看到一个圈有好几个维护人，不作评价：</p><img src="https://s2.loli.net/2024/10/03/wXIcJWmsdSHnRGE.jpg" alt="IMG_20240218_231242" style="zoom:80%;"><p>路过一个小学的课后教室：</p><img src="https://s2.loli.net/2024/10/03/c8TXPiryzHkbtIO.jpg" alt="IMG_20240219_210136" style="zoom:80%;"><p>使用胶片拍摄的，由于我是胶片新手，曝光没有控制好，就在这个教室旁边，有一个很日本的摇篮：</p><p>条纹是由于x光导致的，海关的X光。</p><img src="https://s2.loli.net/2024/10/03/1COhr2SPaGbzBVf.png" alt="image-20241003012607161" style="zoom:80%;"><p>过了几个路口，就到了我住的红灯区：没错你没听错，这里确实是有名的红灯区，夜晚都是来找送人的出租车，这里是红灯区和居民区的分界线：</p><img src="https://s2.loli.net/2024/10/03/gwnqDGPX7pYuc5x.jpg" alt="IMG_20240219_210524" style="zoom:80%;"><p>路过的红灯区：</p><img src="https://s2.loli.net/2024/10/03/l1KI7BCqFfEQMbh.jpg" alt="IMG_20240218_232514" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/5bxnGDwYPAltF3a.jpg" alt="IMG_20240222_112047" style="zoom:80%;"><p>很暴露的写真广告：</p><img src="https://s2.loli.net/2024/10/03/Zwep5SivbmTAECY.jpg" alt="IMG_20240220_220132" style="zoom:80%;"><p>迷路的时候看到的炸鸡店，最后没找到去吃：</p><img src="https://s2.loli.net/2024/10/03/3qVHR58gDUyQv1j.jpg" alt="IMG_20240220_213604" style="zoom:80%;"><p>迷路的时候路过的吉原神社，门口有一个洗手池子：</p><img src="https://s2.loli.net/2024/10/03/kuCvtG79b6DNgQY.jpg" alt="IMG_6164" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/LeGwhAW6U3uHMbv.jpg" alt="IMG_6165" style="zoom:80%;"><p>红灯区的牌坊，反黑帮证，很资本主义：</p><img src="https://s2.loli.net/2024/10/03/ERWYsKaNkwVnHLP.jpg" alt="IMG_6160" style="zoom:80%;"><p>浅草寺周围的拉面店里，这时我在日本吃的第一餐，使用富士的一次性胶片相机拍摄，屏蔽了人物信息。</p><p><img src="https://s2.loli.net/2024/10/03/c8FANdBHSYGjMRi.png" alt="image-20241003004626915"></p><p>第一顿饭永远是最香的：</p><p>浅草寺五丁目往前走，的一家酱油拉面店，非常好吃，第一次使用售票机购餐，由于在店里面不方便拍摄，只留下了最珍贵的两张，餐厅是那种开放式的，购买餐券之后交给厨师，英语交流也很ok毕竟是在景区周围：</p><img src="https://s2.loli.net/2024/10/03/a86mRTjiycQK5ve.jpg" alt="IMG_6161" style="zoom:80%;"><p>这家拉面店对面的另外一家拉面，拉面大多数都是猪骨熬汤，这家店比较特殊，当然价格也比较贵：</p><img src="https://s2.loli.net/2024/10/03/xJunIHf3ZoDvUdE.jpg" alt="IMG_6171" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/b4v5NEISTHVJFPc.jpg" alt="IMG_6172" style="zoom:80%;"><p>周围卖的小吃，玉团子，其实就是年糕外边裹了糖浆，很粘牙：</p><p><img src="https://s2.loli.net/2024/10/03/rSadwgDNj1fp53U.png" alt="image-20241003011339841"></p><p>吃旋转寿司：</p><img src="https://s2.loli.net/2024/10/03/x2vNWY3Gud7hcsz.jpg" alt="IMG_20240218_123432" style="zoom:80%;"><p><img src="https://s2.loli.net/2024/10/03/Kk5r8s2nMHDUgu3.png" alt="image-20241003021246348"></p><p>两个人吃的还不少：</p><img src="https://s2.loli.net/2024/10/03/x7l9JQr5TPFY4wt.jpg" alt="IMG_20240218_130359" style="zoom:80%;"><p>晚上在浅草寺周围商圈的居酒屋，喝啤酒，进去之后店员看我年龄很小，很奇怪hhh，点餐用的APP，这是唯一一个在日本见到可以用app点餐的。</p><img src="https://s2.loli.net/2024/10/03/eMw4pQybc5A6GLm.jpg" alt="IMG_20240219_200430" style="zoom:80%;"><p>啤酒很爽口，但烤肉很咸：</p><img src="https://s2.loli.net/2024/10/03/olLcGiVKDMYItnp.jpg" alt="IMG_20240219_201847" style="zoom:80%;"><p>路过一家卖烤饭的店，很有特色的是他们家把套餐的所有都做成模型来展示：</p><img src="https://s2.loli.net/2024/10/03/5Albry8ST1DezaO.jpg" alt="IMG_20240220_202357" style="zoom:80%;"><p>看起来很少，吃起来竟然是很饱。有一说一这个价格在这地段很不错了，米也比国内大部分店里面的更好吃。</p><p><img src="https://s2.loli.net/2024/10/03/HqEivJu7wkdnKbW.jpg" alt="IMG_20240220_203651"></p><p>第二天路过的时候又去吃了一次，不仅是好吃，店员有个很卡哇伊的。</p><img src="https://s2.loli.net/2024/10/03/DhL5lsZyYzJGErk.jpg" alt="IMG_20240221_113049" style="zoom:80%;"><p>浅草寺周围有一个唐吉克德，就是日本开的和比较多的超市大卖场：</p><p><img src="https://s2.loli.net/2024/10/03/NSa4EKxALZikyGq.png" alt="image-20241003013229300"></p><p>门口还有一个鳗鱼：</p><img src="https://s2.loli.net/2024/10/03/tykpIv3U7iXNquY.png" alt="image-20241003013117902" style="zoom:80%;"><p>售卖的各种烟，需要找店员才能看到实物：</p><img src="https://s2.loli.net/2024/10/03/TOitmdR9G1JFeUQ.jpg" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/TOitmdR9G1JFeUQ.jpg" alt="IMG_20240219_204005" style="zoom:80%;"><p>店内的牛奶价格，只能说很便宜还好喝，我买了两种，看到好像是由于工艺不同，国内大部分是巴氏杀菌，日本好像是相反的冷处理。</p><p>看了下国内价格，进口进来基本都在三倍以上。</p><img src="https://s2.loli.net/2024/10/03/zXO9B2dviAVopqN.jpg" alt="IMG_20240218_225738" style="zoom:80%;">]]></content>
    
    
    <summary type="html">日本影集，不包含任何评论，图片较大，耐心等待。</summary>
    
    
    
    <category term="JAP" scheme="http://neonexusx.github.io/categories/JAP/"/>
    
    
    <category term="JAP" scheme="http://neonexusx.github.io/tags/JAP/"/>
    
  </entry>
  
  <entry>
    <title>Git(2)</title>
    <link href="http://neonexusx.github.io/2024/10/22/Git__Base(2)/"/>
    <id>http://neonexusx.github.io/2024/10/22/Git__Base(2)/</id>
    <published>2024-10-21T16:40:01.000Z</published>
    <updated>2025-03-13T08:18:05.646Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="git分支管理2">Git——分支管理（2）</span></h1><img src="https://s2.loli.net/2024/10/22/zFJb9U6fiaprvdR.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1729527720427" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:50%;"><h2><span id="提示图床在国外且动图比较多的情况下需要时间加载">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2><h2><span id="目录">目录：</span></h2><!-- toc --><ul><li><a href="#git%E5%9F%BA%E7%A1%80">Git基础</a><ul><li><a href="#git%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8Ehead">Git的分支与HEAD</a><ul><li><a href="#git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6">Git的存储机制</a></li><li><a href="#git%E7%9A%84%E5%88%86%E6%94%AF%E6%8C%87%E9%92%88">Git的分支指针</a></li></ul></li><li><a href="#git%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">Git的远程仓库</a></li><li><a href="#git%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">Git的远程分支管理</a></li></ul></li><li><a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86">远程分支和本地仓库的冲突处理</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E6%83%85%E5%86%B5">查看当前分支情况</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="git基础">Git基础</span></h2><p>关于Git的基础请参考上一篇基础的教程，这里主要是关于Git的分支管理的内容，在讲解完成之后会以实战的形式让各位更好的理解如何使用Git这一个强大的工具。</p><h3><span id="git的分支与head">Git的分支与HEAD</span></h3><h4><span id="git的存储机制">Git的存储机制</span></h4><p>当你发起提交的时候，Git存储的是提交对象，其中包含了指向暂存区快照的指针。</p><p>Git在仓库区一般会这样保存对象：</p><pre class="mermaid">graph LRA("提交对象") --&gt; C("Tree对象") --&gt;B("Blob1对象")C--&gt;D("Blob2对象")</pre><ul><li><p>提交对象，一次提交包含着元数据以及指向项目根目录的树对象的指针，以便需要的时候重新创建这次快照。</p><img src="https://pic4.zhimg.com/80/v2-b8b7d634df1cf8a9d079c762fc2781b3_720w.webp" alt="image.png" style="zoom:80%;"></li><li><p>Blob 对象，只用于存储单个文件内容，一般都是二进制的数据文件，不包含任何其他文件信息，比如不包含文件名和其他元数据,可以同时有多个。</p></li><li><p>Tree 对象，对应文件系统的目录结构，里面主要有：子目录 (tree)，文件列表 (blob)，文件类型以及一些数据文件权限模型等。</p></li></ul><p>Git将文件的快照存储为对象，每个对象都有一个唯一的哈希值。当文件发生变化时，Git会计算新文件的哈希值，并将其作为新对象存储在对象数据库中。当Git检测到两个文件版本相似时，它会计算差异（即两个版本之间的不同之处），并将这些差异作为一个新的对象存储。这个差异对象会引用原始文件的哈希值，以便可以重构原始文件的内容。</p><h4><span id="git的分支指针">Git的分支指针</span></h4><p>Git的分支只不过是一个指向某次提交的轻量级的可以移动指针，Git默认的分支名是master,当你发起提交的时候就有了一个指向最后一次提交的master分支。每次提交时他都会自己向前移动。</p><p>举个例子：</p><pre class="mermaid">graph LRH("HEAD")  --&gt;GG("master") ==&gt; Commit_C    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C</pre><p>也就是说分支其实就是指针，指针指向某一次提交。其中比较特殊的是HEAD指针，是用来指向当前分支指针的指针，表示当前在master分支上。</p><h3><span id="git的远程仓库">Git的远程仓库</span></h3><p>远程分支是指远程仓库的分支指针，这些指针存在于本地且无法被移动，当你与服务器进行网络通信的时候，他会自动更新，也就是使用pull等命令的时候，远程分支有点像书签，会提示你上一次连接服务器时远程仓库中每个分支的位置。</p><pre class="mermaid">graph LRG("master") ==&gt; Commit_C    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C     H("remote") ==&gt; Commit_C</pre><p>remote指针同master指针一样，都是一个指针而已。</p><h3><span id="git的远程分支管理">Git的远程分支管理</span></h3><p>合并冲突</p><p>Fast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>main节点落后于服务器上的main（以后都称之为origin/main），<strong>此时执行Fast-forward操作就是把本地分支main合并到orgin/main之上</strong>，此时main指针会向前走一个，这样的操作就是Fast-forward。</p><p>合并之后结果如下：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_C    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>merge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_A --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。</p><pre class="mermaid">graph LR    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end         subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end         subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end                   subgraph merge_commit        direction TB        G("提交对象C") --&gt; H("文件对象C")     end          Commit_A --&gt; Commit_B     Commit_A --&gt; Commit_C     Commit_C --&gt; merge_commit     Commit_B --&gt; merge_commit     merge_commit --&gt; J("orgin/main")     merge_commit --&gt; I("main")</pre><p>Rebase操作指的是在上述情况之上直接将某个分支之上所有提交的更改在另一个分支上重现一遍。</p><p>为了Rebase需要先找到两个要整合的分支的共同祖先，然后取得当前所在分支的每次提交引入的变更，并把这些变更保存成文件，这之后将当前分支重置为要整合到的分支，然后在该分支上依次引入之前保存的每个更改。</p><p>在合并之前分支已成这个样子：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_A --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>当我们想把远程分支的内容整合到main分支之上（就是将orgin/main rebase到 main）的话就会有如下情况，合并之后：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C+        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C+     H("orgin/main") ==&gt; Commit_C+</pre><p>可以看到这里实际上变化成了Fast-forward所处理的情况，再次执行Fast-forward（merge）即可完成操作。</p><h2><span id="远程分支和本地仓库的冲突处理">远程分支和本地仓库的冲突处理</span></h2><h3><span id="查看当前分支情况">查看当前分支情况</span></h3><p>查看当前分支信息：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch* main  test</code></pre><p>加上参数v可以显示当前每个分支的最新提交和其的提交信息，加上a则会包括当前的远程分支：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av* main                dd0258f [ahead 3] Merge branch 'test'  test                8eafb31 update git rm pycharm  remotes/origin/HEAD -&gt; origin/main  remotes/origin/main e5d18d7 del copy</code></pre><p><code>*</code>代表了HEAD指针所处位置，也就是当前所在的分支。 <code>update git rm pycharm</code>就是对应的提交信息。<code>e5d18d7</code>就是提交对象的散列值。</p><p>如果要查看已并入当前的分支的所有分支信息可以使用：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av --merged* main                dd0258f [ahead 3] Merge branch 'test'  test                8eafb31 update git rm pycharm  remotes/origin/HEAD -&gt; origin/main  remotes/origin/main e5d18d7 del copy</code></pre><p>相反的，显示没有并入分支的命令可以使用（注意这里和上文并不是一个仓库，你可以看到对应的路径不同）：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/Desktop/Essays$ git branch -av --no-merged  remotes/origin/HEAD -&gt; origin/main  remotes/origin/main e5d18d7 del copy</code></pre><p>但是以上的方式都不够明显展示分支的变化及历史，所以推荐还是使用如下命令：</p><pre><code class="language-bash">git log --graph --decorate --oneline --all</code></pre><p>如图展示了两个本地的仓库，其中二者的远程仓库是保持一致的，也就是说二者都有一样的远程信息，但是本地却差别很大，我们的工作就是尽量合并二者的内容并优化分支结构。</p><img src="https://s2.loli.net/2024/05/06/lrENoDWkt92Fd36.png" alt="image-20240506012058410" style="zoom:67%;"><p>在看到二者的分支图的时候我们就能看到：</p><p>图中的领先指的是领先远程仓库的意思。</p><img src="https://s2.loli.net/2024/05/06/zuK2aUAx384oBr6.png" alt="image-20240506012643030" style="zoom: 67%;"><p>简单来说我们的解决方案如下</p><p>首先rebase仓库A,将仓库A的main分支rebase到远程上然后push到服务器。</p><p>然后将远程新的内容pull到仓库B，再进行一次rebase然后将内容push到服务器。最终再pull，仓库A、仓库B、服务器三者就可以实现同步。</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/Desktop/Essays$ git rebase origin/mainSuccessfully rebased and updated refs/heads/main.</code></pre><p>reabase之后：</p><img src="https://s2.loli.net/2024/05/06/v1zQSXFucd45ROx.png" alt="image-20240506020430611" style="zoom:67%;"><p>由于仓库B还有部分内容没有提交，这里就再提交一次：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git commit -a -m "finished git 1"[main e2fdc30] finished git 1 1 file changed, 61 insertions(+), 6 deletions(-)</code></pre><p>提交之后分支如下,本次提交并不影响合并方案，只是单纯多加了一次提交而已。</p><img src="https://s2.loli.net/2024/05/06/ixv7hQX3VoBcWlN.png" alt="image-20240506020817574" style="zoom:67%;"><pre><code class="language-bash">git pull --rebase# 等价于：git fetch origin/maingit rebase origin/main</code></pre><img src="https://s2.loli.net/2024/05/06/Dy1olHPMKZExYLT.png" alt="image-20240506023005761" style="zoom:67%;"><p>其中的分支变化如下：</p><img src="https://s2.loli.net/2024/05/06/6XujLS5UyvFc4pf.png" alt="image-20240506032249539"><p>关于rebase的变化的解释：</p><p>根据精通Git（第二版）的内容，其变基按照如下的方式：</p><ul><li>判断出分支上那些工作是本地独有的（245d、8ea、dd02、e2fdc）。</li><li>判断出哪些提交不是合并提交（245d、8ea、e2fdc）。</li><li>判断出哪些提交并没有被重写到基分支上（orgin/master）（245d、8ea、e2fdc）。</li><li>把筛选出来的分支重写到基分支上</li></ul><p>Git会将合并提交的更改拆分成多个单独的提交，并将它们重新应用在远程分支的顶部。这意味着原始的合并提交（在这个例子中是 <code>dd0258f</code>）不再存在于变基后的分支历史中。</p><p>245df5e提交和e5d18提交完全一致，并不是有效提交，所以被舍弃。</p><p><img src="https://s2.loli.net/2024/05/06/AXrHNwx89vnEa2I.png" alt="image-20240506025758663"></p><p>需要注意的是，没有手动推送上图中test分支，服务器上实际上是没有245df5e,8eafb31的信息的。</p><p>参考：精通Git（第二版）</p>]]></content>
    
    
    <summary type="html">关于Git的分支管理</summary>
    
    
    
    <category term="git" scheme="http://neonexusx.github.io/categories/git/"/>
    
    
    <category term="branch" scheme="http://neonexusx.github.io/tags/branch/"/>
    
    <category term="base" scheme="http://neonexusx.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Git(1)</title>
    <link href="http://neonexusx.github.io/2024/10/22/Git__Base(1)/"/>
    <id>http://neonexusx.github.io/2024/10/22/Git__Base(1)/</id>
    <published>2024-10-21T16:40:01.000Z</published>
    <updated>2025-03-13T08:18:05.646Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="git关于git的一些补充1">Git——关于Git的一些补充（1）</span></h1><img src="https://s2.loli.net/2024/10/22/zrPTFChwRB1jf9g.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1729527526564" style="zoom: 50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h2><span id="提示图床在国外且动图比较多的情况下需要时间加载">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2><h2><span id="目录">目录：</span></h2><!-- toc --><ul><li><a href="#git%E5%9F%BA%E7%A1%80">Git基础</a><ul><li><a href="#git%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Git文件的生命周期</a></li><li><a href="#git%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86">Git文件的存储空间的划分</a></li><li><a href="#git%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">Git安装过程补充说明</a></li><li><a href="#git%E7%9A%84%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C">Git的撤销操作</a><ul><li><a href="#%E4%BF%AE%E6%AD%A3%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E6%8F%90%E4%BA%A4">修正上一次的提交</a></li><li><a href="#%E6%92%A4%E9%94%80%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6">撤销暂存区的文件</a></li></ul></li><li><a href="#git%E7%9A%84rm%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85">Git的rm命令补充</a></li><li><a href="#git%E7%9A%84diff%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85">Git的diff命令补充</a><ul><li><a href="#git-diff-%E8%A7%A3%E6%9E%90">Git diff 解析</a></li></ul></li></ul></li><li><a href="#git%E7%9A%84mv%E5%91%BD%E4%BB%A4">Git的mv命令</a></li><li><a href="#github-windows-version-install">Github Windows Version Install</a></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="git基础">Git基础</span></h2><p>基础内容请参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰Git教程</a>，这里只做一点概念的补充，来方便理解。</p><h3><span id="git文件的生命周期">Git文件的生命周期</span></h3><p>此部分补充上述教程中<strong>创建版本库</strong>的部分内容</p><p>Git所管理的文件可以处于以下五种状态：</p><p>未跟踪（untracked）、未修改（clean）、已修改（modified）、已暂存（staged）、已提交（committed）</p><pre class="mermaid">sequenceDiagramparticipant untrackedclean -&gt;&gt; untracked:(rm)clean  --&gt;&gt; modified:(edit data or code)untracked --&gt;&gt; staged:(add)modified --&gt;&gt; staged: (add)staged --&gt;&gt; +committed:(commit)committed -&gt;&gt;-clean: (committed)</pre><p>上图中（浏览器右侧有切换到浅色主题的按钮，使用之后看的更清楚），线上的命令代表了在各个状态变化中使用的命令名称，状态clean和其翻译并对不上，其原因是clean代表的是刚刚完成克隆或者刚刚提交完成之后的仓库状态，详细状态切换及使用的命令的参数可以参考廖雪峰的教程。其中committed部分指的是每次提交完成之后工作区的代码又返回了clean状态，即没有变化，更改的意思，并没有其对应的命令。</p><p>由此五种状态的转变可以引出——什么是<strong>仓库</strong>?</p><p>Git是如何在存储空间中划分的?</p><p>是如何将的代码在各个状态中进行保存的？</p><h3><span id="git文件的存储空间的划分">Git文件的存储空间的划分</span></h3><ul><li>**工作目录(Working Directory)：**工作目录实际上是项目中某一个版本的单次检出（check out）。这些文件是从Git目录下的压缩数据库内被提取出，放置在磁盘上以供使用和修改。也就是你能看到的项目内容。</li><li><strong>暂存区(Stage/Index)：暂存区是一个文件，一般位于Git目录中</strong>，保存了下次提交内容的相关信息。有时候也被称之为<strong>索引</strong>。</li><li><strong>Git目录(Repository)：</strong>：Git目录是保存项目元数据和对象数据库的地方。这是Git最重要的部分，也是其他计算机中克隆仓库时复制的内容。</li></ul><p>在你使用命令之后整个工作流程 上划分如下：</p><pre class="mermaid">sequenceDiagrambox rgb(30,144,255, .5) Working Directoryparticipant untrackedparticipant cleanparticipant modifiedendbox rgb(0,255,255, .5) Indexparticipant stagedendbox rgb(255,65,81,.8) Repositoryparticipant committedendclean -&gt;&gt; untracked:(rm)clean  --&gt;&gt; modified:(edit data or code)untracked --&gt;&gt; staged:(add)modified --&gt;&gt; staged: (add)staged --&gt;&gt; +committed:(commit)committed -&gt;&gt;-clean: (committed)</pre><p>蓝色部分是你的工作区域，也就是你修改的或者使用的代码皆是存在于此的,其中比较重要的是add和commit命令，使用这两个命令或者操作会将文件拉入Index区或者Repository区。受限于mermaid画图无法嵌套，实际上Index应是Repository区的一部分。</p><h3><span id="git安装过程补充说明">Git安装过程补充说明</span></h3><img src="https://s2.loli.net/2024/03/20/Az8EiRo5dcKFJyU.png" alt="git_pull" style="zoom: 80%;"><p>在安装过程中，git会让你选择pull操作的逻辑：</p><p>Fast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：</p><pre class="mermaid">sequenceDiagram  main --&gt;&gt; orgin/main : pull</pre><p>main节点落后于服务器上的main（以后都称之为origin/main），此时执行Fast-forward操作就是将当把服务器的远程分支合并到main之上，也就是执行merge操作，此时main指针会向前走一个，这样的操作就是Fast-forward。</p><p>merge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：</p><pre class="mermaid">graph LRFirst_commit--&gt;Second_commitFirst_commit --&gt; Remote_commitSecond_commit --&gt;merge_commitRemote_commit --&gt;merge_commit</pre><p>在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。</p><p>Rebase操作指的是在上述情况之上直接将Remote_commit修改，再合并到Second_commit之上：</p><pre class="mermaid">graph LRFirst_commit--&gt;Second_commitSecond_commit --&gt;Remote_commit_changed</pre><p>这里选择默认即可。当然git pull --rebase操作不仅仅能实现这种效果，更多内容请参考下一篇，关于分支管理的内容。</p><h3><span id="git的撤销操作">Git的撤销操作</span></h3><h4><span id="修正上一次的提交">修正上一次的提交</span></h4><p>撤销上一次的提交指的是上一次的提交会被这次新的提交所覆盖，假设你的commit信息在上次输入错误了，我们就可以使用：</p><pre><code class="language-bash">git commit --amend</code></pre><p>来再次进行提交，这次提交还是会打开输入信息框，修改后信息就会更新，且上一次提交就被覆盖了或者说应该是被修正了。</p><p>第一次提交：</p><img src="https://s2.loli.net/2024/05/04/aiWVk9C2Pxw6l7N.png" alt="image-20240504170607739" style="zoom: 80%;"><p>第二次提交：</p><img src="https://s2.loli.net/2024/05/04/C2itf4nJyqeI58h.png" alt="image-20240504170440919" style="zoom:80%;"><h4><span id="撤销暂存区的文件">撤销暂存区的文件</span></h4><p>如果你不小心提交了不该提交的内容到index区，我们可以使用：</p><pre><code class="language-bash">git reset HEAD filename</code></pre><p>来将其从暂存区中删除，记得不要使用rm，rm同时也会把其从工作区一起删除，这是二者的区别。</p><h3><span id="git的rm命令补充">Git的rm命令补充</span></h3><p>要从版本管理系统中移除某一个文件，你需要把它先从已跟踪文件列表里面删除，然后再提交修改才可以，这里就要使用rm命令来实现，如果没有使用git rm，而是简单的直接从文件列表删除，就会产生如下后果：</p><p>我们将copy结尾的文件删除，其已经被修改后提交：</p><img src="https://s2.loli.net/2024/05/04/qAQYlBJtoOypmdi.png" alt="image-20240504161643586" style="zoom: 80%;"><p>我们将其手动删除，查看git的状态。</p><p><img src="https://s2.loli.net/2024/05/04/wcDiKaIsxWnbSTq.png" alt="image-20240504162813549"></p><p>这里就会提示你有一个删除操作没有提交到暂存区，你需要手动使用</p><pre><code class="language-bash">git add .</code></pre><p>来将删除操作暂存，并用commit命令提交到committed区。</p><p><img src="https://s2.loli.net/2024/05/04/CiKJpLdIoen9gDO.png" alt="image-20240504163209617"></p><p>这样的操作略显麻烦，不过问题不大，我们可以直接使用rm命令来进行操作。<strong>rm命令会将文件从暂存区和工作区直接删除</strong>，这样提交的时候就不会有未跟踪的文件提示了。</p><p><img src="https://s2.loli.net/2024/05/04/vlLWsxwRzoQd31B.png" alt="image-20240504163329446"></p><h3><span id="git的diff命令补充">Git的diff命令补充</span></h3><p>在安装完成之后，我们使用git bash 来查看 diff，在diff查看之前我们应该有一个已经committed的版本，方便我们来查看不同之处，这里使用的就是本篇文章的存储库来查看，</p><p>写到这里，我们使用命令：</p><pre><code class="language-bash">git diff</code></pre><p>效果如下：</p><img src="https://s2.loli.net/2024/05/04/Cda3xO4zrnKjIMQ.png" alt="image-20240504065415466" style="zoom:67%;"><p>上图红红绿绿的部分，就是代表了修改的内容，这个表格是用来查看你相对于索引（index）（下次提交的暂存区域）所做的修改。 换句话说，这些差异是你_可以告诉 Git 进一步添加到索引中，但你仍然没有。，我们从头开始，解析这一段代表的是什么意思。</p><h4><span id="git-diff-解析">Git diff 解析</span></h4><p>git所使用的diff是1990年，GNU diff率先推出了"合并格式"的diff，将需要比较文件的上下文合并在一起显示的一种diff格式、不同的diff格式不同，目前比较多的是GNU diff格式，git在此基础上添加了一些信息，用来显示一些内容。</p><p>第一部分实际上是文件的基本信息，用来显示git的对象：</p><p>一般格式如下：</p><pre><code class="language-bash">　　diff --git a/f1 b/f1</code></pre><p>进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。</p><p>由于我的文件包含中文，所以中文被解析成了对应的字符，仔细看实际上是能发现对应的内容的：</p><p><img src="https://s2.loli.net/2024/05/04/h21MAUDnIKNGZci.png" alt="image-20240504071327934"></p><p>然后一行显示的是两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）</p><pre><code class="language-bash">index a7a1862..fcf1525 100644</code></pre><p>第三行表示进行比较的两个文件。</p><p><img src="https://s2.loli.net/2024/05/04/rx3Rhn2KuSql5sJ.png" alt="image-20240504071546670"></p><p>"—“表示变动前的版本，”+++"表示变动后的版本。</p><p>第二部分，变动的位置用两个@作为起首和结束。</p><pre><code class="language-bash">@@ -33,14 +33,18 @@</code></pre><p><code>-33</code>中<code>-</code>代表第一个文件也就是上一个版本的文件，33代表第33行，<code>14</code>代表连续14行，合在一起意思就是从33行起连续14行，同样的，<code>+</code>代表变动后的文件，从33行开始一直到18行。</p><p>第三部分，就是具体的修改内容了：</p><p><img src="https://s2.loli.net/2024/05/04/NDy3dtEzwSjgGiC.png" alt="image-20240504160151147"></p><p>文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。图片中的<code>+- --</code> 均为文档自身包含一个-号，与git无关。</p><p>参考：<a href="https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">读懂diff - 阮一峰的网络日志 (ruanyifeng.com)</a></p><h2><span id="git的mv命令">Git的mv命令</span></h2><p>git并不会显式的跟踪文件的移动，如果你在文件管理系统中，直接重名了文件，git并不能发觉，会将其认为是一个新的文件，如此这般我们就需要将文件重新加入到跟踪队列，实际上我们可以说使用git mv命令来实现更快捷的操作：</p><p>如图我们直接修改文件夹中的README.md文件为README，此时git会发觉到：</p><p><img src="https://s2.loli.net/2024/05/05/8WlI4OXQTgKF6zB.png" alt="image-20240505201754780"></p><p>不过问题不大我们可以直接用mv来修改，这样git就会自动将其加入到追踪文件中：</p><pre><code class="language-bash">git mv README.md README</code></pre><p>此时可以看到对应的文件被变成了这个样子：</p><p><img src="https://s2.loli.net/2024/05/05/XiM13yEHIQYtPhj.png" alt="image-20240505201925068"></p><p>我们直接提交修改即可。需要注意的是，这一个操作相当于将其改名之后，并将其提交到stage区域，如果你想改回来，就需要将暂存区的内容清空使用上文的reset命令，最后再手动将名字修改回来。</p><h2><span id="github-windows-version-install">Github Windows Version Install</span></h2><p>很多人上来就要安装Git for windows项目，我是不推荐的，Github针对Git开发了更方便的Github Desktop软件，主要包含GUI和操作，同时也针对了PowerShell做了兼容，这一点非常好。便于跨平台的使用。(这是比较老的说法了，实际上他们放弃了维护CLI部分，专注使用GUI部分，详见：<a href="https://stackoverflow.com/questions/34565238/where-does-github-desktop-install-command-line-version-of-git">Where does Github desktop install command line version of Git - Stack Overflow</a>)，但对新手来说GUI更适合一点，虽然无法使用全部的Git命令，但GUI已经足够了。</p><p>下载地址如下：<a href="https://desktop.github.com/">GitHub Desktop | Simple collaboration from your desktop</a></p><p>下载后注册账号登陆即可：</p><img src="https://s2.loli.net/2024/03/19/KMDWurV9LT4BEks.png" alt="image-20240319230316232" style="zoom:67%;"><p>设置本地Git信息也是易如反掌，我的建议是对于工具类不需要太过深入了解，但是要有求知的心，建议看完Git for Windows项目的教程之后再来看这个会更加理解，本人入门的时候也是用的Git for Windows来进行配置的，整个过程受益颇多。</p><img src="https://s2.loli.net/2024/03/19/dP9IvSoFAfQ6gLR.png" alt="image-20240319231027438" style="zoom:67%;"><p>我们可以简单过一遍教程：</p><img src="https://s2.loli.net/2024/03/19/X7RhIFyA136Gv95.png" alt="image-20240319231115582" style="zoom:67%;"><p>这里省略了几个验证的细节，只需要点点就可以了，来到正式的界面：</p><img src="https://s2.loli.net/2024/03/19/eCDZ7wXPvxYk5RL.png" alt="image-20240319231404949" style="zoom:67%;"><p>右侧写了教程的步骤，这里要我们创建一个新的分支，分支的含义在这里已经详细阐述了，简单来说就是可以允许不同版本的代码同时在相同仓库下进行开发。点击创建新的分支之后：</p><img src="https://s2.loli.net/2024/03/19/62jQlzivfNc5npk.png" alt="image-20240319231619311" style="zoom:67%;"><img src="https://s2.loli.net/2024/03/19/g3HRmj8wDQfIlAi.png" alt="image-20240319231712553" style="zoom: 80%;"><p>会使用系统默认的编辑器打开对应文本文件：</p><img src="https://s2.loli.net/2024/03/19/d6F8ScXOKLpyTIP.png" alt="image-20240319231807726" style="zoom:67%;"><p>在下方添加以下总结信息，这对参与项目者十分重要，来标识你干了什么。</p><img src="https://s2.loli.net/2024/03/19/AeWmqkO4jX2CQrs.png" alt="image-20240319231917272" style="zoom:67%;"><p>最后将分支推送到Github之上：</p><img src="https://s2.loli.net/2024/03/19/CbuW9apGqoK5VHj.png" alt="image-20240319232010779" style="zoom:67%;"><p>pull request，是将你修改好的代码推送到审核人员那里，在审核人员将你实现的功能合并到主分支或者某一个分支之上。</p><img src="https://s2.loli.net/2024/03/19/NQGVcslxkqAomgY.png" alt="image-20240319232103905" style="zoom:67%;"><p>跳转到网页进行申请处理</p><img src="https://s2.loli.net/2024/03/19/GfbUMrgaVCxk5O2.png" alt="image-20240319232223793" style="zoom: 80%;"><p>审核人员审核之后也就是分支合并之后，可以选择删除你的开发分支，删除之后GIt上就剩下了一个分支。</p><img src="https://s2.loli.net/2024/03/19/6xujJ7V1TZhek8P.png" alt="image-20240319232351124" style="zoom: 80%;">]]></content>
    
    
    <summary type="html">关于Git的一些补充，包含一些基础之类的，以防忘记</summary>
    
    
    
    <category term="git" scheme="http://neonexusx.github.io/categories/git/"/>
    
    
    <category term="branch" scheme="http://neonexusx.github.io/tags/branch/"/>
    
    <category term="base" scheme="http://neonexusx.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（第一个Android项目）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.574Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门第一个android项目">Android开发笔记——快速入门（第一个Android项目）</span></h1><img src="https://s2.loli.net/2024/09/29/MrYRTUN64jDSZ5c.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727615445573" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><p>[TOC]</p><!-- toc --><ul><li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAandroid%E9%A1%B9%E7%9B%AE">第一个Android项目</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAandroid%E6%A8%A1%E6%8B%9F%E5%99%A8">创建一个Android模拟器</a></li><li><a href="#%E9%A1%B9%E7%9B%AE%E5%86%85%E5%AE%B9%E5%88%86%E6%9E%90">项目内容分析</a></li><li><a href="#androidmainifestxml%E7%9A%84%E5%88%86%E6%9E%90">AndroidMainifest.xml的分析</a></li><li><a href="#buildgradle%E7%9A%84%E5%88%86%E6%9E%90">build.gradle的分析</a><ul><li><a href="#buildgradle%E7%9A%84%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE">build.gradle的模块配置</a></li></ul></li></ul><!-- tocstop --><h2><span id="第一个android项目">第一个Android项目</span></h2><p>首先你需要安装<strong>Android Studio</strong>来进行开发，详细安装过程可以参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123426867">Android开发笔记——快速入门（壹)</a></p><p>根据教程创建一个基于<strong>Kotlin</strong>的项目：</p><p>选择新建一个项目以后，选择<strong>Empty Activity</strong>，点击next。</p><p><img src="https://s2.loli.net/2024/09/29/o35u4nGSqmU6cgl.png" alt="13"></p><p>接下来配置项目一些属性，</p><p><strong>Name</strong>代表了项目的名称；</p><p><strong>Package name</strong>表示项目的包名，在<strong>Android</strong>中项目的包名可以用来区分不同的应用程序这个一定要保持唯一性，通常会根据<strong>Name</strong>来自动设定；</p><p><strong>Save Location</strong>表示代码存放的位置，看个人喜好设定；</p><p><strong>Language</strong>选择<strong>Kotlin</strong>；</p><p>**Minimum SDK：**SDK最小支持的 JAVA API level等级；</p><p>最下边的选项是<strong>Android support library</strong>是否支持，目前谷歌已经几乎淘汰了<strong>Android support library</strong></p><p>，替换成了<strong>Android X</strong>。详细了解可以看：<a href="https://blog.csdn.net/guolin_blog/article/details/97142065">Android X</a>。</p><p><img src="https://s2.loli.net/2024/09/29/nJ3FsBmuyVHqSi7.png" alt="2"></p><p>点击Finish后项目会进行预加载会进行一段时间。</p><h2><span id="创建一个android模拟器">创建一个Android模拟器</span></h2><p>在环境搭建部分已经安装了模拟器这里直接运行一个就ok，</p><p><img src="https://s2.loli.net/2024/09/29/WEuiCwO3aStKB9L.png" alt="3"></p><p><img src="https://s2.loli.net/2024/09/29/y4iVG7sbzC6RqwX.png" alt="4"></p><p><img src="https://s2.loli.net/2024/09/29/vgykp8BzCdW9wNs.png" alt="5"></p><h2><span id="项目内容分析">项目内容分析</span></h2><p><img src="https://s2.loli.net/2024/09/29/nSVXrWzBxKtbNaQ.png" alt="6"></p><p>在一般情况下，默认创建的<strong>Android</strong>项目并不是磁盘上的结构，这是因为AS替我们隐藏了一些不必要的信息，但是为了详细了解还是打开<strong>Project模式</strong>看一看：</p><p><img src="https://s2.loli.net/2024/09/29/YCda9rR82G75yJx.png" alt="7"></p><p><strong>.idea</strong>和.<strong>gradled</strong> 是由<strong>AS</strong>所自动产生的gradle配置工具和idea所需要的配置信息，这里不需要深入了解。</p><p><strong>app</strong>就是我们开发所最关心的目录，打开可以看到：</p><p><img src="https://s2.loli.net/2024/09/29/LeTp1IWEGAnmgKk.png" alt="8"></p><ul><li>里面分别还有一个<strong>build文件夹</strong>，这个是存放编译app代码后的地方；</li><li>当你需要使用外部的<strong>Jar</strong>包的时候将外部的<strong>jar</strong>包放入<strong>libs文件夹</strong>，就可以在编译的时候实现自动引用；</li><li><strong>src文件夹</strong>就是存放的我们需要写的代码了；</li><li>在<strong>src</strong>文件夹的<strong>res</strong>目录下存放着整个项目需要的所有资源，包括图片、布局、字符等，后边使用会详细讲；</li><li>在<strong>src文件夹</strong>的<strong>java</strong>目录下存放着整个项目的代码；</li><li>在<strong>src文件夹</strong>的<strong>AndroidMainifest.xml</strong>,这个是整个Android项目的配置文件，需要使用的组件都需要在这里注册，并给应用程序添加权限声明。</li></ul><p>回到主目录</p><p><strong>gradle文件夹</strong>包含了gradle wrapper，gradle wrapper是针对gradle的一种配置工具，<a href="https://blog.csdn.net/sinat_31311947/article/details/81084689">具体可以看这里</a>；</p><p><strong>build.gradle</strong>是全局的gradle构建脚本，稍后会详细分析；</p><p><strong>gradle.properties</strong>是针对gradle构建的全局配置文件，包含了需要配置的构建属性，更改这个会影响全局gradle构建脚本 <a href="https://blog.csdn.net/u013553529/article/details/55011602">具体可以参考这里；</a></p><p><strong>gradle.bat</strong>是在Windos环境下使用的命令行；</p><p><strong>settings.gradle</strong>这个文件指定的是项目所有引用的模块，一般只有app模块，通常情况下是自动完成引用的；</p><h2><span id="androidmainifestxml的分析">AndroidMainifest.xml的分析</span></h2><p><img src="https://s2.loli.net/2024/09/29/z3uvANDVnyU8Zr7.png" alt="9"></p><p>这个xml看起来一大堆的，看起来很麻烦，这波就来一个庖丁解牛分析：</p><p>先回忆一下，<strong>AndroidMainifest</strong>是整个安卓项目的配置文件，所以里面的内容一定是和项目的各个属性相关的，最外层的标签你可以猜到是用来表示这个应用的最外层，标签以内都是这个应用的属性，大眼一扫你可以看到一个很熟悉的关键字<strong>activity</strong>，这段代码实际上是为应用注册了一个名字为<strong>MainActivity</strong>的组件，在<strong>activity</strong>标签里面还有一个<strong>intent-filter</strong>标签是过滤器标签节点，通过<strong>Action</strong>属性和<strong>category</strong>分别实现了把<strong>Activity</strong>设为主<strong>Activity</strong>和启动<strong>Activity</strong>。，在手机上点击图标首先启动的就是这个<strong>Activity</strong>。</p><p>看回到外层，可以看到许多这样的形式：<code>android:icon="@mipmap/ic_launcher</code>，这些是干什么的呢？在这里就要回想一个东西：<strong>res文件夹</strong>，通过英文名称你也能猜到这表示的是某个图标，而后面的就是图标存放的位置，事实的确如此，打开res文件夹可以看到有着相同路径的内容，这里的@语法就是引用的意思：</p><p><img src="https://s2.loli.net/2024/09/29/6M21mqdNGWDh3Yz.png" alt="10"></p><p>看到图片你会想到一个问题，为什么有这么多Mipmap开头的文件夹？其实后缀是针对不同的分辨率，现在主流的分辨率还是xxhdpi，你如果有合适的图标就可放进去。</p><h2><span id="buildgradle的分析">build.gradle的分析</span></h2><p>gradle是一种新型构建工具，不同于传统的XML，使用基于Groovy的领域特定语言（目前还不太懂，挖个坑）。</p><p>其实在app目录下和项目根目录下都有一个build.gradle脚本，我们先来看看最外层的脚本：</p><pre><code class="language-groovy">// Top-level build file where you can add configuration options common to all sub-projects/modules.plugins {    id 'com.android.application' version '7.1.2' apply false    id 'com.android.library' version '7.1.2' apply false    id 'org.jetbrains.kotlin.android' version '1.5.30' apply false}task clean(type: Delete) {    delete rootProject.buildDir}</code></pre><p>和老版小雪狐的不太相同的是小蜜蜂版本出现了许多位置变化，可以参考：<a href="https://blog.csdn.net/sinat_38167329/article/details/123175556">Gradle新版变化</a>。</p><p>参考以上链接：</p><p>工程的build.gradle的<strong>dependencies</strong>修改为plugins，替代了引用原来的Gradle版本。</p><pre><code class="language-groovy">plugins {    id 'com.android.application' version '7.1.2' apply false    id 'com.android.library' version '7.1.2' apply false    id 'org.jetbrains.kotlin.android' version '1.5.30' apply false}</code></pre><p>功能位置迁移，原来在工程build.gradle的<strong>buildscript</strong>和<strong>allprojects</strong>移动至<strong>setting.gradle</strong>并改名为<strong>pluginManagement</strong> 和<strong>dependencyResolutionManagement</strong>。里面的东西依旧可以按照原来的copy过来。</p><pre><code class="language-groovy">pluginManagement {    repositories     {        gradlePluginPortal()        google()        mavenCentral()    }}dependencyResolutionManagement {    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)    repositories    {        google()        mavenCentral()    }}rootProject.name = "My Application"include ':app'</code></pre><p>两个repositories分别中的的   <code>google(）  mavenCentral()</code>分别对应了两个官方仓库，通过这两个配置可以在项目中引用这两个仓库中的所有依赖。</p><h3><span id="buildgradle的模块配置">build.gradle的模块配置</span></h3><pre><code class="language-groovy">plugins {    id 'com.android.application'    id 'org.jetbrains.kotlin.android'}android {    compileSdk 32// 编译时用的SDK版本    defaultConfig {        applicationId "com.example.myapplication"//应用标识名称，这里默认使用应用名字，系统根据这个区分不同应用，应用的唯一标识        minSdk 21//最小SDK兼容版本        targetSdk 32//测试使用的sdk版本        versionCode 1//代码的版本        versionName "1.0"        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"    }    buildTypes {        release {            minifyEnabled false//是否对代码进行混淆            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'//混淆规则        }    }    compileOptions {        sourceCompatibility JavaVersion.VERSION_1_8//编译兼容java版本        targetCompatibility JavaVersion.VERSION_1_8    }    kotlinOptions {        jvmTarget = '1.8'//kotlin运行的目标jvm版本    }    buildFeatures {        viewBinding true    }}dependencies {    implementation 'androidx.core:core-ktx:1.7.0'    implementation 'androidx.appcompat:appcompat:1.3.0'    implementation 'com.google.android.material:material:1.4.0'    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'    implementation 'androidx.navigation:navigation-fragment-ktx:2.3.5'    implementation 'androidx.navigation:navigation-ui-ktx:2.3.5'    testImplementation 'junit:junit:4.13.2'    androidTestImplementation 'androidx.test.ext:junit:1.1.3'    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'}</code></pre><p>接下来就需要一点点分析了，开头还是针对插件的引用，<code>'com.android.application'</code>代表这是一个应哟个程序模块，有时你可以建立一个<code>'com.android.library'</code>表示是库模块。而这最大区别在于，库模块依附于其他应用程序，而应用程序可以独立于运行。具体内容要了解可以看一下注释。</p><p>dependecies闭包是需要详细说一下的，</p><p>如需向项目添加依赖项，请在 <code>build.gradle</code> 文件的 <code>dependencies</code> 代码块中指定依赖项配置，如 <code>implementation</code>。</p><p>例如，应用模块的以下 <code>build.gradle</code> 文件包含三种不同类型的依赖项：</p><ul><li><strong>本地库模块依赖项</strong></li></ul><pre><code class="language-groovy">implementation project(':mylibrary')</code></pre><p>这声明了对一个名为“mylibrary”（此名称必须与在您的 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html"><code>settings.gradle</code></a> 文件中使用 <code>include:</code> 定义的库名称相符）的 <a href="https://developer.android.google.cn/studio/projects/android-library">Android 库模块</a>的依赖关系。在构建您的应用时，构建系统会编译该库模块，并将生成的编译内容打包到 APK 中。目前还没有用到用到时具体再说。</p><ul><li><strong>本地二进制文件依赖项</strong></li></ul><pre><code class="language-groovy">implementation fileTree(dir: 'libs', include: ['*.jar'])</code></pre><p>Gradle 声明了对项目的 <code>module_name/libs/</code> 目录中 JAR 文件的依赖关系（因为 Gradle 会读取 <code>build.gradle</code> 文件的相对路径）。</p><ul><li><strong>远程二进制文件依赖项</strong></li></ul><pre><code class="language-groovy">implementation 'com.example.android:app-magic:12.3'</code></pre><p>这声明了对“com.example.android”命名空间组内的 12.3 版“app-magic”库的依赖关系。</p><p>gradle在构建的时候会检查一下本低是否有这个库的缓存，如果没有会自动联网下载，在添加到目录中</p>]]></content>
    
    
    <summary type="html">第一个Android项目</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin与lambda）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E4%B8%8E%20lamda)/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E4%B8%8E%20lamda)/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.574Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin与lambda">Android开发笔记——快速入门（Kotlin与lambda）</span></h1><img src="https://s2.loli.net/2024/09/29/Y1eySEM3hX46p8C.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727617420599" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E4%B8%8Elambda">Kotlin与lambda</a><ul><li><a href="#kotlin%E7%9A%84%E9%9B%86%E5%90%88">Kotlin的集合</a><ul><li><a href="#kotlin%E7%9A%84list">kotlin的list</a></li><li><a href="#kotlin%E5%8F%AF%E5%8F%98%E7%9A%84list">kotlin可变的list</a><ul><li><a href="#kotlin%E7%9A%84arraylist">kotlin的ArrayList</a></li></ul></li><li><a href="#kotlin%E7%9A%84set">kotlin的set</a></li><li><a href="#kotlin%E7%9A%84map">kotlin的map</a></li></ul></li><li><a href="#kotlin%E7%9A%84lambda">kotlin的lambda</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BC%A0%E9%80%92lambda%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">什么时候需要传递lambda作为参数？</a></li><li><a href="#kotlin%E7%9A%84%E9%97%AD%E5%8C%85">kotlin的闭包</a><ul><li><a href="#kotlin%E5%87%BD%E6%95%B0%E5%BC%8Fapi">kotlin函数式API</a></li><li><a href="#kotlin%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">kotlin的函数式接口</a></li><li><a href="#java%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">Java的函数式接口作为参数</a></li><li><a href="#kotlin%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">kotlin的语法糖</a></li><li><a href="#java%E5%87%BD%E6%95%B0%E5%BC%8Fapi%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">Java函数式API的语法糖</a></li></ul></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin与lambda">Kotlin与lambda</span></h2><h3><span id="kotlin的集合">Kotlin的集合</span></h3><p>在介绍lambda表达式之前先介绍一下kotlin中的集合类，传统意义上的集合主要是list和set还有map。下面来一一介绍一下kotlin中这些内容如何使用。</p><h4><span id="kotlin的list">kotlin的list</span></h4><p><strong>list的主要实现类是ArrayList与LinkedList</strong>，这里主要是介绍<strong>List</strong>而不是它的具体实现类</p><p>List的特性很简单：</p><ul><li>允许出现重复的元素。</li><li>元素有序，存入和取出的顺序一致。</li><li>元素以一种线性的方式存储，在程序中可以通过索引来访问集合中的主要元素。</li></ul><p>使用传统的list像java一样通过函数一个一个初始化添加在kotlin中也是可以的：</p><pre><code class="language-kotlin">val list_test = ArrayList&lt;String&gt;()list_test.add("apple")list_test.add("pear")</code></pre><p>不过kotlin提供了更加方便的方法,我们使用<code>listof</code>来实现更加方便快捷:</p><pre><code class="language-kotlin">val list_kotlin = listOf&lt;String&gt;("apple","pear")for (list in list_kotlin)println(list)</code></pre><p>你可以注意到这里声明的list使用的是val关键字而不是var说明他是一个不可变的量，除了初始化添加的内容不允许再添加其他内容。</p><p>输出结果如下</p><pre><code class="language-shell">applepear</code></pre><h4><span id="kotlin可变的list">kotlin可变的list</span></h4><p>kotlin中使用可修改的list也很简单，更换关键字为<code>mutableListOf</code>即可：</p><pre><code class="language-kotlin">var list_var = mutableListOf("apple","pear")list_var.add("no fruits")println(list_var[0])println(list_var[2])</code></pre><p>可以看到调用了add来进行添加。</p><p>输出结果：</p><pre><code class="language-kotlin">appleno fruits</code></pre><h5><span id="kotlin的arraylist">kotlin的ArrayList</span></h5><p>List与ArrayList的不同点：</p><p>List实际上是接口并不是一个普通的类</p><p>ArrayList继承了几乎全部的<strong>MutableList</strong>的方法，除了继承的方法ArrayList类内部还实现了两个独特的方法：</p><pre><code class="language-kotlin">fun trimToSize()fun ensureCapacity(minCapacity: Int)</code></pre><p>分别是可以扩容和缩小占用内存，具体可以见：<a href="https://blog.csdn.net/gzheclipse/article/details/105956271">ArrayList的trimToSize</a>。</p><p>但是！你如果使用<strong>mutableListOf</strong>来实现一个可变的列表，它实际上返回的就是<strong>ArrayList！</strong></p><p>不信可以看源码：</p><pre><code class="language-kotlin">/** * Returns a new [MutableList] with the given elements. * @sample samples.collections.Collections.Lists.mutableList */public fun &lt;T&gt; mutableListOf(vararg elements: T): MutableList&lt;T&gt; =    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))</code></pre><p>ArrayList是List接口的一个实现类，它是程序中最常见的一种集合。</p><pre><code class="language-kotlin">val list_kotlin = arrayListOf("apple","pear")for (list in list_kotlin)    println(list)</code></pre><p>它的使用和list基本一致，当然效率相较于list可能会有些下降，因为ArrayList集合在增加或删除指定位置的数据时，会创建新的数组导致效率变低。</p><h4><span id="kotlin的set">kotlin的set</span></h4><p>set类与list的不同在于底层，set不允许集合内存在相同的内容，set的集合底层使用的是hash映射机制来存放数据的，因此集合的元素保证了内容的不重复，但同时也失去了顺序。</p><p>set的演示：</p><pre><code class="language-kotlin">//set 演示val set_kotlin = setOf("apple","pear","apple")for (set in set_kotlin)    println(set)</code></pre><p>可变set演示：</p><pre><code class="language-kotlin">var set_var = mutableSetOf("1","2","3","4")for (set in set_var)    println(set)</code></pre><h4><span id="kotlin的map">kotlin的map</span></h4><p>map类就不再多说，实际上就是通过键值和内容实现的映射集合，值得注意的是他的迭代方式有所不同：</p><pre><code class="language-kotlin">val map_test = HashMap&lt;String,Int&gt;()map_test["apple"] = 1map_test["banana"] = 2for ((fruit ,number) in map_test)    println("fruit is $fruit number is $number")</code></pre><p>前面介绍过for循环转变为了迭代器，这里就充分发挥了其迭代器的特性，可以同时迭代map中的内容和键值。可以看到输出结果：</p><pre><code class="language-kotlin">fruit is banana number is 2fruit is apple number is 1</code></pre><p>当然kotlin也提供了简洁的写法通过<code>to</code>来实现，键值与内容的映射，但to在这里并不是关键字而实更复杂的内容，我们到后边再说：</p><pre><code class="language-kotlin">val map_kotlin = mapOf("apple" to 1,"banana" to 2)for ((fruit ,number) in map_kotlin)    println("fruit is $fruit number is $number")</code></pre><p>输出结果：</p><pre><code class="language-kotlin">fruit is apple number is 1fruit is banana number is 2</code></pre><p>可以看到两次输出结果并不一致，这里先挖一个坑，当然你也注意到set并不能直接用【】类似于数组下标的方式访问，这些等以后再详细说明。</p><h3><span id="kotlin的lambda">kotlin的lambda</span></h3><p>集合的函数式API作为lambda表达式的演示再好不过了。</p><p>首先我们来说一说什么是lambda。</p><p><strong>Lambda就是一小段可以作为参数传递的代码</strong>，这就很厉害，因为常规情况下我们作为参数传递的都是变量，而参数转变为lambda表达式的时候就可以传递进去一段带有逻辑处理的代码。</p><p>对于一小段这个量词的定义并不明确，通产来说在能保持可读性的前提下可以尽量的短或长。</p><p>lambda的常规语法：</p><pre><code>{参数名1 ：参数类型，参数名2，参数类型 -&gt; 函数体（代码块）}</code></pre><p>首先最外层是一个大括号，如果有参数需要向lambda传递的话我们需要先声明参数列表，参数列表的结尾是一个“-&gt;”这代表着参数的结束和函数体的开始，<strong>函数体的最后一行会自动作为lambda表达式的返回值</strong>。</p><h4><span id="什么时候需要传递lambda作为参数">什么时候需要传递lambda作为参数？</span></h4><p>在Java里面lambda表达式出现所要替代的对象实际上Java的<strong>单抽像方法接口</strong>也可以被叫做<strong>函数式接口</strong>，他俩共同的所代表的意义就是：</p><p><strong>接口中有且仅有一个抽象方法需要被实现</strong>。</p><p><strong>换句话说就是接口里面只有一个需要被实现的方法。</strong></p><p>当<strong>这种类型的接口</strong>作为参数的时候，我们就需要传递一个内部匿名类来实现其抽象方法</p><p>这里为了方便下边讲解先说几个结论，并不完全，可自行推广：</p><ul><li>kotlin的函数式API</li><li>kotlin的函数式接口</li><li>Java的函数式接口作为参数</li></ul><h4><span id="kotlin的闭包">kotlin的闭包</span></h4><p>与其说Kotlin是一等公民，不如说是闭包才是一等公民。</p><p>闭包在kotlin中常常指的就是由{}构成的lambda表达式，之所以叫他闭包，实际上就是因为他与函数有很大的区别，比如闭包可以访问外部环境的变量，普通函数想要访问外部环境的变量是需要传入参数的，而闭包可以直接访问，并将其保存下来，具体可见参考文章。</p><p>参考文章：</p><p><a href="https://www.jianshu.com/p/b968524a0e95%E3%80%82">https://www.jianshu.com/p/b968524a0e95。</a></p><p><a href="https://kymjs.com/code/2017/04/09/01/#:~:text=%E9%97%AD%E5%8C%85%E5%BA%94%E8%AF%A5%E7%AE%97%E6%98%AF%20Kotlin%20%E6%9C%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%80%E4%BA%86%E3%80%82%20%E4%BD%BF%E7%94%A8%E5%A5%BD%E9%97%AD%E5%8C%85%E5%8F%AF%E4%BB%A5%E8%AE%A9%E4%BB%A3%E7%A0%81%E9%87%8F%E5%A4%A7%E5%A4%A7%E5%87%8F%E5%B0%91%EF%BC%8C%E4%BE%8B%E5%A6%82%20Kotlin%20%E6%9C%80%E8%91%97%E5%90%8D%E7%9A%84%E5%BC%80%E6%BA%90%E5%BA%93%EF%BC%9A%20Anko,%EF%BC%8C%E4%BD%BF%E7%94%A8%20Anko%20%E5%8E%BB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80%EF%BC%8C%E6%AF%94%E4%BD%BF%E7%94%A8%20Java%20%E4%BB%A3%E7%A0%81%E9%85%8D%E5%90%88%20xml%20%E8%A6%81%E6%9B%B4%E5%8A%A0%E7%AE%80%E6%B4%81%E3%80%82%20%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E5%85%85%E5%88%86%E8%BF%90%E7%94%A8%E4%BA%86%E9%97%AD%E5%8C%85%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7%EF%BC%8C%E7%9C%81%E7%95%A5%E4%BA%86%E5%BE%88%E5%A4%9A%E7%9A%84%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%82%E6%95%B0%E5%A3%B0%E6%98%8E%E3%80%82">闭包2</a>.</p><p>我在这里举一个例子方便大家理解一下，如果看不懂看完本文再回过头来看效果更好：</p><pre><code class="language-kotlin">    val list = listOf("Apple", "Banana", "Orange", "Pear",        "Grape", "Watermelon")    val newList = list.map() { fruit: String -&gt;        {fruit.uppercase() }}    for (fruit in newList) {        println(fruit)    }</code></pre><p>这里实际上输出的是闭包或者说是函数类型常量。</p><h5><span id="kotlin函数式api">kotlin函数式API</span></h5><p>我们先说明什么是kotlin函数式API：</p><p>先看一段代码，在最开始的一行我们定义了一个lambda表达式，他接受一个String类型的参数并返回字符的长度。</p><pre><code class="language-kotlin">//lambda 表达式演示val lambda = { fruit:String -&gt; fruit.length}val Max = list_test.maxOf(lambda)println(Max)</code></pre><p>我们跳转到maxof函数的定义去看看一看它的参数写的是什么：</p><pre><code class="language-kotlin">public inline fun &lt;T, R : Comparable&lt;R&gt;&gt; Iterable&lt;T&gt;.maxOf(selector: (T) -&gt; R): R {    val iterator = iterator()    if (!iterator.hasNext()) throw NoSuchElementException()    var maxValue = selector(iterator.next())    while (iterator.hasNext()) {        val v = selector(iterator.next())        if (maxValue &lt; v) {            maxValue = v        }    }    return maxValue}</code></pre><p>可以看到它的参数实际上就是一个lambda表达式：<code>selector: (T) -&gt; R</code></p><p>是不是很简单？很明了？我们再来看看什么是kotlin的函数式接口：</p><h5><span id="kotlin的函数式接口">kotlin的函数式接口</span></h5><p>在kotlin1.4中更新了函数接口，与java不同的是，kotlin需要显示的来定义一个函数接口，在<code>interface</code>接口添加一个<code>fun</code>关键字就可以实现把他转换为函数式接口：</p><pre><code class="language-kotlin">fun interface Eat{    fun eat_rice()}</code></pre><p>当函数式接口作为参数的时候就可以使用kotlin的lamda表达式：</p><pre><code class="language-kotlin">//lambdaval lambda2 = { -&gt; println("lambda is ok with kotlin interface")}test.lambda_tester(lambda2)</code></pre><p>因为原方法中并没有参数，所以前边也没有任何参数需要传递，我们可以简写成：</p><pre><code class="language-kotlin">//lambdaval lambda2 = { println("lambda is ok with kotlin interface")}test.lambda_tester(lambda2)</code></pre><h5><span id="java的函数式接口作为参数">Java的函数式接口作为参数</span></h5><p>如果我们在Kotlin代码中调用一个java方法，并且该方法只接收一个java单抽像方法接口作为参数，我们就可以使用lambda来传递参数：</p><p>我们这里来拿java的Thread类来举例子：</p><p>thread类的构造方法接收一个Runnable接口作为参数，Runnable是典型的函数式接口，里面只有一个run方法需要实现，当我们使用匿名内部类来实现的时候写法如下：</p><pre><code class="language-kotlin">Thread(object :Runnable{    override fun run() {        println("kotlin is  ok with anonymous")    }}).start()</code></pre><p>看起来很复杂，这里不再介绍匿名类的具体内容，你只需要知道 kotlin完全舍弃new关键字，这里的object类似于创建一个内部类，先尝试理解一下，实际上和这个感知还是有一定差距，到后面再说，我们直接来说如何用kotlin的lambda来实现java的函数式接口：</p><pre><code class="language-kotlin">Thread(    Runnable{-&gt; println("kotlin is ok with java")}).start()</code></pre><p>语法格式：</p><pre><code class="language-shell">接口名 { 参数 -&gt; 函数体 }</code></pre><p>讲到这里我想你应该明白什么时候用lambda什么参数的情况下使用lambda。</p><p>接下来我们顺着kotlin的设计思想，来讨论一下他的语法糖，上边为了你方便理解我并没有使用简写，但kotlin的最关键的还是他的语法糖，语法糖很甜。</p><h5><span id="kotlin的语法糖">kotlin的语法糖</span></h5><p>我们回到maxof方法：</p><pre><code class="language-kotlin">//lambda 表达式演示val lambda = { fruit:String -&gt; fruit.length}val Max = list_test.maxOf(lambda)</code></pre><p>实际上这里的lambda参数可以改写为：</p><pre><code class="language-kotlin">val Max = list_test.maxOf({ fruit:String -&gt; fruit.length})</code></pre><p>kotlin规定当lambda参数是函数的最后一个参数的时候可以放到括号外边：</p><pre><code class="language-kotlin">val Max = list_test.maxOf(){ fruit:String -&gt; fruit.length}</code></pre><p>接下来如果lambda表达式时函数唯一的参数的话还可以将括号省略：</p><pre><code class="language-kotlin">val Max = list_test.maxOf{ fruit:String -&gt; fruit.length}</code></pre><p>不要忘了kotlin具有很强的推导类型的能力，所以参数类型也可以省略：</p><pre><code class="language-kotlin">val Max = list_test.maxOf{ fruit -&gt; fruit.length}</code></pre><p>最后如果lambda表达式中只有一个参数的时候可以直接省略参数使用it来替代，同时“-&gt;”也可以省略：</p><pre><code class="language-kotlin">val Max = list_test.maxOf{ it.length}</code></pre><p>你会对这些省略规则感到复杂，其实抓住重点就是几条：</p><ul><li>最后一个参数 -&gt;移出到外边</li><li>唯一参数 - &gt; 省略和替代</li><li>参数类型-  &gt;可推导的省略</li></ul><p>我们按照这三个语法糖来实现代码优化：</p><h5><span id="java函数式api的语法糖">Java函数式API的语法糖</span></h5><pre><code class="language-kotlin">Thread(object :Runnable{    override fun run() {        println("kotlin is  ok with anonymous")    }}).start()</code></pre><p>首先Runnable接口是一个java的函数式接口，也就是其中只有一个抽象方法，并且对于Tread来说构造函数也只有这样一个接口参数，这两个唯一就符合上边的省略的替代策略。</p><p>省略接口名称，和重写方法的名称：</p><pre><code class="language-kotlin">Thread({        println("kotlin is ok with java")    }).start()</code></pre><p>同时他也是最后一个参数，也是唯一的参数省略括号和外移：</p><pre><code class="language-kotlin">Thread{        println("kotlin is ok with java")    }.start()</code></pre><p>牢记语法糖的实现规则，很方便的来优化代码。</p>]]></content>
    
    
    <summary type="html">Kotlin入门；Kotlin与lambda，list set map 闭包</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/categories/Android/Kotlin/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin入门）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E5%85%A5%E9%97%A8)/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E5%85%A5%E9%97%A8)/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.574Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin入门">Android开发笔记——快速入门（Kotlin入门）</span></h1><img src="https://s2.loli.net/2024/09/29/gC5eQ3URr1qGApZ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727617280095" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#why-kotlin">Why Kotlin？</a><ul><li><a href="#kotlin%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2">Kotlin的发展历史</a></li><li><a href="#kotlin%E5%92%8Cjava%E7%9A%84%E6%AF%94%E8%BE%83%E4%BC%98%E7%82%B9">Kotlin和java的比较优点</a></li></ul><ul><li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8kotlin%E5%BC%80%E5%8F%91android">如何使用Kotlin开发Android？</a><ul><li><a href="#kotlin%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0">Kotlin的变量与函数</a><ul><li><a href="#kotlin%E7%9A%84%E5%8F%98%E9%87%8F">kotlin的变量</a></li><li><a href="#kotlin%E7%9A%84%E5%87%BD%E6%95%B0">Kotlin的函数</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6">Kotlin的逻辑控制</a><ul><li><a href="#kotlin%E7%9A%84if">Kotlin的if</a></li><li><a href="#kotlin%E7%9A%84when">Kotlin的when</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E5%BE%AA%E7%8E%AF">Kotlin的循环</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h1><span id="why-kotlin">Why Kotlin？</span></h1><h3><span id="kotlin的发展历史">Kotlin的发展历史</span></h3><p>2011年，JetBrains 发布了Kotlin的第一个版本，并在2012年将其开源。</p><p>2016年Kotlin发布了1.0正式版，代表着Kotlin语言已经足够成熟和稳定了，并且JetBrains 也在自家的旗舰IDE开发工具Intelli]IDEA中加入了Kotlin的支持。</p><p>2017年Google 宣布 Kotlin 正式成为Android开发一级语言，并且Android Studio 也加入了对 Kotlin的支持。</p><p>2019年Google正式宣布了Kotlin First，未来提供的官方API会以Kotlin为主。</p><p><strong>Kotlin</strong>作为<strong>Jetbrain</strong>全新开发的语言，虽然是基于<strong>JVM</strong>进行的开发但是却是<strong>JAVA</strong>的温和改良版本，如果说C是一个国色天香的感觉，那么<strong>Java</strong>就是窈窕淑女而<strong>Kotlin</strong>就是小家碧玉，端庄优雅的温柔。</p><p><strong>Kotlin</strong>是一个极其成功的开源项目，代表了目前编程语言的一个发展方向，<strong>Kotlin</strong>在编写代码时有如下优势：代码简洁高效、函数式编程、空指针安全、支持<strong>lambda</strong>表达式、流式API等。光说起来你会感觉很难懂到底在说什么，但是当你跨进<strong>Kotlin</strong>大门之后才能体会到运用<strong>Kotlin</strong>编程的快乐。</p><h3><span id="kotlin和java的比较优点">Kotlin和java的比较优点</span></h3><p>Kotlin是完全和java兼容的，怎么个兼容办法呢？</p><p>Kotlin可以做到和Java 100%兼容，这主要是得益于Java虚拟机的工作机制 ，其实Java虚拟机并不会直接和你编写的Java代码打交道，而是和编译之后生 成的class文件打交道 ，而Kotlin也有一个自己的编译器，它可以将Kotlin代码也编译成同样规格的 class文件 ，Java虚拟机不会关心class文件是从Java编译来的，还是从Kotlin编译来的， 只要是符合规格的class文件，它都能识别 ，也正是这个原因，JetBrains才能以一个第三方公司的身份设计出一门用来 开发Android应用程序的编程语言</p><p>Kotlin是完全兼容Java现有的代码库的，也就是说你可以跨语言调用对应的代码内容，甚至于还有C、C++互操作，更神奇的是Kotlin也可以完成Javascript的工作，他编写的代码可以编译成JS的代码来运行！</p><h2><span id="如何使用kotlin开发android">如何使用Kotlin开发Android？</span></h2><p>首先你需要安装<strong>Android Studio</strong>来进行开发，详细安装过程可以参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123426867">Android开发笔记——快速入门（壹)</a></p><p>根据教程创建一个基于<strong>Kotlin</strong>的Android项目：</p><p>具体如何创建项目可以参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123458305?spm=1001.2014.3001.5502">上一篇文章</a>。</p><p>创建完成以后，在相同包下创建一个Kotlin类：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/20/8b4f5bf6b35badac.png" alt="1"></p><p>Kotlin class的创建：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/20/acc3bdd49432536e.png" alt="2"></p><h3><span id="kotlin的变量与函数">Kotlin的变量与函数</span></h3><p>创建完成以后就可以愉快的，使用AS来进行kotlin的编写：</p><p>首先创建一个主函数：</p><pre><code class="language-Kotlin">package com.example.codewithkotlinfun main(){    println("Hello Kotlin!")}</code></pre><p>你可以点击左边的小箭头运行一下</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/20/d8f09d31972d0ae5.png" alt="3"></p><h4><span id="kotlin的变量">kotlin的变量</span></h4><p>kotlin的变量与Java有很大的不同，可以总结如下两点：</p><ul><li>定义时不需要指定类型，而是需要指定变量是否可变。</li><li>没有保留Java基本的数据类型，而是使用对象数据类型，在 Kotlin 中，所有东西都是对象。</li></ul><p>举例：</p><p>不需要指定变量类型，其会自动推导：</p><pre><code class="language-kotlin">fun main(){    val a=10    println("a is " + a)}</code></pre><p>指定数据类型时不会再自动推导：</p><pre><code class="language-kotlin">fun main(){    val a : Int=10    println("a is " + a)}</code></pre><p>输出结果：</p><pre><code class="language-shell">a is 10</code></pre><p>val与var是用来指定是否为变量的关键字，val类似于java的final，var就是常规的变量，为什么要这样设计你如果有编程基础你就知道变量是不安全的，val，var就是为了指定这个变量是否可变（强制要求显式定义），这有一个小技巧，定义变量时应该是都定义为val，只有你需要var的时候再回来将这个变量改定义为var，这样就保证了基本所有变量的安全。</p><h4><span id="kotlin的函数">Kotlin的函数</span></h4><p>kotlin的函数与Java中的方法其实很像，但是更自由，书写更方便。</p><p>fun（function的简写）是定义函数的关键字，无论你定义什么函数，都一定要使用fun来声明。当然这不包含函数表达式。</p><p>其基本定义格式如下：</p><pre><code class="language-kotlin">fun funName(param1 : Int,param2 :Int) ：returnvaluetype {return value}</code></pre><p>如果没有返回参数就可以省略<code>：returnvaluetype</code> 部分，从这里看出Kotlin的设计思想：</p><p><strong>能省就省</strong></p><p>简化以后就可以表现为：</p><pre><code class="language-kotlin">fun funName(param1 : Int,param2 :Int){}</code></pre><p>为了保持设计思想，Kotlin做出了更多的省略,当你的函数体只有一块作为返回值的代码时，可以直接省略大括号，用等号来连接,这里用一个返回最大值的函数来表示：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int):Int = max(num1,num2)</code></pre><p>但是我们说过Kotlin具有出色的推导机制，那么他能不能推断出这里一定返回的是和max函数返回相同的内容呢？当然可以。所谓我们进一步简化省略去返回值：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int)= max(num1,num2)</code></pre><p>使用Kotlin以后你就会发现能在一行就实现一个完整的函数，但这并不是我们想要的，因为这里我们只是对MAX函数进行了一个包装，里面并没有任何逻辑部分。下面我们来写一下如何写逻辑部分的内容，并对其进行简化，进一步体验其强大性。</p><h3><span id="kotlin的逻辑控制">Kotlin的逻辑控制</span></h3><h4><span id="kotlin的if">Kotlin的if</span></h4><p>if在使用的时候与传统的if并没有太大区别，但是他还有一个额外的功能，可以有返回值。为什么要给if来整一个返回值呢？返回值常常与函数相关，对于现在流行的函数式编程，Kotlin也对其做出了支持，if的返回值就是如此，<strong>if语句会自动返回其最后一条语句的返回值</strong>：</p><p>常规IF的写法如下：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int) ：Int{    var maxnumber =0    if(num1 &gt;= num2)        maxnumber = num1    else        maxnumber = num2    return maxnumber}</code></pre><p>使用其返回值如下，是不是看起来更简略一点了呢：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int):Int{    val maxnumber = if(num1 &gt;= num2)                        num1                    else                        num2    return maxnumber}</code></pre><p>其实还可以再简略一下我们可以把if和else看成一个语句，这样他就可以直接给函数返回内容，我们就可以省略函数体的括号和返回值类型：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int)=if(num1 &gt;= num2)num1 else num2</code></pre><p>这样就实现了最简洁的写法。</p><h4><span id="kotlin的when">Kotlin的when</span></h4><p>Kotlin的when就是Java，C中的Switch case，负责的是样例匹配的工作，当你需要匹配内容很多的时候用if，是很不优雅的，但是Kotlin的when提供了一种简介方便的方式。</p><p>我先提供一个写法：</p><pre><code class="language-kotlin">fun getGender(name : String) =    when (name)    {        "zzy"-&gt; println("boy")        "lxl"-&gt; println("girl")        "hrq"-&gt; println("boy")        else -&gt;  println("not a boy or girl")    }</code></pre><p>这段代码给我们提供了一个样例，我们通过传入任意一个类型的变量来使用when来进行匹配，when后面的括号就是要匹配的对象，下边的函数体就是要匹配的内容，你可以发现他取消了case等关键字而是使用**“-&gt;”<strong>来作为关键字，意义表达明确，而且你不用担心执行完成后没有</strong>break**会自动向下运行，每一个匹配后会执行完自己的逻辑代码然后退出。值得提醒的是你的逻辑代码只有一行的时候可以省略“{}”。</p><p>除了数据匹配之外，when语句还可以进行类型匹配，没错就是你想的那个数据类型，如果你想起来Kotlin中没有基本的数据类型，而是全部都是类数据，你就会意识到为什么要这样设计数据类型，为了类型匹配只是一小部分优点。</p><p>下面举一个例子：</p><pre><code class="language-kotlin">fun getType(number : Number) =    when (number)    {        is Int -&gt; println("Int type")        is Float-&gt; println("Float type")        is Long-&gt; println("Long type")        else -&gt;  println("not my type")    }</code></pre><p>通过设置输入的number为所有数字类型的父类Number，你可以输入任意类型的数据，然后使用<strong>is</strong>关键字来检测是不是对应的类型。</p><p>你可以看到When里边都是同一种类型的匹配模式，但是如果要使用不同的匹配模式呢，打个比方我一个想要分离出名字里面有是zzy的，另一个想要分离出名字是lxl怎么办？很简单这里去掉when后边的括号就好了，将匹配表达式写入大括号里面。</p><pre><code class="language-kotlin">fun getGender2(name : String) =    when    {        name.contentEquals("zzy")-&gt; println("a part of zzy")        name === "lxl"-&gt; println("girl")        else -&gt;  println("not Anyone")    }</code></pre><h3><span id="kotlin的循环">Kotlin的循环</span></h3><p>在介绍循环之前先介绍一个新的东西，区间</p><p>区间这个东西很简单，它的作用就是按照规律生成一组数列，我们举个例子试一试：</p><pre><code class="language-kotlin">fun rangeTest(){    val range = 1..10    val untils = 0 until 10    val downtos = 10 downTo 1    println(range)    println(untils)    println(downtos)}</code></pre><p>输出结果：</p><pre><code class="language-shell">1..100..910..1</code></pre><p>你可以看见这两个区间生成的数列区别，一个是包含左右边界，一格式只有左边界没有右边界。</p><p>有了区间以后就可以使用for来迭代，for循环在Kotlin中有了巨大的变化，我先来展示一下：</p><pre><code class="language-kotlin">fun rangeTest(){    val range = 1..10    val untils = 0 until 10    println(range)    println(untils)    for (i in 10 downTo 1)        println(i)}</code></pre><p>输出：</p><pre><code class="language-shell">1..100..910987654321</code></pre><p>你可以看到了一个和java c都不太像的for 更想java里面的增强for循环，你就意识到这里for转化为了一个迭代器的作用。在后边我再继续讲解for的强大之处。</p>]]></content>
    
    
    <summary type="html">Kotlin入门</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/categories/Android/Kotlin/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin的NULL）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84NULL)%20/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84NULL)%20/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.574Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门-kotlin与null">Android开发笔记——快速入门 (Kotlin与NULL)</span></h1><img src="https://s2.loli.net/2024/09/29/9rGTdRm4giweluL.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727617602165" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E7%A9%BA%E6%8C%87%E9%92%88%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7">Kotlin的空指针与辅助工具</a><ul><li><a href="#kotlin%E7%9A%84%E5%88%A4%E7%A9%BA">Kotlin的判空</a></li><li><a href="#kotlin%E7%9A%84%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B">Kotlin的可空类型</a></li><li><a href="#kotlin%E7%9A%84%E5%88%A4%E7%A9%BA%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7">Kotlin的判空辅助工具</a><ul><li><a href="#"><code>?.</code></a></li><li><a href="#"><code>?:</code></a></li><li><a href="#let%E5%87%BD%E6%95%B0">let函数</a></li></ul></li><li><a href="#kotlin%E5%88%A4%E7%A9%BA%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5">Kotlin判空的特殊情况</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的空指针与辅助工具">Kotlin的空指针与辅助工具</span></h2><h3><span id="kotlin的判空">Kotlin的判空</span></h3><p>在写java或者c的时候最让人难受的就是空指针的问题了，当你写了一大段代码，运行时来一个报错，心态是很爆炸的，怎么又找不到变量在哪里了？但是你如果正常情况下书写kotlin就不会遇到这些问题，为什么呢？</p><p>因为kotlin将判空过程不是放在运行时，而是放在了编译过程中，甚至有些在kotlin语言设计的时候就已经在考虑如何避免了，说起来可能很复杂，接下来详细介绍一下kotlin的判空机制。</p><p>先来看一段代码：</p><pre><code class="language-kotlin">class Zzy(val gender: String = "Boy") : Person(22,"zhuzeyu"){    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init    {        println(name+" is a "+gender+" age is "+age)    }}fun main(args: Array&lt;String&gt;){    //koltin 空指针检查 //这段代码没有空指针风险    val zzy = Zzy("boy")}</code></pre><p>我们构造了一个类并且继承了Person类，最后在主函数中调用这个类的构造方法，需要注意的是构造方法需要传入的一个字符串，如果传入的是一个空的字符串这里就会产生空指针问题，在java中是不给你任何提示的，但是在kotlin中就有所不同：</p><p><img src="https://s2.loli.net/2024/09/29/ob2dVHwq4IxAWSU.png" alt="image-20220408215120939"></p><p>可以看到kotlin因为传入空而报错，这不是最重要的，因为这里显式的传入了null，那如果我们传入的是一个变量呢？</p><p>这里为了方便演示再传入一段代码：</p><pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;){    //koltin 空指针检查 //这段代码没有空指针风险    val zzy = Zzy(null)    var fake_zzy :String = null;}</code></pre><p>实际上<code>var fake_zzy :String = null</code>是不能运行的，kotlin给出了错误提示：</p><p><img src="https://s2.loli.net/2024/09/29/ASvpMjH15egbKnd.png" alt="image-20220408222048233"></p><p>编译器知道你这里传入就是一个null，所以代码实际上是不能运行的。</p><p>可以看到Kotlin从编译层面就避免了空指针问题的发生，但是这就意味着null在kotlin中就没有用处了吗？当然不是，接下来来介绍kotlin的可空类型。</p><h3><span id="kotlin的可空类型">Kotlin的可空类型</span></h3><p>如果在某个情况下我需要根据传入的变量的情况（空或者不空）来进行操作，但是你意识到这里面所有的传递参数都不能是空，甚至连编译都没办法通过这怎么办？</p><p>kotlin其实提供了可空类型</p><p>我们来看一个例子：</p><p><img src="https://s2.loli.net/2024/09/29/q7HRpfNolbKTBs8.png" alt="image-20220408221845089"></p><p>你注意到String后边添加了一个？这事 String的变量不再报错了，对这就是可空的String类型。</p><p>当然不止String有，每个kotlin的类型都可以声明为可空类型，基本结构如下：</p><pre><code class="language-kotlin">var 变量名 ： 变量类型 ? = null</code></pre><p>当然你也许也注意到了方法传入的参数也被报错了，</p><p>其中test类是用来创建测试函数的，函数具体内容如下：</p><pre><code class="language-kotlin">fun eat_empty_food (person: Person) =     if (person != null)         person.eat_empty()     else        "empty"</code></pre><p>可以看到此方法接受一个Person类作为参数，而zzy类继承了People类正好可以作为参数传递进去，但是这里我们传入了一个null，编译器报错了，为什么呢？因为参数也需要设置成可空的类型：</p><pre><code class="language-kotlin">fun eat_empty_food (person: Person?) = if (person != null) person.eat_empty() else "empty"</code></pre><p>这段代码什么意思呢？就是如果传进来的参数不是null的就正常调用一个方法，如果是空的就返回empty字符串。</p><p>是不是很简单呢？这是kotlin为了避免空指针问题而做的隔离，完全将空指针和正常变量做了一个隔离。</p><h3><span id="kotlin的判空辅助工具">Kotlin的判空辅助工具</span></h3><p>在上面我们介绍了kotlin如何将空指针赶尽杀绝，但是我们有些时候也需要通过空指针来判断一些具体情况，Kotlin同时提供了一套完整、便捷的判断工具。</p><h4><span id><code>?.</code></span></h4><p>首先介绍：<code>?.</code></p><p>在上一节，如果你更改了参数为可空类型，实际上他还会报错，因为这时候函数使用的时候，就有可能遇到null问题，如何更改呢？就要使用<code>?.</code>。</p><pre><code class="language-kotlin">fun eat_empty_food_update (person: Person?) = person?.eat_empty()</code></pre><p><code>?.</code>当对象不为空的时候正常调用方法，当为空的时候什么也不做。这里的作用就是为了避免空指针调用方法，你会说这好鸡肋啊没什么用，先别急后边会有更方便的方法一起组合来使用。</p><h4><span id><code>?:</code></span></h4><p>我们先介绍第二个工具关键词：<code>?:</code></p><p>这个操作符左右两边都接受一个表达式，如果左边表达式的结果不为空就返回左边的表达式，否则就返回右边的表达式的结果。你如果问这个有什么用？我们返回去看一段代码：</p><pre><code class="language-kotlin">fun eat_empty_food (person: Person?) = if (person != null) person.eat_empty() else "empty"</code></pre><p><code>?:</code>就和if和else作用一摸一样，就是其的简写，这样看起来是不是很简单很方便？</p><pre><code class="language-kotlin">fun eat_empty_food_plus (person: Person?) = person?.eat() ?: "empty"</code></pre><p>当person为空的时候<code>?.</code>就会返回一个null这时候配合<code>?:</code>就实现了简化版的if else，从而避免了为null的情况。</p><h4><span id="let函数">let函数</span></h4><p>let函数是kotlin独特的一个函数，这个函数接收的参数是一个函数式API接口，也就是需要你传入进去一个lambda表达式来使用，如果你不懂就翻回去看上一篇。</p><p>我这里直接介绍let如何使用：</p><pre><code class="language-kotlin">obj.let{obj -&gt; //函数体}</code></pre><p>举个例子：</p><pre><code class="language-kotlin">private var special : String? = "empty_special"//let函数this.special?.let{it.length}输出结果：13</code></pre><p>你可以发现let函数默认将调用它的对象作为参数传入到了lambda表达式中，这有什么用呢？</p><p>如果存在一种情况，你需要判断的对象调用了两个方法，你要这样写吗？</p><pre><code class="language-kotlin">fun eat_twofood (person: Person?) = {    person?.eat_empty()    person?.eat()}</code></pre><p>这样一点也不优雅，打咩！</p><p>kotlin就是讲究优雅，我们改写以后使用let函数会将对象自动作为参数的特性：</p><pre><code class="language-kotlin">fun eat_twofood (person: Person?) = person?.let { it.eat_empty(); it.eat();  }</code></pre><p>kotlin的函数一行就足够了！</p><p>可以看到我们使用let函数的特性来实现了对单个对象引用多方法的判空处理，这样我们只需要判断一次就可以了，如果有多个方法调用，也只需要一次，省力又省时。我们只需要在let函数前使用<code>?.</code>判断一次即可,然后使用let函数的参数来调用对应方法。</p><h3><span id="kotlin判空的特殊情况">Kotlin判空的特殊情况</span></h3><p>Kotlin的判空并不是完美的，某些情况下会阻碍我们的书写，因此要提前预知从而避免。</p><pre><code class="language-kotlin">//特殊情况if (test.special!=null)    println(test.eat_empty_food_special())</code></pre><p>其中<code>eat_empty_food_specia</code>方法如下：</p><pre><code class="language-kotlin">fun eat_empty_food_special () = this.special.length</code></pre><p><img src="https://s2.loli.net/2024/09/29/lkxcVzMjhs3oUGq.png" alt="image-20220408232756812"></p><p>实际上这里是有报错的，因为这里编译器判定special可能为空，但是实际我们在函数的外，调用方法之前已经对其做了防空处理，但是IDE感知不到，但是问题不大，我们更换写法即可。</p>]]></content>
    
    
    <summary type="html">Kotlin的NULL</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/categories/Android/Kotlin/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin的对象扩展与高阶函数深入）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95)%20/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95)%20/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.575Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门-kotlin的对象扩展与高阶函数深入">Android开发笔记——快速入门 (Kotlin的对象扩展与高阶函数深入)</span></h1><img src="https://s2.loli.net/2024/09/29/RU7cAxv8aTSKQf4.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727618114855" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95">Kotlin的对象扩展语法</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F">对象表达式</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F-1">对象表达式</a><ul><li><a href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AD%98%E5%9C%A8%E5%8F%82%E6%95%B0">父类的构造函数存在参数</a></li><li><a href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1">匿名对象</a></li><li><a href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC">匿名对象作为返回值</a></li></ul></li></ul></li></ul></li><li><a href="#kotlin%E7%9A%84%E7%B1%BB%E6%89%A9%E5%B1%95">Kotlin的类扩展</a></li><li><a href="#kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">Kotlin的高阶函数</a></li><li><a href="#%E7%B1%BB%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88">类扩展函数和高阶函数结合</a></li><li><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">深入理解高阶函数</a><ul><li><a href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">内联函数</a></li><li><a href="#noinline%E5%92%8Ccrossinline">noinline和crossinline</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的对象扩展语法">Kotlin的对象扩展语法</span></h2><h3><span id="对象表达式">对象表达式</span></h3><p>有时候，我们需要创建一个对某个类有轻微改动的类的实例化对象，就要再去继承原来的类声明一个子类，但是通过Kotlin的对象表达式就可以避免去创建一个只使用一次的类。</p><h4><span id="对象表达式">对象表达式</span></h4><p>要创建一个继承自某个类的匿名类对象，我们可以使用对象表达式来简化书写，通过对象表达式将<strong>匿名类</strong>的声明和<strong>匿名类对象</strong>的声明糅合在一起，为我们省去了很多代码。</p><p>通常来说我们在使用接口作为参数的的时候使用对象表达式的情况比较多，举个例子，如果我们使用Thread来创建一个线程的时候，Thread类的参数实际上就是一个Ruunable接口，这个Runnable接口就是Java中所说的函数式接口，如果我们不使用lambda来传递的话，就要使用一个实现了<strong>Ruunable接口类的对象</strong>作为参数传递进去。或者使用匿名类的实现（实际上匿名类的实现也是对象）来替代需要实现的类的对象。</p><p>对于对象表达式就类似于的java的匿名类，只不过他的功能更多，在这里你可以先理解为Java中匿名内部类。</p><p>举个例子：</p><pre><code class="language-kotlin">Thread(    object : Runnable {        override fun run() {            println("Kotlin is ok with Anonymous")        }    }).run()</code></pre><p>这里我们创建了一个对象表达式然后继承了Runnable接口，并实现了其中的run方法，最终对象表达式会自动创建一个这个类的对象并返回给Thread类。</p><p>代码运行结果如下：</p><pre><code class="language-shell">Kotlin is ok with AnonymousProcess finished with exit code 0</code></pre><p>当然对象表达式的作用不仅仅局限于函数式接口，它可以用于任何可继承的类，下面再来讨论几种特殊情况。</p><h5><span id="父类的构造函数存在参数">父类的构造函数存在参数</span></h5><p>我们有一个父类如下：</p><pre><code class="language-kotlin">package com.example.codewithkotlinopen class Person(var age :Int, val name:String){    fun study() = name + "love study"}</code></pre><p>父类的形式很简单，就是只有一个方法，两个成员变量。</p><p>我们存在一个函数，需要传入一个父类的对象，就可以使用对象表达式来构造。</p><p>函数如下：</p><pre><code class="language-kotlin">fun fatherargs_tester(person: Person){    println(person.name)}</code></pre><p>解决办法如下：</p><pre><code class="language-kotlin">/*父类的构造函数存在参数*/fatherargs_tester(    object :Person(18,"Jszszzy") {    override fun study() = "$name love studing kotlin"    })</code></pre><p>可以看到我们使用对象表达式创建了一个新的对象，并且将类里面的方法进行了重写，输出是结果如下：</p><pre><code class="language-shell">Jszszzy love studing kotlin</code></pre><p>同时表达式可以访问其所在作用域的变量：</p><pre><code class="language-kotlin">/*父类的构造函数存在参数*/val name = "Jszszzy"fatherargs_tester(    object :Person(18,name) {    override fun study() = "$name love studing kotlin"    })</code></pre><h5><span id="匿名对象">匿名对象</span></h5><p>对象表达式同时也可以构造<strong>匿名对象</strong>，即不继承任何类的匿名表达式。</p><p>举个例子：</p><pre><code class="language-kotlin">val anonymous_object = object {    val x = "test";}println(anonymous_object::class.java.toString())</code></pre><p>我们使用：：class方法来获取到对应的类是什么。</p><p>结果如下:</p><pre><code class="language-kotlin">class com.example.codewithkotlin.TestKt$main$anonymous_object$1</code></pre><p>看以看到是一个特殊的类，类的名称和创建的变量名有一定关系。</p><h5><span id="匿名对象作为返回值">匿名对象作为返回值</span></h5><p>这个是用的比较少，简单来说一下。</p><p>当匿名对象最为返回值的时候，</p><p>如果是一般的共有方法则返回类型自动转化为Any。</p><p>如果是私有办法则为返回类型为对应的匿名对象。</p><p>也就是说匿名对象，实际上其作用域仅限于他所处的类本身。</p><h2><span id="kotlin的类扩展">Kotlin的类扩展</span></h2><p>在某些情况下，我们希望在不修改某些类的源码的情况下（实际上你根本修改不了，大多数库代码都只是可读的）仍然可以为这个类添加新的功能，添加新的方法。就要使用到类的扩展了。</p><p>其基本使用结构如下：</p><pre><code class="language-kotlin">fun Classname.methodName(param1:type,param2:type):Int{return 0}</code></pre><p>可以看到实际上就是定义了一个函数，在前面加上想要添加的具体类名就可以了。注意的是你在在哪里声明的添加方法就会收到其作用域的影响，所以往往把添加的方法直接放到文件中，拥有顶层作用域来使用。</p><h2><span id="kotlin的高阶函数">Kotlin的高阶函数</span></h2><p>高阶函数和Lambda的关系密不可分，可以说高阶函数就是lambda应用的扩展。</p><p>高阶函数的定义是如果某个函数接收另一个函数作为参数或者返回值是一个函数就可以称之为高阶函数。你可能很难理解什么是函数类型？</p><p>实际上新一代语言中不止包含有我们常说的数据类型，大部分语言为了支持函数式编程，都添加了函数类型作为一种基础类型，他和其他基本类型一样，只不过其他基本类型传递的是一段二进制数据，函数类型传递的是一段可执行的代码。</p><p>对于一个lambda表达式来说，我们定义它其实很方便，举个例子，我们这里定义一个函数型变量（其实就是lambda表达式），并调用它输出它运行的结果：</p><pre><code class="language-kotlin">/*Kotlin的类扩展*/val lambda = { x:Int -&gt; x*x }println(lambda(3))</code></pre><p>我们其实也知道kotlin有优秀的推导机制，其实上一个Lambda在声明的时候并没有指明具体返回类型，返回类型是在编译的时候推理出来的。</p><p>但是有些时候，Kotlin无法推断具体类型的情况下，就要手动来声明具体类型来指定了，声明类型也很简单，具体方法如下：</p><pre><code class="language-kotlin">/*Kotlin的lambda使用*/val lambda : (Int) -&gt; Int =  {x -&gt; x*x }println(lambda(3))</code></pre><p>此处指明了lambda表达式的参数类型是Int、并且返回值类型依然是Int，最终输出的结果和上文一样。</p><p>说了这么多，这些又和高阶函数什么关系呢？</p><p>高阶函数的定义指明了要传递函数作为参数，那么如何定义函数参数呢？</p><p>没错就是lambda表达式来作为参数。</p><p>下面举一个例子，以下定义了一个高阶函数。</p><pre><code class="language-kotlin">fun advanced_function( func :(Int) -&gt; Int){    println(func(9))}</code></pre><p>此高阶函数中参数为func，传入的lambda表达式类型为<code>(Int) -&gt; Int</code>也就是说，接收一个输入参数为Int返回值Int的函数。</p><p>但是为什么要传入一个函数作为参数呢？发挥一下你的想象力，我们可以定义符合上述参数类型的lambda表达式，但是函数的逻辑内容可以完全不一样。举个例子：</p><p>我们仍然使用上述高阶函数，但是创建一个新的lambda表达式：</p><pre><code class="language-kotlin">/*Kotlin的高阶函数*/val lambda1 :(Int) -&gt;Int  = {x -&gt; x+x}advanced_function(lambda1)</code></pre><p>此时运算结果就变为了相加。</p><p>与此相对的，Kotlin也支持直接将lambda表达式传递进去，当高阶函数只有一个lambda参数的时候，我们可以直接省略小括号，最终效果和前边完全相同：</p><pre><code class="language-kotlin">/*高阶函数常规用法*/advanced_function{x -&gt; x+x}</code></pre><h2><span id="类扩展函数和高阶函数结合">类扩展函数和高阶函数结合</span></h2><p>当我们在前边使用apply函数的时候很方便就能获得一个上下文，这样调用对象的时候就可以避免重复书写对象，Kotlin同时也为高阶函数提供了类似的功能，我们先来尝试使用扩展函数和高阶函数结合一下：</p><pre><code class="language-kotlin">fun StringBuilder.build(block : () -&gt; Unit):StringBuilder{    block()    return  this}</code></pre><p>这一段函数所代表的意义就是为StringBuilder类扩展一个高阶函数build，其参数为:<code>（）-&gt;Unit</code>的函数。</p><p>在函数内调用传入的函数，并将处理后的对象返回。</p><p>但是这里就会遇到一个问题，我如果想在传入的函数中使用StringBuilder的方法怎么办？也就说这部分函数还是要调用扩展类的方法的，Kotlin为此设计了一个能提供上下文的办法，使用起来很简单效果如下：</p><pre><code class="language-kotlin">fun StringBuilder.build(block :  StringBuilder. () -&gt; Unit):StringBuilder{    block()    return  this}</code></pre><p>可以看到实际上就是在参数类型前边加上了ClassName.的前缀，这样就将要传入的函数参数定义在了在StringBuilder的里面，保证了函数可以自动获取StringBuilder的上下文。</p><p>举个实际例子：</p><pre><code class="language-kotlin">val result = StringBuilder().build {    append("jszszzy")}</code></pre><p>我们在传入的参数中加入了StringBuilder的上下文这样，就相当于获得了调用方法的时候创建的上下文，完整写法如下：</p><pre><code class="language-kotlin">val result = StringBuilder().build {    this.append("jszszzy")}</code></pre><p>最终结果也很简单，输出了添加的字符串：</p><pre><code class="language-shell">jszszzy</code></pre><h2><span id="深入理解高阶函数">深入理解高阶函数</span></h2><h3><span id="内联函数">内联函数</span></h3><p>我们始终要意识到一个问题，kotlin的代码最终都要被编译为java的字节码文件的，但是在java中我们并没有高阶函数的概念，那么Kotlin是如何实现的高阶函数呢？</p><p>这就要归功于Koltin的强大编译器了，在这里我还是要狠狠吹一波Kotlin！Kotlin可不仅仅适用于JVM运行，他甚至还有专门的编译器去编译成类似c语言的字节码直接运行，不依赖于JVM,详细请了解：<a href="https://book.kotlincn.net/text/multiplatform.html">Kotlin多平台</a>。</p><p>那么现在需要编译成JVM的字节码，他会怎么编译呢？我们还是拿上边的函数举个例子：</p><p>我们打开他的反编译java代码：</p><pre><code class="language-java">public static final void advanced_function(@NotNull Function1 func) {   Intrinsics.checkNotNullParameter(func, "func");   int var1 = ((Number)func.invoke(9)).intValue();   System.out.println(var1);}</code></pre><p>可以看到我们的函数类型参数转变为了一个Function1接口，这是神马？</p><p>我们打开看一看：</p><pre><code class="language-kotlin">/** A function that takes 1 argument. */public interface Function1&lt;in P1, out R&gt; : Function&lt;R&gt; {    /** Invokes the function with the specified argument. */    public operator fun invoke(p1: P1): R}</code></pre><p>里面有一个函数叫invoke，继承这个接口的话，那必须就要把这个函数给实现了。</p><p>可以看到原来我们执行传入的函数参数的位置被替换成了一行代码：</p><pre><code class="language-kotlin"> int var1 = ((Number)func.invoke(9)).intValue();</code></pre><p>原来的函数的调用被替换为了一个invoke()函数的调用。</p><p>实际上在调用高阶函数的时候，对应的代码被转换为了如下的样子：</p><pre><code class="language-kotlin">/*替换前源代码*/advanced_function{x -&gt; x+x}/*替换后*/advanced_function(    new Function(){        @Overrride        public Integer invoke(Integer x){            retaurn x+x;        }    })</code></pre><p>也就是说对应的lambda表达式位置被替换成了一个匿名类的实现，通过这个接口将对应的lambda表达式封装到了invoke函数里面，调用invoke函数就相当于使用了对应的lambda表达式！</p><p>但是这就产生了一个问题！我的每一个lambda不会都是这样实现的吧，这样就会造成很大的性能浪费，当你在上边愉快的书写lambda表达式，下边kotlin跑的匿名类累死。</p><p>kotlin为了消除这个问题，又创建了一个方法，这就是内联函数，内联函数是干什么的呢？</p><p>他会使Kotlin编译器将内联函数中的代码在编译的时候替换到对应的地方。实现真正的代码传递。这样在运行的时候就不存在任何运行开销了。说起来可能不太容易，我们做个演示，替换后调用的位置是什么样的:</p><p>使用inline来修饰：</p><pre><code class="language-kotlin">inline fun advanced_function( func :(Int) -&gt; Int){    println(func(9))}</code></pre><p>对应调用位置的代码：</p><pre><code class="language-kotlin">/*使用内联函数替代后*/println(x+x)</code></pre><p>你会发现他把原来你调用的函数给替掉了，实际上就是把lambda表达式融合进函数里面最终在再把函数内所有的代码都拿出来替换掉调用的地方。</p><p>当然他的替换过程可能没有那么简单，因为在内联函数的内部可能存在return等语句所以我们在这里不再详细介绍具体的实现过程，我们不妨来说一说一个便捷的理解方法。</p><ul><li>Kotlin编译器首先将Lambda表达式中的代码替换到内联函数调用函数型参数的地方。</li><li>接下来，再将内联函数中的全部代码再反向替换到内联函数调用的地方</li><li>左后将内联函数中的return等操作省略，将return的表达式或者值直接省略替换成对应的表达式。</li></ul><h3><span id="noinline和crossinline">noinline和crossinline</span></h3><p>接下来我们再来讨论一下，使用inline关键字的内联函数特殊情况。</p><p>在某些情况下你需要打断lambda表达式的运行，就是需要在lambda表达式中使用return，这时候就麻烦了lambda表达式中一般是不允许使用return的，你当然也可以使用特殊的关键字<code>return@内联函数名称</code>，使用以后lambda表达式剩余的内容就不会执行。</p><p>举个例子：</p><pre><code class="language-kotlin">/*Kotlin 内联函数*/advanced_function{        x -&gt;    return@advanced_function x*x    x+x}</code></pre><p>这里运行的结果就是返回一个x*x.而不是下面的x+x。</p><p>那我如果使用inline关键字呢？</p><p>回想上文所说的，inline关键字实际上是代码替代，所以可以直接使用return来返回，不过注意的是这里return会导致调用函数直接return！</p><p>这就是高阶函数使用inline关键字的第一个关注点。</p><p>第二个关键点在于高阶函数内部的lambda表达式需要使用函数型参数作为lambda表达式的内容会因为return关键字产生冲突。</p><p>看起来很复杂实际上是一种嵌套的情况，我们来举个例子：</p><p><img src="https://s2.loli.net/2024/09/29/OAh7siKrDbE3MN5.png" alt="image-20220617175447968"></p><p>可以看到这里报错了，这里的代码实际上在匿名类中调用了传入的函数类型参数。</p><p>因为使用了inline，所以可能会导致Runnable接口的lambda中包含了全局返回使用的return。</p><p>但是我们如果lambda中其实并没有包含return呢？有什么办法绕开这个错误呢？</p><p>当然！</p><pre><code class="language-kotlin">inline fun advanced_function_withlambda( crossinline func :(Int) -&gt; Int){    val runnable = Runnable {        func(9)    }}</code></pre><p>crossinline本质上解决的问题是在声明了inline关键字的高阶函数内部的lambda表达式需要使用函数型参数作为lambda表达式的内容而产生的冲突。再本质一点的问题是，lambda表达式和匿名类一样只允许函数局部返回，而对于内联操作使用的确实为全局返回。</p><p>总的来说如果你的高阶函数的lambda表达式使用了return关键字，那么你就应该考虑到以上的关键字和return带来的具体影响。</p>]]></content>
    
    
    <summary type="html">Kotlin的对象扩展与高阶函数深入</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/categories/Android/Kotlin/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门 (Kotlin的延迟初始化与Viewbinding、密封类)</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E4%B8%8E%E5%AF%86%E5%B0%81%E7%B1%BB)%20/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E4%B8%8E%E5%AF%86%E5%B0%81%E7%B1%BB)%20/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.575Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门-kotlin的延迟初始化与viewbinding-密封类">Android开发笔记——快速入门 (Kotlin的延迟初始化与Viewbinding、密封类)</span></h1><img src="https://s2.loli.net/2024/09/29/kAI59OWGPqluiQN.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727618527687" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B">Kotlin的延迟初始</a><ul><li><a href="#%E9%82%A3%E4%B9%88%E5%88%B0%E5%BA%95%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%A8">那么到底该怎么用？</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E5%AF%86%E5%B0%81%E7%B1%BB%E5%92%8Cwhen">Kotlin的密封类和When</a></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的延迟初始">Kotlin的延迟初始</span></h2><p>鉴于Kotlin的判空机制，在编译的时候就会检测变量是否存在空的可能，这就导致了一个麻烦，你需要额外多写代码来处理那些可能为空的类，即使在逻辑上他也不可能是NULL的，kotlin的判空机制还是会强制让你增加判空，不过这也不是没有解决办法，下面介绍一个关键字延迟初始化：<code>lateinit</code></p><p>当你遇到这样一种场景：</p><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {    private lateinit var binding :ActivityMainBinding         override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding= ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)    }}</code></pre><p>我想在MainActivity类里面调用一个viewbinding，可是这个viewbinding只有在oncreate方法里面才能对他进行初始化你如果在类里面直接进行初始化就会产生错误，实际上绑定类调用的<code>layoutInflater</code>并没有在ACT刚开始的时候就完成了初始化，你如果直接调用就会导致报错：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/facbd8d00ebeb0e3.png" alt="2"></p><pre><code class="language-shell"> Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'android.view.LayoutInflater android.view.Window.getLayoutInflater()' on a null object reference    at android.app.Activity.getLayoutInflater(Activity.java:5310)    at com.example.listviewtest.MainActivity.&lt;init&gt;(MainActivity.kt:16)    at java.lang.Class.newInstance(Native Method)    at android.app.AppComponentFactory.instantiateActivity(AppComponentFactory.java:95)    at androidx.core.app.CoreComponentFactory.instantiateActivity(CoreComponentFactory.java:45)    at android.app.Instrumentation.newActivity(Instrumentation.java:1287)    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:4148)    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:4463)     at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:111)     at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:149)     at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:103)     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2665)     at android.os.Handler.dispatchMessage(Handler.java:109)     at android.os.Looper.loopOnce(Looper.java:206)     at android.os.Looper.loop(Looper.java:296)     at android.app.ActivityThread.main(ActivityThread.java:8899)</code></pre><p>如果你对Context不够了解，你会很奇怪到底为什么？</p><p>不妨先推荐你按照如下顺序阅读下面几篇文章：</p><p>因为获取绑定类的时候使用的是layoutInflate所以关键问题就在于layoutInflate之上：</p><p><a href="https://blog.csdn.net/guolin_blog/article/details/121889703?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165215148016780357214066%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165215148016780357214066&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-121889703-null-null.nonecase&amp;utm_term=layoutinflater&amp;spm=1018.2226.3001.4450">再看LayoutInflater</a></p><p><a href="https://blog.csdn.net/guolin_blog/article/details/12921889?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165215148016780357214066%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165215148016780357214066&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-12921889-null-null.nonecase&amp;utm_term=layoutinflater&amp;spm=1018.2226.3001.4450">Android LayoutInflater原理分析，带你一步步深入了解View</a>。</p><p>等你看完了以后你会意识到LayoutInflater本质上和Context脱不了干系，每次都调用**LayoutInflater的from()**方法去获取一个LayoutInflater的实例，为什么要传context呢？</p><p>其实本质上只有一种写法：</p><pre><code class="language-kotlin">LayoutInflater layoutInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</code></pre><p>只是Android给我们做了一下封装而已。得到了LayoutInflater的实例之后就可以调用它的inflate()方法来加载布局了。这里不在多讨论这个，我们再来看一下什么是Context：</p><p><a href="https://blog.csdn.net/guolin_blog/article/details/47028975?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165232423116782248586882%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165232423116782248586882&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-6-47028975-null-null.nonecase&amp;utm_term=onCreate&amp;spm=1018.2226.3001.4450">Android Context完全解析</a>。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/1df15d4972330b74.png" alt="img"></p><p>对于ACT来说，执行过程也是大差不大，但是，ACT的layoutInflate是调用的方法获取的对象，为什么会和本ACT中的Context有关系呢？</p><p>我们再来看一下ACT到底如何获取LayoutInflate对象：</p><p><a href="https://blog.csdn.net/ruancoder/article/details/51760942?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165232543116782350911197%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165232543116782350911197&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-51760942-null-null.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Econtrol&amp;utm_term=getLayoutInflater&amp;spm=1018.2226.3001.4187">获取LayoutInflater的三种方式分析</a>。</p><p>可以看到本质上ACT调用的还是<code>LayoutInflater.from(context)</code>方法，而context方法在onCreate方法之前是没有进行加载的，所以会产生NULL报错。</p><h3><span id="那么到底该怎么用">那么到底该怎么用？</span></h3><p>回到最初的问题，那我们该怎么办呢？在合适的位置进行初始话的话就要使用lateinit关键字，通过lateinit就可以把对应的全局变量在合适的位置进行初始化。</p><p>当然Kotlin也提供了一个固定语法来检测在某个位置的全局变量，注意！是全局变量是否进行了初始化代码如下：</p><pre><code class="language-kotlin">companion object  {      private lateinit var tester: Zzy      var signal : Boolean = true      fun laterinit_tester()      {          if(!::tester.isInitialized) {              tester = Zzy()              //如果你不太清楚Zzy类是什么或者不太懂Kotlin的类请参考我的专栏文章关于Kotlin的类          }          //Log.d("tester", tester.gender)          println(tester.gender)      }}</code></pre><p><code>::tester.isInitialized</code>来获取对应变量是否进行了初始化，我们在对他取！就可以完成对他的判断了，在没有初始化的地方对其进行初始化。</p><p>zzy类的代码：</p><pre><code class="language-kotlin">class Zzy(val gender: String = "Boy") : Person(22,"zhuzeyu"){    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init    {        println(name+" is a "+gender+" age is "+age)    }    //方法调用省略this关键字演示如下：    fun this_test()    {        eat_empty()    }    fun this_tester2()    {        this_test()    }}</code></pre><p>最后运行结果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/b053645a3d413608.png" alt="4"></p><p>最后完整的代码在我的Gitee上全部开源：<a href="https://gitee.com/jszszzy/android_kotlin">Gitee地址</a>。下载压缩包即可。</p><h2><span id="kotlin的密封类和when">Kotlin的密封类和When</span></h2><p>先来回忆一下，When是如何使用的，请参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123688687?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165234161016781685335776%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165234161016781685335776&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-123688687-null-null.nonecase&amp;utm_term=when&amp;spm=1018.2226.3001.4450">When的用法</a>。</p><p>我们新建一个类，用来反馈某些操作的结果：</p><pre><code class="language-kotlin">interface Resultclass  Success(val msg :String) :Resultclass  Failure(val error :Exception) :Result</code></pre><p>可以看到<strong>Success、Failure</strong>都是继承于Result接口的实现。</p><p>我们再来创建一个方法用识别返回的是成功还是失败。</p><pre><code class="language-kotlin">fun When_tester(result: Result){    when(result)    {        is Success -&gt; println(result.msg)        is Failure -&gt; println(result.error)    }}</code></pre><p>写完以后你觉得需要简写一下，因为函数只有一条语句，于是改成如下操作：</p><pre><code class="language-kotlin">fun When_tester(result: Result) =   when(result)    {        is Success -&gt; println(result.msg)        is Failure -&gt; println(result.error)    }</code></pre><p>万恶的编译检查竟然给你报错！</p><pre><code class="language-kotlin">e: D:\Android\Projects\CodeWithKotlin\app\src\main\java\com\example\codewithkotlin\Utils.kt: (25, 14): 'when' expression must be exhaustive, add necessary 'else' branch</code></pre><p>问题不大，实际上的简写原则是这样的：</p><p>当你的函数体只有 <strong>一块</strong> 作为返回值的代码时，<strong>可以直接省略大括号，用等号来连接,并且省略return关键字，因为等号足以包含返回值的意思</strong>。</p><p>也就是说你这样写他也是报错的：</p><pre><code class="language-kotlin">fun When_tester(result: Result){    return  when(result)    {        is Success -&gt; println(result.msg)        is Failure -&gt; println(result.error)    }}</code></pre><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/5ea08f7acc81ce69.png" alt="5"></p><p>实际上你的类就这样两种可能，基本没有可能出现else内的情况，但是！万恶的编译检查竟然给你报错！</p><p>不过Kotlin也针对这种情况给出了解决办法：<strong>密封类</strong>。</p><p>使用方法很简单我们把对应的接口更改成sealed class即可：</p><pre><code class="language-kotlin">sealed class Result class  Success(val msg :String) :Result()class  Failure(val error :Exception) :Result()</code></pre><p>记得把括号带上，因为这时候是class需要调用父类的构造方法。</p><p>修改好以后就发现报错消失了。可以愉快的避免else的编译检查了。</p><p>最后完整的代码在我的Gitee上全部开源：<a href="https://gitee.com/jszszzy/android_kotlin">Gitee地址</a>。下载压缩包即可。</p>]]></content>
    
    
    <summary type="html">Kotlin的延迟初始化与Viewbinding、密封类</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Viewbinding" scheme="http://neonexusx.github.io/tags/Viewbinding/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin的标准函数和静态方法）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95)/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95)/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.575Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin的标准函数和静态方法">Android开发笔记——快速入门（Kotlin的标准函数和静态方法）</span></h1><img src="https://s2.loli.net/2024/10/04/Ash97EO3iRUGNo4.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727980663756" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Kotlin的标准函数和静态方法</a><ul><li><a href="#kotlin%E7%9A%84with%E5%87%BD%E6%95%B0">Kotlin的with函数</a></li><li><a href="#kotlin%E7%9A%84run%E5%87%BD%E6%95%B0">Kotlin的run函数</a></li><li><a href="#kotlin%E7%9A%84apply%E5%87%BD%E6%95%B0">Kotlin的apply函数</a></li><li><a href="#koltin%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Koltin的静态方法</a><ul><li><a href="#koltin%E7%9A%84%E7%9C%9F%E6%AD%A3%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Koltin的真正静态方法</a><ul><li><a href="#jvmstatic%E6%B3%A8%E8%A7%A3"><code>@JvmStatic</code>注解</a></li><li><a href="#%E9%A1%B6%E5%B1%82%E6%96%B9%E6%B3%95">顶层方法</a></li></ul></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的标准函数和静态方法">Kotlin的标准函数和静态方法</span></h2><p>Kotlin的标准函数指的是Standard.kt文件中定义的函数，任何Kotlin代码都可以自由调用所有标准函数</p><p>比如上一次所说的Let函数就是标准函数之一。</p><h3><span id="kotlin的with函数">Kotlin的with函数</span></h3><p>with函数的参数：</p><ul><li>第一个为任意类型的对象</li><li>第二个是Lambda表达式</li></ul><p>with函数的作用：</p><ul><li>在lambda表达式中提供第一个参数作为对应的上下文</li><li>使用表达式中最后一行代码的返回值作为返回值返回</li></ul><p>那么这个函数具体有什么作用呢？看一下示例代码：</p><p>我们通过<strong>Stringbuilder</strong>对象来实现将ArrayList对象中保存的People实例转化成一个同一的字符串</p><p><img src="https://s2.loli.net/2024/10/04/1dlNVDtcP3SnJp9.png" alt="1"></p><pre><code class="language-kotlin">fun withFunTester(){    val string = StringBuilder()    val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))    with(string){        for ( people in list_people)        {            append(people).append("\n")        }        val result =string.toString()        println(result)    }}</code></pre><p>可以看到我们为了更简介的去构造这个字符串通过with函数将构造字符串的对象作为上下文来引用这样就省去了多次调用Stringbuilder的对象的麻烦。</p><p>调用结果如下：</p><p><img src="https://s2.loli.net/2024/10/04/F7zLdsUaeEBvJRc.png" alt="image-20220429233250384"></p><p>因为People类是自定义的类并没有直接重写tostring方法所以返回的是对象的的具体信息</p><h3><span id="kotlin的run函数">Kotlin的run函数</span></h3><p>run函数的参数：</p><ul><li>第一个就是Lambda表达式</li><li>需要对象直接调用此函数</li></ul><p>run函数的作用：</p><ul><li>在lambda表达式把调用对象作为对应的上下文</li><li>使用lambda表达式中最后一行代码的返回值作为返回值返回</li></ul><p>我们改写一下上一个函数使用run函数来实现：</p><pre><code class="language-kotlin">fun runFunTester(){    val string = StringBuilder()    val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))    val runFunTester= string.run {        for ( people in list_people)        {            append(people).append("\n")        }        string.toString()    }    println(runFunTester)}</code></pre><p>输出结果和上一个相同，这里不再赘述。</p><h3><span id="kotlin的apply函数">Kotlin的apply函数</span></h3><p>apply函数的参数：</p><ul><li>第一个就是Lambda表达式</li><li>需要对象直接调用此函数</li></ul><p>apply函数的作用：</p><ul><li>在lambda表达式把调用对象作为对应的上下文</li><li>apply无法指定返回值而将调用对象作为返回值返回</li></ul><p>举个例子：</p><p>可以看到实际上函数里面并没有写任何作为返回值的表达式，其返回的正是Stringbuilder的对象，只不过println自动调用的是对象的tostring方法。</p><pre><code class="language-kotlin">fun applyFunTester(){    val string = StringBuilder()    val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))    val applyFunTester= string.apply {        for ( people in list_people)        {            append(people).append("\n")        }    }    println(applyFunTester)}</code></pre><h3><span id="koltin的静态方法">Koltin的静态方法</span></h3><p>Kotlin的设计者一直在弱化静态方法这个概念，为了什么呢？因为从本质上来说Kotlin已经提供了更方便的方法来实现类似于静态方法的操作。</p><p>举个例子：</p><p>Kotlin提供了一个单例类作为静态方法的实现办法。</p><p>我们创建一个单例类，实际上JVM已经替我们创建好了一个对象，找个对象不需要你自己手动创建，而是帮你创建好了和类名相同的对象，直接</p><p><code>类名.方法</code>即可实现方法调用。</p><p>这里我们创建一个Utils类，把刚才使用的函数都放入Util类中来进行调用。</p><pre><code class="language-kotlin">object Utils{    fun withFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val withFunTester=with(string){            for ( people in list_people)            {                append(people).append("\n")            }            val result =string.toString()            println(result)        }    }    fun runFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val runFunTester= string.run {            for ( people in list_people)            {                append(people).append("\n")            }            string.toString()        }        println(runFunTester)    }    fun applyFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val applyFunTester= string.apply {            for ( people in list_people)            {                append(people).append("\n")            }        }        println(applyFunTester)    }}</code></pre><p>在main函数中直接调用即可：</p><pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;){Utils.runFunTester()}</code></pre><p>当然你会注意到有个问题，在Utils类中所有方法都是静态的，那如果我想部分函数是静态的怎么办呢？</p><p>Kotlin也提供了一个方法,<strong>伴生对象</strong>。</p><p>通过伴生对象就可以实现在一个类中既有静态也有一般方法。</p><p>我们将Utills类改为一般的类，然后使用伴生对象来实现静态和一般调用。</p><pre><code class="language-kotlin">class Utils{    fun withFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val withFunTester=with(string){            for ( people in list_people)            {                append(people).append("\n")            }            val result =string.toString()            println(result)        }    }        companion object    {        fun runFunTester()        {            val string = StringBuilder()            val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))            val runFunTester= string.run {                for ( people in list_people)                {                    append(people).append("\n")                }                string.toString()            }            println(runFunTester)        }        fun applyFunTester()        {            val string = StringBuilder()            val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))            val applyFunTester= string.apply {                for ( people in list_people)                {                    append(people).append("\n")                }            }            println(applyFunTester)        }    }}</code></pre><p>伴生对象的使用很简单，直接在普通的类中这样即可：</p><pre><code class="language-kotlin">class objext1{companion object    {        }}</code></pre><p><code>companion object</code>大括号中的内容就是伴生对象的**‘’静态方法‘’**,但需要注意的是实际上这两种方法都不是真正的静态方法，而是通过系统创建的同名对象实现的。</p><h4><span id="koltin的真正静态方法">Koltin的真正静态方法</span></h4><p>Kotlin同样提供了两种方法，来实现真正的静态方法。对于上边两种假的静态方法，如果你的代码需要在Java里面以静态的方法去调用，你会发现这些方法实际上根本不存在。而如果我们需要真正的静态方法呢？</p><h5><span id="jvmstatic注解"><code>@JvmStatic</code>注解</span></h5><p><code>@JvmStatic</code>注解只能作用在单例类或者伴生类中的方法上，如果你尝试在普通类的方法是使用这个注解就会产生报错。</p><p>举个例子：</p><pre><code class="language-kotlin">companion object{    @JvmStatic    fun applyFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val applyFunTester= string.apply {            for ( people in list_people)            {                append(people).append("\n")            }        }        println(applyFunTester)    }}</code></pre><p>那么如何调用呢？</p><p>调用的方式也很简单，就是静态方法的调用模式：</p><pre><code class="language-Kotlin">fun main(args: Array&lt;String&gt;){    Utils.runFunTester()    Utils.applyFunTester()}</code></pre><p>可以看到上边两种方法虽然在Kotlin中看起来一摸一样实际上原理并不相同。</p><h5><span id="顶层方法">顶层方法</span></h5><p>我们在前几张说过main函数有些特殊他是直接写在一个文件里面的，里面并没有包含任何类，就像这样：</p><p><img src="https://s2.loli.net/2024/10/04/QYeV3D6cK2OoiXm.png" alt="image-20220502094322826"></p><p>Kotlin的编译器会将所有顶层方法全部编译成静态方法，因此只要你定义了一个顶层方法，那么他一定是静态方法。在前几节我们使用test类作为单例类来创建静态的main方法，这里我们抛弃多余的test类，然后使用顶层方法作为mian方法让JVM调用，效果如上图所示。</p><p>那么对于顶层方法如何调用呢？</p><p>我们再将<code>withFunTester</code>方法作为顶层方法来看看如何使用：</p><p>创建一个Kotlin File后直接把方法放进去即可，效果如下：</p><p><img src="https://s2.loli.net/2024/10/04/3QR6kJuKiEzcU1j.png" alt="image-20220502095102381"></p><p>我们在main函数直接调用即可！对!不需要管路径，也不用创建实例，直接键入方法名即可：</p><p><img src="https://s2.loli.net/2024/10/04/OAltvENwy5pfSJh.png" alt="image-20220502095418638"></p><p>当然这里还是要提一嘴，如果要在java中调用Kotlin编写的静态方法怎么办？</p><p>我们创建的文件名为：Statictester.kt</p><p>当编译完成的时候，Kotlin的编译器实际上创建了一个Statictesterkt类，静态方法就按照java的静态形式定义在类里面，所以按照文件名.方法的形式来调用就行了。</p>]]></content>
    
    
    <summary type="html">Kotlin的延迟初始化与Viewbinding、密封类</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin的面对对象）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1)%20/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1)%20/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.575Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin的面对对象">Android开发笔记——快速入门（Kotlin的面对对象）</span></h1><img src="https://s2.loli.net/2024/10/04/TU4j1YWLER9caFp.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727980774295" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1">Kotlin的面对对象</a><ul><li><a href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1">类与对象</a></li><li><a href="#kotlin%E7%9A%84%E6%96%B9%E6%B3%95">Kotlin的方法</a></li><li><a href="#kotlin%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%9E%84%E9%80%A0">Kotlin的继承与构造</a></li><li><a href="#kotlin%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B">Kotlin的接口与面向接口编程</a><ul><li><a href="#%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%A2%84%E5%85%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">在接口中预先实现一个方法（默认实现）</a></li><li><a href="#%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B">面向接口编程</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6">Kotlin的可见性修饰符</a></li><li><a href="#kotlin%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%92%8C%E5%8D%95%E4%BE%8B%E7%B1%BB">Kotlin的数据类和单例类</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB">数据类</a></li><li><a href="#%E5%8D%95%E4%BE%8B%E7%B1%BB">单例类</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的面对对象">Kotlin的面对对象</span></h2><h4><span id="类与对象">类与对象</span></h4><p>在上一节我们创建了一个类但是并没有使用，所有的代码都是通过函数实现的，这并不符合面向对象的编程的要求。至于什么是面向对象编程这里就不再多说了有兴趣的或不了解的可以去知乎看一看。</p><p>这里我们再新建一个class名叫Person。Kotlin 中使用关键字 <code>class</code> 声明类。</p><p><img src="https://s2.loli.net/2024/10/04/DF2Pz5Yp9vkL1ar.png" alt="1"></p><p>类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的； 如果一个类没有类体，可以省略花括号。</p><pre><code class="language-kotlin">class Person</code></pre><p>这样也是完全正确的。</p><p>给他添加一些字段：</p><pre><code class="language-Kotlin">package com.example.codewithkotlinclass Person{    var  age :Int =0 ;    val name  = "";}</code></pre><p>可以看到我这里使用了两种写法来提示你字段也能自动推导类型。</p><p>下面我们来考虑一下如何实例化这个类：</p><pre><code class="language-kotlin">package com.example.codewithkotlinclass Person{    var  age :Int =0 ;    val name  = "";}fun main(){    var jack = Person()    println(jack.age)}</code></pre><p>首先看到代码时你如果有Java的编程基础你会有疑问，main为什么不在类里面？而且也不是静态方法？这里暂且先放一放，我们到后边再来说这个我问题，这里先接受它，能运行，是一个程序的入口。</p><p>具体在里面呢我们实例化了一个类，你可以看看非常轻巧简单，保持着<strong>能省就省</strong>的原则，不需要类型名，不需要new关键字，直接调用类名+（）就实现了初始化：</p><pre><code class="language-Kotlin">fun main(){    var jack = Person()    println(jack.age)}</code></pre><h4><span id="kotlin的方法">Kotlin的方法</span></h4><p>方法也没什么好说的，他和函数的语法糖一摸一样，连关键字也一摸一样，你可以用一行来写一个方法的简单明了，调用的时候也是实例+.+方法。例子如下：</p><pre><code class="language-kotlin">package com.example.codewithkotlinclass Person{    var  age :Int =0 ;    val name  = "";    fun study() =  "zzy love study"}fun main(){    var zzy = Person()    println(zzy.age)    println(zzy.study())}</code></pre><p>输出结果如下：</p><p><img src="https://s2.loli.net/2024/10/04/NpirAk83Z72XQGm.png" alt="2"></p><h4><span id="kotlin的继承与构造">Kotlin的继承与构造</span></h4><p>关于继承的概念也不再详细解释，感兴趣请移步知乎。</p><p>这里直接介绍用法和技巧.</p><p>为了验证使用我们这里需要新建一个类：</p><p><img src="https://s2.loli.net/2024/10/04/UmjrRzg1743pfxh.png" alt="3"></p><p>继承的方法很简单，kotlin将关键字extends替换位：，写起来相对简单一些。可以看到如下就继承了Person类，同时也继承了其类内部的字段。</p><pre><code class="language-kotlin">class Zzy : Person(){}</code></pre><p>这里也许你会产生疑问，为啥后边还会跟一个（）？这不就是打破了能省就省的设计思想了吗？当然不是啦！</p><p>这个（）就是每个面向对象不可或缺的构造函数，只不过我们目前构造的都是无参的构造函数，在类后边就不需要写无参构造函数的括号。</p><p>在前边我们说过Kotlin的类的声明中可以省略类体和类头，在 Kotlin 中的一个类可以有一个<em>主构造函数</em>以及一个或多个<em>次构造函数</em>。主构造函数是类头的一部分：它跟在类名与可选的类型参数后。</p><pre><code class="language-kotlin">class Person constructor() { /*……*/ }</code></pre><p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 <code>constructor</code> 关键字。</p><pre><code class="language-kotlin">class Person() { /*……*/ }</code></pre><p>如果构造函数有注解或可见性修饰符，这个 <code>constructor</code> 关键字是必需的，并且这些修饰符在它前面：</p><pre><code class="language-kotlin">class Customer public @Inject constructor(name: String) { /*……*/ }</code></pre><p>那么在没有修饰符的情况下，有参数的构造函数如何写呢？我们反过来修改一下父类：</p><pre><code class="language-kotlin">open class Person(age :Int, name:String){    fun study() = name + "love study"}</code></pre><p>可以看到需要在构造函数里声明的字段就写好了，在实例化的时候就需要传入这些字段的参数：</p><pre><code class="language-kotlin">open class Person(age :Int, name:String){    val name :String = name;    var age :Int = age;    fun study() = name + "love study"}</code></pre><p>这里值得注意的是，这里的age，name和下面字段所指并不是一个，构造函数的参数只是个构造函数的局部变量，而不是成员变量，你如果想直接声明成字段的话就要显示的指定他是val还是var，指定后默认将其作为字段来初始化。</p><pre><code class="language-kotlin">open class Person(var age :Int, val name:String){    fun study() = name + "love study"}</code></pre><p>你可能还会有疑问，那我想写一些逻辑处理函数怎么办呢？Kotlin同时也提供了构造函数的函数体：</p><pre><code class="language-kotlin">open class Person(age :Int, name:String){    val name :String = name;    var age :Int = 0;//这里不初始化等到init再来初始化它。    init {        this.age = age;    }    fun study() = name + "love study"}</code></pre><p>我们再回到继承上来说，有参的父类怎么继承？很简单在对应的位置输入构造参数就行了：</p><pre><code class="language-Kotlin">package com.example.codewithkotlinclass Zzy(gender: String) : Person(22,"zhuzeyu"){}</code></pre><p>同样你也可以使用它的构造参数：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"){init {    println(name+" is a "+gender+" age is "+age)}}//输出结果zhuzeyuis a man age is 22</code></pre><p>在我们讨论完了主构造函数以后，既然有主构造函数那么一定有次构造函数，来看看他如何使用：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"){    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init {    println(name+" is a "+gender+" age is "+age)    }}</code></pre><p>使用很简单，constructor关键字就是来创建构造函数的，kotlin规定次构造函数必须要调用主构造函数，所以你可以看到this关键字来调用主构造函数。与主构造函数不同的是此构造函数有函数体，并且次构造函数没办法直接声明成员，这里需要注意一下，参数的作用范围只有在此构造函数之中。</p><p>调用实例：</p><pre><code class="language-kotlin">fun main(){    var zzy = Zzy(120,100)}输出结果：zhuzeyu is a man age is 22his iq is 120 eq is 100</code></pre><h4><span id="kotlin的接口与面向接口编程">Kotlin的接口与面向接口编程</span></h4><p>kotlin和java一样都不是多继承的面向对象编程，也就是说你只能继承一个父类，但是对于子类来说需要多继承的时候就很麻烦了，所以这里选择接口会更方便。</p><p>接口和普通类的界限在逐渐变得模糊，不管是针对java还是kotlin都是一样，可以继承多个接口，接口的继承演示如下：</p><p>继承的关键字同样被<code>：</code>所替代，和继承的父类可以直接一起使用，将它们分开就可以同时继承。</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"),Eat{    //实现了两个接口中的函数    override fun drink_soap() {        println("drink soap")    }    override fun eat_rice() {       println("eat rice")    }    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init {    println(name+" is a "+gender+" age is "+age)    }}</code></pre><p>Eat接口：</p><pre><code class="language-kotlin">interface Eat{    fun drink_soap()    fun eat_rice()}</code></pre><p>为什么说接口和普通类正在变得模糊呢？我们再来看一个操作：</p><h5><span id="在接口中预先实现一个方法默认实现">在接口中预先实现一个方法（默认实现）</span></h5><p>如果你在接口中实现了一个方法：</p><pre><code class="language-kotlin">interface Eat{    fun drink_soap(){        println("drink soap")    }    fun eat_rice()}</code></pre><p>在类的实例就可以直接不需要重写他们，IDEA也不会报错：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"),Eat{    override fun eat_rice()     {       println("eat rice")    }    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init     {        println(name+" is a "+gender+" age is "+age)    }}</code></pre><p>在使用的时候直接调用即可：</p><pre><code class="language-kotlin">fun main(){    var zzy = Zzy(120,100)    zzy.drink_soap()}</code></pre><h5><span id="面向接口编程">面向接口编程</span></h5><p>你如果了解面向对象，你也一定可以明白什么是面向接口，如果面向对象的方法参数传递的是对象，那么面向接口，就是传递的是接口：</p><p>我们来看一个复杂一点的例子：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"),Eat{// 以上代码省略，新添加一个方法    fun  eat_drink_together( eat : Eat)    {        eat.drink_soap()        eat_rice()    }}</code></pre><p>在这里调用新方法，传入自己作为参数：</p><pre><code class="language-kotlin">fun main(){    var zzy = Zzy(120,100)    zzy.eat_drink_together(zzy)}</code></pre><p>这段代码可能有点稍微难理解他的目的是什么，注意看到<code>eat_drink_together</code>方法的参数实际上是一个接口，因为zzy类实现了这个接口当然也可以传入作为参数，顺理成章地调用其中的实现的抽象的方法，这里就可以叫接口的多态。</p><h4><span id="kotlin的可见性修饰符">Kotlin的可见性修饰符</span></h4><p>kotlin的修饰符存在很大的与java的不同：</p><p>可以参考一下表：</p><p><img src="https://s2.loli.net/2024/10/04/OYCuzypwlLreh1D.png" alt="3"></p><p>可以看到最大的区别有几点</p><ul><li>Kotlin中默认的类型是public而不是default。</li><li>Kotlin中没有default类型，也就是没有包级可见，Kotlin的protect类型同一包路径下也不可见（牢记没有包可见）。</li><li>新增internal类型，在同一模块下可见。</li></ul><p>可以看到kotlin和android设计首选的语言并不是全无道理，抛弃了原来java的文件构建模式，转而支持更多的android的文件架构，关于模块等到写到的时候再说。</p><h4><span id="kotlin的数据类和单例类">Kotlin的数据类和单例类</span></h4><h5><span id="数据类">数据类</span></h5><p>数据类常常用于将服务器端或数据库中的数据集映射到内存中，为编程提供数据模型的支持。简单来说就是专门用来管理数据在内存中的类。</p><p>在java中为了实现一个数据类我们通常要实现equals（）、hashCode（）方法等。kotlin保持着能省就省的原则，这些没有实际逻辑意义的代码都应该被替换掉，被替换成什么了呢？</p><p>就一个关键字：<code>data</code></p><pre><code class="language-KOTLIN">data class Exam(val exameername:String,val examname:String,val examgrade:Int)</code></pre><p>你可能会疑问为什么后边没有{}呢，在提示一下语法糖，没有代码的话可以省略的。</p><p>那么数据类怎么使用呢？</p><p>我这里定义的是考试类，参数分别是考试人名称，考试名称，考试成绩。</p><p>这里我们创建两个实体对象然后调用，.equals()方法进行匹配：</p><pre><code class="language-kotlin">val exam1 = Exam("zzy","exam1",100)val exam2 = Exam("zzy","exam1",100)if (exam1 == exam2)println("same")if(exam1.equals(exam2))println("yesyes")</code></pre><pre><code class="language-shell">sameyesyes</code></pre><h5><span id="单例类">单例类</span></h5><p>单例类是针对单例模式而特殊设计的类，它可以避免创造重复的对象，当我们希望某个类在全局最多只有一个实例的时候们就可以使用单例类。</p><p>对于java我们不再赘述，将构造函数私有化等就可以实现单例类，虽然java实现的并不复杂但是kotlin明显做的更好，我们只需要将关键字class改为object即可，不需要自己去写实现方法，操作简单。</p><p>演示：</p><p>其实在前面我们都是通过直接定义main函数来直接运行的，但是在面向对象的时候大多是是没有函数的概念，这里我们借助单例类来实现类似于java类中的main方法：</p><pre><code class="language-kotlin">object test{    @JvmStatic    fun main(args: Array&lt;String&gt;)    {        //继承等演示        var zzy = Zzy(120,100)        zzy.eat_drink_together(zzy)        //数据类演示        val exam1 = Exam("zzy","exam1",100)        val exam2 = Exam("zzy","exam1",100)        if (exam1 == exam2)            println("same")        if(exam1.equals(exam2))            println("yesyes")        //单例类演示        test.tester();    }    // 单例类方法    fun tester()    {        println("test")    }}</code></pre><p>可以看到创建了一个单例类，并且声明了两个方法，分别是main和tester方法</p><p>你可以看到main上边有一个注释@JvmStatic，你可以意识到这里的main其实并不是static的</p><p>实际上kotlin并没有static这个关键字，这个先留到以后再说，这里的main就是程序的入口，调用单例类的方法很简单而且不需要自己实例化，在启动的时候kotlin已经自动帮忙创建了所有单例类的实例化，在作用范围内调用很简单：</p><pre><code class="language-kotlin">//单例类演示test.tester();</code></pre><p>直接类名+方法即可，注意这里要和java的静态方法区别开，只是结构类似，本质完全不同，并不是静态的数据类型。</p>]]></content>
    
    
    <summary type="html">Kotlin的面对对象</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（从入门ACT到Fragment放肆）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Fragment%E4%B8%AD%E4%BD%BF%E7%94%A8Viewbinding%EF%BC%89/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Fragment%E4%B8%AD%E4%BD%BF%E7%94%A8Viewbinding%EF%BC%89/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.575Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门从入门act到fragment放肆">Android开发笔记——快速入门（从入门ACT到Fragment放肆）</span></h1><img src="https://s2.loli.net/2024/09/29/Y6ROSXiaEBhjVMG.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727616948149" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><p>[TOC]</p><!-- toc --><ul><li><a href="#%E4%BB%8E%E5%85%A5%E9%97%A8act%E5%88%B0fragment%E6%94%BE%E8%82%86">从入门ACT到Fragment放肆</a></li><li><a href="#%E8%BF%87%E5%BA%A6%E5%88%B0fragment">过度到Fragment</a><ul><li><a href="#%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8viewbinding%E9%85%8D%E5%90%88activity%E7%9A%84fragment">优雅的使用Viewbinding配合Activity的Fragment</a></li></ul></li></ul><!-- tocstop --><h2><span id="从入门act到fragment放肆">从入门ACT到Fragment放肆</span></h2><p>学习了那么多的ACT，你有没有考虑过一个问题？</p><p><strong>ACT的布局是如何和ACT的显示内容关联起来的？</strong></p><p>在理解这个问题之前需要先理解几个个问题：</p><p>什么是view？view的本质是什么？如何把布局转化为view？</p><p>接下来你可以参考文章：</p><h2><span id="过度到fragment">过度到Fragment</span></h2><p>我们都知道，Android上的界面展示都是通过Activity实现的，Activity实在是太常用了，他的缺点也很明显，同样的Activity界面在手机上显示可能很好看，在平板上就未必了，因为平板的屏幕非常大，手机的界面放在平板上可能会有过分被拉长、控件间距过大等情况。这个时候更好的体验效果是在Activity中嵌入"小Activity"，然后每个"小Activity"又可以拥有自己的布局。</p><p>这个"小Activity"就被称为<strong>Fragment</strong>。</p><p>这里使用郭神的图片来做个演示：</p><p>如果现在程序运行竖屏模式的平板或手机上，Fragment 1可能嵌入在一个Activity中，而Fragment 2可能嵌入在另一个Activity中，如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/MZJDRmSqnQ8r3j1.png" alt="image-20220621110817903"></p><p>而如果现在程序运行在横屏模式的平板上，两个Fragment就可以嵌入在同一个Activity中了，如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/TUuAlf6NBIiqLgY.png" alt="f91c86ce1773d8be"></p><p>由此可以看出，使用Fragment可以让我们更加充分地利用平板的屏幕空间，下面我们一起来探究下如何使用Fragment。</p><p>使用Fragment很简单，类似于创建Activity一样，具体操作可以参考《Anodroid第一行代码》的内容，我们这里就从View的角度去考虑Act是如何将Fragment导入到其中的。</p><p>对于一个ACT来说想要让其显示到手机上，只需要一个布局文件和一个ACT类来将布局文件加载进来就可以了，对于一个Fragment来说同样也是这样。首先我们创建两个Fragment的布局文件，让他等下填充一个ACT，简单来说就是把一个ACT用两个Fragment布局来填充。</p><p>创建的布局文件如下：</p><p><code>left_fragment.xml</code></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    android:orientation="vertical"    tools:context=".Left_fragment"&gt;    &lt;Button        android:id="@+id/button"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:layout_gravity="center_horizontal"        android:layout_marginBottom="683dp"        android:text="Button"        app:layout_constraintBottom_toBottomOf="parent"        app:layout_constraintEnd_toEndOf="parent"        app:layout_constraintStart_toStartOf="parent"        app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p>右布局如下：</p><p><code>right_fragment.xml</code></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    android:orientation="vertical"    android:background="#00ff00"    tools:context=".Right_fragment"&gt;    &lt;!-- TODO: Update blank fragment layout --&gt;    &lt;TextView        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:layout_gravity="center_horizontal"        android:textSize="24sp"        android:text="This is right Fragment" /&gt;&lt;/LinearLayout&gt;</code></pre><p>为了直观一点我把左右布局的放上来看一看：</p><p>左布局情况：</p><p>实际上左布局就是通过约束布局在上边放置了一个水平中间对齐的按钮。</p><p><img src="https://s2.loli.net/2024/09/29/245eJwsVId3OBfZ.png" alt="image-20220621104941190"></p><p>右部局情况：</p><p>右边的布局更简单，使用线性布局并将背景颜色设置为绿色，在中间设置了一个对齐的Textview，来显示一段文字。</p><p><img src="https://s2.loli.net/2024/09/29/EIvNkZVmqOHfaud.png" alt="image-20220621105020844"></p><p>布局文件有了就是具体的类了，AS创建新的Fragment很简单，可以通过直接UI引导工具创建也可以自己新建一个Kotlin类作为Fragmen类只要继承 Fragment()就好了。</p><p>通过UI创建：</p><p><img src="https://s2.loli.net/2024/09/29/PgXhOlYuW3kGfaV.png" alt="image-20220621105240034"></p><p>左LeftFragment代码如下，如果你是通过UI创建的会帮写好很多重写的方法，目前还用不到，可以直接删除重写，具体代码如下：</p><pre><code class="language-kotlin">class Left_fragment : Fragment() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)    }    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View? {         return layoutInflater.inflate(R.layout.left_fragment,container,false)    }}</code></pre><p>通过上边针对layoutInflater的学习，我相信你能很快的理解这里onCreateView是如何工作的，在调用这个方法之前肯定是通过context对象来获取了一个LayoutInflater，我们只要正常使用这个LayoutInflater的inflate方法就可以将对应的布局加载进来，这里有个小细节是<strong>这里inflate()方法的最后一个参数一定要传入false</strong>。</p><p>在Fragment的相关源码，你会发现它会自动将我们在onCreateView()方法中返回的View添加到一个Container当中：</p><pre><code class="language-kotlin">void addViewToContainer() {    // Ensure that our new Fragment is placed in the right index    // based on its relative position to Fragments already in the    // same container    int index = mFragmentStore.findFragmentIndexInContainer(mFragment);    mFragment.mContainer.addView(mFragment.mView, index);}//版权声明：本文为CSDN博主「guolin」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/guolin_blog/article/details/121889703</code></pre><p>也就是说，后续Fragment自己会有一个addView的操作，如果我们将inflate()方法的第三个参数传入true，那么就会直接将inflate出来的布局添加到父布局当中。这样后面再次addView的时候就会发现它已经有一个父布局了，从而抛出崩溃信息。</p><p><strong>总的来说就是使用 layoutInflater来向Fragment加载了布局。</strong></p><p>同样的右Fragment的代码如下：</p><pre><code class="language-kotlin">class Right_fragment : Fragment() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)    }    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View? {        return layoutInflater.inflate(R.layout.right_fragment,container,false)    }}</code></pre><p>代码基本一摸一样没什么好说的。</p><p>接下来就是在ACT的布局中引入两个Fragment，这个更简单：</p><p>我们直接在ACT的布局中引入两个Fragment即可然后通过ID指定是布局文件中哪个Fragment，</p><p><code>android:id="@+id/rightFragment"</code>。</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".MainActivity" &gt;    &lt;fragment        android:id="@+id/rightFragment"        android:name="com.example.fragmenttest.Right_fragment"        android:layout_width="0dp"        android:layout_height="match_parent"        android:layout_weight="1"        app:layout_constraintBottom_toBottomOf="parent"        app:layout_constraintEnd_toStartOf="@+id/leftFragment"        app:layout_constraintHorizontal_weight="1"        app:layout_constraintStart_toStartOf="parent"        app:layout_constraintTop_toTopOf="parent"        app:layout_constraintVertical_bias="0.0" /&gt;    &lt;fragment        android:id="@+id/leftFragment"        android:name="com.example.fragmenttest.Left_fragment"        android:layout_width="0dp"        android:layout_height="match_parent"        android:layout_weight="1"        app:layout_constraintBottom_toBottomOf="parent"        app:layout_constraintEnd_toEndOf="parent"        app:layout_constraintHorizontal_weight="1"        app:layout_constraintStart_toEndOf="@+id/rightFragment"        app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p>我们通过        <code>app:layout_constraintHorizontal_weight="1"</code>属性来将约束布局的占比调整成1：1，最终实现效果如下：</p><p><img src="https://s2.loli.net/2024/09/29/QpG38ikaRU5XJ46.png" alt="image-20220621105739852"></p><p>当然只是使用Fragment不能算是放肆，我们来结合一点新的东西：</p><h3><span id="优雅的使用viewbinding配合activity的fragment">优雅的使用Viewbinding配合Activity的Fragment</span></h3><p>viewbinding已经出来很久了，他和LayoutInflater的最大区别在于，当我使用LayoutInflater获取加载的View对象的时候，我们只是获取了一个view对象，我们无法直接获得view中的组件，打个比方你如果其中包含了一个button的话你是无法直接获得一个button的，你需要这样：</p><p><code>view.findViewById()</code></p><p>我并不推荐这样，因为对于一个项目来说如果其中包含了大量的控件的话，<code>findViewById()</code>是通过遍历他的组件树来查找某个组件的，这会造成性能问题，虽然现在性能很强了，但是小细节还是要注意。</p><p>我们如果使用Viewbinding的话，这些问题都可以迎刃而解了，首先你如果还不太懂如何使用viewbinding的话请参考我的前一篇文章，先学习一下如何在Activity中使用viewbinding。</p><p>我们首先在Activity中创建两个绑定类，首先是Activity的绑定类，其次是左Fragment的绑定类，我们在这里先把左Fragemnt加载进来，右边的就先不要考虑。</p><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {    private lateinit var binding :ActivityMainBinding    private lateinit var leftbinding  : LeftFragmentBinding        override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        //使用viewbinding填充Activity视图        binding = ActivityMainBinding.inflate(layoutInflater)        val left_fragment: View = binding.????????        setContentView(binding.root)    }}</code></pre><p>在绑定类创建完成的时候，我们不能直接对他初始化，如果你仔细看了Viewbinding的关于Context类的介绍就知道，这时候Activity的Context还没完成，直接调用的话就会造成空指针问题。</p><p>接下来和Act中一样使用layoutInflater来将布局加载进来，加载的时候同时也将布局中的Fragment一并加载进来，这时候你就会有疑问了，那么我的Fragment在哪里呢？为什么绑定类无法获取到我的Fragment？</p><p><img src="https://s2.loli.net/2024/09/29/OQgDSIPWT8vBise.png" alt="image-20220621113055061"></p><p>实际上Fragment是一个container而不是一个Viewgroup，所以在layoutInflater中无法获取到对应的Fragment。关于Fragment并不是一个view类型，在Stackoverflow上有这样的说：</p><p><img src="https://s2.loli.net/2024/09/29/Lps6K74hyjgztn9.png" alt="10"></p><p>Fragment 标签( <code>&lt;fragment&gt;</code>) 并不是一个 <code>view</code>而是一个<code>container</code>类型，所以Viewbinding是无法直接获取到的，即使我在Fragment布局文件中包含了某个Fragment的id。如下图：</p><p><img src="/home/neo/%E6%96%87%E7%AB%A0/Android/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Fragment%E4%B8%AD%E4%BD%BF%E7%94%A8Viewbinding%EF%BC%89.assets/12.png" alt="12"></p><p>实际上即使有ID的但是还是无法获取，我同时在stackoverflow上看到了这样的介绍，我觉得是最容易理解的：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/21/3ce882914ef5dafd.png" alt="13"></p><p>普通的Lauout都是直接继承于ViewGroup，像是<code>LinearLayout</code>，<code>RelativeLayout</code>这些实际上是继承于ViewGroup的类，这些类的后缀之中都包含着<code>Lauout</code>。</p><p>而<code>container</code>类型更像是view的桶，里面放着动态的内容他相对于Views他可以继承一个Layouts类同样也可以不继承，其中很多实际上没有直接继承<code>Viewgroup</code>像<code>Listview</code>，而有些直接就选择不继承，像<code>VideoView</code>就是这样虽然<code>container</code>标签被用于在AS中，但它不是任何一个类的名称。</p><p>你可能会想这还不简单？我这样写就能创建一个<code>Fragement</code>的绑定类了：</p><pre><code class="language-kotlin">leftbinding =LeftFragmentBinding.inflate(layoutInflater,binding.root,true)</code></pre><p>错！仔细看上文中<code>layoutInflater</code>的介绍，<code>LayoutInflater</code>的inflate方法实际上是唯一加载布局的方法，加载布局就是把布局转化为view对象，我们在这里调用了一个<code>LeftFragmentBinding.inflate()</code>方法实际上是重新加载了一个布局，而不是使用Activity中的Fragement！</p><p>效果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/21/fed6d742e3c3afcf.png" alt="image-20220621113929146"></p><p>这当然不是我们想要的，那么到底如何访问到Fragment的button组件呢？</p><p>其实很简单，我们只需要将绑定类绑定到Activity的中Fragment中即可</p><pre><code class="language-kotlin">leftbinding = LeftFragmentBinding.bind(binding.root)</code></pre><p>这时候这个绑定类实际上就是Activity中的Fragment的绑定类！</p><p>我们就可以通过这个绑定类来获取到button组件。</p><p>完整代码如下：</p><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {    private lateinit var binding :ActivityMainBinding    private lateinit var leftbinding  : LeftFragmentBinding        override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding = ActivityMainBinding.inflate(layoutInflater)        //绑定对应的Fragment视图上        leftbinding =LeftFragmentBinding.bind(binding.root)        leftbinding.button.setOnClickListener {             //button的点击操作        }        setContentView(binding.root)    }    }</code></pre><p>你觉得这样就完成了吗！大错特错！能运行就说明你用的对吗？</p><p>我们在这里打破砂锅问到底！</p><p>这里需要注意的细节是并不是所有布局都可以随意绑定的，在Activity中的Fragment实际上是囊括在一个约束布局之中的,我们回忆一下，Fragment实际上并不是一个view而是一个存放view的容器。</p><p><img src="Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Fragment%E4%B8%AD%E4%BD%BF%E7%94%A8Viewbinding%EF%BC%89.assets/14.png" alt="14"></p><p>我们再来回看一个例子，说为什么这里将Fragment绑定到binding.root上是不正确的。</p><p>我们看一下我刚刚绑定的左边的Fragment，还有一个右边的Fragment我们没有尝试绑定：</p><p>他的布局是什么呢？</p><pre><code class="language-kotlin">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    android:orientation="vertical"    android:background="#00ff00"    tools:context=".Right_fragment"&gt;    &lt;TextView        android:id="@+id/text"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:layout_gravity="center_horizontal"        android:textSize="24sp"        android:text="This is right Fragment" /&gt;&lt;/LinearLayout&gt;</code></pre><p>是一个由<code>LinearLayout</code>内部包含的<code>TextView</code>组成的布局，按道理来说绑定也很简单对吧：</p><pre><code class="language-kotlin">rightbinding=RightFragmentBinding.bind(binding.root)    </code></pre><p>当我们尝试绑定的结果是什么呢？</p><p>竟然报错啦！</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/21/f4faea41eb14ede6.png" alt="0"></p><pre><code class="language-shell">E/AndroidRuntime: FATAL EXCEPTION: main    Process: com.example.fragmenttest, PID: 27502    java.lang.RuntimeException: Unable to start activity ComponentInfo{com.example.fragmenttest/com.example.fragmenttest.MainActivity}: java.lang.ClassCastException: androidx.constraintlayout.widget.ConstraintLayout cannot be cast to android.widget.LinearLayout</code></pre><p>怎么会报错呢？<code>java.lang.ClassCastException: androidx.constraintlayout.widget.ConstraintLayout cannot be cast to android.widget.LinearLayout</code></p><p>为什么说是把<code>ConstraintLayout</code> 强转成<code>LinearLayout</code>失败呢？</p><p>要了解这个问题我们就要去看看bind的代码是什么，可惜的是由于它是以插件辅助的形式存在，实际上你是无法直接访问到对应的绑定类的，这就基本告别了bind方法是如何实现的，不过好在我找到了Google的开发人员书写的Viewbinding的指南</p><p><a href="https://medium.com/androiddevelopers/use-view-binding-to-replace-findviewbyid-c83942471fc">原文链接</a>。</p><p>对于bind方法他大致的样子是这样的：</p><pre><code class="language-java"> @NonNull  public static 某个bidning类 bind(@NonNull View rootView)   {    /* Edit: Simplified code – the real generated code is an optimized version */    TextView textview = rootView.findViewById(R.id.subtext);         if (textview != null)     {      return new 某个bidning类的构造方法 ((ConstraintLayout) rootView, textview);//注意这里有一个强转操作    }    throw new NullPointerException("Missing required view […]");  }</code></pre><p>他的方法很简单，就是将这个布局里面的所有组件通过<code>findViewById</code>方法获取到<code>view</code>对象，然后通过构造方法构造一个绑定类进行返回。</p><p>我们再来看一下绑定类的构造方法：</p><pre><code class="language-kotlin">private 某个bidning类的构造方法 (@NonNull 根布局的类型 rootView, @NonNull TextView textview/*此处应包含所有的子组件，这里只有一个textview所以只需要传入一下textview就可以*/){ … }</code></pre><p>虽然没有详细写，但是我们知道根据视图生成的绑定类实际上的rootview是整个布局的根布局，对于<code>rightbinding</code>来说我们实际上的rootview应该是一个<code>LinearLayout</code>，我们调用bind方法的时候获取的<code>binding.root</code>实际上是Activity的根部局，是<code>constraintlayout</code>，所以产生了强转错误，也就是说我们绑定的对象根本不对！实际上应该怎么写呢？</p><p>我们先来确认一下对于Activity加载进来的view对象构成是什么样，rightFragment的父组件是什么？rightFragment是什么布局？我们通过Log来输出以下结果：</p><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {                                                                                        private lateinit var binding :ActivityMainBinding              private lateinit var leftbinding  : LeftFragmentBinding        private lateinit var rightbinding  : RightFragmentBinding                                                                     override fun onCreate(savedInstanceState: Bundle?)             {                                                                  super.onCreate(savedInstanceState)                             binding = ActivityMainBinding.inflate(layoutInflater)          setContentView(binding.root)                       val rightfragment: View =findViewById(R.id.rightFragmen)        val Textview :View = findViewById(R.id.text)                                            Log.e("tester",Textview.parent.toString())                     Log.e("tester",Textview.parent.parent.toString())                  Log.e("tester",rightfragment.toString())                       Log.e("tester",rightfragment.parent.toString())                        Log.e("tester",binding.root.toString())                        Log.e("tester",binding.root.rootView.toString())          }}</code></pre><p>这里通过万能的<code>findViewById</code>来获取Activity中Fragment的组件，将其中的textview和fragment本身提取出来，输出看一下其对应的类型和父类对应的类型。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/21/d754d43aa68a0b02.png" alt="15"></p><pre><code class="language-shell">2022-05-18 23:29:47.132 12020-12020/com.example.fragmenttest E/tester: android.widget.LinearLayout{aa4256a V.E...... ......ID 0,0-0,0 #7f08012b app:id/rightFragment}2022-05-18 23:29:47.132 12020-12020/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0}2022-05-18 23:29:47.132 12020-12020/com.example.fragmenttest E/tester: android.widget.LinearLayout{aa4256a V.E...... ......ID 0,0-0,0 #7f08012b app:id/rightFragment}2022-05-18 23:29:47.132 12020-12020/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0}2022-05-18 23:29:47.132 12020-12020/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0}</code></pre><p>可以看到textview的父类其实是一个<code>Linearlayout</code>，而<code>Linearlayout</code>的父类其实是一个<code>ConstraintLayout</code>也就是Activity布局文件的最外层的<code>ConstraintLayout</code>。</p><p>而bind方法你也能看到,实际上它是将现有view绑定到这个类之中，所以我们应该绑定的是其对应的Fragment，而不是对应的<code>ConstraintLayout</code>。获取到对应的Fragment的外层布局也很简单，我们只要通过</p><pre><code class="language-kotlin">val rightfragment: View =findViewById(R.id.rightFragment)</code></pre><p>获取即可，有人说我用viewbinding不就是为了避免用<code>findViewById</code>吗？这个问题需要得到正视，因为在</p><p>bind方法中实际上也是使用<code>findViewById</code>来获取的，view binding的核心在于类型安全和快捷，减少多余的代码量，实际上是一种<code>findViewById</code>的封装。</p><p>最后在针对上文的错误结果查看一下：</p><p>对于绑定的布局我们再次输出他的根部局类型和他本身的布局类型：</p><pre><code class="language-kotlin">Log.e("tester",leftbinding.root.toString())Log.e("tester",leftbinding.button.parent.toString())//修正绑定对象val left_fragment: View =findViewById(R.id.leftFragment)leftbinding =LeftFragmentBinding.bind(left_fragment)Log.e("tester",leftbinding.root.toString())  Log.e("tester",leftbinding.button.parent.toString())</code></pre><p>结果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/21/7f0507d081ce62b9.png" alt="16"></p><pre><code class="language-shell">2022-05-19 08:18:31.215 10392-10392/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{aa4256a V.E...... ......I. 0,0-0,0}2022-05-19 08:18:31.215 10392-10392/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0 #7f0800c9 app:id/leftFragment}2022-05-19 08:18:31.216 10392-10392/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0 #7f0800c9 app:id/leftFragment}2022-05-19 08:18:31.216 10392-10392/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0 #7f0800c9 app:id/leftFragment}</code></pre><p>可以看到当使用binding.root直接作为绑定对象的时候，leftbinding的根部局是错误的不应该为Act的外层布局，修正以后变为Fragment的根部局。有时候代码能运行完全就是运气！</p>]]></content>
    
    
    <summary type="html">从入门ACT到Fragment放肆 Viewbinding等实战问题处理</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Fragment" scheme="http://neonexusx.github.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（入门Service）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Service%EF%BC%89/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Service%EF%BC%89/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.575Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门入门service">Android开发笔记——快速入门（入门Service）</span></h1><img src="https://s2.loli.net/2024/10/04/GgvAfI4DCxnYPJT.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727980973253" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#android%E7%9A%84service">Android的Service</a></li><li><a href="#android%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C">Android的多线程操作</a></li><li><a href="#android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6">Android异步消息处理机制</a><ul><li><a href="#asynctask">AsyncTask</a></li><li><a href="#android-%E7%9A%84service">Android 的Service</a><ul><li><a href="#%E4%B8%8Eactivity%E7%B4%A7%E5%AF%86%E7%BB%93%E5%90%88">与Activity紧密结合</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%9C%A8act%E4%B8%AD%E7%BB%91%E5%AE%9Aservice">如何在Act中绑定Service？</a></li></ul></li></ul></li><li><a href="#%E6%B3%A8%E6%84%8F">注意</a><ul><li><a href="#service%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Service生命周期</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><h2><span id="android的service">Android的Service</span></h2><p>Service是为了解决那些不需要和用户通过界面交互但还是需要长期运行的程序需求，Service的运行不依赖于任何界面，即使程序切换到后台，或者用户打开了另一个应用程序，Service依然能在后台稳定运行。</p><p>不过Service的实现并不是单独创建了一个进程，而是依赖于创建Service的进程，当某个程序被kiil掉之后，依赖于该进程的Service也会被Kill掉。</p><p>更需要注意的是，Service不会自动开启线程去处理内部的操作，实际上是需要你手动开启线程来处理操作，否则就有可能导致主界面内容不刷新（主线程操作被Service占满了）。</p><p>下面来介绍一下，Android如何开启线程。</p><h2><span id="android的多线程操作">Android的多线程操作</span></h2><p>Android的多线程操作基本就是移植Java的操作，在kotlin中使用Java的API我们常常是用lambda表达式来创建一个线程，类似于如下所示：</p><pre><code class="language-kotlin">Thread(){    println("YES")}.start()</code></pre><p>实际上Kotlin提供了更方便快捷的函数来实现操作：</p><pre><code class="language-kotlin"> thread {      println("YES") }</code></pre><p>他实现的方法就是对Java接口的再封装：</p><pre><code class="language-kotlin">public fun thread(    start: Boolean = true,    isDaemon: Boolean = false,    contextClassLoader: ClassLoader? = null,    name: String? = null,    priority: Int = -1,    block: () -&gt; Unit): Thread {    val thread = object : Thread() {        public override fun run() {            block()        }    }    if (isDaemon)        thread.isDaemon = true    if (priority &gt; 0)        thread.priority = priority    if (name != null)        thread.name = name    if (contextClassLoader != null)        thread.contextClassLoader = contextClassLoader    if (start)        thread.start()    return thread}</code></pre><h2><span id="android异步消息处理机制">Android异步消息处理机制</span></h2><p>我们知道多线程的情况下，有可能存在线程数据不安全的问题，Android提供了一套异步处理机制，来保证数据的安全，当你需要在一个线程中去操作另一个线程中的内容的时候，就可以使用这一套机制来实现数据修改。</p><p>在Android中所有的UI界面显示的数据都是线程不安全的，也就是说你无法在其他线程直接访问UI的数据并修改其中的内容，因为这样会导致抛出线程不安全的异常。有些时候，我们必须在子线程里面执行一些耗时的任务，然后根据任务结果来更新UI的内容。</p><p>在讨论这个部分之前，请先参考部分Kotlin语法的内容。在完全了解异步线程机制的之前，我们不妨来先写一个试试。</p><p>下面我们来举个例子：</p><p>我们为了实现音乐播放器在暂停的时候显示音乐已经暂停的文本，我们在界面之中放置一个TextView来显示一些信息，再通过一个线程来修改它，具体代码如下：</p><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {    lateinit var binding : ActivityMainBinding    val SongisPause = 1    val handler = object : Handler(Looper.getMainLooper()) {        override fun handleMessage(msg: Message) {            super.handleMessage(msg)            when (msg.what){                SongisPause -&gt; binding.textView.text ="Song is Pause"            }        }    }             override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding= ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)                 binding.stop.setOnClickListener {            thread {                val msg = Message()                msg.what = SongisPause                handler.sendMessage(msg)            }        }     }    }</code></pre><p>这段代码看起来很复杂难以理解，我们不妨在再拆开看一看：</p><p>在类的开始我们初始化了一些变量和对象：</p><pre><code class="language-kotlin">lateinit var binding : ActivityMainBindingval SongisPause = 1val handler = object : Handler(Looper.getMainLooper()) {    override fun handleMessage(msg: Message) {        super.handleMessage(msg)        when (msg.what){            SongisPause -&gt; binding.textView.text ="Song is Pause"        }    }}</code></pre><p>前两个就不再多说分别是一个绑定对象和一个一般的变量，需要仔细了解的是下面的这一个对象，这个handler使用了对象表达式来构造自己，他继承了Handler类，看到名字你也应该能猜到他是具体干什么的，他就是处理，具体去操作的函数。不过为什么这里要声明一个具体操作的函数，其背后原理的概念我们晚点再说，这里先理解最后线程的操作归咎于这里。</p><pre><code class="language-kotlin">binding.stop.setOnClickListener {    thread {        val msg = Message()        msg.what = SongisPause        handler.sendMessage(msg)    }}</code></pre><p>我们又在onCreate函数里面为暂停按钮绑定了一个回调函数，在回调函数里面我们使用thread函数创建了一个线程去处理暂停的操作，实际上我们是创建了一个message来向刚才创建的handler发送了一条消息，提示他该暂停了，当handler接收到了消息以后就会执行刚刚注册到handler的操作。</p><p>最终先效果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/26/ba6f7fd04f661604.png" alt="And"></p><p>看完以后你可能一脸懵，什么鬼？我们再来讨论一下，其背后实现的原理。</p><p>实际上我们可以注意到，接受收消息处理的操作还是在主线程中完成的，并不是在子线程中完成的，子线程实际上只是发送了meaasge，可是，message、handler和隐藏在背后的looper、MessageQueue都是什么呢？</p><p>Message：</p><p>是在线程中间传递的消息，它可以携带少量的内部信息，用于在不同线程之间传递数据，上一节我们使用了Message的what字段，除此之外他还包含arg1、arg2字段，用来携带一些整型数据，还有obj字段用来携带一个Object对象。</p><p>Handler：</p><p>它主要用于发送和处理信息，发送消息一般使用sendMessage和Post方法，而发出的消息经过内部处理以后，最终会传递到Handler的handleMessage方法当中。</p><p>MessageQueue：</p><p>是隐藏在消息背后的数据解构，里面以队列的形式存放着所有通过Handler发送的消息。这部分消息会一直存放在队列中，直到被取出后处理。每一个线程中最多只允许存在一个MessageQueue对象。</p><p>Looper</p><p>Looper是每个线程中的管家，调用Looper以后会进入到loop方法中，这是一个无限循环，每当MessageQueue中存放着一条消息的时候们就会将它自动取出来，并将消息内容传递到handleMessage()方法中。</p><p>我们主要来说一说Looper和MessageQueue是在哪里创建的，以及他们是如何串起来工作的。</p><p>Loop很简单，在主线创建的时候，就会自动产生一个属于主线程的looper对象，我们一般通过以下方式获取到looper对象：</p><ol><li>使用Looper静态方法getMainLooper()</li><li>使用Looper的静态方法获取到当前线程的Looper对象。</li></ol><pre><code class="language-kotlin">Looper.getMainLooper()</code></pre><p>一般情况下我们不会去手动创建一个loop去和某个线程产生关联，大多数直接调用拥有Looper的线程，比如主线程，如果想要创建的话请参考：<a href="https://developer.android.google.cn/reference/android/os/Looper#getMainLooper%28%29">Looper文档</a>。</p><p>MessageQueue其中的技术细节我们不探讨，我只考虑如何创建的MessageQueue以及MessageQueue是如何前边几个对象产生关联的。</p><p>在Hnadler接口的初始化函数里面我们可以看到：</p><pre><code class="language-java">@UnsupportedAppUsagepublic Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) {    mLooper = looper;    mQueue = looper.mQueue;    mCallback = callback;    mAsynchronous = async;}</code></pre><p>队列直接和looper是相互存在的，我们在looper的内部构造函数中可以看到，在Looper创建的时候就会创建配套的MessageQueue。</p><pre><code class="language-kotlin">private Looper(boolean quitAllowed) {    mQueue = new MessageQueue(quitAllowed);    mThread = Thread.currentThread();}</code></pre><p>也就是说在一个线程里面，创建了Looper就相当于创建好了两个通信组件，Looper和MessageQueue是相互绑定的。</p><p>那么Looper是如何和Handler来产生关联的呢？</p><p>很简单就在Handler的构造函数啊，可别忘了我们是传入了一个Looper进去的。</p><pre><code class="language-kotlin">val handler = object : Handler(Looper.getMainLooper())</code></pre><p>那么在looper里面是如何调用我传入的处理函数呢？详细解答请看：stackoverflow上一个大佬的解释：<a href="https://stackoverflow.com/questions/14030534/how-the-looper-knows-to-send-the-message-to-handler">连接</a>。</p><p>这里不再做过多解释。最后放一张图来帮助你理解：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/26/b0df7efa37bcc9bf.png" alt="Servic-1"></p><p>当然更具体的详解可以看：</p><p><a href="https://blog.csdn.net/qq_39431405/article/details/113716185">同步异步消息详解</a>。</p><p><a href="https://stackoverflow.com/questions/38818642/android-what-is-message-queue-native-poll-once-in-android">为什么looper一直循环却不占满cpu？</a></p><h3><span id="asynctask">AsyncTask</span></h3><p>AsyncTask是另一种多线程工具， 借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单的从子线程切换到主线程。当然Async背后也是上述异步消息处理机制构成的，只是Android提供了更好的封装组成了的AsyncTask。</p><p>首先我们来看一下用法：</p><p>AsyncTask是个抽象类，如果我们想使用它，就必须创建一个子类去继承他，在继承的时候，可以为其指定三个泛型参数，这三个参数的用途如下：</p><p>Params  在执行AsyncTask时候需要传入的参数，可用于后台任务中使用。</p><p>Progress 在后台任务执行的时候，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为单位。</p><p>Result 当任务执行完毕以后，如果需要对结果进行返回，则这里指定的泛型作为返回值类型。</p><pre><code class="language-kotlin">inner class Download: AsyncTask&lt;Unit, Int, Boolean&gt;() {}</code></pre><p>我们在这里将Params设置为Unit代表线程是不需要参数的设置为Unit。至于这样设置效果是什么请看下边的方法，同时还存在四个需要重写的方法：</p><ul><li>onPreExecute()</li></ul><p>​这个方法会在后台任务开始之前调用，用于进行一些界面上的初始化操作，比如显示一下进度条对话框等。</p><ul><li>doInBackground(Params )</li></ul><p>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有耗时的任务。任务一旦完成，就可以通过return语句将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Unit，就可以不返回任务执行结果.注意此方法中是不可以进行UI操作的，因为此时实际上是在另一个线程并不是在主线程。如果需要反馈任务进度，可以调用publishProgress来实现。</p><ul><li>onProgressUpdate(Progress)</li></ul><p>当后台任务调用了 pulishProgress（Progress）方法以后，onProgressUpdate方法就很快会被调用，该方法中携带的参数是在后台任务传递过来的。在这个方法中可以针对UI进行操作，利用参数中的数值，可以对界面元素进行更新。</p><ul><li>onPostExecute(Result)</li></ul><p>当后台任务之执行完毕并通过return语句进行返回的时候，这个方法很快就会被调用，返回的数据会作为参数传递到此方法当中。可以利用返回的数据进行一些UI操作，比如提醒任务执行的结果，以及关闭进度条等。</p><pre><code class="language-kotlin">inner class Download: AsyncTask&lt;Unit, Int, Boolean&gt;() {     override fun onPreExecute() {         super.onPreExecute()         binding.progressBar.visibility=View.VISIBLE     }     override fun onPostExecute(result: Boolean?) {         super.onPostExecute(result)         if(result == true) {             binding.progressBar.setProgress(100,true)             binding.textView.text="Jszszzy"         }     }    override fun doInBackground(vararg params: Unit?): Boolean {        Log.d("doInBackground","This is background")        publishProgress(10)        return true    }    override fun onProgressUpdate(vararg values: Int?) {         super.onProgressUpdate(*values)        values[0]?.let { binding.progressBar.setProgress(it,true) }        Toast.makeText(baseContext,"Downloading",Toast.LENGTH_SHORT).show()     } }</code></pre><p>我们将第二参数设置为Int，这样调用publishProgress()的时候，切换到主线程，并且给主线程的方法传入一个参数为Int,这样我们就可以获得具体的参数，并且在主线程中更新U。</p><p>可惜的是，目前AsyncTask API 在Android10 已经被弃用，目前推荐的是使用协程来实现相同的操作，这个我们在Kotlin专栏里面再去讨论，接下来直接进入Service。</p><h3><span id="android-的service">Android 的Service</span></h3><p>创建一个Service，我们在项目的顶层包下右键，new-&gt;Service-&gt;Service。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/26/169026e4d4df6fea.png" alt="service"></p><p>创建一个以后我们再来重写几个方法：</p><pre><code class="language-kotlin">class PlayerService : Service() {    override fun onBind(intent: Intent): IBinder {    }    override fun onCreate() {        super.onCreate()    }    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {        return super.onStartCommand(intent, flags, startId)    }    override fun onDestroy() {        super.onDestroy()    }}</code></pre><p>其中：</p><p>onCreate方法在Service创建的时候调用。</p><p>onStartCommand方法在每次Service启动的时候调用。</p><p>onDestory方法会在Service销毁的调用。</p><p>关于具体的生命周期和调用我们留到生命周期部分再来详细说。</p><p>实际上在我们通过Service向导创建以后，AS在Manifest文件中帮我们声明好了对应的Service，所有的Service都需要在Manifest文件中声明以后才能使用。实际上Android的四大组件都需要在Manifest文件中来声明。</p><pre><code class="language-xml">&lt;service    android:name=".PlayerService"    android:enabled="true"    android:exported="true"&gt;&lt;/service&gt;</code></pre><h4><span id="与activity紧密结合">与Activity紧密结合</span></h4><p>虽然Service是在Activity中启动的，但是启动了之后好像与Activty并没有什么太大关系了，但是如果我们想让Service和Act有一点交流呢？比如传递个参数什么的，比如我们有些时候需要在Act中去控制Service的一些方法，让他去进行一些任务的操作，这就需要我们刚刚专门没有说的onBind()方法了。</p><p>修改Service类，创建一个Binder对象，用来向Act提供内部的方法。</p><pre><code class="language-kotlin">inner class PlayerBinder:Binder() {     fun initPlayer(){         initMediaPlayer()     } }</code></pre><p>在类里面创建成员：</p><pre><code class="language-kotlin">private val mBinder = PlayerBinder()</code></pre><p>同时在onBind方法中返回对象，在Act绑定的时候会带调用这个方法，并将绑定对象返回给Act中的绑定方法。</p><pre><code class="language-kotlin">override fun onBind(intent: Intent?): IBinder {    return mBinder}</code></pre><h5><span id="如何在act中绑定service">如何在Act中绑定Service？</span></h5><p>首先创建一个与Service连接的类，这里我们使用对象表达式，连同对应的对象一起创建了：</p><pre><code class="language-kotlin">private  val connection = object : ServiceConnection{        override fun onServiceConnected(name: ComponentName?, service: IBinder) {        playerBinder = service as PlayerService.PlayerBinder        Log.e("jszszzy",playerBinder.toString())        playerBinder.initPlayer()    }        override fun onServiceDisconnected(name: ComponentName?) {    }}</code></pre><p>创建ServiceConnection的实体对象需要实现其中的量抽象方法：</p><p>onServiceConnected是在Act与Service建立连接完成的时候回调的，传入的参数包含binder对象，实际上就是通过刚才创建的binder类构造的，在创建的时候会调用Service的onBind方法来返回一个binder对象。</p><p>我们当然可以在这个方法中获取到对应的绑定对象，通过绑定对象就可以在下文代码中使用Binder对象中的方法。</p><p>比如在这里我们使用了一个初始化播放器的方法，就是直接调用binder对象中的的方法。当然你也可以直接在Act中创建一类成员（<code>lateinit var binding : ActivityMainBinding</code>），让他直接获取到binder中的方法，这样你就可以在Act中的任意位置获取到binder对象，并调用他其中的方法。</p><pre><code class="language-kotlin">class MainActivity : BaseActivity() {    lateinit var binding : ActivityMainBinding    lateinit var playerBinder: PlayerService.PlayerBinder    private  val connection = object : ServiceConnection{        override fun onServiceConnected(name: ComponentName?, service: IBinder) {            playerBinder = service as PlayerService.PlayerBinder            Log.e("jszszzy",playerBinder.toString())            playerBinder.initPlayer()        }        override fun onServiceDisconnected(name: ComponentName?) {        }    }}</code></pre><p>你可能注意到了里面其实还有一个onServiceDisconnected方法，它只有在Service创建进程崩溃或者被杀掉的时候才会调用，这个方法不太常用，所以空着不写。</p><p>当然到这里还没有进行绑定呢，绑定的方式也很简单，我们来举个例子：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {     val intent = Intent(this, PlayerService::class.java)     bindService(intent, connection, Context.BIND_AUTO_CREATE)}</code></pre><p>我们直接在onCreate回调中执行绑定的代码，先构造要绑定的Service意图，这和前边的intent差不多，这里就不再赘述，再通过context的<code>bindService</code>方法，传入<code>intent</code>，和刚才构造的<code>ServiceConnection</code>对象，还有一个标志位<code>Context.BIND_AUTO_CREATE</code>，其代表的意思是，在Act和Service绑定的时候自动创建一个Service对象，<strong>其实就是调用OnCreate方法，但是这个过程中，onStartCommand()方法并不会执行。</strong></p><p>解除绑定的方法也很简单，使用unbindService方法即可解除绑定，同<strong>时Service也会执行onDestroy方法来销毁Service。</strong></p><p>我们为界面一个名为stop按钮添加一个解绑的回调函数：</p><pre><code class="language-kotlin">binding.stop.setOnClickListener {    playerBinder.stopPlayer()    unbindService(connection)}</code></pre><h3><span id="注意">注意</span></h3><p>Service这个功能是一个极其特殊的功能功能，他在绑定的时候部分代码过程并不是在主线程完成的，虽然我们知道Service只是一个长久运行的模块，他不创建进程，也不创建线程，他需要运行的时候是直接在主线程中运行的，但是初始化的时候是通过Android AMS来帮助创建的，这就会导致一个问题，即我在某个阶段直接去调用它的初始化函数可能导致，变量没有被正确赋值，因为在其他AMS还没有执行到对应的赋值代码。举个例子：</p><p>如果我们绑定调用完就立马执行binder里面的方法就会报错：</p><p>我们不再在OnCreate方法里面绑定我们在一个按钮的会带函数里面绑定并且调用绑定的方法：</p><pre><code class="language-kotlin">binding.play.setOnClickListener {    val intent = Intent(this, PlayerService::class.java)    bindService(intent, connection, Context.BIND_AUTO_CREATE)    playerBinder.startPlayer()}</code></pre><p>我们点击按钮就会产生报错：</p><pre><code class="language-powershell">E/AndroidRuntime: FATAL EXCEPTION: main    Process: com.example.audiotest, PID: 709    kotlin.UninitializedPropertyAccessException: lateinit property playerBinder has not been initialized        at com.example.audiotest.MainActivity.getPlayerBinder(MainActivity.kt:17)        at com.example.audiotest.MainActivity.onCreate$lambda-0(MainActivity.kt:49)        at com.example.audiotest.MainActivity.$r8$lambda$NLfemTBvJsTkHif14Uhm1FqFVaI(Unknown Source:0)        at com.example.audiotest.MainActivity$$ExternalSyntheticLambda1.onClick(Unknown Source:2)        at android.view.View.performClick(View.java:7603)        at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1119)        at android.view.View.performClickInternal(View.java:7577)        at android.view.View.access$3800(View.java:865)        at android.view.View$PerformClick.run(View.java:29375)        at android.os.Handler.handleCallback(Handler.java:955)        at android.os.Handler.dispatchMessage(Handler.java:102)        at android.os.Looper.loopOnce(Looper.java:206)        at android.os.Looper.loop(Looper.java:296)        at android.app.ActivityThread.main(ActivityThread.java:8899)        at java.lang.reflect.Method.invoke(Native Method)        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:569)        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:976)</code></pre><p>实际上就是我们的binder对象没有初始化完成，就在主线程里调用了binder的方法。所以绑定和调用需要分开在两个不同的阶段，以保证绑定的时候binder对象被正确的赋值。</p><h4><span id="service生命周期">Service生命周期</span></h4><p>我们在每一个回调函数里面加入Log来提示对应的生命周期，具体的代码如下：</p><pre><code class="language-kotlin">class PlayerService : Service() {    override fun onBind(intent: Intent?): IBinder? {        TODO("Not yet implemented")    }    override fun onCreate() {        super.onCreate()        Log.d("Service","This is onCreate Service")    }    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {        Log.d("Service","This is onStartCommand Service")        return super.onStartCommand(intent, flags, startId)    }    override fun onDestroy() {        Log.d("Service","This is onDestroy Service")        super.onDestroy()    }}</code></pre><p>我们在主函数中向一个button中添加按钮事件，按下按钮的时候开启Service,在另一个按钮按下的时候关闭Service。</p><p>当我们按下开启的按钮的时候，对应回调执行如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/26/c0a3d0922b8d7fde.png" alt="service-1"></p><p>当我们按下结束的时候：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/26/9f10bc948c9cc030.png" alt="service-2"></p><p>下面来说一下，onCreate，onStartCommand存在什么区别，onStartCommand在每次Service启动的时候都会去调用这个方法，而onCreate方法只有在第一次Service被调用创建的时候才会使用，Service启动了之后，会一直保持启动状态，直到stopService或者stopSelf方法被调用的时候Service才会停止。</p><p>这都是很常规的情况，如果一个Service被startService()和bindService()同时调用，那么在这种情况下就需要调用stopService和unbindService方法，这样OnDestory才会执行。</p><p>代码留档：</p><pre><code class="language-kotlin">package com.example.audiotestimport android.content.Intentimport android.media.MediaPlayerimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.os.Handlerimport android.os.Looperimport android.os.Messageimport com.example.audiotest.databinding.ActivityMainBindingimport kotlin.concurrent.threadclass MainActivity : AppCompatActivity() {    lateinit var binding : ActivityMainBinding    private val mediaPlayer = MediaPlayer()    val SongisPause = 1    val handler = object : Handler(Looper.getMainLooper()) {        override fun handleMessage(msg: Message) {            super.handleMessage(msg)            when (msg.what){                SongisPause -&gt; binding.textView.text ="Song is Pause"            }        }    }    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding= ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        initMediaPlayer()        binding.play.setOnClickListener {            val intent = Intent(this,PlayerService::class.java)            startService(intent)            if (!mediaPlayer.isPlaying)            {                mediaPlayer.start()            }        }        binding.stop.setOnClickListener {            thread {                if (mediaPlayer.isPlaying){                    val intent = Intent(this,PlayerService::class.java)                    stopService(intent)                    val msg = Message()                    msg.what = SongisPause                    handler.sendMessage(msg)                    mediaPlayer.reset()                    initMediaPlayer()                }            }        }        binding.pause.setOnClickListener {            if (mediaPlayer.isPlaying)                mediaPlayer.pause()        }    }    private fun initMediaPlayer()    {        val assetManager = assets        val fd = assetManager.openFd("music.mp3")        mediaPlayer.setDataSource(fd.fileDescriptor,fd.startOffset,fd.length)        mediaPlayer.prepare()    }    override fun onDestroy() {        super.onDestroy()        mediaPlayer.stop()        mediaPlayer.release()    }}</code></pre>]]></content>
    
    
    <summary type="html">入门Service</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Android_Service" scheme="http://neonexusx.github.io/tags/Android-Service/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（从入门ACT到Fragment放肆2）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BB%8E%E5%85%A5%E9%97%A8ACT%E5%88%B0Fragment%E6%94%BE%E8%82%86%EF%BC%89/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BB%8E%E5%85%A5%E9%97%A8ACT%E5%88%B0Fragment%E6%94%BE%E8%82%86%EF%BC%89/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.575Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门从入门act到fragment放肆2">Android开发笔记——快速入门（从入门ACT到Fragment放肆2）</span></h1><img src="https://s2.loli.net/2024/10/04/jlUq1gXsIM6Wt8G.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727981351201" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#fragment%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E5%9B%9E%E8%B0%83">Fragment的状态和回调</a><ul><li><a href="#fragment%E7%9A%84%E7%8A%B6%E6%80%81">Fragment的状态</a><ul><li><a href="#1-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81">1、运行状态</a></li><li><a href="#2-%E6%9A%82%E5%81%9C%E7%8A%B6%E6%80%81">2、暂停状态</a></li><li><a href="#3-%E5%81%9C%E6%AD%A2%E7%8A%B6%E6%80%81">3、停止状态</a></li><li><a href="#4-%E9%94%80%E6%AF%81%E7%8A%B6%E6%80%81">4、销毁状态</a></li></ul></li><li><a href="#fragment%E7%9A%84%E5%9B%9E%E8%B0%83">Fragment的回调</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><h2><span id="fragment的状态和回调">Fragment的状态和回调</span></h2><h3><span id="fragment的状态">Fragment的状态</span></h3><p>类似于Activity的生命周期，Fragment的生命周期也可能会经历几种状态，只不过在一些细小的地方会有部分区别。</p><h4><span id="1-运行状态">1、运行状态</span></h4><p>当一个Fragment所关联的Activity正处于运行状态的时，该Fragment也处于运行状态。</p><h4><span id="2-暂停状态">2、暂停状态</span></h4><p>当一个Activity进入暂停状态时候（由于另一个未占满屏幕的Activity被添加到了栈底）。与他关联的Fragment就会进入暂停状态。</p><h4><span id="3-停止状态">3、停止状态</span></h4><p>在这个状态下Fragment本身是不可见的，这个状态可以由FragmentTransaction的remove() 、replace()方法将Fragment从Activity中移除。但在事务提交前调用了addToBackStack()方法他也会进入停止状态。</p><h4><span id="4-销毁状态">4、销毁状态</span></h4><p>Fragment总是依附于Activity存在，因此当此Activity被销毁时，与它关联的Fragment就会进入销毁状态，或这个状态可以由FragmentTransaction的remove() 、replace()方法将Fragment从Activity中移除。但在事务提交前<strong>没有</strong>调用addToBackStack()方法他也会进入停止状态</p><p>这里放一张官方的图，看起来可能很难理解，不过没事，我们实验一下就会有很深的印象：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/6303547cce78e01a.png" alt="1"></p><h3><span id="fragment的回调">Fragment的回调</span></h3><p>我们可以通过新建一个基础类来方便我们观察Fragment的回调周期。</p><p>基础类实现如下：</p><pre><code class="language-kotlin">open class BasicFragment: Fragment() {     val TAG = javaClass.name.toString();    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(TAG,"This is onCreate")    }    override fun onAttach(context: Context) {        super.onAttach(context)        Log.d(TAG,"This is onAttach Attach  Activity is ${context.toString()}")    }    override fun onResume() {        super.onResume()        Log.d(TAG,"This is onResume")    }    override fun onPause() {        super.onPause()        Log.d(TAG,"This is onPause")    }    override fun onStop() {        super.onStop()        Log.d(TAG,"This is onStop")    }    override fun onDestroyView() {        super.onDestroyView()        Log.d(TAG,"This is onDestroyView")    }    override fun onDestroy() {        super.onDestroy()        Log.d(TAG,"This is onDestroy")    }    override fun onDetach() {        super.onDetach()        Log.d(TAG,"This is onDetach")    }}</code></pre><p>直接选择让他继承Fragment类，再让Fragment继承这个类即可。需要注意的是因为onCreateView方法需要返回对应的View这里需要到对应的Fragment中编写。</p><p>本次使用的Fragment是上一篇文章中的LeftFragment，就是单纯的一个Fragment没有什么特殊的通过继承BasicFragment来实现生命周期的输出，代码如下：</p><pre><code class="language-kotlin">class Left_fragment : BasicFragment() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)    }    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View? {        //onCreateView输出对应的内容         Log.d(TAG,"This is onCreateView")         return layoutInflater.inflate(R.layout.left_fragment,container,false)            }}</code></pre><p>我们启动看一看有什么结果：</p><p>可以看到绑定完成后直接调用到onCreate和onCreateView方法，随着onStart和onResume方法的调用Fragment也被显示出来。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/bbae2e7c9a12b8c5.png" alt="2"></p><p>显示结果：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/86b2e78bb782594c.png" alt="5"></p><p>当我i们按下返回键退出的时候，会调用：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/13746867e9521d7d.png" alt="3"></p><p>这时候在主界面已经不可见。</p><p>当我们尝试在后台切换回来的时候,又重新调用了</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/506ecff72f9c9f3c.png" alt="4"></p><p>下面我们再来考虑一种情况，就<strong>是当一个Fragment被另一个Fragment覆盖的时候</strong>，Fragment的回调都会调用什么？</p><p>我们在Activity中创建一个FrameLayout布局作为容器轮流将多个Fragment放入进去，当第二个Fragment显示的时候，会将第一个Fragment、完全覆盖。</p><p>如何实现将Fragment替换呢？我们先创建一个方法用来实现替换：</p><p>思路很简单，就是通过Activity的<code>supportFragmentManager</code>来对Activity中的Fragment进行管理，其中的<code>transaction</code>就是可以用来创建一个事务的，通过创建事务实现针对Fragment的操作，具体代码如下：</p><pre><code class="language-kotlin">private  fun replaceFragment( fragment: Fragment){    val fragmentManager = supportFragmentManager    val transaction = fragmentManager.beginTransaction()        transaction.replace(R.id.Framelayout_another,fragment)    transaction.addToBackStack(null)    transaction.commit()}</code></pre><p>replace方法传入两个参数一个是容器的ID用来找到容器，另一个是要加载的Fragment。</p><p>可以看到在替换之后我们将其装入了返回栈，具体有什么效果接着看。</p><p>在Activity中我们为左边按键绑定了一个回调函数，用来触发更换Fragmenmt，具体代码如下：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?){    super.onCreate(savedInstanceState)    binding = ActivityMainBinding.inflate(layoutInflater)    setContentView(binding.root)    val left_fragment: View =findViewById(R.id.leftFragment)    leftbinding =LeftFragmentBinding.bind(left_fragment)    //绑定替换函数：    leftbinding.button.setOnClickListener     {        replaceFragment(Another_Fragment())    }    replaceFragment( Right_fragment())}</code></pre><p>​    先将<code>Framelayout</code>填充一个<code>Right_fragment</code>最后使用button来替换新的<code>Another_Fragment</code>，<code>Another_Fragment</code>的布局和类完全和、<code>Right_fragment</code>代码相同，只是背景颜色不一样。</p><p>打开APP效果如下：</p><p>因为我开起了夜间模式，所以所有APP的背景颜色会随着背景进行修改将白色替换成黑色。</p><p>可以看到左边是我们的<code>Left_fragment</code>右边是我们的<code>Framelayout</code>承载的<code>Right_fragment</code>。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/119146dbcb55e739.png" alt="7"></p><p>这时候<code>Right_fragment</code>的回调函数进行如下：和上文的一个Fragment启动过程完全一致。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/eb5b1745c78c9ba0.png" alt="6"></p><p>我们点击button触发替换函数，此时他被覆盖结果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/ec74e43eee959791.png" alt="9"></p><p>这时候<code>Right_fragment</code>的回调函数进行如下：</p><p>和上文Fragment和Act一同退至后台不显示的时候不太一样，这里追加调用了一个<code>DestroyView</code>用于销毁对应的View对象。因为这个view实际上不会再显示了，注意这里将Fragment添加到了返回栈里面。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/4430bde6cf485ed3.png" alt="image-20220621182351631"></p><p>我们用返回键出栈查看结果：</p><p>按下返回键，果然返回到了初始界面：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/fe59410af2dfb4de.png" alt="11"></p><p>他的回调过程进行如下：</p><p>可以看到再调用<code>onCreateView</code>方法重新创建了view来进行显示。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/1d6f733ba2ed88d8.png" alt="10"></p><p>实际上目前栈顶是最早的<code>RightFragment</code>对象我们甚至可以将栈清空看一看有什么效果：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/ac4ceb4d36438de8.png" alt="12"></p><p>回调函数执行如下：</p><p>也就是说在执行完全退栈的时候会调用<code>onDestory</code>和<code>onDetach</code>方法。最终实现Fragment的销毁。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/945584c8a55166fb.png" alt="13"></p><p>如果我们不使用返回栈来保存呢？</p><p>当我们再次返回到<code>Right_fragment</code>会怎么样呢？</p><p>我们尝试一下：</p><p>结果很明显，我们点击替换按钮以后Fragment直接就执行销毁了，我们替换后再去执行返回就会直接退出程序，返回到主界面。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/1a910c017f6bee88.png" alt="14"></p><p>最后再放一次目前实验后得到的生命周期图：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/232788410f6601cf.png" alt="15"></p><p>总的归结来说，只存在两种情况和一种特殊情况：</p><ul><li><strong>用户点击返回键</strong>和<strong>fragment没有被添加到返回栈而被替换移除</strong>算是同一种 <strong>当前的Fragment</strong>都会从左边的路径。</li><li><strong>而添加了返回栈被替换移除</strong> <strong>当前的Fragment</strong> 都会从右边的路径上去。</li><li>特殊情况就是点击了返回键直接返回到了主界面效果如上图所示。</li></ul>]]></content>
    
    
    <summary type="html">从入门ACT到Fragment放肆2</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Fragment" scheme="http://neonexusx.github.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（优雅的开发Activity）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Activity2%EF%BC%89%20/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Activity2%EF%BC%89%20/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.575Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门优雅的开发activity">Android开发笔记——快速入门（优雅的开发Activity）</span></h1><img src="https://s2.loli.net/2024/09/29/fDGVwPp6OMtaZ5E.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727616671844" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h2><span id="软件环境">软件环境：</span></h2><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p>[TOC]</p><!-- toc --><ul><li><a href="#%E4%BD%BF%E7%94%A8android%E6%89%8B%E6%9C%BA%E5%9C%A8as%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91">使用Android手机在AS直接进行开发</a></li><li><a href="#activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F">Activity的启动模式</a><ul><li><a href="#standard">standard</a></li><li><a href="#sigletop">sigleTop</a></li><li><a href="#sigletask">sigleTask</a></li><li><a href="#singleinstance">singleInstance</a></li></ul></li><li><a href="#%E5%85%85%E5%88%86%E7%AE%A1%E7%90%86%E5%92%8C%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84act">充分管理和了解你的ACT</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E7%9F%A5%E6%99%93%E5%BD%93%E5%89%8Dact%E7%9A%84%E5%90%8D%E5%AD%97">如何知晓当前ACT的名字？</a></li><li><a href="#%E9%9A%8F%E6%97%B6%E9%80%80%E5%87%BA%E7%A8%8B%E5%BA%8F">随时退出程序</a></li><li><a href="#%E5%90%AF%E5%8A%A8act%E7%9A%84%E6%9C%80%E4%BD%B3%E5%86%99%E6%B3%95">启动ACT的最佳写法</a></li></ul></li><li><a href="#activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Activity的生命周期</a><ul><li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D">基本匹配</a></li><li><a href="#%E9%99%90%E5%AE%9A%E7%AC%A6">限定符</a></li><li><a href="#%E9%92%88%E5%AF%B9%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6">针对多个字符的运算符</a></li><li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a></li><li><a href="#%E8%BD%AC%E7%A0%81%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">转码特殊字符</a></li></ul></li></ul></li><li><a href="#%E9%94%9A%E7%82%B9">锚点</a><br>- <a href="#%E5%8F%B7">^号</a><br>- <a href="#%E5%8F%B7"><code>$</code> 号</a><ul><li><a href="#%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86">简写字符集</a></li><li><a href="#%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%83%B0%E6%80%A7%E5%8C%B9%E9%85%8D-greedy-vs-lazy-matching">贪婪匹配与惰性匹配 (Greedy vs lazy matching)</a></li></ul></li></ul><!-- tocstop --><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><h2><span id="使用android手机在as直接进行开发">使用Android手机在AS直接进行开发</span></h2><p>参考过的文章链接：</p><p><a href="https://baijiahao.baidu.com/s?id=1717480652313244278&amp;wfr=spider&amp;for=pc">如何在Android12开启开发者模式</a></p><p><a href="https://blog.csdn.net/qq_42851946/article/details/121332064">荣耀 打开USB调试 Android开发</a></p><p>首先安装google的驱动：打开SDK管理器：</p><p><img src="https://s2.loli.net/2024/09/29/LXJgQSdiZCvPOIE.png" alt="23"></p><p>找到：Google USB Driver下载：</p><p><img src="https://s2.loli.net/2024/09/29/XnRos5Embja3Qpx.png" alt="1"></p><p>然后开启设备管理器：</p><p><img src="https://s2.loli.net/2024/09/29/Rq27KFcE9xPmjnN.png" alt="24"></p><p>为设备安装驱动：</p><p><img src="https://s2.loli.net/2024/09/29/L4JXsKcUrfyxtj1.png" alt="25"></p><p>在本地找到刚下载的驱动，路径如下，需要参考你的具体路径：</p><p><img src="https://s2.loli.net/2024/09/29/92UsVMwN8GjelEf.png" alt="26"></p><p>等待安装完成</p><p><img src="https://s2.loli.net/2024/09/29/rNuAqF7DBMtvEle.png" alt="3"></p><p>打开开发者模式：</p><p>连续点击<strong>内部版本号</strong>：直到提示打开开发者模式：</p><img src="https://s2.loli.net/2024/09/29/47nQZH5fvT9qArx.jpg" alt="16" style="zoom:50%;"><p>打开如下选项就可以看到开发者选项：</p><p><img src="https://s2.loli.net/2024/09/29/Gpe6YnmbuTHX7Aw.png" alt="17"></p><p>打开开发者选项：</p><p><img src="https://s2.loli.net/2024/09/29/pcLrnjf6GV4Sbmu.png" alt="19"></p><p><img src="https://s2.loli.net/2024/09/29/wS89kgBdJ5aVNLW.png" alt="18"></p><p>往下拉找到USB配置选项：</p><p><img src="https://s2.loli.net/2024/09/29/24C8vLnRpSPlZac.png" alt="20"></p><p>如果不是RNDIS选择改成RNDIS,不知道为什么即使开启<strong>仅充电模式下开启ADB</strong>调试选项，也不无法在仅充电模式下调试，所以手动开启RNDIS稳妥一点。</p><p><strong>如果选择此模式还是没有反应，就在其它模式和本模式切换一下</strong>。</p><p><img src="https://s2.loli.net/2024/09/29/ZJEDhVyHjOTcqtu.png" alt="21"></p><p>可以看到AS中出现了设备：</p><p><img src="https://s2.loli.net/2024/09/29/Mors4Tiq6fHkpdP.png" alt="22"></p><h2><span id="activity的启动模式">Activity的启动模式</span></h2><p>Android的Activity的启动模式一共有四种。</p><p><strong>standard、sigleTop、sigleTask、singleInstace</strong>。</p><h3><span id="standard">standard</span></h3><p>standard模式是Activity的默认启动模式，在不显式指定的情况下，所有Activity都会使用这种模式。</p><p>举个例子：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    //此处注意    Log.d("FirstActivity","Task id is $taskId")   val  binding = ActivityFirstBinding.inflate(layoutInflater)    setContentView(binding.root)    binding.button1.setOnClickListener()    {        val intent = Intent(this,FirstActivity::class.java)        startActivity(intent)    }}</code></pre><p>我们给一个Act设定一个操作当点击按钮的时候再次创建一个一摸一样的Act出来。</p><p><img src="https://s2.loli.net/2024/09/29/4KpASe7gfj5a89t.png" alt="4"></p><p>实际上两个ACT的实例句柄并不相同，也就是说ACT中有两个相同的ACT实例。</p><p>具体实现模式如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/XU9teNOwGMDQsnF.png" alt="11"></p><h3><span id="sigletop">sigleTop</span></h3><p>对于标准启动模式你会觉得奇怪，明明我的ACT已经在栈顶了为什么还要启动一个重复的呢？</p><p>在sigleTop模式下就能解决你这个疑问，在本模式下，当ACT的启动模式指定为sigleTop，再启动之前就会查询栈顶元素，如果发现返回栈顶已经是该ACT，则认为可以直接使用它，不会在创建新的实例。</p><p>我们这里使用一个ACT来测试，在第一个ACT中在来创建一个相同ACT，看是否会创建。</p><p><img src="https://s2.loli.net/2024/09/29/AP3oEg7iwv2krSM.png" alt="6"></p><p>果然点击多次并没有新的ACT产生。</p><p>模式图如下：</p><p><img src="https://s2.loli.net/2024/09/29/PkvMnN92j3CDZrY.png" alt="12"></p><h3><span id="sigletask">sigleTask</span></h3><p>在SigleTop模式下你会有一个疑问，如果有两个ACT相互调用怎么办呢？如果我们使用sigleTop模式，在第二个ACT2中调用第一个ACT（此时栈顶是ACT2）仍会导致创建一个和第一个ACT相同的ACT导致资源的浪费，sigleTask就是能完美解决重复创建栈顶ACT的问题。</p><p>每次启动ACT的时候就会检查ACT是否存在该ACT的实例，如果发现已经存在则直接使用这个ACT，并将本ACT之上的所有ACT统统出栈，如果发现没有则创建一个新的ACT实例在栈顶。</p><p>我们这里创建两种测试，首先创建两个ACT，一个ACT中调用第二个ACT，在第二个ACT中调用第一个ACT，此时应该会把第一个ACT重新唤醒。</p><p><img src="https://s2.loli.net/2024/09/29/1PRjmeLucSxDndt.png" alt="7"></p><p>可以看到ACT1被重新唤醒了。</p><p>模式图如下：</p><p><img src="https://s2.loli.net/2024/09/29/P9hYJliIbgjoqSX.png" alt="14"></p><h3><span id="singleinstance">singleInstance</span></h3><p>不同于以上三种模式，singleInstance模式会启用一个新的返回栈来管理新的ACT，那么这样做有什么意义呢？</p><p>假设我们的程序中有一个ACT是允许其他程序调用的，如果想实现其他程序和我们的程序可以共享找个ACT的实例，应该如何实现呢？</p><p>前三种方式肯定是不正确的，因为他们都是在自己的返回栈的基础上进行操作，每一个应用程序都有自己的返回栈，同一个ACT在不同的返回栈中入栈的时候都必然创建新的实例。而在本模式下，不管是哪个应用程序来访问这个ACT，都会共用一个返回栈，就解决了ACT实例的问题。</p><p>我们这里使用三个ACT来实现操作：</p><p>将第一个第三个设置为stander启动模式，再将第二个设置成singleInstance启动模式。</p><p>我们让第一个调用第二个ACT，第二个调用第三个ACT.</p><p>可以通过输出的信息看到：</p><p><img src="https://s2.loli.net/2024/09/29/YnSj1cxkMK9HfGA.png" alt="9"></p><p>我们先启动了第一个ACT他的返回栈ID是106，在启动了第二个ACT他的返回栈ID是107，最后启动了第三个ACT他的返回栈是106和第一个返回栈id相同，因为他们三个都是standard模式。</p><p>我们在第三个ACT按下返回键，最后我们看到在提示信息里面有ACT1的restart方法的调用，我们在第三个ACT返回却直接返回的是ACT1，这里很好理解因为ACT1和ACT3在同一个返回栈里面。</p><p>singleInstance的返回模式图如下：</p><p><img src="https://s2.loli.net/2024/09/29/9MWjTyOgXfYKaqF.png" alt="13"></p><h2><span id="充分管理和了解你的act">充分管理和了解你的ACT</span></h2><p>在阅读之一部分前请先阅读：<a href="https://www.zhihu.com/question/24304289/answer/38218810">关于JAVA的反射与Class</a>。</p><h3><span id="如何知晓当前act的名字">如何知晓当前ACT的名字？</span></h3><p>创建一个<code>BaseActivity类</code>，注意是Kotlin的类，并不是创建一个ACT，让他继承<code>AppCompatActivity类</code>，并重写<code>onCreate方法</code>：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    Log.d("BaseActivity",javaClass.simpleName)}</code></pre><p>使用Log来输出当前的类名，值得注意的是，这里使用的是类似于java的反射机制，你可以注意到当前的类就是<code>BaseActivity</code>为什么还要通过<code>javaClass.simpleName</code>来输出类名呢？</p><p>实际上并不是这样的，我们先看一个结果：</p><p>运行一个FirstActivity以后：</p><p><img src="https://s2.loli.net/2024/09/29/ApDtHvN2JnKYQh3.png" alt="image-20220504101007423"></p><p>在Koltin中javaclass表示获取当前实例的Class对象，相当于在Java中调用getClass方法。</p><p>具体什么是Class类和对象请参考上文链接，简单的来说就是JVM中用来管理每个类的一个专门的管理类，通过这个类可以获取具体的信息包括对应类的存储位置，类的方法，类名等。</p><p>我们在重写父类的onCreate方法同时调用了父类的<code>super.onCreate(savedInstanceState)</code>方法，这样就相当于在本类中使用了<code>Log.d("BaseActivity",javaClass.simpleName)</code>方法，通过class来获取当前的实例名。</p><p>只要我们让<code>BaseActivity</code>成为所有ACT的父类就能输出类的信息。</p><p>当然你也可以这样写：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    Log.d("BaseActivity",this.toString())}</code></pre><p>这样输出内容在创建相同实例的时候更准确：</p><p><img src="https://s2.loli.net/2024/09/29/VUTAtxGlkSifBPw.png" alt="10"></p><h3><span id="随时退出程序">随时退出程序</span></h3><p>如果你目前栈内已经有了三个ACT，而现在你想检测退出程序对应ACT阶段回调函数的运行效果怎么样，总不能连续按下三次返回按键吧，那如果有很多的ACT，就连续按下多次？当然不现实了。</p><p>解决思路很简单，这里创建一个专门的类针对所有类进行管理。</p><p>先看个例子，创建了一个<code>ActitvityCollector</code>类：</p><pre><code class="language-kotlin">object ActitvityCollector{    private val activities = ArrayList&lt;Activity&gt;()    fun addActivity(activity: Activity)    {        activities.add(activity)    }    fun removeActivity(activity: Activity)    {        activities.remove(activity)    }    fun finishALL()    {        for (activity in activities)        {            if(!activity.isFinishing)            {                activity.finish()            }        }        activities.clear()    }}</code></pre><p>这里ActitvityCollector是一个单例类，因为全局实际上只需要一个ActitvityCollector来管理所有ACT就可以了。</p><p>我们创建了一个ArrayList来存放当前所有Activity，又声明了三个方法：</p><ul><li><code>addActivity</code> 用于向集合添加现有的ACT。</li><li><code>removeActivity</code> 用于移除某个ACT</li><li><code>finishALL</code> 用于将所有ACT销毁，销毁的时候需要注意当前ACT是否正在被销毁。</li></ul><p>接下来我们使用这个三个方法来管理自己的ACT</p><p>首先我们要配合<code>BaseActivity</code>来管理，首先是<code>addActivity</code>我们不需要自己手动每次调用的时候都添加这到集合中，我们配合BaseActivity的<code>onCreate</code>就可以在创建的时候自动调用了，修改后的<code>onCreate</code>如下：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    Log.d("BaseActivity",javaClass.simpleName)    ActitvityCollector.addActivity(this)}</code></pre><p>接下来修改BaseActivity的<code>onDestroy</code>方法，让他在退出或者销毁的的时候直接把自己从队列里面移除。</p><pre><code class="language-kotlin">override fun onDestroy() {    super.onDestroy()    ActitvityCollector.removeActivity(this)}</code></pre><p>实现一键退出也很简单，我们在任何需要退出的地方调用：</p><pre><code class="language-kotlin">ActitvityCollector.finishALL()</code></pre><h3><span id="启动act的最佳写法">启动ACT的最佳写法</span></h3><p>在一个ACT中启动到另一个ACT的方法很简单，首先通过intent来构造<strong>意图</strong>，指明需要启动的ACT：</p><pre><code class="language-kotlin">val intent = Intent(this,SecondActivity::class.java)</code></pre><p>其中this为上下文对象，<code>SecondActivity::class.java</code>也是获取对应类的Class对象，为启动传输class参数。</p><p>然后通过<code>startActivity(intent)</code>或者<code>startActivityForResult()</code>将ACT启动起来，如果有数据可以使用Intent来传输，这里就不再赘述。</p><p>但是如果在另一个ACT需要启动这个ACT我们该如何传输参数呢？这时候就得跑去阅读代码了或者去问写这个ACT的人，但实际上我们应该把每一个ACT的启动都规整化把它封装一下，这样和别人一起协作的时候你写完的ACT很容易就能让别人利用起来。</p><p>在这里我们利用了companion object来实现因为这样方便在调用的时候不需要自己创建一个对象再去调用它的方法，我们本着高内聚低耦合的想法，就把启动方法声明在伴生对象里面。</p><pre><code class="language-kotlin">companion object {    fun actionStart(context: Context, data1: String, data2: String) {        val intent = Intent(context, SecondActivity::class.java).apply {            putExtra("param1", data1)            putExtra("param2", data2)        }        context.startActivity(intent)    }}</code></pre><p>我们通过这个方法把上下文传递进来然后传入要传递的参数最后构造intent实现数据传递和ACT启动。</p><h2><span id="activity的生命周期">Activity的生命周期</span></h2><p>《第一行代码》虽然是新的但其中关于Act的生命周期的部分已经发生了很大的改变，我推荐还是具体实验来真正手动去实践一下，实践才是检验真理的唯一标准。</p><p>我们在原来BasicActivity的基础上来进行修改，在每个回调之中输出对应的回调函数：</p><pre><code class="language-kotlin">open class BaseActivity : AppCompatActivity() {    val tag :String = javaClass.simpleName    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(tag,"onCreate")        ActitvityCollector.addActivity(this)    }    override fun onDestroy() {        Log.d(tag,"onDestroy")        super.onDestroy()        ActitvityCollector.removeActivity(this)    }    override fun onStart() {        super.onStart()        Log.d(tag, "onStart")    }    override fun onResume() {        super.onResume()        Log.d(tag, "onResume")    }    override fun onPause() {        super.onPause()        Log.d(tag, "onPause")    }    override fun onStop() {        super.onStop()        Log.d(tag, "onStop")    }    override fun onRestart() {        super.onRestart()        Log.d(tag, "onRestart")    }}</code></pre><p>输出的方式很简答，我们通过Log来输出tag是一个成员获取当前类的实例名称，为了让获取Log的结果更加准确，我们要使用正则表达式来过滤掉不必要的信息。所以插入学习一下正则表达式来看看具体结果。</p><h3><span id="正则表达式">正则表达式</span></h3><p>在开始之前我们先来学习一下什么是正则表达式，这个在以后调试的时候非常有用。</p><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p><p>在线测试网站：<a href="https://regexr.com/%E3%80%82">https://regexr.com/。</a></p><p>教程地址：<a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">Regex</a></p><h4><span id="基本匹配">基本匹配</span></h4><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。 例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p><p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p><h4><span id="限定符">限定符</span></h4><ul><li><strong>runoo+b</strong>，可以匹配 <strong>runoob、runooob、runoooooob</strong> 等，<strong>+</strong> 号代表前面的一个字符必须至少出现一次（1次或多次）。</li><li><strong>colou?r</strong> 可以匹配 <strong>color</strong> 或者 <strong>colour</strong>，<strong>?</strong> 问号代表前面的字符最多只可以出现一次（0次或1次），简单来说？代表的就是前一个字符是可有可无的。这里的例子就是u是可有可无的。</li><li><strong>runo*b</strong>，可以匹配 <strong>rund</strong>、<strong>runob、runoob、runoooooob</strong> 等，***** 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</li><li><strong>ab{2,}c</strong>，表示字符b至少需要出现两次，本质上是**+**的增强版。<strong>ab{2,6}c</strong> 表示b出现次数区间在【2.6】大于6的也不能算匹配。</li></ul><p>以上字符都只能作用于一个字符，这是需要注意的。</p><h4><span id="针对多个字符的运算符">针对多个字符的运算符</span></h4><p><strong>（ab)+</strong>,是()和+的结合，这里将ab看为一个整体来做+运算。</p><h4><span id="逻辑运算符">逻辑运算符</span></h4><p><strong>a(cat|dog)</strong>，表示匹配到a的情况下，后边是cat或者dog都是可以的。</p><p>需要注意的是，这里如果这样写：<strong>acat|dog</strong> 匹配结果就变成了：<strong>acat</strong>或者<strong>dog</strong></p><p>如果输入是acatdog,则匹配结果包含两个匹配项。</p><p><img src="https://s2.loli.net/2024/09/29/SmxuADRf6Z8X5HJ.png" alt="12"></p><h4><span id="字符集">字符集</span></h4><p><strong>[ ]</strong>,代表的是字符集，[abc]表示我们要匹配的是含有字符abc的单词，是abc中任意一个字母哦。</p><p>特殊用法：</p><p>[a-z]表示含有任意一个小写字母即可。</p><p>[a-z0-9]表示含有小写字母和数字即可。</p><p>[^ 0-9]表示所有不含有数字的单词，包含换行符。</p><h4><span id="转码特殊字符">转码特殊字符</span></h4><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p><p>举个例子：</p><p><code>(com\.)</code>匹配效果：</p><p><img src="https://s2.loli.net/2024/09/29/eYJruWMF12y7qHO.png" alt="11"></p><h2><span id="锚点">锚点</span></h2><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p><h5><span id="号">^号</span></h5><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p><p><code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串</p><p>匹配结果：</p><p><img src="https://s2.loli.net/2024/09/29/wFtMEofDlqU8pmW.png" alt="13"></p><p><strong>注意这里是这个字符串的开头，不是单词的开头。</strong></p><p>在上边基础类得基础上，我们为每一个周期的回调函数添加一个状态输出代码如下：</p><h5><span id="号"><code>$</code> 号</span></h5><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p><p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p><p><img src="https://s2.loli.net/2024/09/29/ug62VsdMfGbXZDI.png" alt="14"></p><h3><span id="简写字符集">简写字符集</span></h3><table><thead><tr><th>.</th><th>除换行符外的所有字符</th></tr></thead><tbody><tr><td>\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td>\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td>\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td>\s</td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p{Z}]</code></td></tr><tr><td>\S</td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符</td></tr><tr><td>\p</td><td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><h3><span id="贪婪匹配与惰性匹配-greedy-vs-lazy-matching">贪婪匹配与惰性匹配 (Greedy vs lazy matching)</span></h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><p>贪婪匹配，指的是每次匹配都选择匹配最多的内容：</p><p><img src="https://s2.loli.net/2024/09/29/hf1XMRBEyPUw8cj.png" alt="15"></p><p>如果需要在第一个地方就筛选出来（尽量短的匹配），就要配合？来实现：</p><p><img src="https://s2.loli.net/2024/09/29/Od8MelFQc3bZDon.png" alt="16"></p><p>学会了以后我们看看在AS中如何使用正则表达式来进行调试信息的输出：</p><p>选择下拉栏的Logcat模块：</p><p><img src="https://s2.loli.net/2024/09/29/RmrhSsLvABxTX8H.png" alt="18"></p><p>选择自定义效果：</p><p><img src="https://s2.loli.net/2024/09/29/yGfPcQYErJdsIeV.png" alt="19"></p><p>在Tag中定义自己需要的Tag：</p><p><img src="https://s2.loli.net/2024/09/29/Qxns8yGIacq7z5A.png" alt="17"></p><p>这样就可以自定义看到想要看到的结果啦。</p><p>这里我让他显示了FirtAct和SecondAct的所有信息。</p><p>我们在FirstAct中调用SecondAct然后在一步一步通过返回按键返回到主界面（退出程序）。</p><p>开启程序主Act完成：</p><p>界面如下：</p><p><img src="https://s2.loli.net/2024/09/29/adZutNsRQcbqwf4.png" alt="22"></p><p>此时Log中的输出为：</p><p><img src="https://s2.loli.net/2024/09/29/V9fYIqNGaBbv4Ud.png" alt="20"></p><p>点击button打开第二个界面：</p><p><img src="https://s2.loli.net/2024/09/29/ZDbP8Oujm3MV6l1.png" alt="21"></p><p>此时输出为：</p><p><img src="https://s2.loli.net/2024/09/29/1ceQqrZHlKOuENy.png" alt="24"></p><p>可以看到FirstAct实际上在SecondAct完全就绪的时候才会调用onStop方法。</p><p>我们使用返回键返回到第一个Act，结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/WXaLnYKo7wvizVE.png" alt="25"></p><p>这时候在SecondAct返回时先调用了onPause方法，直到完全被覆盖才调用onStop和onDestory。</p><p>我们再次按下返回键这时候就要返回到主界面了，结果会是什么呢？</p><p><img src="https://s2.loli.net/2024/09/29/buTEKCoqjAt5fxH.png" alt="26"></p><p>在返回主界面以后会有会连续调用<strong>onPause</strong>和<strong>onStop</strong>，但是没有调用<strong>onDestory</strong>！</p><p>这是和原来完全不一样的，也就是说，退出程序并不会去调用<strong>onDestory。</strong></p><p>还有一个细节就是，onPause是在退出前调用的，onStop是在被完全销毁退出后调用的。</p><p>最后放一张完全的图流程图：</p><p><img src="https://s2.loli.net/2024/09/29/T4BpjRCSZYP8A7O.png" alt="27"></p><p>总结Act的生命周期只有三点需要详细记忆。</p><ul><li><strong>前台生命周期：指的是在onResume到onPause之间的过程，在这个过程之间Act是正在运行的，可以交互和操作。</strong></li><li><strong>可见生命周期：指的是onStrart到onStop方法之间的过程，在onStop之前都是可见的，在不可见之后会执行onStop()。</strong></li><li><strong>OnDestory方法：他的情况在新版之后有些特殊，只有在返回栈退栈的时候才会调用方法，退出程序也不会执行。</strong></li></ul>]]></content>
    
    
    <summary type="html">优雅的开发Activity</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    <category term="Activity" scheme="http://neonexusx.github.io/categories/Android/Activity/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Activity" scheme="http://neonexusx.github.io/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（从入门SQLlite到Room放肆）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BB%8E%E5%85%A5%E9%97%A8SQLlite%E5%88%B0Room%E6%94%BE%E8%82%86%EF%BC%89/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BB%8E%E5%85%A5%E9%97%A8SQLlite%E5%88%B0Room%E6%94%BE%E8%82%86%EF%BC%89/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-03-12T09:45:34.575Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门从入门sqllite到room放肆">Android开发笔记——快速入门（从入门SQLlite到Room放肆）</span></h1><img src="https://s2.loli.net/2024/10/04/TI4CoLbPNzysXFH.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727981633751" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#android%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85">Android的数据持久</a></li><li><a href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8">文件存储</a><ul><li><a href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%88%B0%E6%96%87%E4%BB%B6%E5%BD%93%E4%B8%AD">将数据存储到文件当中</a></li><li><a href="#java%E6%B5%81%E5%9B%9E%E9%A1%BE">Java流回顾</a><ul><li><a href="#java%E7%9A%84%E5%AD%97%E8%8A%82%E6%B5%81">Java的字节流</a></li></ul><ul><li><a href="#android%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8">Android的文件存储</a><ul><li><a href="#%E6%9E%84%E9%80%A0%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E7%9A%84%E6%96%B9%E5%BC%8F">构造文件打开的方式</a></li><li><a href="#%E6%9E%84%E9%80%A0%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E6%B5%81">构造缓冲输入流</a></li></ul></li></ul></li><li><a href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE">从文件中读取数据</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><h2><span id="android的数据持久">Android的数据持久</span></h2><p>Android的数据持久化技术有三种，文件存储、SharedPreferences、数据库存储。</p><p>下面先来一 一介绍一下。</p><h2><span id="文件存储">文件存储</span></h2><p>文件存储是最基本的存储方式，他不对存储的内容进行任何格式化处理，所有数据都是原封不动的保存在文件当中的，因此他非常适合<strong>存储一些简单的文本数据或者二进制数据</strong>。</p><p>如果想你想通过文件存储的方式来保存一些较为复杂的结构化数据，就需要定义一套属于自己的格式规范。</p><h3><span id="将数据存储到文件当中">将数据存储到文件当中</span></h3><p>Context类当中提供了一个<code>openFileOutput()</code>方法，可以用于将指定数据存储到指定的文件中。</p><p>这个方法接收两个参数：第一个参数是文件名，在文件创建的时候使用，注意这里的第一个参数是文件名，在文件创建的时候使用，此文件名不包含路径，因此所有的文件都默认存储到/data/data/&lt; package name &gt;/files/目录下；第二个参数是文件的操作模式，主要有 ：</p><ul><li>MODE_PRIVATE:当输入的文件名相同的时候，所写的内容会覆盖原文件的内容。</li><li>MODE_APPEND:若该文件已存在，就往里面追加内容，若不存在就创建新文件。</li></ul><p><code>openFileOutput()</code>方法返回的是一个<code>FileOutputStream</code>对象，通过这个对象就可以使用Java流的方式写入文件中了。</p><h3><span id="java流回顾">Java流回顾</span></h3><p>流比喻数据的均匀连续性。流这个比喻的本质就是为了让某个对象可以均匀持续地吐出无间隔的数据，或者你可以向这个对象毫无压力地持续不断塞进数据。</p><p>我们在这里叙述的流主要是I/O流中的节点流，指的是可以从特定的io设备中读写数据的流。他只能连接数据源进行数据的读写操作。</p><p>举个例子：</p><h5><span id="java的字节流">Java的字节流</span></h5><p>在计算机当中，无论是文本还是图片或者是音频，都是以二进制，字节的形式存在的，IO流针对这种</p><p>形式提供了一系列的流，统称为字节流。</p><p>所有的字节流<strong>输入</strong>都继承于Inputstream。所有的字节流<strong>输出</strong>都继承于Outputstream。由于这两个类都是抽象的所以它没办法实例化。</p><p>这里就介绍一种来举例：FileInputStream，它可以通过字节流来实现对数据的读入。</p><p>结果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/c5800227c341e509.png" alt="1"></p><p>需要注意的是路径斜杠与反斜杠都是可以的。</p><h4><span id="android的文件存储">Android的文件存储</span></h4><p>首先来讲解存储的实现，存储的步骤分为三步，分别是构造打开文件的方式、构造缓冲输出流，关闭文件。</p><h5><span id="构造文件打开的方式">构造文件打开的方式</span></h5><p>上文提到过存在两种打开方式：</p><ul><li>MODE_PRIVATE:当输入的文件名相同的时候，所写的内容会覆盖原文件的内容。</li><li>MODE_APPEND:若该文件已存在，就往里面追加内容，若不存在就创建新文件。</li></ul><p>因为本次是在没有创建文件的前提下，所以优先使用<strong>MODE_APPEND</strong>。</p><p>使用API <code> val output = openFileOutput("data",Context.MODE_PRIVATE)</code></p><p>其中 openFileOutput返回两个参数：</p><p>分别是：文件的名字，文件的打开模式。</p><pre><code class="language-kotlin">public FileOutputStream openFileOutput(String name, int mode)</code></pre><p>最终返回一个FileOutputStream对象，实际上就是一个java的字节流对象。你可能会疑问我的文件创建在哪里呢？实际上这里的默认路径在app路径下单独创建一个File文件夹来存储没有指定路径的内容。</p><h5><span id="构造缓冲输入流">构造缓冲输入流</span></h5><p>这个和Java几乎一模一样，都是先构造输出流然后通过输出流构造成包含缓冲区的输出流，代码如下：</p><pre><code class="language-kotlin">val write = BufferedWriter(OutputStreamWriter(output))</code></pre><p>OutputStreamWriter()输入一个构造好的<code>FileOutputStream</code>对象用来将节流输出转化成字符流输出，方便直接写入字符。如果你对字符流还不太清楚，你会想为什么我不能用字节流来存储呢？可看到上文Java从一个UTF-8编码的文件中读取出来的其实是整数，并不是对应的字符。字符流可以参考一下以下文章：</p><p><a href="https://www.zhihu.com/question/39262026">字节流体系分析</a>。这里就不再赘述。</p><p>最后我们使用构造好的write，来写入对应的字符。</p><p>我们在这里可以使用kotlin的扩展函数函数来操作，kotlin提供了一个扩展函数方便我们对流进行操作，</p><pre><code class="language-kotlin">write.use {    it.write(inputText)}</code></pre><p>直接使用构造好的对象来调用use，他会在内部lambda表达式完成的时候自动调用close来关闭流，十分方便。最后完整的代码如下,我们将其封装成一个完整的函数来调用：</p><pre><code class="language-kotlin">fun save (inputText :String){    try {        val output = openFileOutput("data",Context.MODE_PRIVATE)        val write = BufferedWriter(OutputStreamWriter(output))        write.use {            it.write(inputText)        }    }catch (e:IOException)    {        e.printStackTrace()    }}</code></pre><p>结合我在Activity那篇文章的生命周期的分析，其实在Act的生命周期中onStop是保存数据的最佳时刻，此时是这个Act不可见后的操作，不影响第二个Act的展现。</p><p>所以我们在此法中保存对应的数据。</p><p>代码如下：</p><pre><code class="language-kotlin">override fun onStop() {    super.onStop()    save(binding.datasave.text.toString())}</code></pre><p>实现效果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/bf294551e954d75b.png" alt="29"></p><p>我们按下返回键，退出程序到主界面，我们从文件浏览器中观察到存储的数据如下：</p><p>浏览器中的路径：</p><p>data/data/com.example.dataset/files/data</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/922107f6d4854483.png" alt="28"></p><h3><span id="从文件中读取数据">从文件中读取数据</span></h3><p>从文件中读取数据几乎和写入数据没有什么太大区别，只是读入的时候我，我们可以使用kotlin系统内置的函数来读取对应的内容，具体代码如下：</p><pre><code class="language-kotlin">fun load():String?{    val content = StringBuilder();    try {        val input = openFileInput("data")        val reader= BufferedReader(InputStreamReader(input))        reader.use {            reader.forEachLine {                Log.e(javaClass.simpleName.toString(),reader.toString())                content.append(it)            }        }    }catch (e : IOException)    {        e.printStackTrace()    }    return content.toString();}</code></pre><p>可以看到使用方法也很简单，我们使用openFileInput、InputStreamReader来分别构造对象然后使用BufferedReader最终实现一个带缓冲区的读入流。</p><p>openFileInput是通过context返回的一个读入流（FileInputStream），后边就是字节流转换为字符流等一系列常规操作，没有什么好说，我需要特别说明的是，<code>forEachLine</code>这个系统的扩展函数，这个函数非常有意思，大多数博主的使用都多多少少存在一些问题，比如本文上边的这种写法，下面就来说一说为什么这种写法是错误的，我们跳转到<code>forEachLine</code>函数的实现，来看一看：</p><pre><code class="language-kotlin">/** * Iterates through each line of this reader, calls [action] for each line read * and closes the [Reader] when it's completed. * * @param action function to process file lines. */public fun Reader.forEachLine(action: (String) -&gt; Unit): Unit = useLines { it.forEach(action) }</code></pre><p>可以看到上边的注释，实际上这个函数的操作就是遍历文档的每一行，并将操作映射到每一行上。</p><p>函数的参数很有意思，使用的lambda表达式作为参数，这个lambda表达式名字叫<code>action</code>接收一个String类型的参数没有返回值，然后它使用了<code>useLines</code>，<code>forEach</code>函数来配合这个lambda来处理这个函数，我们再看看<code>forEach</code>的实现：</p><pre><code class="language-kotlin">/** * Performs the given [action] on each element. * * The operation is _terminal_. */public inline fun &lt;T&gt; Sequence&lt;T&gt;.forEach(action: (T) -&gt; Unit): Unit {    for (element in this) action(element)}</code></pre><p>他的实现也很简单，就是传入一个λ表达式并将调用他的对象中的内容都遍历一遍。那么是谁来调用它呢？</p><p><code>useLines { it.forEach(action) }</code>这个就是调用他的东西，这个it是什么呢？</p><p>当Lambda的参数只有一个的时候就可以用it来调用对象，我们来看一下实现：</p><pre><code class="language-kotlin">/** * Calls the [block] callback giving it a sequence of all the lines in this file and closes the reader once * the processing is complete. * @return the value returned by [block]. */@RequireKotlin("1.2", versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = "Requires newer compiler version to be inlined correctly.")public inline fun &lt;T&gt; Reader.useLines(block: (Sequence&lt;String&gt;) -&gt; T): T =    buffered().use { block(it.lineSequence()) }</code></pre><p>实际上就是将上边的<code>forEach</code>迭代<code>传入的lambda表达式</code>作为一个<code>迭代lambda表达</code>式传入到<code>useLines</code>的参数中，最后调用<code>lineSequence</code>方法，这个方法的实现很长，简答来说就是将文档中的每一行加入到一个Sequence里面然后使用<code>迭代lambda表达</code>将每一行处理，这是它的功能的实现，那为什么说大家都用错了?</p><p>注意看实际上还有两个函数：</p><p><code>buffered(),use()</code>,use是老朋友了，这里就不再详细说明了，你到这里会意识到个问题，我在这里用了use了，为什么外层还要用呢？</p><p>所以对于外层来说，正确的用法是：</p><pre><code class="language-kotlin">fun load():String?{    val content = StringBuilder();    try {        val input = openFileInput("data")        val reader= BufferedReader(InputStreamReader(input))            reader.forEachLine {                content.append(it)        }    }catch (e : IOException)    {        e.printStackTrace()    }    return content.toString();}</code></pre><p>你会感到不安，我怎么知道这个流是否关闭了呢？关于如何监测流的关闭，我们晚点再说，继续说</p><p><code>buffered()</code>函数，这个函数的实现也很简单：</p><pre><code class="language-kotlin">Returns a buffered reader wrapping this Reader, or this Reader itself if it is already buffered.@kotlin.internal.InlineOnlypublic inline fun Reader.buffered(bufferSize: Int = DEFAULT_BUFFER_SIZE): BufferedReader =    if (this is BufferedReader) this else BufferedReader(this, bufferSize)</code></pre><p>注释写的很清楚，这个函数就是用来检测是否是缓冲流的，不是的话自动给你加上包装，所以在外层我们根本不需要手动去构造缓冲流，修改后代码如下：</p><pre><code class="language-kotlin">fun load():String?{    val content = StringBuilder();    try {        val input = openFileInput("data")        val reader= InputStreamReader(input)            reader.forEachLine {                content.append(it)        }    }catch (e : IOException)    {        e.printStackTrace()    }    return content.toString();}</code></pre><p>这才是正确的使用方法。</p><p>接下来讨论如何检测流是否关闭的问题，方法也很简单，我们构造一个内部类来实现检测，这类继承于</p><p><code>InputStreamReader</code>，每次关闭的时候肯定要调用 close()方法，我们的思路就是，每次调用这个方法的时候使用Log输出一下表示流关闭了，这样就能直观的看到流关闭。</p><pre><code class="language-kotlin">inner class AddTestStream( input:FileInputStream):InputStreamReader(input){    override fun close() {        Log.d(javaClass.simpleName.toString(),"File is closed load succeed")        super.close()    }}</code></pre><p>最后使用上文的内部类替代一下，load函数结果如下：</p><pre><code class="language-kotlin">fun load():String?{    val content = StringBuilder();    try {        val input = openFileInput("data")        val reader= AddTestStream(input)            reader.forEachLine {                content.append(it)        }    }catch (e : IOException)    {        e.printStackTrace()    }    return content.toString();}</code></pre><p>我们打开软件，可以看到在onCreate执行后加载文件内容，并加载完毕后调用了close关闭了流。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/a2a2a8f9e513deb0.png" alt="1-1"></p>]]></content>
    
    
    <summary type="html">从入门SQLlite到Room放肆</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="SQLlite" scheme="http://neonexusx.github.io/tags/SQLlite/"/>
    
    <category term="Room" scheme="http://neonexusx.github.io/tags/Room/"/>
    
  </entry>
  
</feed>
