<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://neonexusx.github.io/atom.xml" rel="self"/>
  
  <link href="http://neonexusx.github.io/"/>
  <updated>2026-01-04T08:56:53.568Z</updated>
  <id>http://neonexusx.github.io/</id>
  
  <author>
    <name>NeoNexus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>From JavaScript to TypeScript</title>
    <link href="http://neonexusx.github.io/2025/12/30/From%20JavaScript%20to%20TypeScript(1)/"/>
    <id>http://neonexusx.github.io/2025/12/30/From%20JavaScript%20to%20TypeScript(1)/</id>
    <published>2025-12-29T16:00:00.000Z</published>
    <updated>2026-01-04T08:56:53.568Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="from-javascript-to-typescript1javascript-basic-concepts">From JavaScript to TypeScript（1）JavaScript Basic Concepts</span></h1><img src="https://s2.loli.net/2026/01/03/cqXdwvMNp81GlDK.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1767455676375" style="zoom:67%;"><img src="https://s2.loli.net/2025/12/30/ybuUSFvcs5MhCiE.jpg" alt="nodejs" style="zoom: 67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><!-- toc --><ul><li><a href="#javascript-%E7%9A%84%E5%8E%86%E5%8F%B2">JavaScript 的历史</a></li><li><a href="#javascript-%E4%B8%8E-ecmascript-%E7%9A%84%E5%85%B3%E7%B3%BB">JavaScript 与 ECMAScript 的关系</a></li><li><a href="#javascript-%E7%9A%84%E7%89%B9%E7%82%B9">JavaScript 的特点</a><ul><li><a href="#%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">解释型脚本语言</a></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a></li><li><a href="#%E5%BC%B1%E7%B1%BB%E5%9E%8B">弱类型</a></li><li><a href="#%E5%8A%A8%E6%80%81%E6%80%A7">动态性</a></li><li><a href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台</a></li></ul></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-dom-%E5%92%8C-bom">什么是 DOM 和 BOM</a></li><li><a href="#nodejs-%E6%98%AF%E4%BB%80%E4%B9%88">Node.js 是什么？</a></li><li><a href="#nodejs-%E5%92%8C-v8-%E7%AE%80%E4%BB%8B">Node.js 和 V8 简介</a></li></ul><!-- tocstop --><h2><span id="javascript-的历史">JavaScript 的历史</span></h2><p>JavaScript 最初被称为 LiveScript，由 Netscape（Netscape Communications Corporation，网景通信公司）公司的布兰登·艾奇（Brendan Eich）在 1995 年开发。在 Netscape 与 Sun（一家互联网公司，全称为“Sun Microsystems”，现已被甲骨文公司收购）合作之后将其更名为了 JavaScript。</p><p>之所以将 LiveScript 更名为 JavaScript，是因为 JavaScript 是受 Java 的启发而设计的，因此在语法上它们有很多相似之处，JavaScript 中的许多命名规范也都借鉴自 Java；另一个原因就是为了营销，蹭 Java 的热度。</p><p>同一时期，微软和 Nombas（一家名为 Nombas 的公司）也分别开发了 JScript 和 ScriptEase 两种脚本语言，与 JavaScript 形成了三足鼎立之势。它们之间没有统一的标准，不能互用。为了解决这一问题，1997 年，在 ECMA（欧洲计算机制造商协会，European Computer Manufacturers Association）的协调下，Netscape、Sun、微软、Borland（一家软件公司）组成了工作组，并以 JavaScript 为基础制定了 <a href="https://www.ecma-international.org/publications-and-standards/standards/">ECMA-262 标准</a>（ECMAScript）。</p><h2><span id="javascript-与-ecmascript-的关系">JavaScript 与 ECMAScript 的关系</span></h2><p>ECMAScript（简称“ES”）是根据 ECMA-262 标准实现的通用脚本语言。ECMA-262 标准主要规定了这门语言的语法、类型、语句、关键字、保留字、运算符、对象等部分。ECMAScript 采用按年份发布的版本命名方式，例如 ECMAScript 2024（简称“ES2024”）。</p><p>ES6（也称 ES2015，早期代号 ES Harmony）是 JavaScript 发展史上最重要的版本之一。该版本包含了大量关键增强特性，例如类、模块、迭代器、生成器、箭头函数、Promise（期约）、Reflect、Proxy 等。</p><p>至于 JavaScript，有时人们会将 JavaScript 与 ECMAScript 看作是相同的，其实不然，JavaScript 中所包含的内容远比 ECMA-262 中规定的多得多，完整的 JavaScript 是由以下三个部分组成：</p><ul><li>核心（ECMAScript）：提供语言的语法和基本对象；</li><li>文档对象模型（DOM）：提供处理网页内容的方法和接口；</li><li>浏览器对象模型（BOM）：提供与浏览器进行交互的方法和接口。</li></ul><h2><span id="javascript-的特点">JavaScript 的特点</span></h2><p>JavaScript 具有以下特点：</p><ul><li><h4><span id="解释型脚本语言">解释型脚本语言</span></h4><p>JavaScript 通常不需要像 C、<a href="http://c.biancheng.net/cplus/">C++</a> 这类语言那样先进行显式编译再运行；在常见宿主环境中，JavaScript 引擎会负责解析并执行代码（通常也会进行 JIT 编译）。</p></li><li><h4><span id="面向对象">面向对象</span></h4><p>JavaScript 是一种面向对象语言，使用 JavaScript 不仅可以创建对象，也能操作使用已有的对象。</p></li><li><h4><span id="弱类型">弱类型</span></h4><p>JavaScript 是一种弱类型的编程语言，对使用的数据类型没有严格的要求，例如可以将一个变量初始化为任意类型，<strong>也可以随时改变这个变量的类型</strong>。</p></li><li><h4><span id="动态性">动态性</span></h4><p>JavaScript 是一种采用事件驱动的脚本语言，它不需要借助 Web 服务器就可以对用户的输入做出响应，例如我们在访问一个网页时，通过鼠标在网页中进行点击或滚动窗口时，通过 JavaScript 可以直接对这些事件做出响应。</p></li><li><h4><span id="跨平台">跨平台</span></h4><p>JavaScript 不依赖特定操作系统，在浏览器中就可以运行。因此一个 JavaScript 脚本在编写完成后可以在任意系统上运行，只需要系统上的浏览器支持 JavaScript 即可。</p></li></ul><h2><span id="什么是-dom-和-bom">什么是 DOM 和 BOM</span></h2><p>DOM 全称是 Document Object Model，也就是文档对象模型。DOM 是 XML（或 HTML）文档在内存中的一种结构化表示和编程接口【API：Application Programming Interface】。</p><p><strong>XML</strong> 是一种<strong>标记语言</strong>，其本身是一个文本文件，用标签来定义数据的结构和含义，它定义了一套通用的语法规则（如必须有根元素、标签成对出现、属性加引号等）。它本身不定义任何具体标签。它是一个“死”的文本字符串。</p><p><strong>DOM</strong> 是一个<strong>编程模型（对象模型）</strong>。当程序（如浏览器、JavaScript、Python 脚本）读取一个 XML 文件时，它会将这个文本文件<strong>解析</strong>成一棵由节点组成的树形结构。这棵树就是 DOM 树。</p><p>DOM 通过创建表示文档的树，让开发者可以随心所欲地控制网页内容。更详细见：<a href="https://www.zhihu.com/question/33453164/answer/56549408">DOM 和 BOM 的区别是什么？</a></p><p>BOM 全称：Browser Object Model，也就是浏览器对象模型。BOM 是一套由浏览器提供的 API，允许 JavaScript 与浏览器窗口（而非网页内容本身）进行交互。它没有像 DOM 那样统一、完整的正式标准（其中部分接口在 HTML 规范中有定义）。</p><pre><code class="language-bash">┌─────────────────────────────────┐│           浏览器 (Browser)       │ ← 运行环境├─────────────────────────────────┤│  BOM (浏览器对象模型)            │ ← JavaScript 访问浏览器的接口│  ┌──────────────────────────┐  ││  │  document (DOM 的入口)   │  │ ← 包含 HTML5 文档│  │  ┌──────────────────┐   │  ││  │  │  HTML5 文档内容  │   │  │ ← 实际网页内容│  │  └──────────────────┘   │  ││  └──────────────────────────┘  │└─────────────────────────────────┘</code></pre><h2><span id="nodejs-是什么">Node.js 是什么？</span></h2><p>Node.js 不是一门新的编程语言，也不是一个 JavaScript 框架，它是一套 JavaScript 运行环境，用来支持 JavaScript 代码的执行。用编程术语来讲，Node.js 是一个 JavaScript 运行时（Runtime）。所谓运行时，就是程序在运行期间需要依赖的一系列组件或者工具；把这些工具和组件打包在一起提供给程序员，程序员就能运行自己编写的代码了。</p><p>对于 JavaScript 来说，它在运行期间需要依赖以下组件：</p><ol><li><p><strong>JavaScript 引擎</strong></p><p>JavaScript 在运行时依赖 <strong>JavaScript 引擎</strong>，引擎内部结合了解释执行和即时编译（JIT），并非传统意义上的“解释器”。</p></li><li><p>标准库</p><p>我们在 JavaScript 代码中会调用一些内置函数，这些函数不是我们自己编写的，而是标准库自带的。JavaScript 运行时包含一套 <strong>语言内建标准库（ECMAScript）</strong>，同时还会由宿主环境额外提供 API。</p></li><li><p><strong>宿主环境提供的 API</strong><br>如浏览器中的 DOM、网络、定时器，或 Node.js 中的文件系统、网络模块。这些能力由底层本地代码实现，但并不属于 JavaScript 语言本身。</p></li></ol><h2><span id="nodejs-和-v8-简介">Node.js 和 V8 简介</span></h2><p>JavaScript 的一生伴随着浏览器大战。JavaScript 由 Netscape（网景）浏览器发布，但是 Netscape 在和 IE 的竞争中落败，早已不复存在；后来谷歌公司的 Chrome 浏览器异军突起，凭借强悍的性能把 IE 按在地上摩擦。</p><p>谷歌公司在 Chrome 浏览器中集成了一种名为“<strong>V8</strong>”的 <strong>JavaScript 引擎</strong>，它能够非常快速地解析和执行 JavaScript 代码。</p><p><strong>V8 引擎使用 C++ 语言编写，可以独立运行，也可以嵌入到任何其它 C++ 程序中。谷歌公司将 V8 引擎甚至整个 Chrome 浏览器都开源了，任何人都可以免费地将 V8 应用到自己的项目中。</strong></p><p>Node.js 是针对 <a href="https://v8.dev/">V8</a> 引擎构建的。通过与此引擎的最新版本保持同步，确保及时向 Node.js 开发人员提供 <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">JavaScript ECMA-262 specification</a> 中的新功能，以及持续的性能和稳定性改进。</p>]]></content>
    
    
    <summary type="html">JavaScript Basic Concepts</summary>
    
    
    
    <category term="javascript" scheme="http://neonexusx.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="http://neonexusx.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>From JavaScript to TypeScript</title>
    <link href="http://neonexusx.github.io/2025/12/30/From%20JavaScript%20to%20TypeScript(2)/"/>
    <id>http://neonexusx.github.io/2025/12/30/From%20JavaScript%20to%20TypeScript(2)/</id>
    <published>2025-12-29T16:00:00.000Z</published>
    <updated>2026-01-04T08:56:44.631Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="from-javascript-to-typescript2basic-variables-and-number-types">From JavaScript to TypeScript（2）Basic Variables and Number Types</span></h1><img src="https://s2.loli.net/2026/01/03/h8HzEIaA6xZ3UjT.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1767453491323" style="zoom: 67%;"><img src="https://s2.loli.net/2025/12/30/ybuUSFvcs5MhCiE.jpg" alt="nodejs" style="zoom: 67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><!-- toc --><ul><li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a></li><li><a href="#%E4%BF%9D%E7%95%99%E5%AD%97">保留字</a></li><li><a href="#%E9%A2%84%E5%AE%9A%E4%B9%89">预定义</a></li><li><a href="#%E5%AD%97%E9%9D%A2%E9%87%8Fliteral">字面量（Literal）</a></li><li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89">变量的定义</a><ul><li><a href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">严格模式</a></li><li><a href="#%E5%8F%98%E9%87%8F">变量</a></li></ul></li><li><a href="#%E6%95%B0%E5%80%BC%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B">数值变量类型</a><ul><li><a href="#number%E7%B1%BB%E5%9E%8B">Number类型</a><ul><li><a href="#%E6%95%B0%E5%80%BC%E5%88%86%E9%9A%94%E7%AC%A6">数值分隔符</a></li><li><a href="#%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4">值的范围</a></li><li><a href="#nan">NaN</a></li></ul></li><li><a href="#bigint%E7%B1%BB%E5%9E%8B">BigInt类型</a></li><li><a href="#%E9%9D%9E%E6%95%B0%E5%80%BC%E5%90%91%E7%9A%84%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2">非数值向的数值转换</a><ul><li><a href="#number">Number</a></li><li><a href="#parseint">parseInt</a></li><li><a href="#parsefloat">parseFloat</a></li></ul></li></ul></li></ul><!-- tocstop --><h2><span id="关键字">关键字</span></h2><p>关键字（Keyword）就是 JavaScript 语言内部使用的一组名字（或称为命令）。这些名字具有特定的用途，用户不能自定义同名的标识符，具体内容如表所示。</p><table><thead><tr><th style="text-align:center"><strong>break</strong></th><th style="text-align:center"><strong>delete</strong></th><th style="text-align:center"><strong>if</strong></th><th style="text-align:center"><strong>this</strong></th><th style="text-align:center"><strong>while</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>case</strong></td><td style="text-align:center"><strong>do</strong></td><td style="text-align:center"><strong>in</strong></td><td style="text-align:center"><strong>throw</strong></td><td style="text-align:center"><strong>with</strong></td></tr><tr><td style="text-align:center"><strong>catch</strong></td><td style="text-align:center"><strong>else</strong></td><td style="text-align:center"><strong>instanceof</strong></td><td style="text-align:center"><strong>try</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>continue</strong></td><td style="text-align:center"><strong>finally</strong></td><td style="text-align:center"><strong>new</strong></td><td style="text-align:center"><strong>typeof</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>debugger（ECMAScript 5 新增）</strong></td><td style="text-align:center"><strong>for</strong></td><td style="text-align:center"><strong>return</strong></td><td style="text-align:center"><strong>var</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>default</strong></td><td style="text-align:center"><strong>function</strong></td><td style="text-align:center"><strong>switch</strong></td><td style="text-align:center"><strong>void</strong></td><td style="text-align:center"></td></tr></tbody></table><h2><span id="保留字">保留字</span></h2><p>保留字就是 JavaScript 语言内部预备使用的一组名字（或称为命令）。这些名字目前还没有具体的用途，是为 JavaScript 升级版本预留备用的，建议用户不要使用。具体说明如表所示。</p><table><thead><tr><th>abstract</th><th>double</th><th>goto</th><th>native</th><th>static</th></tr></thead><tbody><tr><td><strong>boolean</strong></td><td><strong>enum</strong></td><td><strong>implements</strong></td><td><strong>package</strong></td><td><strong>super</strong></td></tr><tr><td><strong>byte</strong></td><td><strong>export</strong></td><td><strong>import</strong></td><td><strong>private</strong></td><td><strong>synchronized</strong></td></tr><tr><td><strong>char</strong></td><td><strong>extends</strong></td><td><strong>int</strong></td><td><strong>protected</strong></td><td><strong>throws</strong></td></tr><tr><td><strong>class</strong></td><td><strong>final</strong></td><td><strong>interface</strong></td><td><strong>public</strong></td><td><strong>transient</strong></td></tr><tr><td><strong>const</strong></td><td><strong>float</strong></td><td><strong>long</strong></td><td><strong>short</strong></td><td><strong>volatile</strong></td></tr></tbody></table><p>ECMAScript 3 将 Java 所有关键字都列为保留字，而 ECMAScript 5 规定较为灵活，例如：</p><ul><li>在严格模式下，ES 5 变得更加谨慎，严格限制 implements、interface、let、package、private、protected、public、static、yield、eval（非保留字）、arguments（非保留字）的使用。</li></ul><h2><span id="预定义">预定义</span></h2><p>JavaScript 预定义了很多全局变量和函数，用户也应该避免使用它们，具体说明如表所示。</p><table><thead><tr><th>arguments</th><th>encodeURL</th><th>Infinity</th><th>Number</th><th>RegExp</th></tr></thead><tbody><tr><td><strong>Array</strong></td><td><strong>encodeURLComponent</strong></td><td><strong>isFinite</strong></td><td><strong>Object</strong></td><td><strong>String</strong></td></tr><tr><td><strong>Boolean</strong></td><td><strong>Error</strong></td><td><strong>isNaN</strong></td><td><strong>parseFloat</strong></td><td><strong>SyntaxError</strong></td></tr><tr><td><strong>Date</strong></td><td><strong>eval</strong></td><td><strong>JSON</strong></td><td><strong>parseInt</strong></td><td><strong>TypeError</strong></td></tr><tr><td><strong>decodeURL</strong></td><td><strong>EvalError</strong></td><td><strong>Math</strong></td><td><strong>RangeError</strong></td><td><strong>undefined</strong></td></tr><tr><td><strong>decodeURLComponent</strong></td><td><strong>Function</strong></td><td><strong>NaN</strong></td><td><strong>ReferenceError</strong></td><td><strong>URLError</strong></td></tr></tbody></table><p>无论是在严格模式下还是在非严格模式下，都不要在定义变量名、函数名或者属性名时使用上面列举出的名字。</p><h2><span id="字面量literal">字面量（Literal）</span></h2><p>下面示例分别定义不同类型的直接量：</p><p>字符串、数值、布尔值、正则表达式、特殊值、对象、数组和函数</p><pre><code class="language-javascript">//1 Literal String console.log("Hello, World!");//2 Literal Numberconsole.log(1);//3 Literal Booleanconsole.log(true);//4 Null Literalconsole.log(null);//5 Literal regular expressionconsole.log(/ab+c/);//6 Literal Arrayconsole.log([1, 2, 3]);//7 Literal Dictionary (Object)console.log({name: "John", age: 30});//8 function Literalconsole.log(function() { return "Hello"; });</code></pre><p>输出结果：</p><pre><code class="language-bash">Hello, World!1truenull/ab+c/[ 1, 2, 3 ]{ name: 'John', age: 30 }[Function (anonymous)]</code></pre><p>有趣的是，默认的log支持不同颜色来区分不同的变量：</p><img src="https://s2.loli.net/2025/12/30/xkoeYhnvyCN8gI6.png" alt="image-20251230214518108" style="zoom: 50%;"><h2><span id="变量的定义">变量的定义</span></h2><p>JavaScript 吸收了 Java、C 等语言的语法风格，但也存在一些独特的设定，下面将针对这些设定做出讲解。</p><h3><span id="严格模式">严格模式</span></h3><p>ES5 标准中增加了严格模式（Strict Mode）的概念。在这种模式下，一些不规范或不安全的写法会抛出错误；本质上，它更接近一种“更严格的 JavaScript 语义”。</p><p>如果需要某个脚本使用严格模式，可在脚本开头加入：</p><pre><code class="language-javascript">'use strict';</code></pre><p>任何 JS 引擎看到这个编译指令之后都会切换到严格模式。<strong>比较特殊的是：ES6 的模块和类在默认情况下会自动启用严格模式</strong>。如果想要某个函数在该模式下执行，可以在函数开头添加这个指令：</p><pre><code class="language-javascript">function doSomething(){'use strict';}</code></pre><h3><span id="变量">变量</span></h3><p>在 ECMAScript 的语义下，变量是松散类型的：<strong>变量本质上是一个命名占位符；它保存的是值（或指向值的引用）</strong>。有 3 个关键字可以声明变量：</p><ul><li><strong>var</strong></li><li><strong>let</strong></li><li><strong>const</strong></li></ul><p><code>var</code> 关键字和另外两个关键字一样，后面跟一个变量名即可完成定义：</p><pre><code class="language-javascript">var name;let name;const name;</code></pre><p>三者存在很大的区别，这里就不详细介绍，我们等到下一篇作用域再进行。</p><h2><span id="数值变量类型">数值变量类型</span></h2><p>ES 规定了 7 种原始数据类型（Primitive Types）：</p><ul><li><strong>Undefined</strong></li><li><strong>Null</strong></li><li><strong>Boolean</strong></li><li><strong>Number</strong></li><li><strong>BigInt</strong></li><li><strong>String</strong></li><li><strong>Symbol</strong></li></ul><p>除此之外还有 <strong>Object</strong>（引用类型），它不是原始类型。</p><p>这些类型足以表示各种常见数据。<strong>ECMAScript 的变量名通常采用驼峰命名：第一个单词首字母小写，后续单词首字母大写</strong>。</p><h3><span id="number类型">Number类型</span></h3><p>数值（Number）类型用来表示数值。JavaScript 中不区分整数和小数（浮点数），统一使用 Number 类型表示；其底层采用 IEEE 754 双精度浮点数（Float64）。如下例所示：</p><pre><code class="language-javascript">// Number type variablevar num = 42;console.log(num);//42var floatNum = 3.14;console.log(floatNum);//3.14</code></pre><p>整数当然也支持 2 进制、8 进制、16 进制的字面量：</p><pre><code class="language-javascript">'use strict';//binary type variablevar binNum = 0b1010; // binary for 10console.log(binNum);//octalvar octNum = 0o52; // octal for 42console.log(octNum);//octal (legacy)var octNum2 = 052; // octal for 42 (implicit)console.log(octNum2);//hexadecimal type variablevar hexNum = 0x2A; // hexadecimal for 42console.log(hexNum);</code></pre><p>需要注意的是，在严格模式下不允许使用隐式 8 进制声明，会报错：</p><pre><code class="language-bash">/home/neo/Desktop/Example/JavaScript/example_variable.js:18var octNum2 = 052; // octal for 42 (older syntax)              ^^^SyntaxError: Octal literals are not allowed in strict mode.    at wrapSafe (node:internal/modules/cjs/loader:1378:20)    at Module._compile (node:internal/modules/cjs/loader:1428:41)    at Module._extensions..js (node:internal/modules/cjs/loader:1548:10)    at Module.load (node:internal/modules/cjs/loader:1288:32)    at Module._load (node:internal/modules/cjs/loader:1104:12)    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:174:12)    at node:internal/main/run_main_module:28:49Node.js v20.17.0</code></pre><h4><span id="数值分隔符">数值分隔符</span></h4><p>为了增加可读性，所有数值都可以使用下划线作为数值分隔符，解释器在解释的时候会自动忽略它们，比如：</p><pre><code class="language-javascript">// BigInt type variablevar bigIntNum = 1_000_000_000_000;console.log(bigIntNum); //1000000000000var bigfloatNum = 1_000_000.123_456;console.log(bigfloatNum); //1000000.123456</code></pre><p>需要注意的是，下划线不能出现在字面量的开头或结尾，不能紧挨小数点，前面也不能有 0：</p><pre><code class="language-javascript">var wrongNum1 = 1_000_.123; // Incorrect usage of underscorevar wrongNum2 = 1._000; // Incorrect usage of underscorevar wrongNum3 = 0_123; // Incorrect usage of underscore</code></pre><h4><span id="值的范围">值的范围</span></h4><p>数值的范围取决于 IEEE 754 标准。IEEE 754 浮点数采用二进制科学计数法，结构如下（以 double 为例）：</p><ul><li>1 位符号位（sign）</li><li>11 位指数位（exponent）</li><li>52 位尾数（fraction/mantissa）</li></ul><p>$$<br>(−1) ^{sign}×1.fraction×2^{exponent−1023}<br>$$</p><p>JS 可以表示的<strong>最小的非 0 正数</strong>保存在 <code>Number.MIN_VALUE</code>，相反的<strong>最大值</strong>保存在 <code>Number.MAX_VALUE</code>。如果某次计算的绝对值超过了最大值，结果会变为 <code>Infinity</code> 或 <code>-Infinity</code>（取决于符号）；而当数值过小发生下溢时，结果会趋近于 <code>0</code>（可能变为 <code>0</code>）。如果要判断某个结果是否仍为有限数值，可以使用函数 <code>isFinite</code>；当结果为 <code>Infinity</code> 或 <code>-Infinity</code> 时会返回 <code>false</code>：</p><pre><code class="language-javascript">var minValue = Number.MIN_VALUE;console.log(minValue);//5e-324var maxValue = Number.MAX_VALUE;console.log(maxValue);//1.7976931348623157e+308var infinityValue = Infinity;console.log(infinityValue);//Infinityvar negativeInfinityValue = -Infinity;console.log(negativeInfinityValue);//-Infinity// isFinitevar isFiniteValue = isFinite(100 / 0);console.log(isFiniteValue);//false</code></pre><h4><span id="nan">NaN</span></h4><p>还有一个特殊值 <code>NaN</code>（Not a Number），表示“不是一个可表示的数值结果”。例如对负数求平方根等操作会得到 <code>NaN</code>。需要注意的是，JS 提供的 <code>isNaN</code> 会先做类型转换，因此其行为可能和一些语言的“严格 NaN 判断”不一致：</p><pre><code class="language-javascript">var notANumber = NaN;console.log(notANumber);//NaNisNaNValue = isNaN("123");console.log(isNaNValue);//falseisNaNValue2 = isNaN(123);console.log(isNaNValue2);//falseisNaNValue3 = isNaN(NaN);console.log(isNaNValue3);//trueisNaNValue4 = isNaN("Hello");console.log(isNaNValue4);//true</code></pre><p>字符串 “123” 会先被转换为数字 <code>123</code>，然后再判断。</p><p>简单总结：<code>isNaN(x)</code> 会先尝试把 <code>x</code> 转成数字；如果转换后结果是 <code>NaN</code>，才返回 <code>true</code>。</p><h3><span id="bigint类型">BigInt类型</span></h3><p>BigInt 用于表示任意精度的大整数，超出普通 Number（即 IEEE 754 double）能精确表示的范围。BigInt 并不是把大数“转化”为能放入寄存器的数值，而是通过软件层面将大整数拆分成多个小块（通常每块是 32 位或 64 位），分别存储和运算。CPU 寄存器只能直接处理有限位数（如 32 位或 64 位）的整数。BigInt 的大数运算通常由 JavaScript 引擎用多段算法在内存中实现，分多步用寄存器处理每一小段，最后合成结果。</p><p>它的设计目标之一是支持超过安全整数范围的整数：</p><pre><code class="language-javascript">Number.MAX_SAFE_INTEGER; // 9007199254740991Number.MIN_SAFE_INTEGER; // -9007199254740991</code></pre><p>这个范围的大整数。</p><p>要创建 BigInt 可以使用如下方式：</p><pre><code class="language-javascript">// BigInt testNumber.MAX_SAFE_INTEGER; // 9007199254740991Number.MIN_SAFE_INTEGER; // -9007199254740991var bigIntNum = 111111111111111111n; // BigInt type variableconsole.log(bigIntNum);//111111111111111111nvar bigIntNum2 = BigInt("12345678901234567890");console.log(bigIntNum2);//12345678901234567890nvar bigIntNum3 = BigInt("0xFFFFFFFFF");console.log(bigIntNum3)//68719476735n</code></pre><p>BigInt 支持几乎所有 Number 类型的算术运算，但其本身不支持如下运算符：</p><ul><li><code>&gt;&gt;&gt;</code>右移操作符</li><li>一元<code>+</code>操作符</li></ul><p>BigInt 作为特殊类型与 Number 几乎完全独立，无法进行混合运算，但可以进行比较和排序。</p><pre><code class="language-javascript">123 + 123n // type error</code></pre><p>可以：</p><pre><code class="language-javascript">console.log(123 &lt; 1234n); // true</code></pre><h3><span id="非数值向的数值转换">非数值向的数值转换</span></h3><p>有三个常用函数可以将非数值转换为数值：</p><ul><li><code>Number()</code>：用于将任何数据类型转换为数字</li><li><code>parseInt()</code>：主要用于从字符串中解析整数</li><li><code>parseFloat()</code>：主要用于从字符串中解析浮点数</li></ul><h4><span id="number">Number</span></h4><p><code>Number()</code> 的转换规则相对复杂，包含以下内容：</p><ol><li><p>字符串转 Number</p><ul><li><p>纯数字字符串直接转为数字，如 “123” → 123</p></li><li><p>如果字符串包含有效浮点值、十六进制值、科学计数法值也能转换，如 “3.14” → 3.14，“1e3” → 1000，<strong>字符串前面的 0 和空格都会被省略</strong>。</p><ul><li><pre><code class="language-javascript">console.log(Number(" -123")); // -123console.log(Number("00001.1")); // 1.1</code></pre></li></ul></li><li><p>空字符串 “” 转为 0</p></li><li><p>除此之外，非法数字字符串（如 “abc”）转为 NaN</p><ul><li><pre><code class="language-javascript">console.log(Number("abc1.1")); // NaN</code></pre></li></ul></li></ul></li><li><p>布尔值转 Number</p><ul><li>true → 1</li><li>false → 0</li></ul></li><li><p>null 和 undefined</p><ul><li>null → 0</li><li>undefined → NaN</li></ul></li><li><p>对象转 Number</p><ul><li>先调用对象的 valueOf()，再调用 toString()，最后尝试转换，如 {} → NaN，[1] → 1</li></ul></li><li><p>自动类型转换场景</p><ul><li><p>算术运算符（如 +, -, *, /）会自动尝试将操作数转换为 Number</p></li><li><p>比较运算符（如 &lt;, &gt;, ==）也会尝试转换</p></li></ul></li></ol><p>考虑到 <code>Number()</code> 的转换规则较复杂，在“把字符串转换为整数”的需求上通常使用 <code>parseInt()</code>；而在“把字符串转换为浮点数”的需求上使用 <code>parseFloat()</code>。二者用法相似，其中 <code>parseInt()</code> 的规则如下：</p><h4><span id="parseint">parseInt</span></h4><p><code>parseInt</code> 会从字符串第一个非空白字符开始解析：遇到非数字字符（不含开头的 <code>+</code>/<code>-</code>）就停止，并返回已解析的整数部分；如果第一个有效字符就不是数字（也不是 <code>+</code>/<code>-</code>），<strong>会立即返回 NaN（注意不是 0）</strong>。例如 <code>Number("")</code> 得到 0，但 <code>parseInt("")</code> 得到 NaN。</p><pre><code class="language-javascript">console.log(parseInt("clue1234")); // NaN</code></pre><p><code>parseInt</code> 还有第二个参数用于指定进制（radix）。例如强制按 16 进制解析可以传入 16；另外需要注意，<code>parseInt</code> 不会自动识别 <code>0b</code> 二进制前缀（因此下面例子只解析到开头的 <code>0</code>）：</p><pre><code class="language-javascript">console.log(parseInt("1234blue")); // 1234console.log(parseInt("  0b1010")); // 0console.log(parseInt("0xA", 16)); // 10</code></pre><p>需要注意的是，这三个函数的共同点在于，在 10 进制底数下都会<strong>自动忽略和省略开头多余的 0</strong>。</p><pre><code class="language-javascript">console.log(parseInt("01010")); // 1010</code></pre><h4><span id="parsefloat">parseFloat</span></h4><p>相较于 <code>parseInt</code>，主要有两点：</p><ul><li>首先是没有进制参数，遇到 <code>0x</code> 这类输入通常只会解析到 <code>0</code>。</li><li>其次是只有第一个小数点有效，其余小数点无效。</li></ul><pre><code class="language-javascript">console.log(parseFloat("  -123.45.56abc")); // -123.45</code></pre>]]></content>
    
    
    <summary type="html">Basic Variables and Number Types</summary>
    
    
    
    <category term="javascript" scheme="http://neonexusx.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="http://neonexusx.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Rust 快速入门指北[引用与借用]</title>
    <link href="http://neonexusx.github.io/2025/11/28/Rust%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97[%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8]/"/>
    <id>http://neonexusx.github.io/2025/11/28/Rust%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97[%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8]/</id>
    <published>2025-11-27T16:00:00.000Z</published>
    <updated>2026-01-04T09:09:37.299Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="rust-快速入门指北引用与借用">Rust 快速入门指北[引用与借用]</span></h1><img src="https://s2.loli.net/2026/01/04/kA9wNqIzTfLeQ7s.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1767517753573" style="zoom: 67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><p>由于所有权和作用域的作用，在我们使用函数的时候可能会不方便：对像 <code>String</code> 这类<strong>非 <code>Copy</code></strong> 类型，按值传参会发生 Move，从而导致所有权转移。有办法在<strong>不转移所有权</strong>的前提下还能对数据进行操作和处理吗？Rust 当然可以，接下来我们将通过介绍引用与借用来解释这里面的机制：</p><p>[TOC]</p><h2><span id="引用与可变引用">引用与可变引用</span></h2><p>回到最早的例子：</p><pre><code class="language-rust">fn take_ownership(some_string: String)-&gt; String {    println!("{}", some_string);    some_string}fn main()  {    let s1 = String::from("ownership test");    let mut s2 = s1;    s2 = take_ownership(s2);// 通过递交所有权和收回所有权来实现变量的延续    println!("{s2}, function!");}</code></pre><p>我们可以提供一个 <code>String</code> 值的引用（reference）。<strong>引用</strong>（<em>reference</em>）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用在其生命周期内保证指向某个特定类型的有效值。</p><p>修改例子为：</p><pre><code class="language-rust">fn borrow_string(some_string: &amp;String) {  // 参数为 String 的引用（借用），不需要返回值    // some_string.push_str(", world"); // 暂时不启用    println!("{} function call", some_string);}  // 这里，some_string 离开了作用域。但因为它并不拥有引用值的所有权，所以什么也不会发生fn main() {    let s1 = String::from("ownership test");    let s2 = s1; // 这一行会发生 Move；这里保留 s2 只是为了和上一章例子呼应    borrow_string(&amp;s2);    println!("{s2}, function!");}</code></pre><p>这里的<code>&amp;s2</code>为s2的引用，这个 &amp; 符号就是 <strong>引用</strong>，它们允许你使用值但不获取其所有权。其内存状态类似如下图1：</p><img src="https://s2.loli.net/2025/11/27/gYf2IxValRN6yPL.png" alt="image-20251127211921949" style="zoom: 33%;"><p>我们将创建一个引用的行为称为 <strong>借用</strong>（<em>borrowing</em>）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完后，必须还回去。因为我们并不拥有它的所有权。</p><p>借用的时候，大多都是为了对被借用对象进行操作和更新，这里的例子我们同时也修改了<code>s2</code>为不可变对象，如果我们要对<code>s2</code>在函数里面进行更新和操作我们就要使用<strong>可变引用</strong>，其和可变变量一样，基于一个可变变量才能创建可变借用，我们修改例子：</p><pre><code class="language-rust">fn borrow_string_mut(some_string: &amp;mut String) { // 可变借用    some_string.push_str(",  add something");    println!("{} function inside", some_string);} // 这里，some_string 离开了作用域。但因为它并不拥有引用值的所有权，所以什么也不会发生fn main() {    let s1 = String::from("ownership test");    let mut s2 = s1; // 修改为可变变量    borrow_string_mut(&amp;mut s2); // 传入可变引用    println!("{s2}, function out!");}</code></pre><p>输出：</p><pre><code class="language-text">ownership test, add something function insideownership test, add something, function out!</code></pre><p>可以看到 字符串添加了 <code>add something</code>的内容，你可能会好奇如果传入一个不可变的s2引用会怎么样，当然也是可以的，我们在函数里面不对它进行修改添加等操作，将一个可变变量以一个不可变变量的形式引用：</p><pre><code class="language-text">warning: variable does not need to be mutable --&gt; src/main.rs:9:13  |9 |         let mut s2 = s1;  |             ----^^  |             |  |             help: remove this `mut`  |  = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by defaultwarning: `massflow_accelerator` (bin "massflow_accelerator") generated 1 warning</code></pre><p>Rust的编译很智能，能提示出来，可以直接定义为不可变变量。</p><p>可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的可变引用和不可变引用。尝试创建两个 <code>s</code> 的可变引用的代码会失败，但是创建多个不可变引用却是可以的，举个例子：</p><pre><code class="language-rust">{    let s1 = String::from("ownership test");    let mut s2 = s1;    let s3: &amp;String = &amp;s2; // 创建一个不可变引用    let s4: &amp;String = &amp;s2; // 创建一个不可变引用    println!("s2: {}, s3: {}, s4: {}", s2, s3, s4);    borrow_string_mut(&amp;mut s2);    println!("{s2}, function out!");}</code></pre><p>如果修改为：</p><pre><code class="language-rust">{    let s1 = String::from("ownership test");    let mut s2 = s1;    let s3 = &amp;mut s2; // 创建一个可变引用    let s4: &amp;String = &amp;s2; // 创建一个不可变引用    println!("s2: {}, s3: {}, s4: {}", s2, s3, s4);}</code></pre><p>则会报错：</p><pre><code class="language-bash">   Compiling massflow_accelerator v0.1.0 (/home/neo/Desktop/Massflow_accelerator)error[E0502]: cannot borrow `s2` as immutable because it is also borrowed as mutable  --&gt; src/main.rs:12:27   |11 |         let s3 = &amp;mut s2; // 创建一个可变引用   |                  ------- mutable borrow occurs here12 |         let s4: &amp;String = &amp;s2; // 创建一个不可变引用   |                           ^^^ immutable borrow occurs here13 |         println!("s2: {}, s3: {}, s4: {}", s2, s3, s4);   |                                                -- mutable borrow later used hereerror[E0502]: cannot borrow `s2` as immutable because it is also borrowed as mutable  --&gt; src/main.rs:13:44   |11 |         let s3 = &amp;mut s2; // 创建一个可变引用   |                  ------- mutable borrow occurs here12 |         let s4: &amp;String = &amp;s2; // 创建一个不可变引用13 |         println!("s2: {}, s3: {}, s4: {}", s2, s3, s4);   |                                            ^^  -- mutable borrow later used here   |                                            |   |                                            immutable borrow occurs here   |   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)For more information about this error, try `rustc --explain E0502`.error: could not compile `massflow_accelerator` (bin "massflow_accelerator") due to 2 previous errors</code></pre><p>这一限制以一种非常小心谨慎的方式允许可变性，防止同一时间对同一数据存在多个可变引用。因为大部分语言中变量任何时候都是可变的。这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p><ul><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ul><h2><span id="悬垂引用dangling-references">悬垂引用（Dangling References）</span></h2><p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个<strong>悬垂指针</strong>（<em>dangling pointer</em>）—— 指向可能已被分配给其他用途的内存位置的指针。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂引用：</p><p>常见的悬垂引用可以通过“作用域 + 所有权”相互影响的方式来展现：</p><pre><code class="language-rust">fn main() {    let reference_to_nothing = dangle();// dangle 返回一个字符串的引用}fn dangle() -&gt; &amp;String {    let s = String::from("hello");// s 是一个新字符串    &amp;s// 返回字符串 s 的引用}// 这里 s 离开作用域并被丢弃。其内存被释放。</code></pre><p>报错如下：</p><pre><code class="language-bash">$ cargo run   Compiling ownership v0.1.0 (file:///projects/ownership)error[E0106]: missing lifetime specifier --&gt; src/main.rs:5:16  |5 | fn dangle() -&gt; &amp;String {  |                ^ expected named lifetime parameter  |  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed fromhelp: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`  |5 | fn dangle() -&gt; &amp;'static String {  |                 +++++++help: instead, you are more likely to want to return an owned value  |5 - fn dangle() -&gt; &amp;String {5 + fn dangle() -&gt; String {  |error[E0515]: cannot return reference to local variable `s` --&gt; src/main.rs:8:5  |8 |     &amp;s  |     ^^ returns a reference to data owned by the current functionSome errors have detailed explanations: E0106, E0515.For more information about an error, try `rustc --explain E0106`.error: could not compile `ownership` (bin "ownership") due to 2 previous errors</code></pre><p>在报错信息里面涉及到了生命周期这个概念，目前还没介绍，后边会详细介绍。</p><p>生命周期，作用域，借用，所有权等几个概念共同构建了Rust的内存管理部分，如果把C++的内存管理称之为手动模式，Python/Java称为自动模式，Rust就是半自动模式，其通过上述几个概念的相互作用最终构成了这种半自动模式。</p><p>这里如想让代码正常运行，修改为返回s即可：</p><pre><code class="language-rust">fn no_dangle() -&gt; String {    let s = String::from("hello");    s}//s的所有权被转移</code></pre><h2><span id="总结">总结</span></h2><ul><li>在任意给定时间，<strong>要么</strong>只能有一个可变引用，<strong>要么</strong>只能有多个不可变引用。</li><li>引用必须总是有效的。</li><li>生命周期，作用域，借用，所有权等几个概念共同构建了Rust的内存管理部分</li></ul>]]></content>
    
    
    <summary type="html">引用与借用</summary>
    
    
    
    <category term="Rust" scheme="http://neonexusx.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://neonexusx.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 快速入门指北[所有权与作用域]</title>
    <link href="http://neonexusx.github.io/2025/11/28/Rust%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97[%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F]/"/>
    <id>http://neonexusx.github.io/2025/11/28/Rust%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97[%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F]/</id>
    <published>2025-11-27T16:00:00.000Z</published>
    <updated>2026-01-04T09:08:06.692Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="rust-快速入门指北所有权与作用域">Rust 快速入门指北[所有权与作用域]</span></h1><img src="https://s2.loli.net/2026/01/04/TinylHVZpO3kxae.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1767517637848" style="zoom: 67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><h2><span id="所有权ownership">所有权（<em>ownership</em>）</span></h2><p>所有权是一系列Rust用于内存管理的规则，相较于Python/Java的垃圾回收机制，Rust则通过所有权规则来对内存的使用和回收进行管理。</p><h3><span id="rust所有权规则">Rust所有权规则</span></h3><p>Rust的所有权遵循以下规则：</p><ul><li>Rust 中的每一个值都有一个 所有者（owner）。</li><li>值在任一时刻有且只有一个所有者。</li><li>当所有者离开作用域，这个值将被丢弃。</li></ul><h2><span id="作用域">作用域</span></h2><p>作用域指的是一个项（item）在程序中有效的范围。</p><p>假设在一个代码块**(Block)**:</p><pre><code class="language-rust">{    // 新的作用域开始    let s1 = "hello"; // 此处 s1 开始有效    println!("{}", s1);    //作用域结束}</code></pre><h2><span id="程序内存的分配机制">程序内存的分配机制</span></h2><p>系统的内存类型可分为：</p><ul><li><strong>全局段</strong>（Global segment）：负责存储全局变量和静态变量，生命周期等于程序执行的整个时间段。</li><li><strong>代码段</strong>（Code segment）：包含组成我们程序的实际机器代码或指令，包括函数和方法。</li><li><strong>栈</strong>（Stack）[有些错误的叫为 <strong>堆栈</strong>，早期翻译的旧称，实际上是不正确的]。用于局部变量、函数参数等。</li><li><strong>堆</strong>（Heap）：灵活区域来存储大型数据，动态生命周期，在运行时按需分配或者释放。</li></ul><img src="https://s2.loli.net/2025/11/27/BQir9Z5JvSbDxE1.png" alt="image-20251127111940172" style="zoom:20%;" title="图1，程序内存分段"><p>在现代操作系统（Windows, Linux, macOS）中，每个程序启动时，操作系统都会给它分配一个独立的<strong>虚拟内存空间</strong>。也就是说程序拥有**自己独立的堆区域（逻辑上），但这个区域的“内存”是由操作系统授予的（物理上）。**操作系统管理所有的物理内存，它不关心你具体怎么用，它只负责按“页”（Page，通常是 4KB 大小）为单位，把内存“批发”给各个程序，当你的程序向系统申请内存的时候，操作系统就再划拨几页虚拟内存给你。</p><p>上图1展示了，一个程序的内存的逻辑分段，当中的箭头表明了其扩展方向，当然操作系统不同其扩展方向不同，扩展方向分为：</p><ul><li><strong>上（Up）</strong>：指 <strong>高地址</strong>（High Address），例如 <code>0xFFFFFFFF</code>。</li><li><strong>下（Down）</strong>：指 <strong>低地址</strong>（Low Address），例如 <code>0x00000000</code>。</li></ul><p>在Linux/x86下其模型可能是，下图2的形式，我们可以看到，Stack和Heap的位置发生了反转，不过这并不重要，重要的是二者延展方向是相对的。</p><img src="https://s2.loli.net/2025/11/27/UxkVCz7T5t4rAgl.webp" alt="img" style="zoom:80%;"><p>按照上图的Linux主线程模型来说：</p><ul><li>栈的起始位置通常在内存的高地址区。当你往栈里压入数据（比如调用一个新的函数，或者声明一个新的局部变量）时，栈顶指针（Stack Pointer）会向 <strong>低地址</strong> 移动。</li><li>堆的起始位置通常在内存的低地址区（在程序代码和静态数据区之上）。当你申请新的动态内存（如 Rust 的 <code>String::from</code> 或 C 的 <code>malloc</code>）时，堆的边界会向 <strong>高地址</strong> 移动。</li><li>内存布局中，栈从高地址向下增长，堆从低地址向上增长，中间是空闲区。只要两者不碰头，程序就能运行。在实际中，由于64位系统虚拟内存空间极大，两者几乎不可能碰头。更常见的内存问题是：<strong>物理内存耗尽（OOM）</strong>，这通常发生在堆上，即申请的内存超过了物理内存上限；以及<strong>栈溢出</strong>，这是触碰了操作系统为栈设置的较小固定上限（如8MB），通常由无限递归等导致。</li></ul><p>堆和栈介绍：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/647302641">知乎，栈和堆的区别</a></li><li><a href="https://www.zhihu.com/question/36103513">知乎，栈和堆的延伸方向</a></li></ul><h2><span id="堆上数据的所有权和作用域">堆上数据的所有权和作用域</span></h2><p>上述内容的代码块里面，<code>"hello"</code> 是一个字符串字面量（<code>&amp;'static str</code>），其字符串内容通常存放在程序的只读静态区域（可粗略理解为“全局/静态区”），生命周期贯穿整个程序运行。</p><p>需要注意的是：<code>let s1 = "hello";</code> 这行代码里，栈上保存的是一个<strong>字符串切片</strong>（包含指针+长度，指向静态区的那段只读字符串），而不是把字符串内容本身拷贝到栈上。离开作用域时，<code>s1</code> 这个切片从栈上消失即可；而静态区的字符串字面量不会被释放。与之相对的堆数据变化较多，我们接下来将使用堆数据进行更详细的所有权和作用域介绍。</p><p>Rust 有另一种字符串类型，<code>String</code>。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 <code>from</code> 函数基于字符串字面值来创建 <code>String</code>，如下：</p><pre><code class="language-rust">{    let mut s = String::from("hello"); // 从此处起，s 是有效的    println!("{}", s);    s.push_str(", world!");    println!("{}", s);  // 使用 s} // 此作用域已结束，s 不再有效</code></pre><h3><span id="堆变量的交互和移动">堆变量的交互和移动</span></h3><p>在Rust中，堆变量的交互和移动与栈变量有很大区别，我们回顾下普通的栈变量：</p><pre><code class="language-rust">{    let x = 5; // x 在此作用域内有效    let y = x + 2;    println!("y 的值是: {}", y);}</code></pre><p>上述操作可以理解为：“将 <code>5</code> 绑定到 <code>x</code>；接着生成一个值 <code>x</code> 的拷贝并绑定到 <code>y</code>”</p><p>但是在String里面情况发生了很大区别：</p><pre><code class="language-rust">{    let s1 = String::from("hello");    let s2 = s1;    println!("{s1}, world!");}</code></pre><img src="https://s2.loli.net/2025/11/27/YmHyB8qvA364cZC.png" alt="image-20251127173444714" style="zoom:33%;"><p>上图3展示了内存里面的结构形式，长度表示 <code>String</code> 的内容当前使用了多少字节的内存。容量是 <code>String</code> 从分配器总共获取了多少字节的内存。长度与容量的区别是很重要的，不过在当前上下文中并不重要，所以现在可以忽略容量。</p><p>当我们将 <code>s1</code> 赋值给 <code>s2</code>，这里发生的是 <strong>移动（move）</strong>：</p><ul><li>底层表现为：把 <code>String</code> 在栈上的三元信息（指针、长度、容量）拷贝到 <code>s2</code>；</li><li>但堆上的字符串内容<strong>不会</strong>被拷贝；</li><li>同时，为避免二次释放，Rust 会让 <code>s1</code> 在语义上立即失效（不能再使用）。</li></ul><p>内存中数据的表现如下图4所示。</p><img src="https://s2.loli.net/2025/11/27/NKTaImOycp3UlbH.png" alt="image-20251127173712663" style="zoom:33%;"><p>这和栈变量的复制形式有很大区别，栈变量的情况更类似如下图5：</p><img src="https://s2.loli.net/2025/11/27/jnxq5pw1yAEg3Jl.png" alt="image-20251127174005558" style="zoom:33%;"><p>按照我们原来的所有权释放内存的<a href="###Rust%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99">规则</a>：</p><pre><code class="language-rust">    {      //进入作用域        let s1 = String::from("hello"); //此处S1生效        let s2 = s1; //此处S2生效        println!("{s1}, world!");    }// S1 和 S2 不再生效</code></pre><p>当变量离开作用域后，Rust 自动调用 <code>drop</code> 函数并清理变量的堆内存。不过图 4 展示了两个数据指针指向了同一位置。这就有了一个问题：当 <code>s2</code> 和 <code>s1</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放</strong>（<em>double free</em>）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p><p>当然Rust在所有权的设计上做了一些调整，从而避免了这种情况的出现。实际上上述代码是无法通过编译的，其报错如下：</p><pre><code class="language-bash">Compiling massflow_accelerator v0.1.0 ()warning: unused variable: `s2` --&gt; src/main.rs:9:13  |9 |         let s2 = s1;  |             ^^ help: if this is intentional, prefix it with an underscore: `_s2`  |  = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by defaulterror[E0382]: borrow of moved value: `s1`  --&gt; src/main.rs:10:20   | 8 |         let s1 = String::from("hello");   |             -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 9 |         let s2 = s1;   |                  -- value moved here10 |         println!("{s1}, world!");   |                    ^^ value borrowed here after move   |   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)help: consider cloning the value if the performance cost is acceptable   | 9 |         let s2 = s1.clone();   |                    ++++++++For more information about this error, try `rustc --explain E0382`.warning: `massflow_accelerator` (bin "massflow_accelerator") generated 1 warningerror: could not compile `massflow_accelerator` (bin "massflow_accelerator") due to 1 previous error</code></pre><p>报错的关键有两部分：</p><pre><code class="language-bash"> 8 |         let s1 = String::from("hello");   |             -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 9 |         let s2 = s1;   |                  -- value moved here10 |         println!("{s1}, world!");   |                    ^^ value borrowed here after move</code></pre><p>其中一个是<code>s1</code> has type <code>String</code>, which does not implement the <code>Copy</code> trait，另一个是 <code>value borrowed here after move</code></p><p>造成第二个报错的原因是变量进行了<strong>移动</strong>(move)操作，移动之后变量就无效了，我们对移动操作的定义如下：</p><p>类似如下的操作，我们都统称为<strong>移动</strong>：</p><img src="https://s2.loli.net/2025/11/27/IHzEGwLNg4yoAmP.png" alt="image-20251127194509650" style="zoom:33%;"><p>其操作更像是浅拷贝，但实际上是拷贝指针、长度和容量而不拷贝数据，相较于拷贝操作，移动操作并没有保留第一个变量，所以其并不等价于浅拷贝。</p><p>这样在移动之后，s1无效了，同时也避免了我们刚才所说的<strong>二次释放</strong>问题。</p><h3><span id="可变与不可变变量的移动">可变与不可变变量的移动</span></h3><p>上述过程中的移动操作都是建立在相同类型的变量下的，为了验证不可变与可变类型的转换，我们将撰写一个例子，输出可变之前的数据地址和堆地址，查看在移动过程中地址是否发生了改变：</p><pre><code class="language-rust">{    let s1 = String::from("ownership test");    // 验证：打印 s1 指向的堆数据地址    println!("s1 指向的堆地址: {:p}", s1.as_ptr());    // 验证：打印 s1 变量本身的栈地址    println!("s1 变量的栈地址: {:p}", &amp;s1);    let mut s2 = s1;    // 此时 s1 已经失效 (Move)，不能再打印 s1 了    // 验证：打印 s2 指向的堆数据地址 (应该与 s1 的一样)    println!("s2 指向的堆地址: {:p}", s2.as_ptr());    // 验证：打印 s2 变量本身的栈地址 (应该与 s1 的不一样)    println!("s2 变量的栈地址: {:p}", &amp;s2);    //修改s2的堆上内容    take_ownership(&amp;mut s2);    println!("{s2}, function out!");}</code></pre><p>输出：</p><pre><code class="language-text">s1 指向的堆地址: 0x1047c1d60s1 变量的栈地址: 0x16bd261f8s2 指向的堆地址: 0x1047c1d60s2 变量的栈地址: 0x16bd262d0ownership test, add something function insideownership test, add something, function out!</code></pre><p>我们发现将不可变变量移交到可变变量后，变量本身（栈上的绑定/地址）发生了更新，但其指向的堆数据没有发生变化，且变得可操作了。</p><h3><span id="copy-和-clone">copy 和 clone</span></h3><p>关于第一个报错的原因，在讨论之前我们先说明一下，如何实现类似于图5的复制操作，也就是我们常说的深拷贝的操作。</p><p>如果我们 <strong>确实</strong> 需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的常用方法：</p><pre><code class="language-rust">    let s1 = String::from("hello");    let s2 = s1.clone();    println!("s1 = {s1}, s2 = {s2}");</code></pre><p>这样两个变量都会同时存在，但这样会造成性能的浪费，相当消耗资源。</p><p>在堆操作的数据往往如此，与此相对的对栈上的数据我们进行拷贝的时候不需要调用clone方法的：</p><pre><code class="language-rust">  {      let x = 5; // x 在此作用域内有效      let mut y = x;      y = y + 1;      println!("x 的值是: {x},y 的值是: {y}");  }output ：x 的值是: 5,y 的值是: 6</code></pre><p>对于整型（如 <code>i32</code>）来说，<strong>深拷贝和浅拷贝没有区别</strong>。整型的大小是固定的，完全存储在<strong>栈（Stack）<strong>上。整型不像</strong>String</strong>那样由“栈上的指针”指向“堆上的数据”，整型变量本身就持有数据的值。对于这一类数据长度固定的数据，没有深浅拷贝的区别，所以这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它。</p><p>当然，这样的实现也是依赖于另一个叫做 <code>Copy</code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上，如果一个类型实现了 <code>Copy</code> trait，那么一个旧的变量在将其赋值给其他变量后仍然有效。</p><p>同时Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误，这里实际上就能理解第一个报错： <code>move occurs because s1 has type String, which does not implement the Copy trait</code>,因为这里的<strong>String</strong>实际上持有<code>Drop</code> trait 。</p><p>任何不需要分配内存或某种形式资源的类型都可以实现 <code>Copy</code>，如下是一些 <code>Copy</code> 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li></ul><h2><span id="所有权和函数">所有权和函数</span></h2><p>将值传递给函数与给变量赋值的原理相似。向函数传递值可能会<strong>移动</strong>或者<strong>复制</strong>操作,触发操作的时候所有权产生变化，举个例子：</p><pre><code class="language-rust">fn main() {      let s1 = String::from("ownership test");      let s2 = s1;      take_ownership(s2); //移动了ownership至函数      // println!("{s2}, world!"); // 没有启用  }fn take_ownership(some_string: String) {    println!("{}", some_string);} // 此作用域结束，some_string 不再有效，some_string 移出作用域并调用 `drop` 方法。  // 占用的内存被释放output：ownership test</code></pre><p>如果我们启用，则会有以下报错：</p><pre><code class="language-bash">   Compiling massflow_accelerator v0.1.0 (/Users/neo/Desktop/massflow_accelerator)error[E0382]: borrow of moved value: `s2`  --&gt; src/main.rs:11:20   | 9 |         let s2 = s1;   |             -- move occurs because `s2` has type `String`, which does not implement the `Copy` trait10 |         take_ownership(s2);   |                        -- value moved here11 |         println!("{s2}, world!");   |                    ^^ value borrowed here after move   |note: consider changing this parameter type in function `take_ownership` to borrow instead if owning the value isn't necessary  --&gt; src/main.rs:22:32   |22 | fn take_ownership(some_string: String) {   |    --------------              ^^^^^^ this parameter takes ownership of the value   |    |   |    in this function   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)</code></pre><p>这也是Rust比较麻烦的地方，在其他编程语言里面，变量的生命周期不会这么转瞬即逝，不会随着作用域的变化而产生变化，<strong>即从调用函数的较大作用域进入较小的函数作用域的时候其变量本身的生命周期并没有发生变化</strong>。<strong>但是Rust恰恰相反，其生命周期与所有权，作用域等都存在一定关系，多个特性共同决定了变量的生命周期</strong>。</p><h3><span id="返回值和作用域">返回值和作用域</span></h3><p>返回值也可以转移所有权。示例 展示了一个返回了某些值的示例:</p><pre><code class="language-rust">fn take_ownership(some_string: String)-&gt; String {    println!("{}", some_string);// some_string 进入作用域    some_string // 返回 some_string 并将其移至调用函数} fn main(){    let s1 = String::from("ownership test");    let mut s2 = s1; //这里发生了第一次 Move。s1 的所有权移动给了 s2，s1 失效。    s2 = take_ownership(s2); //移交所有权并重新获取所有权    println!("{s2}, function!");}output：ownership test, function!</code></pre><p>在 Rust 中，这里的 s2从技术上讲是一个<strong>全新的变量绑定</strong>，尽管它可能指向相同的堆内存数据（取决于编译器的优化），但在语义上发生了所有权的转移（Move）。</p><p>函数调用<code>take_ownership(s2)</code>这里发生了第二次 Move。s2 的所有权移动进了函数 take_ownership 的参数 some_string中。此时，外部的 s2（在赋值前）暂时失去了对数据的所有权。</p><h2><span id="总结">总结</span></h2><p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时它会移动。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？</p>]]></content>
    
    
    <summary type="html">所有权与作用域</summary>
    
    
    
    <category term="Rust" scheme="http://neonexusx.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://neonexusx.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>使用Zerotier实现内网穿透</title>
    <link href="http://neonexusx.github.io/2025/11/28/Zerotier/"/>
    <id>http://neonexusx.github.io/2025/11/28/Zerotier/</id>
    <published>2025-11-27T16:00:00.000Z</published>
    <updated>2025-11-28T07:56:51.120Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="使用zerotier实现内网穿透">使用Zerotier实现内网穿透</span></h1><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><p>由于学校新式vpn软件，不⽀持校内资源映射等操作（需申请），原有基于sslvpn可正常 使⽤，现提供临时的穿透解决⽅案，⽅案基于⾃建zerotier planet服务器，服务器位于⼤陆地 区，通过planet服务器实现点对点连接，带宽⽆上限，取决于⽹络连接状况。</p><h2><span id="windows客户端配置">windows客户端配置</span></h2><p>⾸先去 ZeroTier 官⽹下载⼀个 ZeroTier 客户端：</p><p><a href="https://www.zerotier.com/download/">https://www.zerotier.com/download/</a></p><p>根据你的系统选择对应的客户端即可，⽬前⽀持除了ios外的所有主流系统。</p><img src="https://s2.loli.net/2025/11/26/e5KFiMm6ESUzQlG.png" alt="image-20251126201514232" style="zoom: 33%;"><h2><span id="替换-planet-文件">替换 planet ⽂件</span></h2><p>由于是⾃建planet为了保证安全，屏蔽掉所有官⽅的服务器我们需要替换planet⽂件， planet⽂件上传⾄群内，严禁分享，下载后，找到：</p><pre><code class="language-bash">windows：C:\ProgramData\ZeroTier\One （这个⽬录是个隐藏⽬录，需要允许查看隐藏⽬录才⾏）linux：/var/lib/zerotier-onemacos：/Library/Application\ Support/ZeroTier/One/</code></pre><p>在⽂件夹下⾯如果有planet⽂件那说明你找对了复制并替换到这⾥就可以了：</p><img src="https://s2.loli.net/2025/11/26/pXNakByZzoJLYuO.png" alt="image-20251126201738485" style="zoom:50%;"><h2><span id="重启zerotier刷新服务">重启zerotier，刷新服务</span></h2><h3><span id="windows">windows</span></h3><img src="https://s2.loli.net/2025/11/26/BH21LiSKXeZDrQ4.png" alt="image-20251126201859009" style="zoom: 33%;"><p>按照名称排序找到 ZeroTier One，并且重启服务：</p><img src="https://s2.loli.net/2025/11/26/2ECdkKqm8VFxuny.png" alt="image-20251126201920872" style="zoom:50%;"><h3><span id="macos">macos</span></h3><pre><code class="language-zsh">cat /Library/Application\ Support/ZeroTier/One/zerotier-one.pid | sudo xargs kill</code></pre><p>没有消息就重启完成</p><h2><span id="加入自建网络">加⼊自建⽹络</span></h2><p>XMU网络id：553d5a85b18f0814</p><p>JMU网络id：553d5a85b198d5d7</p><pre><code class="language-bash">windows：PS C:\Windows\system32&gt; zerotier-cli.bat join 553d5a85b18f0814macos：zerotier-cli join 553d5a85b18f0814</code></pre><p>JMU应加入JMU网络，XMU直接使用命令即可，二者互相独立，完成之后联系我，等待我授权。</p><h2><span id="测试是否成功">测试是否成功</span></h2><p>完成之后测试⼀下：</p><p>打开命令行或者powershell：</p><pre><code class="language-bash">zerotier-cli peers</code></pre><p><img src="https://s2.loli.net/2025/11/26/qWlTdSkUbPrX8ih.png" alt="image-20251126202432706"></p><p>可以看到PLANET节点，正常，其中117.28.251.155为校内服务器。</p><pre><code class="language-bash">ping 10.11.12.166</code></pre><p>延迟时间逐渐稳定之后即可，如果测试延迟较⼤，可能不太适⽤。</p><img src="https://s2.loli.net/2025/11/26/VbFPQz8dRY7GEZ6.png" alt="image-20251126202511778" style="zoom:50%;"><p>XMU组内服务器IP：</p><pre><code class="language-bash">Bionet_No1 [计算服务器] 10.11.12.166NAS [网络存储服务器] 10.11.12.134</code></pre><p>连接的时候请使⽤上边的IP，不要使⽤校内IP。</p><h2><span id="注意">注意</span></h2><p>zerotier配对需要⼀定时间，重新开机后没有没配对的时候⽆法访问对应的ip，⼀般开机 想⽤的话，可以测试下：</p><pre><code class="language-bash">ping 目标ip举例：ping 10.11.12.166</code></pre><p>直到ping成功了说明配对成功，将zerotier开机⾃启动之后⼀般会⾃⼰配对，⽆需主动管理。如果⻓时间没有配对，请⼿动重启，参考<a href="##%E9%87%8D%E5%90%AFzerotier%E5%88%B7%E6%96%B0%E6%9C%8D%E5%8A%A1">重启 Zerotier</a>。</p>]]></content>
    
    
    <summary type="html">some~</summary>
    
    
    
    <category term="Bionet" scheme="http://neonexusx.github.io/categories/Bionet/"/>
    
    
    <category term="Bionet" scheme="http://neonexusx.github.io/tags/Bionet/"/>
    
  </entry>
  
  <entry>
    <title>Linux Bash Shell 脚本入门（2）——GNU</title>
    <link href="http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%202/"/>
    <id>http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%202/</id>
    <published>2025-03-12T10:37:00.000Z</published>
    <updated>2025-11-28T07:17:01.836Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux-bash-shell-脚本入门2gnu">Linux Bash Shell 脚本入门（2）——GNU</span></h1><p>[TOC]</p><!-- toc --><ul><li><a href="#gnu%E4%B8%8Elinux">GNU与Linux</a><ul><li><a href="#gnu">GNU</a><ul><li><a href="#gnu%E7%9A%84%E7%BB%84%E6%88%90">GNU的组成</a></li></ul></li><li><a href="#shell">Shell</a></li><li><a href="#gnome%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83">GNOME桌面环境</a><ul><li><a href="#x-window-%E8%BD%AF%E4%BB%B6">X Window 软件</a></li></ul></li><li><a href="#gnome">GNOME</a></li></ul></li></ul><!-- tocstop --><img src="https://s2.loli.net/2025/03/12/FvsRHCyO4QK9Tlb.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1741775577228" style="zoom:67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1695021721029" style="zoom: 50%;"><p>可点击内容，大部分来自维基百科，可以点击了解详情。</p><h2><span id="gnu与linux">GNU与Linux</span></h2><h3><span id="gnu">GNU</span></h3><p>GNU操作系统起源于<a href="https://zh.m.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83">GNU计划</a>，由<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>在<a href="https://zh.m.wikipedia.org/wiki/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%B8%E9%99%A2">麻省理工学院</a>人工智能实验室发起，希望发展出一套完整的开放源代码操作系统来取代Unix，计划中的操作系统，名为GNU。</p><p><img src="https://s2.loli.net/2022/08/12/jQLouxXq39ZigGR.png" alt="246px-Heckert_GNU_white.svg"></p><p>GNU的商标是一个<a href="https://zh.m.wikipedia.org/wiki/%E7%89%9B%E7%BE%9A">牛羚</a>头。原先版本是Etienne Suvasa所设计，而今比较流行的粗体版本则是Aurelio Heckert所设计。</p><p><strong>GNU</strong>是一个<a href="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BB%9F%E9%AB%94">自由</a>的<a href="https://zh.m.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1">操作系统</a>，其内容软件完全以<a href="https://zh.m.wikipedia.org/wiki/GPL">GPL</a>方式发布（什么是GPL下文会介绍）。这套操作系统是<a href="https://zh.m.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83">GNU计划</a>的主要目标，名称来自GNU’s Not Unix!的<a href="https://zh.m.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E7%B8%AE%E5%AF%AB">递归缩写</a>，因为GNU的设计类似<a href="https://zh.m.wikipedia.org/wiki/Unix">Unix</a>，但它不包含具著作权的Unix代码。</p><p>读到这里你可能会难以理解，我从来没听说过GNU操作系统，像是Linux，Unix这种都是很有名的，但GNU到底是什么？</p><p>1983年9月27日，<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>在 net.unix-wizards 和 net.usoft<a href="https://zh.m.wikipedia.org/wiki/%E6%96%B0%E8%81%9E%E7%BE%A4%E7%B5%84">新闻组</a>中公布这项GNU计划。斯托曼的目标是成立一个完全自由的操作系统，他希望电脑用户是能够“自由使用”的。</p><p>为什么要在这里强调自由使用呢？因为在20世纪60年代和70年代 - 大多数人都能自由学习软件的源代码，自由地与他人分享的软件，可自由修改软件，自由发布软件修改后的版本。也就是说早些年软件几乎不存在著作权，每个人都可以自由地使用和修改。</p><p>1984年1月5日，理查德正式开始开发软件，为了防止这些软件将来可能被主张所有权，影响到Free Software的发展，斯托曼辞去了在实验室的工作。</p><p>理查德·斯托曼使用<a href="https://zh.m.wikipedia.org/w/index.php?title=%E4%B8%8D%E5%85%BC%E5%AE%B9%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1&amp;action=edit&amp;redlink=1">不兼容分时系统</a>（英语：<a href="https://en.wikipedia.org/wiki/Incompatible_Timesharing_System">Incompatible Timesharing System</a>） (ITS)<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-intervention-6">[6]</a>（一种早期的操作系统，使用<a href="https://zh.m.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">汇编语言</a>撰写，因其所运行的被称为 <a href="https://zh.m.wikipedia.org/wiki/PDP-10">PDP-10</a>的电脑系统架构停止发展而变得过时）的经验，决定了需要设计一种可移植系统。由此，会议决定，将开发新的系统，并使用 <a href="https://zh.m.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">C</a> 和<a href="https://zh.m.wikipedia.org/wiki/Lisp">Lisp</a>作为系统编程语言。<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-8">[8]</a> GNU将与UNIX兼容。<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-9">[9]</a> 当时，UNIX已经是一个流行的专有操作系统。而Unix的设计是模块化的，所以它可以被逐步分块的实现。</p><p>Unix在学术机构和大型企业中得到了广泛的应用，当时的UNIX拥有者<a href="https://zh.m.wikipedia.org/wiki/AT%26T">AT&amp;T</a>公司以低廉甚至免费的许可将Unix源码授权给学术机构做研究或教学之用，许多机构在此源码基础上加以扩展和改进，形成了所谓的“Unix变种”，这些变种反过来也促进了Unix的发展。</p><p>后来<a href="https://zh.m.wikipedia.org/wiki/AT%26T">AT&amp;T</a>意识到了Unix的商业价值，不再将Unix源码授权给学术机构，并对之前的Unix及其变种声明了著作权权利。BSD在Unix的历史发展中具有相当大的影响力，被很多商业厂家采用，成为很多商用Unix的基础。其不断增大的影响力终于引起了AT&amp;T的关注，于是开始了一场持久的著作权官司，至此人们意识到我们需要一个完全免费的操作系统。</p><p>1984年，开始发展编辑器<a href="https://zh.m.wikipedia.org/wiki/Emacs">Emacs</a>等软件。1985年，发表<a href="https://zh.m.wikipedia.org/wiki/GNU%E5%AE%A3%E8%A8%80">GNU宣言</a>。1989年，发表<a href="https://zh.m.wikipedia.org/zh-cn/GNU_General_Public_License">GNU通用公共许可协议</a>。这个公共开源许可协议，你如果开源过项目一定见过，它叫GPL协议，GPL是<a href="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BB%9F%E4%BB%B6">自由软件</a>和<a href="https://zh.m.wikipedia.org/wiki/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6">开源软件</a>的最流行许可证<a href="https://zh.m.wikipedia.org/zh-cn/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81#cite_note-18">[18]</a>。到2004年4月，GPL已占<a href="https://zh.m.wikipedia.org/w/index.php?title=Freshmeat&amp;action=edit&amp;redlink=1&amp;variant=zh-cn">Freshmeat</a>（英语：<a href="https://en.wikipedia.org/wiki/Freshmeat">Freshmeat</a>）上所列的自由软件的约75%，<a href="https://zh.m.wikipedia.org/wiki/SourceForge">SourceForge</a>的约68%。类似的，2001年一项关于<a href="https://zh.m.wikipedia.org/wiki/Red_Hat_Linux">Red Hat Linux</a> 7.1的调查显示一般的代码都以GPL发布。著名的GPL自由软件包括<a href="https://zh.m.wikipedia.org/wiki/Emacs">Emacs</a>，<a href="https://zh.m.wikipedia.org/wiki/Linux">Linux</a>核心（并非所有<a href="https://zh.m.wikipedia.org/wiki/Linux%E7%99%BC%E8%A1%8C%E7%89%88">Linux发行版</a>的核心都是开源的）和<a href="https://zh.m.wikipedia.org/wiki/GCC">GCC</a>。</p><p>我们回到GNU的操作系统来，因为许多必要的软件需要从零开始写起来，但是有很多已经存在的第三方组件如 <a href="https://zh.m.wikipedia.org/wiki/TeX">TeX</a>、<a href="https://zh.m.wikipedia.org/wiki/X_Window_System">X Window System</a><a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-internethist-4">[4]</a>和<a href="https://zh.m.wikipedia.org/wiki/Mach">Mach</a>微内核等等都可以进行利用，其中GNU最关键系统内核，是在<a href="https://zh.m.wikipedia.org/zh-cn/GNU_Mach">GNU Mach</a><a href="https://zh.m.wikipedia.org/wiki/%E5%BE%AE%E5%85%A7%E6%A0%B8">微内核</a>基础上进行开发，<strong>理查德·马修·斯托曼</strong>认为可以借此加速操作系统的开发，但因为一直不确定<a href="https://zh.m.wikipedia.org/wiki/%E5%8D%A1%E5%86%85%E5%9F%BA%E6%A2%85%E9%9A%86%E5%A4%A7%E5%AD%A6">卡内基梅隆大学</a>何时要将核心源代码发布，造成计划延宕三年。他在之后承认这是个错误。</p><p>下图是大佬的照片：</p><img src="https://s3.bmp.ovh/imgs/2022/08/12/b0dde8c65ef4b8b8.jpg" alt="Richard_Stallman_at_LibrePlanet_2019" style="zoom: 33%;"><p>除了上述的第三方组件外，大多数的GNU软件是由许多志愿者，在他们的空闲时间，或由公司、教育机构和非营利性组织赞助下撰写。</p><p>到 1990 年代初期，操作系统中所需的许多程序（例如库、<a href="https://en.wikipedia.org/wiki/Compiler">编译器</a>、<a href="https://en.wikipedia.org/wiki/Text_editor">文本编辑器</a>、<a href="https://en.wikipedia.org/wiki/Shell_(computing)#Command-line_shells">命令行 shell</a>和<a href="https://en.wikipedia.org/wiki/Windowing_system">窗口系统</a>）已完成，尽管一些底层元素如称为<a href="https://en.wikipedia.org/wiki/GNU_Hurd">GNU Hurd的</a><a href="https://en.wikipedia.org/wiki/Device_driver">设备驱动程序</a>、<a href="https://en.wikipedia.org/wiki/Daemon_(computer_software)">守护进程</a>和<a href="https://en.wikipedia.org/wiki/Kernel_(computer_science)">内核</a>都停滞不前且不完整。</p><p>1991年，Linux出现。1993年，<a href="https://zh.m.wikipedia.org/wiki/FreeBSD">FreeBSD</a>发布。FreeBSD就是当年与Unix著作权持有公司达成协议重写的免费版Unix，所有GNU计划中，运行于用户空间的软件，都可以在Linux或FreeBSD上使用。许多开发者转向于Linux或FreeBSD。其中，Linux成为常见的GNU计划软件运行平台。<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>主张，Linux操作系统使用了许多GNU计划软件，应正名为<a href="https://zh.m.wikipedia.org/wiki/GNU/Linux">GNU/Linux</a>，但没有得到Linux社群的一致认同，形成<a href="https://zh.m.wikipedia.org/wiki/GNU/Linux%E5%91%BD%E5%90%8D%E7%88%AD%E8%AD%B0">GNU/Linux命名争议</a>。</p><p><a href="https://zh.m.wikipedia.org/wiki/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9">林纳斯·托瓦兹</a>（Linus）开始在<a href="https://zh.m.wikipedia.org/wiki/MINIX">MINIX</a>上开发<a href="https://zh.m.wikipedia.org/wiki/Linux%E5%85%A7%E6%A0%B8">Linux内核</a>，为<a href="https://zh.m.wikipedia.org/wiki/MINIX">MINIX</a>写的软件也可以在<a href="https://zh.m.wikipedia.org/wiki/Linux%E5%85%A7%E6%A0%B8">Linux内核</a>上使用。1991年Linus[<a href="https://zh.m.wikipedia.org/zh-cn/Linux#cite_note-16">16]</a>后来使用GNU软件代替MINIX的软件，因为使用从GNU系统来的源代码可以自由使用，这对Linux的发展有益。同时在GPL的规定下，使用GNU GPL协议的源代码可以被其他项目所使用，只要这些项目使用同样的协议发布源码。</p><p>对于GNU来说没有构成自己的操作系统是失败的，但是这个失败确实促进了行业进步与发展，<a href="https://zh.m.wikipedia.org/zh-cn/%E6%9E%97%E7%B4%8D%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E8%8C%B2">林纳斯·托瓦兹</a>曾说过如果GNU内核在1991年时可以用，他不会自己去写一个。实际上现在GNU代指的是当年发展下来的一系列软件。</p><h4><span id="gnu的组成">GNU的组成</span></h4><p>该系统的基本组成包括</p><ul><li>GNU编译器套装（<a href="https://zh.m.wikipedia.org/wiki/GCC">GCC</a>）</li><li>GNU的C库（<a href="https://zh.m.wikipedia.org/wiki/Glibc">glibc</a>）</li><li>GNU核心工具组（<a href="https://zh.m.wikipedia.org/wiki/Coreutils">coreutils</a>）</li><li>GNU调试器（<a href="https://zh.m.wikipedia.org/wiki/GDB">GDB</a>）</li><li>GNU<a href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">编程语言</a>工具程序（<a href="https://zh.m.wikipedia.org/wiki/Binutils">binutils</a>）</li><li><a href="https://zh.m.wikipedia.org/w/index.php?title=GNU_Bash">GNU Bash</a> shell<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-linuxinterface-10">[10]</a></li><li>GNOME桌面环境</li></ul><p>GNU开发人员已经转向GNU应用程序和工具的Linux 移植 ，现在也广泛应用在其它操作系统中使用，上文我们提到的MinGW实际上叫Minimalist GNU for Windows，也就是向Windows移植的GNU最小套件，是将<a href="https://zh.wikipedia.org/wiki/GCC">GCC</a>编译器和<a href="https://zh.wikipedia.org/wiki/GNU_Binutils">GNU Binutils</a>移植到Win32平台下的产物，包括一系列头文件（<a href="https://zh.wikipedia.org/wiki/Windows_API">Win32API</a>）、<a href="https://zh.wikipedia.org/wiki/%E9%9D%9C%E6%85%8B%E9%80%A3%E7%B5%90%E5%87%BD%E5%BC%8F%E5%BA%AB">库</a>和<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a>。另有可用于产生32位及64位Windows可执行文件的<a href="https://zh.wikipedia.org/wiki/Mingw-w64"><strong>MinGW-w64</strong></a>项目，是从原本MinGW产生的分支。</p><h3><span id="shell">Shell</span></h3><p>shell是种特殊的交互工具，为用户提供了启动程序，管理文件系统中的文件及运行在Linux系统中的进程的途径。shell的核心就是命令行提示符，负责shell的交互部分，允许用户输入文本命令，然后解释命令并在内核中执行。</p><p>常见的命令被用来复制、移动、重命名文件等，你用鼠标实现的操作，在shell中都可以实现，除此之外，shell也允许在命令行提示符中输入程序的名称，他会将程序名称传递给内核以启动程序。</p><p>同时也允许，将多个shell命令放入文件中作为程序执行。这些文件成为shell脚本。凡是能在命令行中执行的命令都可以放入shell脚本中作为一组命令执行。</p><p>linux中所有发行版的默认几乎都是bash shell，bash shell 是<a href="https://zh.m.wikipedia.org/w/index.php?title=GNU_Bash">GNU Bash</a> shell<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-linuxinterface-10">[10]</a> ，目的是为了替代老版本Unix系统中的Unix shell，Bash shell名字的由来非常有意思，其名字来源于一个谐音梗 Bourne Again Shell （念作 born again）的缩写，Linux 中当然不仅仅包括GNU的 Bash Shell 也包含其他的shell比如：</p><ul><li>ash：轻量级别的shell,适合运行在内存受限的环境中，比如嵌入式等。</li><li>korn：一种与Born Shell兼容的shell,但支持一些高级特性，浮点运算等。</li><li>tcsh：一种包含了一些C语言特性引入到shell脚本的shell。</li><li>zsh：一种结合了bash、korn、tcsh的特性的shell。</li></ul><p>关于shell的内容会在以后的内容中详细介绍，这里就不再赘述。</p><h3><span id="gnome桌面环境">GNOME桌面环境</span></h3><p>随着Linux系统的发展，最初的操作系统文本界面到图形化的发展，操作系统不仅仅服务于计算机开发人员，逐渐走向大众化，用户不再满足于陈旧的文本命令行交互，图形化的操作界面的日渐强烈，当然完成工作的方式不只有一种，Linux一直以来都以此为闻名。图形化桌面更是如此。Linux有多种图形化桌面可供选择。接下来会介绍一种属于GNU项目的桌面环境。</p><h4><span id="x-window-软件">X Window 软件</span></h4><p>有两个基本要素决定了你的视频环境，显卡和显示器，显卡如何让显示器显示就需要软件来实现，Linux中负责这一部分的就是X Window，X Window是图形现实的核心部分，控制Linux应用如何在显示器上呈现漂亮的窗口和图形。X Window System，通常简称为X11或X，是一个基于位图的显示系统，用于在位图显示器上提供图形用户界面（GUI）。</p><p>X Window System的关键特性包括：</p><ul><li><strong>网络透明性</strong>：X Window系统设计之初就考虑到了网络支持，允许应用程序的图形界面可以在网络上的任何地方显示，实现了客户端与服务器之间的通信。这意味着，一个运行在网络中某台计算机上的应用程序可以将其图形界面显示在连接到同一网络的另一台计算机上。</li><li><strong>客户端-服务器架构</strong>：在X Window系统中，"服务器"是运行在用户机器上的程序，它管理屏幕、键盘、鼠标等输入输出设备。"客户端"是指任何请求服务器服务的程序，比如图形应用程序。这里的“服务器”和“客户端”的概念与常规意义上的网络服务和使用者相反。</li><li><strong>设备和网络独立性</strong>：X Window系统与具体的硬件设备和网络协议无关，可以在各种不同的硬件和网络环境中运行。</li><li><strong>灵活性和扩展性</strong>：X Window提供了基本的框架和协议，开发者可以在其之上构建各种窗口管理器和桌面环境，如GNOME、KDE等，这使得用户界面可以高度定制化。</li></ul><p>尽管X Window本身不是驱动程序，但它依赖于底层的硬件驱动程序来进行图形渲染和设备输入输出操作。例如，X服务器需要与显卡的驱动程序交互，以控制屏幕上的图形显示。因此，为了使X Window系统正常工作，相应的硬件设备（如显卡、键盘、鼠标等）需要有正确安装的驱动程序。</p><p>Linux中能够实现  X window的软件不止有一种，Linux中最常见用的有：</p><ul><li>wayland</li><li><a href="http://X.org">X.org</a></li></ul><p>X.org基于最初的Unix X Windos System版本11 ，后来大家把他简称为X11,属于常用的两种的比较老的版本，新版的linux正在向wayland迁移，虽然这样说，但是目前Ubuntu22.04默认的还是X11:</p><img src="https://s2.loli.net/2024/02/11/hdk7HJRvCAWS5Zz.png" alt="image-20240211210131407" style="zoom: 67%;"><p>在首次安装Ubuntu的时X11会检测显卡和显示器，然后创建一个含有必要信息的X Window配置文件。在安装过程中，安装程序会检测一次显示器，以确定所支持的视频模式。有时这会造成显示器黑屏几秒。由于显卡和显示器的种类繁多，因此这个过程可能需要花费一点时间。</p><p>核心的X Window 软件能够生常图形化现实环境，但仅此而已。尽管这已足以运行单独的应用程序，但在日常的计算机使用中并不是特别有用，因为毕竟没有提供桌面环境，用户无法知道该如何启动程序，操作文件，为此需要在此基础上建立一个桌面环境。</p><p>注意一下，下图驱动部分是Nouveau 驱动，是X11的下层驱动：</p><p><img src="https://s2.loli.net/2024/02/11/HRAUjEODPgsiutK.png" alt="image-20240211211054589"></p><p>至于想搞明白每一个环节的具体工作可以参考：</p><h3><span id="gnome">GNOME</span></h3><img src="https://s2.loli.net/2024/02/11/IkGQJ24R6WjDlVH.png" alt="image-20240211215028684" style="zoom:67%;"><p>Gnome桌面工作在Xorg-Server的上层，提供给用户相应的桌面环境，其全称是（GNU Network object model enviroment，GNU网络对象模型环境）是另一个流行的Linux桌面环境，GNOME于1990年首次发布，现已成为许多Linux发行版默认的桌面环境。</p><p>随着发展GNOME已经度过了很多个版本，可以通过以下命令来查看当前的GNOME版本：</p><pre><code class="language-shell">neo@NeoNeuxs:~/Desktop$ gnome-shell --versionGNOME Shell 42.9</code></pre><p>GNOME桌面环境又被称为GNOME-Shell，为什么会有shell这个单词呢？</p><p>“Shell”（壳）在这里的含义与其在计算机科学中的一般含义相似，指的是一个提供用户界面的软件层，用户可以通过这个界面与系统的更深层次的功能进行交互，在操作系统中，"shell"通常指的是提供与用户交互的界面，这可以是命令行界面（CLI）或图形用户界面（GUI）。GNOME Shell 是后者的一个例子，它提供了一个图形界面供用户启动程序、管理窗口、切换任务等。</p><p>一个新版的Gnome-shell如下：</p><p><img src="https://s2.loli.net/2024/02/11/7lv8XCqNnodGhca.png" alt="Snipaste_2024-02-11_22-25-07"></p><p>参考：</p>]]></content>
    
    
    <summary type="html">GNU 介绍 GNOME桌面环境介绍 Shell介绍</summary>
    
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Bash Shell 脚本入门（3）——Linux常用命令介绍</title>
    <link href="http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%203/"/>
    <id>http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%203/</id>
    <published>2025-03-12T10:37:00.000Z</published>
    <updated>2025-11-28T07:17:01.836Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux-bash-shell-脚本入门3linux常用命令介绍">Linux Bash Shell 脚本入门（3）——Linux常用命令介绍</span></h1><p>[TOC]</p><!-- toc --><ul><li><a href="#%E9%80%9A%E8%BF%87man%E6%9D%A5%E4%BA%86%E8%A7%A3%E4%BB%BB%E4%BD%95%E5%91%BD%E4%BB%A4">通过man来了解任何命令</a><ul><li><a href="#%E6%B5%8F%E8%A7%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">浏览文件系统</a><ul><li><a href="#l%E7%9A%84%E9%95%BF%E5%88%97%E8%A1%A8%E4%BF%A1%E6%81%AF">l的长列表信息</a></li><li><a href="#%E8%BF%87%E6%BB%A4%E8%BE%93%E5%87%BA%E5%88%97%E8%A1%A8">过滤输出列表</a></li></ul></li></ul></li><li><a href="#%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95">复制文件和目录</a></li><li><a href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9">删除文件和文件夹</a><ul><li><a href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9">删除文件夹</a></li></ul></li><li><a href="#%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6">链接文件</a><ul><li><a href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E8%BD%AF%E8%BF%9E%E6%8E%A5">符号链接（软连接）</a></li><li><a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5">硬链接</a></li><li><a href="#%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A1%AC%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB">软连接和硬连接的区别</a></li></ul></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6">查看文件</a><ul><li><a href="#cat%E5%91%BD%E4%BB%A4">cat命令</a></li><li><a href="#%E5%8F%AA%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9">只查看文件部分内容</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%9C%AB%E5%B0%BEtail%E5%91%BD%E4%BB%A4">查看文件末尾（tail命令）</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8head%E5%91%BD%E4%BB%A4">查看文件头部（head命令）</a></li></ul></li></ul></li></ul><!-- tocstop --><img src="https://s2.loli.net/2025/03/12/U4dGpMnVZgOzsvA.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1741776068525" style="zoom:67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1695021721029" style="zoom: 50%;"><h2><span id="通过man来了解任何命令">通过man来了解任何命令</span></h2><p>man命令可以访问linux系统的手册页，尤其是当你想要弄清命令行参数的时候，就可以查看对应的命令介绍来了解。</p><p>这对刚入门的新手是非常友好的，这里简单介绍一下man命令的使用以及效果，man使用格式如下：</p><pre><code class="language-sh">man  command-name</code></pre><p>我们最常用的ls命令来举例：</p><pre><code class="language-bash">man ls</code></pre><img src="https://s2.loli.net/2024/04/20/VGBnDJ6O9lhTWHq.png" alt="image-20240420160532398" style="zoom:67%;"><p>当使用man手册的时候实际上是linux的pager程序来显示的，分页显示是一种实用工具，能够逐页逐行显示文本，只需要使用<strong>Space</strong>来进行翻页或者<strong>Enter</strong>逐行查看，假设你使用仿真终端支持箭头翻阅,也可以使用<strong>箭头向前或者向后</strong>滚动手册页的内容，至于什么是仿真终端和真的终端有什么区别，详见上一篇。</p><p>向下翻页我们可以看到<strong>DESCRIPTION</strong>这一小节，浏览手册不是按部就班的学习而是作为快速参考来使用的，<strong>DESCRIPTION</strong>小节描述了这个命令的一般性描述。每一小节都有一定的内容，我们常用的小节有：</p><ul><li>SYNOPSIS：命令的语法</li><li>DESCRIPTION ：命令的一般性描述</li><li>OPTIONS ： 命令选项的描述</li></ul><p>一般来说命令的使用遵循：</p><pre><code class="language-bash">COMMAND-NAME [OPTION] ... [ARGUMENT]...</code></pre><p>OPTION 是用于修改命令的行为选项，可添加的OPTION 通常不只有一个，<code>[ ]</code>表明这内容不是必须的，<code>...</code>表明可以一次指定多个OPTION， <code>[ARGUMENT]</code>是传递给命令的参数，以指明命令的操作对象，从中括号可以看出，ARGUMENT也不是必选的，同时可以指定多个ARGUMENT来使用。</p><p>为了完整介绍命令的格式，我们再找来tar来举个例子，tar是用来归档和压缩的命令：</p><pre><code>tar {A|c|d|r|t|u|x}[GnSkUWOmpsMBiajJzZhPlRvwo] [ARG...]</code></pre><p><code>{ }</code>这一部分是必须的，大括号 <code>{ }</code> 通常表示一组选项或者占位符，用于表示替换选项或参数的选择，所以使用的时候必须要带上至少一个参数，后边的<code>[ ]</code>表明<code>GnSkUWOmpsMBiajJzZhPlRvwo</code>是作为可选参数被加入到命令之中的，相对的<code>A|c|d|r|t|u|x</code>是必选的，如果仔细看后边的<code>[ARG...]</code>也比较神奇，推测省略号是否在外面这两种写法没有太大区别，在全网也没有找到合适的解释，这里就暂且认为二者一致。</p><h3><span id="浏览文件系统">浏览文件系统</span></h3><p>我们使用ls的时候常常只是ls但是默认的ls显示的内容常常具有误导性，我们举个例子：</p><pre><code class="language-bash">Neo@Bionet:~$ ls cudnn-local-repo-ubuntu2204-9.0.0   Downloads   Public            snap              thinclient_drives Desktop                             Music       PycharmProjects  'Sunlogin Files'   Videos Documents                           Pictures    Share_Space       Templates         WorkSpaceNeo@Bionet:~$ ls -aFltotal 1420drwxr-x--- 41 Neo  Neo    4096  4月 20 14:43  ./drwxr-xr-x 45 root root   4096  4月 18 19:03  ../drwxrwxr-x  3 Neo  Neo    4096  3月 25 12:27  .anaconda/drwxrwxr-x  3 Neo  Neo    4096  3月 25 12:03  .astropy/-rw-------  1 Neo  Neo   27327  4月 20 16:09  .bash_history............................etc-rw-r--r--  1 Neo  Neo   24921  4月  3 15:03  .xorgxrdp.18.log.old</code></pre><p>ls带参数和不带参数二者有巨大的区别，我们通过man可以看到参数的意思如下：</p><pre><code class="language-bash">   -a, --all          do not ignore entries starting with .             -F, --classify          append indicator (one of */=&gt;@|) to entries             -l     use a long listing format      -h, --human-readable          with -l and -s, print sizes like 1K 234M 2G etc.</code></pre><ul><li>F 会在目录名之后添加/。在可执行文件之后添加*，以帮助用户区分对应的内容，但是对于彩色终端不同类型的文件有不同的颜色，所以这个可以省略</li><li>a 会显示隐藏文件</li><li>l 会以长列表的形式列出来所有文件及其信息。</li><li>h 会将显示的大小修改为人类可读的类型</li></ul><p>对于使用来说：</p><pre><code class="language-bash">ls -alh</code></pre><p>已经完全够用，且方便记忆。</p><h4><span id="l的长列表信息">l的长列表信息</span></h4><p>让我们来解析一下这里面的内容：</p><pre><code class="language-bash">drwxrwxr-x  3 Neo  Neo    4096  3月 25 12:27  .anaconda/</code></pre><ul><li>第1字母，d代表了文件的类型，比如目录（d），文件是（-）、链接文件（l）、字符设备（c）、块设备（b）。</li><li>第2-10的字母和数字，代表了读写权限，这一部分内容会留到权限篇章介绍，具体可先参看下图。</li><li>第11位的数字，代表了文件的硬链接数目，参看链接小节的内容。</li><li>后边的一组字符，代表了文件的属主。</li><li>后边的一组字符，代表了文件的属组。</li><li>然后是文件的大小，以字节的形式表示，这里表示目录本身的索引信息占据了4096个字节，并不是代表目录占据了4096字节。</li><li>文件的上次修改时间。</li><li>文件名或者目录名。</li></ul><img src="https://s2.loli.net/2024/03/24/oRCPZhtelAB8xuX.png" alt="image-20240324211953007" style="zoom:80%;"><h4><span id="过滤输出列表">过滤输出列表</span></h4><p>ls 默认情况下会显示所有非隐藏文件，但是有时候文件太多，我们就需要使用过滤器来实现过滤，过滤器是一个字符串，可用作简单的文本匹配，可将其作为命令行参数，放置在选项之后使用，举个例子：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ ls -alh pytorch221_cuda122-rw------- 1 root root 13G  3月 26 14:02 pytorch221_cuda122</code></pre><p>其基本格式如下：</p><pre><code class="language-bash">ls -alh Filename</code></pre><p>当然其威力不仅仅于此，对于filename，其支持标准通配符（wildcard），我们可以尝试如下例子：</p><pre><code class="language-bash">ls -alh pytor*</code></pre><p>当然效果上，我们可以看到：</p><img src="https://s2.loli.net/2024/04/20/cpw8xHgXouyKflU.png" alt="image-20240420203626775" style="zoom: 80%;"><p>也会将对应的文件显示出来，通配符也包括<code>？、[ ]、!</code> ,效果如下：</p><img src="https://s2.loli.net/2024/04/20/SHL1FUPydMYzukT.png" alt="image-20240420203943906" style="zoom:80%;"><p>当然匹配符有很多，这里就不再一一赘述。</p><img src="https://s2.loli.net/2024/04/20/Z98N1QBwkSfFdVU.png" alt="image-20240420204333227" style="zoom:80%;"><pre><code class="language-bash">Neo@Bionet:~/Desktop$ ls -alhitotal 13G26083455 drwxr-xr-x  2 Neo  Neo  4.0K  4月 20 22:23 .26083329 drwxr-x--- 43 Neo  Neo  4.0K  4月 20 22:28 ..26088183 -rw-r--r--  1 root root    7  4月 20 21:28 1.txt26086399 -rw-r--r--  1 root root    7  4月 20 21:33 2.txt26083364 -rwxrwxrwx  1 root root 1.4K  4月 20 18:39 creatematlab.sh26088522 -rwxrwxrwx  1 root root  571  4月  1 11:58 c.sh26084449 -rwxrwxrwx  1 Neo  Neo  1.7K  4月 11 17:16 devel_level.df26083390 lrwxrwxrwx  1 Neo  Neo    32  4月 20 22:23 ln_createusr -&gt; /home/some_scripts/createuser.sh26084386 -rw-------  1 root root  13G  3月 26 14:02 pytorch221_cuda122</code></pre><p><code>ls -alhi</code>中的i显示了inode编号，<strong>文件或目录的inode编号是内核分配给文件系统中每一个对象的唯一标识</strong>。</p><h2><span id="复制文件和目录">复制文件和目录</span></h2><p>cp命令是将文件和目录从文件系统的一个位置复制到另一个位置，其最基本的用法如下：</p><pre><code class="language-bash">cp --helpUsage: cp [OPTION]... [-T] SOURCE DEST  or:  cp [OPTION]... SOURCE... DIRECTORY  or:  cp [OPTION]... -t DIRECTORY SOURCE...Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.</code></pre><p>可以看到cp支持的表达式如下：</p><pre><code class="language-bash">cp [OPTION]... [-T] SOURCE DEST</code></pre><p>通常情况下，如果 <code>cp</code> 命令的目标路径是一个目录，则会将源文件复制到目标目录中。但是，如果你希望将源文件复制到一个普通文件中，并且目标路径可能会被解释为目录，那么你可以使用 <code>-T</code> 选项来强制 <code>cp</code> 将目标路径视为普通文件。</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ sudo cp -T 1.txt 2.txt</code></pre><p>需要注意的是这里的的复制指的是将1的内容直接覆盖到2上。如果需要强制询问是否需要覆盖已有文件：</p><pre><code class="language-bash">$ sudo cp -Ti  1.txt 2.txtcp: overwrite '2.txt'? y</code></pre><p>回答y之后就会覆盖，任何不是y的回答都取消覆盖。</p><pre><code class="language-bash">cp -Ri Share_Space/ newshare/</code></pre><p>会直接将<code>Share_Space/</code>的内容直接复制到新的文件夹<code>newshare/</code>当中，递归的包含所有的内容。</p><p>当然cp也支持使用通配符，举个例子，我们使用cp命令将当前目录下的所有sh脚本复制到路径/home/some_scripts/下中：</p><pre><code class="language-bash">:~/Desktop$ sudo cp -i ./*.sh /home/some_scripts/cp: overwrite '/home/some_scripts/creatematlab.sh'? ncp: overwrite '/home/some_scripts/createuser.sh'? ncp: overwrite '/home/some_scripts/c.sh'? n</code></pre><p>此操作会将桌面的所有sh脚本复制过去，因为我已经提前复制了，所以会一个一个询问是否要覆盖。</p><h2><span id="删除文件和文件夹">删除文件和文件夹</span></h2><p>linux中最常用且最危险的命令莫过于rm了。在linux中删除被叫做移除（removing）。bash shell 中用于删除文件的命令是rm。rm命令的基本格式非常简单：</p><pre><code class="language-bash">SYNOPSIS       rm [OPTION]... [FILE]...</code></pre><p>举个例子，我们查看当前目录下面的内容，并尝试删除一个文件：</p><p><img src="https://s2.loli.net/2024/05/03/CfWec4gY7jP3lDh.png" alt="image-20240503220346917"></p><p>可以看到有一个Dockerfile.swp文件这是一个缓存的交换文件，并没有什么用，我们将其删除：</p><pre><code class="language-bash">rm -i .Dockefile.swp</code></pre><p>删除之后我们可以看到：</p><p><img src="https://s2.loli.net/2024/05/03/bTzZSFigO7I3QaK.png" alt="image-20240503220637952"></p><p>此处加入i参数目的是为了提醒自己要删除对应的文件了，shell的删除命令并不存在垃圾箱这种东西，如果一旦不小心删除那么就永远也找不回来了，所以要养成加入i参数的好习惯。</p><p>rm的文件参数同时也支持通配符，也就是说可以通过rm一次性删除很多文件，这是非常有用的，当你想删除某一类文件的时候就可以使用：</p><pre><code class="language-bash">rm -i *.sh</code></pre><p>此操作会删除所有的sh脚本文件。</p><h3><span id="删除文件夹">删除文件夹</span></h3><p>对于非空目录rmdir命令足以，但是大多数情况下，目录中都有内容，我们就必须使用rm命令来实现了。</p><pre><code class="language-bash">rm -ri 目录名或路径 </code></pre><p><code>-r/R</code>（没错此处Rr效果是一样的）参数会向下进入到目录中将其内容全部删除，在这个过程中会一个一个询问你是否删除，如果不想这样，且确认数据真的没有用处了，我们可以选择<code>-rf</code>参数。</p><p>效果如下，有以下文件夹：</p><p><img src="https://s2.loli.net/2024/05/03/mcAO758vHoQZ2gI.png" alt="image-20240503223624129"></p><p>使用命令进入删除：</p><p><img src="https://s2.loli.net/2024/05/03/G3W4wgqejYERMJp.png" alt="image-20240503223554291"></p><h2><span id="链接文件">链接文件</span></h2><p>链接文件可以说是linux系统的优势，如果需要在系统中维护同一个文件的两个或者多个副本的时候可以使用单个物理副本+多个虚拟副本(链接)的方法代替创建多个物理副本，链接是目录中指向文件真实位置的占位符，在linux中有两种类型的文件链接：</p><ul><li>符号链接（软连接）</li><li>硬链接</li></ul><p>创建链接的命令如下：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ ln --helpUsage: ln [OPTION]... [-T] TARGET LINK_NAME  or:  ln [OPTION]... TARGET  or:  ln [OPTION]... TARGET... DIRECTORY  or:  ln [OPTION]... -t DIRECTORY TARGET...In the 1st form, create a link to TARGET with the name LINK_NAME.In the 2nd form, create a link to TARGET in the current directory.In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.Create hard links by default, symbolic links with --symbolic</code></pre><p>可以看到不仅可以创造针对文件的链接，也可以创造针对目录的链接。</p><h3><span id="符号链接软连接">符号链接（软连接）</span></h3><p>符号链接是一个实实在在的文件，只不过文件的内容是指向的是虚拟文件系统中的另一个地方的文件，这两个以符号方式连接在一起的文件彼此的内容并不相同。</p><p>举个例子，我们将刚刚复制的脚本在桌面删除，然后以不同的方式链接回来看看。</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ sudo rm ./createuser.sh Neo@Bionet:~/Desktop$ ln -s /home/some_scripts/createuser.sh ./ln_createusr# 链接完成之后，显示当前实际上是一个链接文件：Neo@Bionet:~/Desktop$ ls -alhlrwxrwxrwx  1 Neo  Neo    32  4月 20 22:23 ln_createusr -&gt; /home/some_scripts/createuser.sh# 源文件并没有任何变换：Neo@Bionet:~/Desktop$ ls -alh /home/some_scripts/createuser.sh -rwxr-xr-x 1 root root 859  4月 20 22:07 /home/some_scripts/createuser.sh</code></pre><p>可以看到通过命令：</p><pre><code class="language-bash">ln -s /home/some_scripts/createuser.sh ./ln_createusr</code></pre><p>我们创造了一个从对应目录下的文件的软连接到桌面的一个新文件叫<code>ln_createusr</code>。</p><p>使用ls来查看的时候其文件名部分被替换成了<code>ln_createusr -&gt; /home/some_scripts/createuser.sh</code>的内容，而不是本身的文件名，这里的 <code>-&gt;</code>代表了该文件是连接到文件<code>/home/some_scripts/createuser.sh</code>的一个符号链接。</p><p>我们通过上文中两个 <code>ls -alh</code>文件看到，两个文件的大小并不相同，源文件有859个字节，而链接文件只有32个字节</p><p>而我们尝试打开链接文件，可以看到：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ vim ./ln_createusr </code></pre><img src="https://s2.loli.net/2024/04/20/SUrzaQJtpcmqbwk.png" alt="image-20240420224944397" style="zoom:67%;"><p>显示内容和源文件保持一致。当我们尝试修改的时候因为源文件权限的问题，无法修改：</p><img src="https://s2.loli.net/2024/04/20/YwyBM5mHhdxNeJV.png" alt="image-20240420225031627" style="zoom:67%;"><p>当我们修改权限以后：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ sudo chmod 777 /home/some_scripts/createuser.sh </code></pre><p>文件就可以正常修改了，这里说明链接文件的权限取决于源文件，二者的权限保持一致。</p><h3><span id="硬链接">硬链接</span></h3><p>硬链接创建的是一个独立的虚拟文件，其中包含了原始文件的信息和位置，但是二者本质上是同一个文件，这是和符号链接的最大区别。</p><p>我们再举一个例子：同样将上文中复制的文件从桌面删除再以硬连接的方式连接回来。</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ rm ./creatematlab.sh     Neo@Bionet:~/Desktop$ sudo ln /home/some_scripts/creatematlab.sh  ln_creatematlabNeo@Bionet:~/Desktop$ ls -alhi109051906 -rwxr-xr-x  2 root root 1.4K  4月 20 22:07 ln_creatematlabNeo@Bionet:~/Desktop$ ls -alhi /home/some_scripts/creatematlab.sh 109051906 -rwxr-xr-x 2 root root 1.4K  4月 20 22:07 /home/some_scripts/creatematlab.sh</code></pre><p>通过<code>sudo ln /home/some_scripts/creatematlab.sh  ln_creatematlab</code>创建链接之后，我们可以看到：</p><p>二者共用一个inode号码，说明二者是一个文件。省略参数的情况下，其意思是默认在当前目录这里创建一个名字一样的硬链接，虽然下图创建失败了，但是其详细展示了创建的内容：</p><p><img src="https://s2.loli.net/2024/05/03/txdviqWJwUNMjRz.png" alt="image-20240503213411568"></p><h3><span id="软连接和硬连接的区别">软连接和硬连接的区别</span></h3><ol><li><strong>软连接（Symbolic Link）</strong>：<ul><li>软连接类似于Windows系统中的快捷方式（Shortcut）。</li><li>它是一个特殊的文件，包含了对另一个文件或目录的引用路径。</li><li>软连接不依赖于原始文件的文件名，即使原始文件被移动或重命名，软连接依然有效。</li><li>软连接可以跨文件系统，即可以链接到不同文件系统中的文件。</li><li>删除原始文件会导致软连接失效，因为它只是指向原始文件的一个路径。</li></ul></li><li><strong>硬连接（Hard Link）</strong>：<ul><li>硬连接直接指向文件的物理位置，即文件的inode节点。</li><li>硬连接与原始文件共享同一个inode，因此它们实际上是同一个文件。</li><li>硬连接不能跨文件系统，只能在同一文件系统中创建。</li><li>硬连接不能链接到目录，只能链接到文件。</li><li>删除原始文件不会影响硬连接，因为只要有一个硬连接存在，文件内容就不会被删除。</li></ul></li></ol><p>硬链接（Hard Link）不会占用两倍的空间。实际上，硬链接与原始文件共享相同的存储空间，它们指向同一个inode节点。这意味着，无论有多少个硬链接指向同一个文件，它们都只占用原始文件所占用的存储空间。</p><p>在UNIX和类UNIX系统中，文件的内容和文件的元数据（如文件名、权限、所有者等）是分开存储的。文件的内容存储在数据块中，而元数据存储在inode节点中。硬链接和原始文件都指向同一个inode节点，因此它们共享相同的数据块。</p><p>举个例子我想查看如何使用 tar 命令进行归档的压缩和解压就可以使用：</p><pre><code class="language-shell">man tar</code></pre><p>效果如下：</p><img src="https://s2.loli.net/2024/04/20/jqhmYyKxe3lD5gT.png" alt="image-20240420145521695" style="zoom:67%;"><img src="https://s2.loli.net/2024/04/20/W4yvErVod9tN58c.png" alt="image-20240420150802190" style="zoom:67%;"><p>这里tar的语法描述如下：</p><pre><code class="language-shell">SYNOPSIS   Traditional usage       tar {A|c|d|r|t|u|x}[GnSkUWOmpsMBiajJzZhPlRvwo] [ARG...]          UNIX-style usage       tar -A [OPTIONS] ARCHIVE ARCHIVE.......       tar -x [-f ARCHIVE] [OPTIONS] [MEMBER...]   GNU-style usage       tar --create [--file ARCHIVE] [OPTIONS] [FILE...].......       tar {--extract|--get} [-f ARCHIVE] [OPTIONS] [MEMBER...]</code></pre><p>这一部分描述了常用的方式：</p><pre><code class="language-bash">Traditional usage       tar {A|c|d|r|t|u|x}[GnSkUWOmpsMBiajJzZhPlRvwo] [ARG...]</code></pre><p>参数了解之后，可以看看这些参数有什么用：</p><p>关于参数的内容linux的运行手册有的内容非常多而且不一致，我们可以换个方式来快速查看， 大多数命令都支持-h选项来实现，更快速的信息获取：</p><pre><code class="language-shell">Neo@Bionet:~/Desktop$ tar --helpUsage: tar [OPTION...] [FILE]...GNU 'tar' saves many files together into a single tape or disk archive, and canrestore individual files from the archive.Examples:  tar -cf archive.tar foo bar  # Create archive.tar from files foo and bar.  tar -tvf archive.tar         # List all files in archive.tar verbosely.  tar -xf archive.tar          # Extract all files from archive.tar. Main operation mode:  -A, --catenate, --concatenate   append tar files to an archive  -c, --create               create a new archive      --delete               delete from the archive (not on mag tapes!)  -d, --diff, --compare      find differences between archive and file system  -r, --append               append files to the end of an archive      --test-label           test the archive volume label and exit  -t, --list                 list the contents of an archive  -u, --update               only append files newer than copy in archive  -x, --extract, --get       extract files from an archive Operation modifiers:      --check-device         check device numbers when creating incremental                             archives (default)  -g, --listed-incremental=FILE   handle new GNU-format incremental backup  -G, --incremental          handle old GNU-format incremental backup      --hole-detection=TYPE  technique to detect holes      --ignore-failed-read   do not exit with nonzero on unreadable files      --level=NUMBER         dump level for created listed-incremental archive      --no-check-device      do not check device numbers when creating                             incremental archives</code></pre><p>获取的信息，截取了一部分，这样就避免了翻页程序过于正式的效果，反而看清楚该如何使用命令。</p><p>我们找到解压的参数 <code>-x</code>作为主参数，同时浏览一下常用的vf参数是什么意思：</p><p><code>-f, --file=ARCHIVE         use archive file or device ARCHIVE</code></p><h2><span id="查看文件">查看文件</span></h2><p>查看文件是linux最重要的特性，有了这些查看命令的支持，相较于windows那些操作系统，在有大文件的时候linux不仅能打开，并且能快速查看当中的内容。</p><p>当你手头有一个很大的文本文件，你可能会想看一看到底是什么，linux有几个经典的命令来实现这个操作，我们只介绍当中比较常用的命令。</p><h3><span id="cat命令">cat命令</span></h3><p>cat命令是最基础的文件探查命令，当你查找资料的时候经常能看到，所以这里介绍一下：</p><p>我们有一个test文件里面包含多行的内容：</p><img src="https://s2.loli.net/2024/05/03/f6vskCKxOaSPNY9.png" alt="image-20240503230813839" style="zoom: 80%;"><p>我们使用cat来查看一下：</p><pre><code class="language-bash">cat -n test</code></pre><p>效果如下：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop$ cat -n test     1123456     212345     31234     4123     512     61     7     8</code></pre><p>这里就没有什么特别的，其显示的内容就是对应的信息，其中有多种变形的参数，这里<code>-n</code>代表显示行号，同时还有<code>-b</code>选项只给有文本的行加上行号，效果如下：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop$ cat -b test     1123456     212345     31234     4123     512     61neo@NeoNeuxs:~/Desktop$ </code></pre><p>对于cat来说当其应对大文件尤其是超大文件的时候他会不停的刷新模拟终端的内容来显示，我们无法查看到底有什么，为了解决这个问题我们可以使用less。</p><p>less命令提供了非常多的实用特性，能够实现文本文件中的前后翻动，还有一些高级搜索功能。最主要的是less能够实现在完全读取文件之前，显示文件的部分内容，cat和more是无法实现的，为了验证这个功能我们来找一个大的文件来进行操作，</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop/PTM/Dataset/uniprot$ less ./uniprotkb_AND_reviewed_true_AND_model_o_2024_04_25.tsv </code></pre><p>uniprotkb是一个蛋白质库，其中记录了许多蛋白质序列，我们使用less来查看里面的内容，显示如下：</p><p><img src="https://s2.loli.net/2024/05/03/abhLBQX83YleS9O.png" alt="image-20240503232813500"></p><p>由于数据的每一行都非长的长，当达到屏幕极限的时候就会换行，less是按页来显示的，我们可以通过键盘的pgup、pgdn，或者空格来翻页查看，其加载速度并不取决于文件大小而在于每一页的内容，这样当你使用vcode、等编辑器无法一下打开查看信息的时候就是less大发神威的时候，如下图，此文件达到了100多MB,算是比较小的，但是使用其他文件阅读器打开还是比较慢，less在一瞬间就可以打开，并查看其中的内容。</p><img src="https://s2.loli.net/2024/05/03/BlaurX6792TROQf.png" alt="image-20240503233216985" style="zoom:67%;"><p><img src="https://s2.loli.net/2024/05/03/J8RSrN1jftEz9Ls.png" alt="image-20240503233340449"></p><h3><span id="只查看文件部分内容">只查看文件部分内容</span></h3><p>你需要查看的文件有时候经常位于文件的开头或者结尾，当文件很大的时候，你就只能干等着cat或more来载入整个文件，当然linux也提供了专门的命令来解决这个问题，下面就会介绍 tail、head命令。</p><h4><span id="查看文件末尾tail命令">查看文件末尾（tail命令）</span></h4><p>tail命令会显示文件的末尾的内容，默认情况下会显示文件末尾的最后10行，我们还是使用刚才的文件来检测：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop/PTM/Dataset/uniprot$ tail ./dbPTM_PhosphorylationZO3_HUMANO95049919Phosphorylation18669648KKFMRVHDAESSDEDGYDWGPZO3_HUMANO95049920Phosphorylation18669648KFMRVHDAESSDEDGYDWGPAZO3_HUMANO95049925Phosphorylation18669648HDAESSDEDGYDWGPATDL--ZRAB2_HUMANO95218-29Phosphorylation18669648--MSTKNFRVSDGDWICPDKKZRAB2_HUMANO95218-2114Phosphorylation18669648GGFNERENVEYIEREESDGEYZRAB2_HUMANO95218-2120Phosphorylation18669648ENVEYIEREESDGEYDEFGRKZRAB2_HUMANO95218-2153Phosphorylation18669648SILKEVEDKESEGEEEDEDEDZRAB2_HUMANO95218-2181Phosphorylation18669648EDEDEDDADLSKYNLDASEEEZRAB2_HUMANO95218-2183Phosphorylation18669648EDEDDADLSKYNLDASEEEDSZRAB2_HUMANO95218-2188Phosphorylation18669648ADLSKYNLDASEEEDSNKKKS</code></pre><p><code>-n</code>可以显示指定行数，效果如下：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop/PTM/Dataset/uniprot$ tail -n 1 ./dbPTM_PhosphorylationZRAB2_HUMANO95218-2188Phosphorylation18669648ADLSKYNLDASEEEDSNKKKS</code></pre><p><strong>tail最重要的参数是<code>-f</code>其可以实现在线刷新的效果，当有新的数据写到文件的时候会自动刷新。</strong></p><h4><span id="查看文件头部head命令">查看文件头部（head命令）</span></h4><p>head命令的使用方式几乎和tail一样，只不过显示的内容是头部的，相同的命令参数-n也可以指定当前显示的行数。</p><p><img src="https://s2.loli.net/2024/05/04/CqGdyjZbElXwSum.png" alt="image-20240504003518940"></p>]]></content>
    
    
    <summary type="html">man/cp/tar/ls/ln/cat/tail/head/less command introducation</summary>
    
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Bash Shell 脚本入门（1）——Linux内核功能介绍</title>
    <link href="http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/"/>
    <id>http://neonexusx.github.io/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/</id>
    <published>2025-03-12T10:37:00.000Z</published>
    <updated>2025-11-28T07:17:01.836Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux-bash-shell-脚本入门1linux内核功能介绍">Linux Bash Shell 脚本入门（1）——Linux内核功能介绍</span></h1><p>[TOC]</p><!-- toc --><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#linux%E5%88%9D%E6%8E%A2">Linux初探</a><ul><li><a href="#linux%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84">Linux系统架构</a></li><li><a href="#linux-%E5%86%85%E6%A0%B8">linux 内核</a><ul><li><a href="#%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">系统内存管理</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86">软件程序管理</a></li><li><a href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86">硬件设备管理</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">文件管理系统</a></li></ul></li></ul></li></ul><!-- tocstop --><img src="https://s2.loli.net/2025/03/12/ns1Fc3hg9ztLBpY.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1741766727606" style="zoom:67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1695021721029" style="zoom: 50%;"><h2><span id="前言">前言</span></h2><p>本文为《Linux命令行与shell脚本编程大全》第四版的读书笔记，突发奇想想看看这本书，实际上是图书馆关于Linux的书正好就这一本了，没想到看起来还不错，遂借出来看看。</p><p>Linux算是接触的比较多了，虽然接触了很多但是并不明白其原理和架构是怎么样的，整本书包含了部分linux架构的内容，重点在于shell脚本编写实战，这个非常重要，能够书写bash脚本，在某些时候能达到事半功倍的效果，同时对系统的维护工作也是有益的。</p><h2><span id="linux初探">Linux初探</span></h2><h3><span id="linux系统架构">Linux系统架构</span></h3><p>Linux系统有很多版本，我们常见的是Ubuntu、Debian等等，这些版本大同小异，但最关键的系统架构是几乎一致的，一般发行版的linux系统由四部分组成：</p><ul><li>Linux内核</li><li>GNU工具</li><li>图形化桌面环境</li><li>应用软件</li></ul><p>每一部分都有各自的职责，实际上是一个层次结构的关系，如下图所示：</p><pre class="mermaid">graph TB;A("应用程序软件") &lt;--&gt; E("窗口管理软件")E&lt;--&gt; B("GNU系统工具")  C &lt;--&gt; E("窗口管理软件(图形化桌面环境)")B &lt;--&gt; C("Linux内核")C &lt;--&gt; D("计算机硬件")</pre><h3><span id="linux-内核">linux 内核</span></h3><p>linux系统的核心就是linux内核，创始人linus在赫尔辛基大学上学的时候就开发了第一版linux内核，目前他主要负责编写和审阅linux内核的代码，时至今日linux的开发仍遵循这一思路，只不过不仅仅是linus一个人来进行，目前有一组开发人员负责这项任务。</p><p>内核主要负责的功能有：</p><ul><li>系统内存管理</li><li>软件程序管理</li><li>硬件设备管理</li><li>文件系统管理</li></ul><h4><span id="系统内存管理">系统内存管理</span></h4><p>linux系统的内存管理，不仅仅在于物理内存，还可以创建并管理虚拟内存，内核通过硬盘上称为交换空间来实现虚拟内存，内核通过在实际物理内存和虚拟内存之间不停的交换，来使系统的内存容量扩大到远大于物理内存的大小，内核会将内存划分为若干页，内核会将每个内存页面置于物理内存或者交换内存之中。内核会维护一张内存页面表，指明那些页面位于物理内存，那些页面被交换到了磁盘。</p><p>内核会记录哪些内存页面正在使用中，自动把一段时间为访问的内存页面复制到交换区域（这操作称为换出，swapping out），当程序要访问一个已经被换出的内存页面，内核就会将物理内存中的另一个页面换出来为其腾出空间，然后从交换空间实行换入操作（swapping in）。显然，这个过程取决于硬盘的读写性能上限和当前的运行状态中是否有较高的读写占用，一般来说这个换入和换出的操作会拖慢程序的运行速度，只要linux系统在运行这个过程就不会停止，因为内核会将长时间不用的内存页面换出，即使当前还有内存可以使用。</p><p>关于系统的交换分区和交换文件的设置，可以参考本人另一篇文章：<a href="https://www.cnblogs.com/NeoNexus/p/17999581">Ubuntu22.04 &amp; Win11 双系统hibernate冷切换实现</a>，里面详细讲述了交换文件和交换分区的内容，并由此为引子实现了双系统的冷切换操作。</p><h4><span id="软件程序管理">软件程序管理</span></h4><p>Linux下运行的程序被称为进程，进程可以在前台运行，显示在屏幕之上，也可以后台运行，隐藏到幕后。内核控制Linux系统如何管理运行在系统中的所有进程。</p><p>内核通过创建init进程来启动系统中所有的其他进程，当内核启动的时候，它会将init进程载入到虚拟内存。内核启动进程的时候，会在虚拟内存中分配一块专有区域，来存储进程用到的数据和代码。</p><p>在linux中，有很多init进程实现的方式，目前最流行的有一下两种：</p><ul><li>SysVinit：Linux最初使用的就是这种方法，该方法基于Unix System V初始方法，目前很多发行版已经不再使用了，但在一些旧的Linux发行版中还能找到其身影。</li><li>systemd：systemd初始化方法诞生于2010年，systemd不仅包含初始化过程，同时包含进程管理的功能。</li></ul><p>关于SysVinit初始化方法已经被淘汰，这里就主要介绍systemd的方法，systemd进步在于能够依据不同的事件启动进程，比如一下事件：</p><ul><li>系统启动时</li><li>连接到特定的硬件设备时</li><li>服务启动时</li><li>建立好网络连接时</li><li>计时器到期时</li></ul><p>systemd方法通过将事件与单元文件（Unit file）链接来决定运行哪些进程，每个单元文件定义了特定事件发生时要启动的程序。</p><p>Unit 文件是 systemd 管理资源的基本单位，定义了如何控制一个**服务（Service）、设备（Device）、挂载点（Mount）、定时器（Timer）**等。</p><ul><li>每个 Unit 文件对应一种资源，例如：<ul><li><code>nginx.service</code>（服务）</li><li><code>home.mount</code>（挂载点）</li><li><code>graphical.target</code>（目标）</li></ul></li></ul><p>systemctl程序允许启动、停止和列出系统中当前运行的单元文件。</p><pre><code class="language-shell">systemctl list-units --type=service</code></pre><img src="https://s2.loli.net/2024/02/11/H57EPWd2tYDxXkG.png" alt="image-20240211125107649" style="zoom:80%;"><p>systemd方法将单元文件划归为目标（target），目标定义了Linux系统的特定状态，在某个目标（target）中就包含了很多单元文件（Unit file），需要注意的是target文件本身就是一种Unit文件类型，二者并不是从属关系的存在。</p><p>比如在系统启动的时候，default.target单元定义了要启动的所有单元文件，可以使用systemctl命令查看当前默认目标：</p><pre><code class="language-shell">neo@NeoNeuxs:/etc$ systemctl get-defaultgraphical.target</code></pre><p>graphical.target单元文件定义了多用户图形 环境运行时要启动的进程。</p><p>这里我们使用systemctl 来启动一个服务，这里的服务是一个云盘的挂载软件：</p><pre><code class="language-shell">systemctl enable --now clouddrive.serviceFailed to enable unit: Unit file clouddrive.service does not exist.</code></pre><p>可以看到报错，没有找到对应的service的Unit单元文件。</p><h4><span id="硬件设备管理">硬件设备管理</span></h4><p>所谓硬件设备管理，就是通过对应的硬件的驱动，来完成硬件和内核的数据交互。</p><p>Linux系统将硬件设备视为一种特殊文件，称为设备文件。设备文件分为3种：</p><ul><li>字符设备文件：对应每次只能处理一个字符的设备，大多数类型的调制解调器和终端是作为字符设备文件创建的。</li><li>块设备文件：对应于每次以块的形式处理数据的设备，比如硬盘。</li><li>网络设备文件：对应于采用数据包发送和接受数据的设备，包含网卡和本地的网络回环设备。网络回环对应的是linux系统允许以常规网络编程的方式同自身通信一般地址127.0.0.1</li></ul><p>Linux会为每一个设备创建一种节点的特殊文件，与设备所有的通信都是通过设备节点完成的，每个节点都有一个唯一的数值对，来供linux内核标识，数值对包括一个主设备号和一个次设备号，类似的设备会被划分到主设备号下面，次设备号用于标识主设备下某个特定的设备。</p><p>例如，如果你有多个SATA硬盘，它们会共享相同的主设备号，但每个硬盘会有不同的次设备号来区分。</p><h4><span id="文件管理系统">文件管理系统</span></h4><p>Linux内核支持多种类型数据的读取，同时支持读写其他操作系统的的文件系统，内核必须在编译时就加入对所有要用到的文件系统的支持。常见的文件系统有：</p><ul><li>EXT1-4: ext是Linux扩展文件系统，最早的Linux文件系统，后续推出了ext2、ext3、ext4,ext4是目前常用的文件系统，支持高级日志功能。</li><li>EXFAT：扩展windos文件系统，常用于大容量移动设备。</li><li>NTFS：NTFS（New Technology File System）是由Microsoft开发的一个文件系统，最初在Windows NT 3.1中引入，并在后续的Windows操作系统中得到广泛应用，包括Windows 2000、Windows XP、Windows Vista、Windows 7、Windows 8、Windows 10以及Windows Server系列。NTFS替代了之前的FAT（File Allocation Table）和HPFS（High Performance File System）文件系统，提供了许多改进和新特性</li><li>SMB：最初由IBM开发，后来由Microsoft进一步扩展和标准化，成为Windows网络环境中文件和打印服务的核心协议。SMB工作在客户端/服务器模型上，允许客户端（通常是计算机或移动设备）通过发送请求消息给服务器（通常是文件服务器或打印服务器）来访问网络上的资源。服务器接收到请求后，处理请求并返回相应的响应给客户端。因此常被用来作为网络硬盘的功能。</li></ul><p>内核采用虚拟文件系统作为和各种文件系统互相交互的接口，linux内核与其他类型的文件系统之间的通信提供了一个标准接口，当文件系统被挂载和使用的时候，VFS会在内存中缓存相关信息。</p>]]></content>
    
    
    <summary type="html">Linux core介绍</summary>
    
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://neonexusx.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>JaP Photo Album (Part One) -- Asakusa</title>
    <link href="http://neonexusx.github.io/2024/12/12/JaP_Photo_Album(1)/"/>
    <id>http://neonexusx.github.io/2024/12/12/JaP_Photo_Album(1)/</id>
    <published>2024-12-12T10:37:00.000Z</published>
    <updated>2025-12-30T14:10:50.766Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="jap影集壹浅草">JaP影集（壹）–浅草</span></h1><p>不做任何评价，没有政治观点，屏蔽所有人物信息。</p><img src="https://s2.loli.net/2024/10/03/1wLtRXqNyoTaH2M.png" alt="image-20241003015854172" style="zoom:80%;"><p>[TOC]</p><h2><span id="东京">东京</span></h2><p>成田机场至东京市中心路上的广告，其实是个很魔性的视频我只拍了结尾：</p><img src="https://s2.loli.net/2024/10/02/hwA1o2YdsqcpxGj.jpg" alt="IMG_6151" style="zoom: 50%;"><p>和某国一样多的肛肠科广告，当然目的还是拍摄很多的太阳能板和日本帅哥：</p><img src="https://s2.loli.net/2024/10/03/t5FfVXugaC1TEne.jpg" alt="IMG_6154" style="zoom:80%;"><h3><span id="浅草寺周围及浅草寺">浅草寺周围及浅草寺</span></h3><p>浅草寺正大门：</p><p>雷门是公元942年为祈求天下太平和五谷丰登而建造的。几经火灾焚毁，后于1960年重建。雷门<a href="https://baike.baidu.com/item/%E6%AD%A3%E9%97%A8/8500116?fromModule=lemma_inlink">正门</a>入口处左右威风凛凛的风神和雷神二将，镇守着浅草寺。</p><img src="https://s2.loli.net/2024/10/03/iMDg6vj53AQFnKR.jpg" alt="IMG_6156" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/ZQGOdluv9KEARXj.jpg" alt="IMG_6157" style="zoom:80%;"><p>浅草寺西南角有一座五重塔，仅次于京都<a href="https://baike.baidu.com/item/%E4%B8%9C%E5%AF%BA/1865740?fromModule=lemma_inlink">东寺</a>的五重塔，为日本第二高佛塔，正午12点左右：</p><img src="https://s2.loli.net/2024/10/03/cKr1XMoAfql6ZYF.jpg" alt="IMG_6158" style="zoom:80%;"><p>由于我居住在浅草寺周围，所以有难得一见的夜景：</p><img src="https://s2.loli.net/2024/10/03/JOc2vbNEdlHnh9a.jpg" alt="IMG_20240217_204658" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/nKmWSAqkfjrI35o.jpg" alt="IMG_20240217_204701" style="zoom:80%;"><p>正门拍摄的人和正门的大灯笼：</p><img src="https://s2.loli.net/2024/10/03/xm2PLWDpyQAqs7o.jpg" alt="IMG_20240217_204834" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/1cRSbwU6mLjAdlH.jpg" alt="IMG_20240217_204804" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/HxvUW6ubA3dlB2Q.jpg" alt="IMG_20240217_205633" style="zoom:80%;"><p>五重塔正门：</p><img src="https://s2.loli.net/2024/10/03/3Ow5BinSpUdhgfF.jpg" alt="IMG_20240217_205044" style="zoom:80%;"><p>浅草寺售卖的御守，护身符：</p><img src="https://s2.loli.net/2024/10/03/VMRJZnHdbrItoy5.jpg" alt="IMG_20240219_121837" style="zoom:80%;"><p>浅草寺有名的出抽签，投入100就可以选一个：</p><img src="https://s2.loli.net/2024/10/03/x43KT8ogEvktJ7H.jpg" alt="IMG_20240222_123720" style="zoom: 80%;"><p>如果抽到不好的签需要邦上去，但是我抽了两次（五天路过又来了一次），都是吉：</p><img src="https://s2.loli.net/2024/10/03/7x6TCyAbK4BuV89.jpg" alt="IMG_20240222_124247" style="zoom:80%;"><p>浅草周围的商业圈和卖场夜晚：</p><img src="https://s2.loli.net/2024/10/03/nuziZBa9Wd8jICm.jpg" alt="IMG_20240218_224417" style="zoom:80%;"><p>需要说明的是，这里正好是地铁站，福州等也有很类似的商业街。</p><img src="https://s2.loli.net/2024/10/03/AfRxPXqnzOLt1KD.jpg" alt="IMG_20240218_224850" style="zoom:80%;"><p>浅草五丁目：</p><img src="https://s2.loli.net/2024/10/03/awKCQROzqVxSn3U.jpg" alt="IMG_6169" style="zoom:80%;"><p>浅草五丁目，一路向前就是浅草寺：</p><img src="https://s2.loli.net/2024/10/03/uaFxLvIG8s4jKTr.jpg" alt="IMG_6170" style="zoom:80%;"><p>路过的日共海报：</p><img src="https://s2.loli.net/2024/10/03/CAjgESHDUXBr169.jpg" alt="IMG_6168" style="zoom:80%;"><p>浅草寺后广场，可以看到晴空塔：</p><p>受拍摄设备限制，比较糊：</p><img src="https://s2.loli.net/2024/10/03/heHKdntbCyTf4k8.jpg" alt="IMG_20240219_204823" style="zoom:80%;"><p>我住在浅草寺后面的居民区，晚上有人在维修道路，可以看到一个圈有好几个维护人，不作评价：</p><img src="https://s2.loli.net/2024/10/03/wXIcJWmsdSHnRGE.jpg" alt="IMG_20240218_231242" style="zoom:80%;"><p>路过一个小学的课后教室：</p><img src="https://s2.loli.net/2024/10/03/c8TXPiryzHkbtIO.jpg" alt="IMG_20240219_210136" style="zoom:80%;"><p>使用胶片拍摄的，由于我是胶片新手，曝光没有控制好，就在这个教室旁边，有一个很日本的摇篮：</p><p>条纹是由于x光导致的，海关的X光。</p><img src="https://s2.loli.net/2024/10/03/1COhr2SPaGbzBVf.png" alt="image-20241003012607161" style="zoom:80%;"><p>过了几个路口，就到了我住的红灯区：没错你没听错，这里确实是有名的红灯区，夜晚都是来找送人的出租车，这里是红灯区和居民区的分界线：</p><img src="https://s2.loli.net/2024/10/03/gwnqDGPX7pYuc5x.jpg" alt="IMG_20240219_210524" style="zoom:80%;"><p>路过的红灯区：</p><img src="https://s2.loli.net/2024/10/03/l1KI7BCqFfEQMbh.jpg" alt="IMG_20240218_232514" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/5bxnGDwYPAltF3a.jpg" alt="IMG_20240222_112047" style="zoom:80%;"><p>很暴露的写真广告：</p><img src="https://s2.loli.net/2024/10/03/Zwep5SivbmTAECY.jpg" alt="IMG_20240220_220132" style="zoom:80%;"><p>迷路的时候看到的炸鸡店，最后没找到去吃：</p><img src="https://s2.loli.net/2024/10/03/3qVHR58gDUyQv1j.jpg" alt="IMG_20240220_213604" style="zoom:80%;"><p>迷路的时候路过的吉原神社，门口有一个洗手池子：</p><img src="https://s2.loli.net/2024/10/03/kuCvtG79b6DNgQY.jpg" alt="IMG_6164" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/LeGwhAW6U3uHMbv.jpg" alt="IMG_6165" style="zoom:80%;"><p>红灯区的牌坊，反黑帮证，很资本主义：</p><img src="https://s2.loli.net/2024/10/03/ERWYsKaNkwVnHLP.jpg" alt="IMG_6160" style="zoom:80%;"><p>浅草寺周围的拉面店里，这时我在日本吃的第一餐，使用富士的一次性胶片相机拍摄，屏蔽了人物信息。</p><p><img src="https://s2.loli.net/2024/10/03/c8FANdBHSYGjMRi.png" alt="image-20241003004626915"></p><p>第一顿饭永远是最香的：</p><p>浅草寺五丁目往前走，的一家酱油拉面店，非常好吃，第一次使用售票机购餐，由于在店里面不方便拍摄，只留下了最珍贵的两张，餐厅是那种开放式的，购买餐券之后交给厨师，英语交流也很ok毕竟是在景区周围：</p><img src="https://s2.loli.net/2024/10/03/a86mRTjiycQK5ve.jpg" alt="IMG_6161" style="zoom:80%;"><p>这家拉面店对面的另外一家拉面，拉面大多数都是猪骨熬汤，这家店比较特殊，当然价格也比较贵：</p><img src="https://s2.loli.net/2024/10/03/xJunIHf3ZoDvUdE.jpg" alt="IMG_6171" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/b4v5NEISTHVJFPc.jpg" alt="IMG_6172" style="zoom:80%;"><p>周围卖的小吃，玉团子，其实就是年糕外边裹了糖浆，很粘牙：</p><p><img src="https://s2.loli.net/2024/10/03/rSadwgDNj1fp53U.png" alt="image-20241003011339841"></p><p>吃旋转寿司：</p><img src="https://s2.loli.net/2024/10/03/x2vNWY3Gud7hcsz.jpg" alt="IMG_20240218_123432" style="zoom:80%;"><p><img src="https://s2.loli.net/2024/10/03/Kk5r8s2nMHDUgu3.png" alt="image-20241003021246348"></p><p>两个人吃的还不少：</p><img src="https://s2.loli.net/2024/10/03/x7l9JQr5TPFY4wt.jpg" alt="IMG_20240218_130359" style="zoom:80%;"><p>晚上在浅草寺周围商圈的居酒屋，喝啤酒，进去之后店员看我年龄很小，很奇怪hhh，点餐用的APP，这是唯一一个在日本见到可以用app点餐的。</p><img src="https://s2.loli.net/2024/10/03/eMw4pQybc5A6GLm.jpg" alt="IMG_20240219_200430" style="zoom:80%;"><p>啤酒很爽口，但烤肉很咸：</p><img src="https://s2.loli.net/2024/10/03/olLcGiVKDMYItnp.jpg" alt="IMG_20240219_201847" style="zoom:80%;"><p>路过一家卖烤饭的店，很有特色的是他们家把套餐的所有都做成模型来展示：</p><img src="https://s2.loli.net/2024/10/03/5Albry8ST1DezaO.jpg" alt="IMG_20240220_202357" style="zoom:80%;"><p>看起来很少，吃起来竟然是很饱。有一说一这个价格在这地段很不错了，米也比国内大部分店里面的更好吃。</p><p><img src="https://s2.loli.net/2024/10/03/HqEivJu7wkdnKbW.jpg" alt="IMG_20240220_203651"></p><p>第二天路过的时候又去吃了一次，不仅是好吃，店员有个很卡哇伊的。</p><img src="https://s2.loli.net/2024/10/03/DhL5lsZyYzJGErk.jpg" alt="IMG_20240221_113049" style="zoom:80%;"><p>浅草寺周围有一个唐吉克德，就是日本开的和比较多的超市大卖场：</p><p><img src="https://s2.loli.net/2024/10/03/NSa4EKxALZikyGq.png" alt="image-20241003013229300"></p><p>门口还有一个鳗鱼：</p><img src="https://s2.loli.net/2024/10/03/tykpIv3U7iXNquY.png" alt="image-20241003013117902" style="zoom:80%;"><p>售卖的各种烟，需要找店员才能看到实物：</p><img src="https://s2.loli.net/2024/10/03/TOitmdR9G1JFeUQ.jpg" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/TOitmdR9G1JFeUQ.jpg" alt="IMG_20240219_204005" style="zoom:80%;"><p>店内的牛奶价格，只能说很便宜还好喝，我买了两种，看到好像是由于工艺不同，国内大部分是巴氏杀菌，日本好像是相反的冷处理。</p><p>看了下国内价格，进口进来基本都在三倍以上。</p><img src="https://s2.loli.net/2024/10/03/zXO9B2dviAVopqN.jpg" alt="IMG_20240218_225738" style="zoom:80%;">]]></content>
    
    
    <summary type="html">日本影集，不包含任何评论，图片较大，耐心等待。</summary>
    
    
    
    <category term="JAP" scheme="http://neonexusx.github.io/categories/JAP/"/>
    
    
    <category term="JAP" scheme="http://neonexusx.github.io/tags/JAP/"/>
    
  </entry>
  
  <entry>
    <title>JaP Photo Album (Part Two) -- 上野、渋谷、池袋、秋叶原</title>
    <link href="http://neonexusx.github.io/2024/12/12/JaP_Photo_Album(2)/"/>
    <id>http://neonexusx.github.io/2024/12/12/JaP_Photo_Album(2)/</id>
    <published>2024-12-12T10:37:00.000Z</published>
    <updated>2025-12-30T14:10:50.776Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="jap影集贰上野-渋谷-池袋-秋叶原">JaP影集（贰）–上野、渋谷、池袋、秋叶原</span></h1><p>不做任何评价，没有政治观点，屏蔽所有人物信息。</p><img src="https://s2.loli.net/2024/10/04/k5V3S6I7TJhj1ex.png" alt="image-20241004204650666" style="zoom:50%;"><p>[TOC]</p><h2><span id="东京">东京</span></h2><h3><span id="上野">上野</span></h3><p>本来去上野去买羽毛球拍，最后都没货了。路过了很饿，就先吃饭了。所以这次从拉面开始：</p><p>具体位置我也忘记了，在御徒町駅北口 コインロッカー附近，附近很多吃的。</p><img src="https://s2.loli.net/2024/10/04/amGvEQTAYPIdhCt.jpg" alt="IMG_20240219_140241" style="zoom:80%;"><p>由于是下雨天，没有很多人，在东京几乎每一家店外国人走进去服务员都能接待，我吃着的时候来了一个老外，吃的老香了，少见的放了豆芽的拉面，大块的五花肉好像是经过油炸的，汤味道很浓厚适合重口味的来品尝，趁着店员忙做饭偷拍了两张，记录下做饭的过程。</p><p>标记的地方貌似是熬好的汤底，有中预制菜的感觉，不过算便宜的了，要什么自行车～</p><p><img src="https://s2.loli.net/2024/10/04/6rSIDgL4UtnlA2o.png" alt="image-20241004185214492"></p><p>御徒町駅北口出来不远的地方就是<strong>摩利支天徳大寺</strong>，说着很大其实是个小破庙，我记得里面好像祭祀的是个人骑着猪，由于不方便拍照，就没记录下来：</p><p>去Google街景找了一下：</p><p><img src="https://s2.loli.net/2024/10/04/6RVN4otEnq2XxYj.png" alt="image-20241004185718218"></p><p>庙里面有很多许愿牌：</p><p><img src="https://s2.loli.net/2024/10/04/kFSgqAIoYhsaVO2.png" alt="image-20241004185935831"></p><p>大多数都是发财考试，还有个世界和平～，看来大家愿望都差不多。</p><p>走之前使用胶片相机拍了两张，由于是阴天效果并不太好，可以和google街景做一个对比：</p><p><img src="https://s2.loli.net/2024/10/04/quvx84rE9jbXzZn.png" alt="image-20241004190053444"></p><p><img src="https://s2.loli.net/2024/10/04/Zk5sWcT98eI3it6.png" alt="image-20241004190152957"></p><p>路过的杂货店，对面就是车站（也是使用胶片拍摄，一点都没有违和感）：</p><p>二木果子就在阿美橫町，二战后，该处是贩卖美军物资的黑市，“阿美”一词即相信源自美国。由于当时有许多售卖饴的店家聚集于此，故又名“饴横丁”。 近年货品种类已经包罗万有，除了糖果外，亦有售卖食品、衣饰、钟表、化妆品、日本土产等，除了本地居民光顾之外，也成为外国观光客造访的景点。</p><p><img src="https://s2.loli.net/2024/10/04/YLWF1AoKa6QCyU3.png" alt="image-20241004190245977"></p><p>在车站拍摄，日本的电车几乎承担了大部分公共交通运输，车站几乎都一模一样，有的车站年龄比我大多了，最早的地铁是80年代就有了，使用胶片拍摄也是一点违和感都没有：</p><p><img src="https://s2.loli.net/2024/10/04/nYEH3lLjzbMWTq5.png" alt="image-20241004190635932"></p><p><img src="https://s2.loli.net/2024/10/04/mjlMCD2oVRahczB.png" alt="image-20241004190613269"></p><h2><span id="渋谷">渋谷</span></h2><p>渋谷站出门：</p><p><img src="https://s2.loli.net/2024/10/04/X2SvsQBTz381fuO.png" alt="image-20241004191422673"></p><p>一些街景，全部都是各种商店，年轻人的聚集地。</p><p><img src="https://s2.loli.net/2024/10/04/AEYMIijTXwlVRKz.jpg" alt="IMG_6213"></p><p><img src="https://s2.loli.net/2024/10/04/3YlChBPHxEKLRpg.jpg" alt="IMG_6214"></p><p><img src="https://s2.loli.net/2024/10/04/3YlChBPHxEKLRpg.jpg" alt></p><p><img src="https://s2.loli.net/2024/10/04/Nco48qrCLWjwGIm.jpg" alt="IMG_6216"></p><p>东京骑自行车的还真不少：</p><p><img src="https://s2.loli.net/2024/10/04/qirM6JDXU79x2hw.jpg" alt="IMG_20240220_190701"></p><p><img src="https://s2.loli.net/2024/10/04/ZfSOiUVFm1WYdkb.jpg" alt="IMG_20240220_190717"></p><p><img src="https://s2.loli.net/2024/10/04/WDGrbCKoV1SMqOU.jpg" alt="IMG_20240220_190748"></p><p>某个路牌上贴满了贴纸：</p><p><img src="https://s2.loli.net/2024/10/04/MISoA5VbnGwCE1N.jpg" alt="IMG_20240221_231723"></p><p>抓拍到消防车，但是被挡住了：</p><p><img src="https://s2.loli.net/2024/10/04/uh3tP4ZvwgFBUxs.jpg" alt="IMG_6219"></p><p>MODI Store：</p><p>Chiikawa在日本真是爆火：</p><p><img src="https://s2.loli.net/2024/10/04/jXx3qYN1CSVgezJ.jpg" alt="IMG_20240220_171355"></p><p><img src="https://s2.loli.net/2024/10/04/Fobkuny9saRBvN6.jpg" alt="IMG_20240220_171351"></p><p>当时以为是炸鸡皮店，吃了以后才发现其实是素鸡皮，甜甜的配上啤酒好吃，怪不得那么便宜～</p><p><img src="https://s2.loli.net/2024/10/04/zvkT2efW68HlXgE.png" alt="image-20241004193611112"></p><h2><span id="池袋">池袋</span></h2><p>池袋这里我拍摄了很多胶片，但是由于当天天气并不好，并且受到X光影响，损失了很多照片。抢救下来只剩下：</p><p>欠曝下只剩闪烁的广告牌：</p><p><img src="https://s2.loli.net/2024/10/04/sKdQ357btieFCME.png" alt="image-20241004193123193"></p><p><img src="https://s2.loli.net/2024/10/04/sIzTPH7QqO2lvia.png" alt="image-20241004193142825"></p><p><img src="https://s2.loli.net/2024/10/04/YsApyJu3M4QTK8k.png" alt="image-20241004193155598"></p><p><img src="https://s2.loli.net/2024/10/04/7hivCYl5BdokMV1.png" alt="image-20241004193206737"></p><p><img src="https://s2.loli.net/2024/10/04/KZY3RxD9ptfWUrQ.png" alt="image-20241004193219574"></p><p><img src="https://s2.loli.net/2024/10/04/oG9BcwCYdvJQUhb.png" alt="image-20241004193246146"></p><p><img src="https://s2.loli.net/2024/10/04/zN1PZBWcGQXsFph.png" alt="image-20241004193233077"></p><p>来池袋主要是为了买EVA周边，买了很多这里就不放图片了。</p><h2><span id="秋叶原">秋叶原</span></h2><p>秋叶原<strong>AKIBA</strong>，秋叶原最初以旧品店和家电量贩店为中心，之后电子游戏浪潮时大量游戏店来到此地，伴随而生的爱好店与动漫店陆续开业。近年因都市再开发，秋叶原站周围兴建许多复合大楼，访客年龄与客层呈现多样化。同时随着动漫的发展，秋叶原也成为了二次元爱好者的聚集地。</p><p><img src="https://s2.loli.net/2024/10/04/jkIpYAaVQmb3U6r.png" alt="image-20241004201037015"></p><p>秋叶原的广告牌，特殊的咖啡厅，这算是一种包容？</p><p><img src="https://s2.loli.net/2024/10/04/axEi78fkUDgPbR2.jpg" alt="IMG_20240218_150026"></p><p>原神入侵全世界：</p><p><img src="https://s2.loli.net/2024/10/04/9b7yrYuE85w6Pos.jpg" alt="IMG_20240218_163423"></p><p>可以看到马路这个时候是不走车的，变成了步行街</p><p><img src="https://s2.loli.net/2024/10/04/7wIzYQGxqJc98eE.jpg" alt="IMG_20240218_163353"></p><p>很多大商场都是免税的，也就是所有物品九折：</p><p><img src="https://s2.loli.net/2024/10/04/1NKCLVDkayA4g9O.jpg" alt="IMG_20240218_153853"></p><p>日本本国的商品价格优势非常大，但是电子产品尤其是台湾和大陆产出的，完全没有优势，都不如京东便宜，所以完全没必要买日行。这样的电子配件在国内不值钱，来日本翻了三倍。</p><p><img src="https://s2.loli.net/2024/10/04/nByxAegtOGwU8bZ.jpg" alt="IMG_20240218_142612"></p><p>![](<img src="https://s2.loli.net/2024/10/04/1aw35AgFLMqyJVs.jpg" alt="wx_camera_1708239123844"></p><p>找了些酒，价格都不错，可惜飞机带上去比较困难：</p><p><img src="https://s2.loli.net/2024/10/04/ALFsUoPNbe8KrC3.jpg" alt="IMG_20240218_151933"></p><p>在派对吃饭的时候，看到了个有趣的贴纸：</p><p><img src="https://s2.loli.net/2024/10/04/u6Ge7x4whkbDIXU.jpg" alt="IMG_20240218_181611"></p><p><img src="https://s2.loli.net/2024/10/04/EwaLFYrfeWx3lqA.jpg" alt="IMG_20240218_181614"></p><p>派对1个小时，终于吃上了饭，店里面竟然还有中文菜单，由于不让拍照，只能厨房非常井然有序，那种西餐的厨房一样，主厨安排一切，牛肉非常好吃，价格也不贵。一定要去，和牛盖饭：</p><p><img src="https://s2.loli.net/2024/10/04/e9Tgrmhbq3VHoGX.png" alt="image-20241004202944243"></p><p><img src="https://s2.loli.net/2024/10/04/g1y2dSmRDhz54tn.jpg" alt="IMG_20240218_190020"></p><p>大多数成人商店都是不允许拍照的，以下内容为18禁：</p><p><img src="https://s2.loli.net/2024/10/04/ZcUGY8zlLgeHCER.jpg" alt="IMG_20240218_140310"></p><p><img src="https://s2.loli.net/2024/10/04/64xqz5fmp2OIWdk.jpg" alt="IMG_20240218_171512"></p><p>电器街剪影：</p><p><img src="https://s2.loli.net/2024/10/04/Jy25w6pWL3fveaN.png" alt="image-20241004194150843"></p><p>日本的电车和地铁很相似，但是由于其轨道经常走上地面，把城市建筑都分割开来，所以和地铁区别还是很大的</p><p><img src="https://s2.loli.net/2024/10/04/w8JqpiahkyGNTjl.png" alt="image-20241004200332930"></p><p>秋叶原有很多商店都是在楼上的，每一栋楼上边都有很多不同的商店。</p><p><img src="https://s2.loli.net/2024/10/04/ft4mKQjp5rieqJI.png" alt="image-20241004200352296"></p><p><img src="https://s2.loli.net/2024/10/04/yQM8ASecRmGXzNk.png" alt="image-20241004200640182"></p><p><img src="https://s2.loli.net/2024/10/04/Z2AmNqcUa4Oi63j.png" alt="image-20241004200812913"></p><p><img src="https://s2.loli.net/2024/10/04/jbPOYvLVfyJg6ae.png" alt="image-20241004200702735"></p><p>在马路中间赶快拍了一张：</p><p><img src="https://s2.loli.net/2024/10/04/jbJ9K3gMFI5NXAv.png" alt="image-20241004200851005"></p><p>日本人很喜欢的招牌夸张hhh，世界曲目最多的ktv：</p><p><img src="https://s2.loli.net/2024/10/04/wucJjUX8WeRKDmd.png" alt="image-20241004200757599"></p><p>夜晚的车站：</p><p><img src="https://s2.loli.net/2024/10/04/UHed74OAiyw3k6z.png" alt="image-20241004200946249"></p>]]></content>
    
    
    <summary type="html">日本影集贰，不包含任何评论，图片较大，耐心等待。</summary>
    
    
    
    <category term="JAP" scheme="http://neonexusx.github.io/categories/JAP/"/>
    
    
    <category term="JAP" scheme="http://neonexusx.github.io/tags/JAP/"/>
    
  </entry>
  
  <entry>
    <title>Git(1)</title>
    <link href="http://neonexusx.github.io/2024/10/22/Git__Base(1)/"/>
    <id>http://neonexusx.github.io/2024/10/22/Git__Base(1)/</id>
    <published>2024-10-21T16:40:01.000Z</published>
    <updated>2025-11-28T07:16:57.270Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="git关于git的一些补充1">Git——关于Git的一些补充（1）</span></h1><img src="https://s2.loli.net/2024/10/22/zrPTFChwRB1jf9g.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1729527526564" style="zoom: 50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h2><span id="提示图床在国外且动图比较多的情况下需要时间加载">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2><h2><span id="目录">目录：</span></h2><!-- toc --><ul><li><a href="#git%E5%9F%BA%E7%A1%80">Git基础</a><ul><li><a href="#git%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Git文件的生命周期</a></li><li><a href="#git%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86">Git文件的存储空间的划分</a></li><li><a href="#git%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">Git安装过程补充说明</a></li><li><a href="#git%E7%9A%84%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C">Git的撤销操作</a><ul><li><a href="#%E4%BF%AE%E6%AD%A3%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E6%8F%90%E4%BA%A4">修正上一次的提交</a></li><li><a href="#%E6%92%A4%E9%94%80%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6">撤销暂存区的文件</a></li></ul></li><li><a href="#git%E7%9A%84rm%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85">Git的rm命令补充</a></li><li><a href="#git%E7%9A%84diff%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85">Git的diff命令补充</a><ul><li><a href="#git-diff-%E8%A7%A3%E6%9E%90">Git diff 解析</a></li></ul></li></ul></li><li><a href="#git%E7%9A%84mv%E5%91%BD%E4%BB%A4">Git的mv命令</a></li><li><a href="#github-windows-version-install">Github Windows Version Install</a></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="git基础">Git基础</span></h2><p>基础内容请参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰Git教程</a>，这里只做一点概念的补充，来方便理解。</p><h3><span id="git文件的生命周期">Git文件的生命周期</span></h3><p>此部分补充上述教程中<strong>创建版本库</strong>的部分内容</p><p>Git所管理的文件可以处于以下五种状态：</p><p>未跟踪（untracked）、未修改（clean）、已修改（modified）、已暂存（staged）、已提交（committed）</p><pre class="mermaid">sequenceDiagramparticipant untrackedclean -&gt;&gt; untracked:(rm)clean  --&gt;&gt; modified:(edit data or code)untracked --&gt;&gt; staged:(add)modified --&gt;&gt; staged: (add)staged --&gt;&gt; +committed:(commit)committed -&gt;&gt;-clean: (committed)</pre><p>上图中（浏览器右侧有切换到浅色主题的按钮，使用之后看的更清楚），线上的命令代表了在各个状态变化中使用的命令名称，状态clean和其翻译并对不上，其原因是clean代表的是刚刚完成克隆或者刚刚提交完成之后的仓库状态，详细状态切换及使用的命令的参数可以参考廖雪峰的教程。其中committed部分指的是每次提交完成之后工作区的代码又返回了clean状态，即没有变化，更改的意思，并没有其对应的命令。</p><p>由此五种状态的转变可以引出——什么是<strong>仓库</strong>?</p><p>Git是如何在存储空间中划分的?</p><p>是如何将的代码在各个状态中进行保存的？</p><h3><span id="git文件的存储空间的划分">Git文件的存储空间的划分</span></h3><ul><li>**工作目录(Working Directory)：**工作目录实际上是项目中某一个版本的单次检出（check out）。这些文件是从Git目录下的压缩数据库内被提取出，放置在磁盘上以供使用和修改。也就是你能看到的项目内容。</li><li><strong>暂存区(Stage/Index)：暂存区是一个文件，一般位于Git目录中</strong>，保存了下次提交内容的相关信息。有时候也被称之为<strong>索引</strong>。</li><li><strong>Git目录(Repository)：</strong>：Git目录是保存项目元数据和对象数据库的地方。这是Git最重要的部分，也是其他计算机中克隆仓库时复制的内容。</li></ul><p>在你使用命令之后整个工作流程 上划分如下：</p><pre class="mermaid">sequenceDiagrambox rgb(30,144,255, .5) Working Directoryparticipant untrackedparticipant cleanparticipant modifiedendbox rgb(0,255,255, .5) Indexparticipant stagedendbox rgb(255,65,81,.8) Repositoryparticipant committedendclean -&gt;&gt; untracked:(rm)clean  --&gt;&gt; modified:(edit data or code)untracked --&gt;&gt; staged:(add)modified --&gt;&gt; staged: (add)staged --&gt;&gt; +committed:(commit)committed -&gt;&gt;-clean: (committed)</pre><p>蓝色部分是你的工作区域，也就是你修改的或者使用的代码皆是存在于此的,其中比较重要的是add和commit命令，使用这两个命令或者操作会将文件拉入Index区或者Repository区。受限于mermaid画图无法嵌套，实际上Index应是Repository区的一部分。</p><h3><span id="git安装过程补充说明">Git安装过程补充说明</span></h3><img src="https://s2.loli.net/2024/03/20/Az8EiRo5dcKFJyU.png" alt="git_pull" style="zoom: 80%;"><p>在安装过程中，git会让你选择pull操作的逻辑：</p><p>Fast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：</p><pre class="mermaid">sequenceDiagram  main --&gt;&gt; orgin/main : pull</pre><p>main节点落后于服务器上的main（以后都称之为origin/main），此时执行Fast-forward操作就是将当把服务器的远程分支合并到main之上，也就是执行merge操作，此时main指针会向前走一个，这样的操作就是Fast-forward。</p><p>merge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：</p><pre class="mermaid">graph LRFirst_commit--&gt;Second_commitFirst_commit --&gt; Remote_commitSecond_commit --&gt;merge_commitRemote_commit --&gt;merge_commit</pre><p>在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。</p><p>Rebase操作指的是在上述情况之上直接将Remote_commit修改，再合并到Second_commit之上：</p><pre class="mermaid">graph LRFirst_commit--&gt;Second_commitSecond_commit --&gt;Remote_commit_changed</pre><p>这里选择默认即可。当然git pull --rebase操作不仅仅能实现这种效果，更多内容请参考下一篇，关于分支管理的内容。</p><h3><span id="git的撤销操作">Git的撤销操作</span></h3><h4><span id="修正上一次的提交">修正上一次的提交</span></h4><p>撤销上一次的提交指的是上一次的提交会被这次新的提交所覆盖，假设你的commit信息在上次输入错误了，我们就可以使用：</p><pre><code class="language-bash">git commit --amend</code></pre><p>来再次进行提交，这次提交还是会打开输入信息框，修改后信息就会更新，且上一次提交就被覆盖了或者说应该是被修正了。</p><p>第一次提交：</p><img src="https://s2.loli.net/2024/05/04/aiWVk9C2Pxw6l7N.png" alt="image-20240504170607739" style="zoom: 80%;"><p>第二次提交：</p><img src="https://s2.loli.net/2024/05/04/C2itf4nJyqeI58h.png" alt="image-20240504170440919" style="zoom:80%;"><h4><span id="撤销暂存区的文件">撤销暂存区的文件</span></h4><p>如果你不小心提交了不该提交的内容到index区，我们可以使用：</p><pre><code class="language-bash">git reset HEAD filename</code></pre><p>来将其从暂存区中删除，记得不要使用rm，rm同时也会把其从工作区一起删除，这是二者的区别。</p><h3><span id="git的rm命令补充">Git的rm命令补充</span></h3><p>要从版本管理系统中移除某一个文件，你需要把它先从已跟踪文件列表里面删除，然后再提交修改才可以，这里就要使用rm命令来实现，如果没有使用git rm，而是简单的直接从文件列表删除，就会产生如下后果：</p><p>我们将copy结尾的文件删除，其已经被修改后提交：</p><img src="https://s2.loli.net/2024/05/04/qAQYlBJtoOypmdi.png" alt="image-20240504161643586" style="zoom: 80%;"><p>我们将其手动删除，查看git的状态。</p><p><img src="https://s2.loli.net/2024/05/04/wcDiKaIsxWnbSTq.png" alt="image-20240504162813549"></p><p>这里就会提示你有一个删除操作没有提交到暂存区，你需要手动使用</p><pre><code class="language-bash">git add .</code></pre><p>来将删除操作暂存，并用commit命令提交到committed区。</p><p><img src="https://s2.loli.net/2024/05/04/CiKJpLdIoen9gDO.png" alt="image-20240504163209617"></p><p>这样的操作略显麻烦，不过问题不大，我们可以直接使用rm命令来进行操作。<strong>rm命令会将文件从暂存区和工作区直接删除</strong>，这样提交的时候就不会有未跟踪的文件提示了。</p><p><img src="https://s2.loli.net/2024/05/04/vlLWsxwRzoQd31B.png" alt="image-20240504163329446"></p><h3><span id="git的diff命令补充">Git的diff命令补充</span></h3><p>在安装完成之后，我们使用git bash 来查看 diff，在diff查看之前我们应该有一个已经committed的版本，方便我们来查看不同之处，这里使用的就是本篇文章的存储库来查看，</p><p>写到这里，我们使用命令：</p><pre><code class="language-bash">git diff</code></pre><p>效果如下：</p><img src="https://s2.loli.net/2024/05/04/Cda3xO4zrnKjIMQ.png" alt="image-20240504065415466" style="zoom:67%;"><p>上图红红绿绿的部分，就是代表了修改的内容，这个表格是用来查看你相对于索引（index）（下次提交的暂存区域）所做的修改。 换句话说，这些差异是你_可以告诉 Git 进一步添加到索引中，但你仍然没有。，我们从头开始，解析这一段代表的是什么意思。</p><h4><span id="git-diff-解析">Git diff 解析</span></h4><p>git所使用的diff是1990年，GNU diff率先推出了"合并格式"的diff，将需要比较文件的上下文合并在一起显示的一种diff格式、不同的diff格式不同，目前比较多的是GNU diff格式，git在此基础上添加了一些信息，用来显示一些内容。</p><p>第一部分实际上是文件的基本信息，用来显示git的对象：</p><p>一般格式如下：</p><pre><code class="language-bash">　　diff --git a/f1 b/f1</code></pre><p>进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。</p><p>由于我的文件包含中文，所以中文被解析成了对应的字符，仔细看实际上是能发现对应的内容的：</p><p><img src="https://s2.loli.net/2024/05/04/h21MAUDnIKNGZci.png" alt="image-20240504071327934"></p><p>然后一行显示的是两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）</p><pre><code class="language-bash">index a7a1862..fcf1525 100644</code></pre><p>第三行表示进行比较的两个文件。</p><p><img src="https://s2.loli.net/2024/05/04/rx3Rhn2KuSql5sJ.png" alt="image-20240504071546670"></p><p>"—“表示变动前的版本，”+++"表示变动后的版本。</p><p>第二部分，变动的位置用两个@作为起首和结束。</p><pre><code class="language-bash">@@ -33,14 +33,18 @@</code></pre><p><code>-33</code>中<code>-</code>代表第一个文件也就是上一个版本的文件，33代表第33行，<code>14</code>代表连续14行，合在一起意思就是从33行起连续14行，同样的，<code>+</code>代表变动后的文件，从33行开始一直到18行。</p><p>第三部分，就是具体的修改内容了：</p><p><img src="https://s2.loli.net/2024/05/04/NDy3dtEzwSjgGiC.png" alt="image-20240504160151147"></p><p>文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。图片中的<code>+- --</code> 均为文档自身包含一个-号，与git无关。</p><p>参考：<a href="https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">读懂diff - 阮一峰的网络日志 (ruanyifeng.com)</a></p><h2><span id="git的mv命令">Git的mv命令</span></h2><p>git并不会显式的跟踪文件的移动，如果你在文件管理系统中，直接重名了文件，git并不能发觉，会将其认为是一个新的文件，如此这般我们就需要将文件重新加入到跟踪队列，实际上我们可以说使用git mv命令来实现更快捷的操作：</p><p>如图我们直接修改文件夹中的README.md文件为README，此时git会发觉到：</p><p><img src="https://s2.loli.net/2024/05/05/8WlI4OXQTgKF6zB.png" alt="image-20240505201754780"></p><p>不过问题不大我们可以直接用mv来修改，这样git就会自动将其加入到追踪文件中：</p><pre><code class="language-bash">git mv README.md README</code></pre><p>此时可以看到对应的文件被变成了这个样子：</p><p><img src="https://s2.loli.net/2024/05/05/XiM13yEHIQYtPhj.png" alt="image-20240505201925068"></p><p>我们直接提交修改即可。需要注意的是，这一个操作相当于将其改名之后，并将其提交到stage区域，如果你想改回来，就需要将暂存区的内容清空使用上文的reset命令，最后再手动将名字修改回来。</p><h2><span id="github-windows-version-install">Github Windows Version Install</span></h2><p>很多人上来就要安装Git for windows项目，我是不推荐的，Github针对Git开发了更方便的Github Desktop软件，主要包含GUI和操作，同时也针对了PowerShell做了兼容，这一点非常好。便于跨平台的使用。(这是比较老的说法了，实际上他们放弃了维护CLI部分，专注使用GUI部分，详见：<a href="https://stackoverflow.com/questions/34565238/where-does-github-desktop-install-command-line-version-of-git">Where does Github desktop install command line version of Git - Stack Overflow</a>)，但对新手来说GUI更适合一点，虽然无法使用全部的Git命令，但GUI已经足够了。</p><p>下载地址如下：<a href="https://desktop.github.com/">GitHub Desktop | Simple collaboration from your desktop</a></p><p>下载后注册账号登陆即可：</p><img src="https://s2.loli.net/2024/03/19/KMDWurV9LT4BEks.png" alt="image-20240319230316232" style="zoom:67%;"><p>设置本地Git信息也是易如反掌，我的建议是对于工具类不需要太过深入了解，但是要有求知的心，建议看完Git for Windows项目的教程之后再来看这个会更加理解，本人入门的时候也是用的Git for Windows来进行配置的，整个过程受益颇多。</p><img src="https://s2.loli.net/2024/03/19/dP9IvSoFAfQ6gLR.png" alt="image-20240319231027438" style="zoom:67%;"><p>我们可以简单过一遍教程：</p><img src="https://s2.loli.net/2024/03/19/X7RhIFyA136Gv95.png" alt="image-20240319231115582" style="zoom:67%;"><p>这里省略了几个验证的细节，只需要点点就可以了，来到正式的界面：</p><img src="https://s2.loli.net/2024/03/19/eCDZ7wXPvxYk5RL.png" alt="image-20240319231404949" style="zoom:67%;"><p>右侧写了教程的步骤，这里要我们创建一个新的分支，分支的含义在这里已经详细阐述了，简单来说就是可以允许不同版本的代码同时在相同仓库下进行开发。点击创建新的分支之后：</p><img src="https://s2.loli.net/2024/03/19/62jQlzivfNc5npk.png" alt="image-20240319231619311" style="zoom:67%;"><img src="https://s2.loli.net/2024/03/19/g3HRmj8wDQfIlAi.png" alt="image-20240319231712553" style="zoom: 80%;"><p>会使用系统默认的编辑器打开对应文本文件：</p><img src="https://s2.loli.net/2024/03/19/d6F8ScXOKLpyTIP.png" alt="image-20240319231807726" style="zoom:67%;"><p>在下方添加以下总结信息，这对参与项目者十分重要，来标识你干了什么。</p><img src="https://s2.loli.net/2024/03/19/AeWmqkO4jX2CQrs.png" alt="image-20240319231917272" style="zoom:67%;"><p>最后将分支推送到Github之上：</p><img src="https://s2.loli.net/2024/03/19/CbuW9apGqoK5VHj.png" alt="image-20240319232010779" style="zoom:67%;"><p>pull request，是将你修改好的代码推送到审核人员那里，在审核人员将你实现的功能合并到主分支或者某一个分支之上。</p><img src="https://s2.loli.net/2024/03/19/NQGVcslxkqAomgY.png" alt="image-20240319232103905" style="zoom:67%;"><p>跳转到网页进行申请处理</p><img src="https://s2.loli.net/2024/03/19/GfbUMrgaVCxk5O2.png" alt="image-20240319232223793" style="zoom: 80%;"><p>审核人员审核之后也就是分支合并之后，可以选择删除你的开发分支，删除之后GIt上就剩下了一个分支。</p><img src="https://s2.loli.net/2024/03/19/6xujJ7V1TZhek8P.png" alt="image-20240319232351124" style="zoom: 80%;">]]></content>
    
    
    <summary type="html">关于Git的一些补充，包含一些基础之类的，以防忘记</summary>
    
    
    
    <category term="git" scheme="http://neonexusx.github.io/categories/git/"/>
    
    
    <category term="branch" scheme="http://neonexusx.github.io/tags/branch/"/>
    
    <category term="base" scheme="http://neonexusx.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Git(2)</title>
    <link href="http://neonexusx.github.io/2024/10/22/Git__Base(2)/"/>
    <id>http://neonexusx.github.io/2024/10/22/Git__Base(2)/</id>
    <published>2024-10-21T16:40:01.000Z</published>
    <updated>2025-11-28T07:16:57.270Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="git分支管理2">Git——分支管理（2）</span></h1><img src="https://s2.loli.net/2024/10/22/zFJb9U6fiaprvdR.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1729527720427" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:50%;"><h2><span id="提示图床在国外且动图比较多的情况下需要时间加载">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2><h2><span id="目录">目录：</span></h2><!-- toc --><ul><li><a href="#git%E5%9F%BA%E7%A1%80">Git基础</a><ul><li><a href="#git%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8Ehead">Git的分支与HEAD</a><ul><li><a href="#git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6">Git的存储机制</a></li><li><a href="#git%E7%9A%84%E5%88%86%E6%94%AF%E6%8C%87%E9%92%88">Git的分支指针</a></li></ul></li><li><a href="#git%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">Git的远程仓库</a></li><li><a href="#git%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">Git的远程分支管理</a></li></ul></li><li><a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86">远程分支和本地仓库的冲突处理</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E6%83%85%E5%86%B5">查看当前分支情况</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="git基础">Git基础</span></h2><p>关于Git的基础请参考上一篇基础的教程，这里主要是关于Git的分支管理的内容，在讲解完成之后会以实战的形式让各位更好的理解如何使用Git这一个强大的工具。</p><h3><span id="git的分支与head">Git的分支与HEAD</span></h3><h4><span id="git的存储机制">Git的存储机制</span></h4><p>当你发起提交的时候，Git存储的是提交对象，其中包含了指向暂存区快照的指针。</p><p>Git在仓库区一般会这样保存对象：</p><pre class="mermaid">graph LRA("提交对象") --&gt; C("Tree对象") --&gt;B("Blob1对象")C--&gt;D("Blob2对象")</pre><ul><li><p>提交对象，一次提交包含着元数据以及指向项目根目录的树对象的指针，以便需要的时候重新创建这次快照。</p><img src="https://pic4.zhimg.com/80/v2-b8b7d634df1cf8a9d079c762fc2781b3_720w.webp" alt="image.png" style="zoom:80%;"></li><li><p>Blob 对象，只用于存储单个文件内容，一般都是二进制的数据文件，不包含任何其他文件信息，比如不包含文件名和其他元数据,可以同时有多个。</p></li><li><p>Tree 对象，对应文件系统的目录结构，里面主要有：子目录 (tree)，文件列表 (blob)，文件类型以及一些数据文件权限模型等。</p></li></ul><p>Git将文件的快照存储为对象，每个对象都有一个唯一的哈希值。当文件发生变化时，Git会计算新文件的哈希值，并将其作为新对象存储在对象数据库中。当Git检测到两个文件版本相似时，它会计算差异（即两个版本之间的不同之处），并将这些差异作为一个新的对象存储。这个差异对象会引用原始文件的哈希值，以便可以重构原始文件的内容。</p><h4><span id="git的分支指针">Git的分支指针</span></h4><p>Git的分支只不过是一个指向某次提交的轻量级的可以移动指针，Git默认的分支名是master,当你发起提交的时候就有了一个指向最后一次提交的master分支。每次提交时他都会自己向前移动。</p><p>举个例子：</p><pre class="mermaid">graph LRH("HEAD")  --&gt;GG("master") ==&gt; Commit_C    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C</pre><p>也就是说分支其实就是指针，指针指向某一次提交。其中比较特殊的是HEAD指针，是用来指向当前分支指针的指针，表示当前在master分支上。</p><h3><span id="git的远程仓库">Git的远程仓库</span></h3><p>远程分支是指远程仓库的分支指针，这些指针存在于本地且无法被移动，当你与服务器进行网络通信的时候，他会自动更新，也就是使用pull等命令的时候，远程分支有点像书签，会提示你上一次连接服务器时远程仓库中每个分支的位置。</p><pre class="mermaid">graph LRG("master") ==&gt; Commit_C    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C     H("remote") ==&gt; Commit_C</pre><p>remote指针同master指针一样，都是一个指针而已。</p><h3><span id="git的远程分支管理">Git的远程分支管理</span></h3><p>合并冲突</p><p>Fast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>main节点落后于服务器上的main（以后都称之为origin/main），<strong>此时执行Fast-forward操作就是把本地分支main合并到orgin/main之上</strong>，此时main指针会向前走一个，这样的操作就是Fast-forward。</p><p>合并之后结果如下：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_C    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>merge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_A --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。</p><pre class="mermaid">graph LR    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end         subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end         subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end                   subgraph merge_commit        direction TB        G("提交对象C") --&gt; H("文件对象C")     end          Commit_A --&gt; Commit_B     Commit_A --&gt; Commit_C     Commit_C --&gt; merge_commit     Commit_B --&gt; merge_commit     merge_commit --&gt; J("orgin/main")     merge_commit --&gt; I("main")</pre><p>Rebase操作指的是在上述情况之上直接将某个分支之上所有提交的更改在另一个分支上重现一遍。</p><p>为了Rebase需要先找到两个要整合的分支的共同祖先，然后取得当前所在分支的每次提交引入的变更，并把这些变更保存成文件，这之后将当前分支重置为要整合到的分支，然后在该分支上依次引入之前保存的每个更改。</p><p>在合并之前分支已成这个样子：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_A --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>当我们想把远程分支的内容整合到main分支之上（就是将orgin/main rebase到 main）的话就会有如下情况，合并之后：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C+        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C+     H("orgin/main") ==&gt; Commit_C+</pre><p>可以看到这里实际上变化成了Fast-forward所处理的情况，再次执行Fast-forward（merge）即可完成操作。</p><h2><span id="远程分支和本地仓库的冲突处理">远程分支和本地仓库的冲突处理</span></h2><h3><span id="查看当前分支情况">查看当前分支情况</span></h3><p>查看当前分支信息：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch* main  test</code></pre><p>加上参数v可以显示当前每个分支的最新提交和其的提交信息，加上a则会包括当前的远程分支：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av* main                dd0258f [ahead 3] Merge branch 'test'  test                8eafb31 update git rm pycharm  remotes/origin/HEAD -&gt; origin/main  remotes/origin/main e5d18d7 del copy</code></pre><p><code>*</code>代表了HEAD指针所处位置，也就是当前所在的分支。 <code>update git rm pycharm</code>就是对应的提交信息。<code>e5d18d7</code>就是提交对象的散列值。</p><p>如果要查看已并入当前的分支的所有分支信息可以使用：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av --merged* main                dd0258f [ahead 3] Merge branch 'test'  test                8eafb31 update git rm pycharm  remotes/origin/HEAD -&gt; origin/main  remotes/origin/main e5d18d7 del copy</code></pre><p>相反的，显示没有并入分支的命令可以使用（注意这里和上文并不是一个仓库，你可以看到对应的路径不同）：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/Desktop/Essays$ git branch -av --no-merged  remotes/origin/HEAD -&gt; origin/main  remotes/origin/main e5d18d7 del copy</code></pre><p>但是以上的方式都不够明显展示分支的变化及历史，所以推荐还是使用如下命令：</p><pre><code class="language-bash">git log --graph --decorate --oneline --all</code></pre><p>如图展示了两个本地的仓库，其中二者的远程仓库是保持一致的，也就是说二者都有一样的远程信息，但是本地却差别很大，我们的工作就是尽量合并二者的内容并优化分支结构。</p><img src="https://s2.loli.net/2024/05/06/lrENoDWkt92Fd36.png" alt="image-20240506012058410" style="zoom:67%;"><p>在看到二者的分支图的时候我们就能看到：</p><p>图中的领先指的是领先远程仓库的意思。</p><img src="https://s2.loli.net/2024/05/06/zuK2aUAx384oBr6.png" alt="image-20240506012643030" style="zoom: 67%;"><p>简单来说我们的解决方案如下</p><p>首先rebase仓库A,将仓库A的main分支rebase到远程上然后push到服务器。</p><p>然后将远程新的内容pull到仓库B，再进行一次rebase然后将内容push到服务器。最终再pull，仓库A、仓库B、服务器三者就可以实现同步。</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/Desktop/Essays$ git rebase origin/mainSuccessfully rebased and updated refs/heads/main.</code></pre><p>reabase之后：</p><img src="https://s2.loli.net/2024/05/06/v1zQSXFucd45ROx.png" alt="image-20240506020430611" style="zoom:67%;"><p>由于仓库B还有部分内容没有提交，这里就再提交一次：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git commit -a -m "finished git 1"[main e2fdc30] finished git 1 1 file changed, 61 insertions(+), 6 deletions(-)</code></pre><p>提交之后分支如下,本次提交并不影响合并方案，只是单纯多加了一次提交而已。</p><img src="https://s2.loli.net/2024/05/06/ixv7hQX3VoBcWlN.png" alt="image-20240506020817574" style="zoom:67%;"><pre><code class="language-bash">git pull --rebase# 等价于：git fetch origin/maingit rebase origin/main</code></pre><img src="https://s2.loli.net/2024/05/06/Dy1olHPMKZExYLT.png" alt="image-20240506023005761" style="zoom:67%;"><p>其中的分支变化如下：</p><img src="https://s2.loli.net/2024/05/06/6XujLS5UyvFc4pf.png" alt="image-20240506032249539"><p>关于rebase的变化的解释：</p><p>根据精通Git（第二版）的内容，其变基按照如下的方式：</p><ul><li>判断出分支上那些工作是本地独有的（245d、8ea、dd02、e2fdc）。</li><li>判断出哪些提交不是合并提交（245d、8ea、e2fdc）。</li><li>判断出哪些提交并没有被重写到基分支上（orgin/master）（245d、8ea、e2fdc）。</li><li>把筛选出来的分支重写到基分支上</li></ul><p>Git会将合并提交的更改拆分成多个单独的提交，并将它们重新应用在远程分支的顶部。这意味着原始的合并提交（在这个例子中是 <code>dd0258f</code>）不再存在于变基后的分支历史中。</p><p>245df5e提交和e5d18提交完全一致，并不是有效提交，所以被舍弃。</p><p><img src="https://s2.loli.net/2024/05/06/AXrHNwx89vnEa2I.png" alt="image-20240506025758663"></p><p>需要注意的是，没有手动推送上图中test分支，服务器上实际上是没有245df5e,8eafb31的信息的。</p><p>参考：精通Git（第二版）</p>]]></content>
    
    
    <summary type="html">关于Git的分支管理</summary>
    
    
    
    <category term="git" scheme="http://neonexusx.github.io/categories/git/"/>
    
    
    <category term="branch" scheme="http://neonexusx.github.io/tags/branch/"/>
    
    <category term="base" scheme="http://neonexusx.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（第一个Android项目）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-11-28T07:16:57.268Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门第一个android项目">Android开发笔记——快速入门（第一个Android项目）</span></h1><img src="https://s2.loli.net/2024/09/29/MrYRTUN64jDSZ5c.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727615445573" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><p>[TOC]</p><!-- toc --><ul><li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAandroid%E9%A1%B9%E7%9B%AE">第一个Android项目</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAandroid%E6%A8%A1%E6%8B%9F%E5%99%A8">创建一个Android模拟器</a></li><li><a href="#%E9%A1%B9%E7%9B%AE%E5%86%85%E5%AE%B9%E5%88%86%E6%9E%90">项目内容分析</a></li><li><a href="#androidmainifestxml%E7%9A%84%E5%88%86%E6%9E%90">AndroidMainifest.xml的分析</a></li><li><a href="#buildgradle%E7%9A%84%E5%88%86%E6%9E%90">build.gradle的分析</a><ul><li><a href="#buildgradle%E7%9A%84%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE">build.gradle的模块配置</a></li></ul></li></ul><!-- tocstop --><h2><span id="第一个android项目">第一个Android项目</span></h2><p>首先你需要安装<strong>Android Studio</strong>来进行开发，详细安装过程可以参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123426867">Android开发笔记——快速入门（壹)</a></p><p>根据教程创建一个基于<strong>Kotlin</strong>的项目：</p><p>选择新建一个项目以后，选择<strong>Empty Activity</strong>，点击next。</p><p><img src="https://s2.loli.net/2024/09/29/o35u4nGSqmU6cgl.png" alt="13"></p><p>接下来配置项目一些属性，</p><p><strong>Name</strong>代表了项目的名称；</p><p><strong>Package name</strong>表示项目的包名，在<strong>Android</strong>中项目的包名可以用来区分不同的应用程序这个一定要保持唯一性，通常会根据<strong>Name</strong>来自动设定；</p><p><strong>Save Location</strong>表示代码存放的位置，看个人喜好设定；</p><p><strong>Language</strong>选择<strong>Kotlin</strong>；</p><p>**Minimum SDK：**SDK最小支持的 JAVA API level等级；</p><p>最下边的选项是<strong>Android support library</strong>是否支持，目前谷歌已经几乎淘汰了<strong>Android support library</strong></p><p>，替换成了<strong>Android X</strong>。详细了解可以看：<a href="https://blog.csdn.net/guolin_blog/article/details/97142065">Android X</a>。</p><p><img src="https://s2.loli.net/2024/09/29/nJ3FsBmuyVHqSi7.png" alt="2"></p><p>点击Finish后项目会进行预加载会进行一段时间。</p><h2><span id="创建一个android模拟器">创建一个Android模拟器</span></h2><p>在环境搭建部分已经安装了模拟器这里直接运行一个就ok，</p><p><img src="https://s2.loli.net/2024/09/29/WEuiCwO3aStKB9L.png" alt="3"></p><p><img src="https://s2.loli.net/2024/09/29/y4iVG7sbzC6RqwX.png" alt="4"></p><p><img src="https://s2.loli.net/2024/09/29/vgykp8BzCdW9wNs.png" alt="5"></p><h2><span id="项目内容分析">项目内容分析</span></h2><p><img src="https://s2.loli.net/2024/09/29/nSVXrWzBxKtbNaQ.png" alt="6"></p><p>在一般情况下，默认创建的<strong>Android</strong>项目并不是磁盘上的结构，这是因为AS替我们隐藏了一些不必要的信息，但是为了详细了解还是打开<strong>Project模式</strong>看一看：</p><p><img src="https://s2.loli.net/2024/09/29/YCda9rR82G75yJx.png" alt="7"></p><p><strong>.idea</strong>和.<strong>gradled</strong> 是由<strong>AS</strong>所自动产生的gradle配置工具和idea所需要的配置信息，这里不需要深入了解。</p><p><strong>app</strong>就是我们开发所最关心的目录，打开可以看到：</p><p><img src="https://s2.loli.net/2024/09/29/LeTp1IWEGAnmgKk.png" alt="8"></p><ul><li>里面分别还有一个<strong>build文件夹</strong>，这个是存放编译app代码后的地方；</li><li>当你需要使用外部的<strong>Jar</strong>包的时候将外部的<strong>jar</strong>包放入<strong>libs文件夹</strong>，就可以在编译的时候实现自动引用；</li><li><strong>src文件夹</strong>就是存放的我们需要写的代码了；</li><li>在<strong>src</strong>文件夹的<strong>res</strong>目录下存放着整个项目需要的所有资源，包括图片、布局、字符等，后边使用会详细讲；</li><li>在<strong>src文件夹</strong>的<strong>java</strong>目录下存放着整个项目的代码；</li><li>在<strong>src文件夹</strong>的<strong>AndroidMainifest.xml</strong>,这个是整个Android项目的配置文件，需要使用的组件都需要在这里注册，并给应用程序添加权限声明。</li></ul><p>回到主目录</p><p><strong>gradle文件夹</strong>包含了gradle wrapper，gradle wrapper是针对gradle的一种配置工具，<a href="https://blog.csdn.net/sinat_31311947/article/details/81084689">具体可以看这里</a>；</p><p><strong>build.gradle</strong>是全局的gradle构建脚本，稍后会详细分析；</p><p><strong>gradle.properties</strong>是针对gradle构建的全局配置文件，包含了需要配置的构建属性，更改这个会影响全局gradle构建脚本 <a href="https://blog.csdn.net/u013553529/article/details/55011602">具体可以参考这里；</a></p><p><strong>gradle.bat</strong>是在Windos环境下使用的命令行；</p><p><strong>settings.gradle</strong>这个文件指定的是项目所有引用的模块，一般只有app模块，通常情况下是自动完成引用的；</p><h2><span id="androidmainifestxml的分析">AndroidMainifest.xml的分析</span></h2><p><img src="https://s2.loli.net/2024/09/29/z3uvANDVnyU8Zr7.png" alt="9"></p><p>这个xml看起来一大堆的，看起来很麻烦，这波就来一个庖丁解牛分析：</p><p>先回忆一下，<strong>AndroidMainifest</strong>是整个安卓项目的配置文件，所以里面的内容一定是和项目的各个属性相关的，最外层的标签你可以猜到是用来表示这个应用的最外层，标签以内都是这个应用的属性，大眼一扫你可以看到一个很熟悉的关键字<strong>activity</strong>，这段代码实际上是为应用注册了一个名字为<strong>MainActivity</strong>的组件，在<strong>activity</strong>标签里面还有一个<strong>intent-filter</strong>标签是过滤器标签节点，通过<strong>Action</strong>属性和<strong>category</strong>分别实现了把<strong>Activity</strong>设为主<strong>Activity</strong>和启动<strong>Activity</strong>。，在手机上点击图标首先启动的就是这个<strong>Activity</strong>。</p><p>看回到外层，可以看到许多这样的形式：<code>android:icon="@mipmap/ic_launcher</code>，这些是干什么的呢？在这里就要回想一个东西：<strong>res文件夹</strong>，通过英文名称你也能猜到这表示的是某个图标，而后面的就是图标存放的位置，事实的确如此，打开res文件夹可以看到有着相同路径的内容，这里的@语法就是引用的意思：</p><p><img src="https://s2.loli.net/2024/09/29/6M21mqdNGWDh3Yz.png" alt="10"></p><p>看到图片你会想到一个问题，为什么有这么多Mipmap开头的文件夹？其实后缀是针对不同的分辨率，现在主流的分辨率还是xxhdpi，你如果有合适的图标就可放进去。</p><h2><span id="buildgradle的分析">build.gradle的分析</span></h2><p>gradle是一种新型构建工具，不同于传统的XML，使用基于Groovy的领域特定语言（目前还不太懂，挖个坑）。</p><p>其实在app目录下和项目根目录下都有一个build.gradle脚本，我们先来看看最外层的脚本：</p><pre><code class="language-groovy">// Top-level build file where you can add configuration options common to all sub-projects/modules.plugins {    id 'com.android.application' version '7.1.2' apply false    id 'com.android.library' version '7.1.2' apply false    id 'org.jetbrains.kotlin.android' version '1.5.30' apply false}task clean(type: Delete) {    delete rootProject.buildDir}</code></pre><p>和老版小雪狐的不太相同的是小蜜蜂版本出现了许多位置变化，可以参考：<a href="https://blog.csdn.net/sinat_38167329/article/details/123175556">Gradle新版变化</a>。</p><p>参考以上链接：</p><p>工程的build.gradle的<strong>dependencies</strong>修改为plugins，替代了引用原来的Gradle版本。</p><pre><code class="language-groovy">plugins {    id 'com.android.application' version '7.1.2' apply false    id 'com.android.library' version '7.1.2' apply false    id 'org.jetbrains.kotlin.android' version '1.5.30' apply false}</code></pre><p>功能位置迁移，原来在工程build.gradle的<strong>buildscript</strong>和<strong>allprojects</strong>移动至<strong>setting.gradle</strong>并改名为<strong>pluginManagement</strong> 和<strong>dependencyResolutionManagement</strong>。里面的东西依旧可以按照原来的copy过来。</p><pre><code class="language-groovy">pluginManagement {    repositories     {        gradlePluginPortal()        google()        mavenCentral()    }}dependencyResolutionManagement {    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)    repositories    {        google()        mavenCentral()    }}rootProject.name = "My Application"include ':app'</code></pre><p>两个repositories分别中的的   <code>google(）  mavenCentral()</code>分别对应了两个官方仓库，通过这两个配置可以在项目中引用这两个仓库中的所有依赖。</p><h3><span id="buildgradle的模块配置">build.gradle的模块配置</span></h3><pre><code class="language-groovy">plugins {    id 'com.android.application'    id 'org.jetbrains.kotlin.android'}android {    compileSdk 32// 编译时用的SDK版本    defaultConfig {        applicationId "com.example.myapplication"//应用标识名称，这里默认使用应用名字，系统根据这个区分不同应用，应用的唯一标识        minSdk 21//最小SDK兼容版本        targetSdk 32//测试使用的sdk版本        versionCode 1//代码的版本        versionName "1.0"        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"    }    buildTypes {        release {            minifyEnabled false//是否对代码进行混淆            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'//混淆规则        }    }    compileOptions {        sourceCompatibility JavaVersion.VERSION_1_8//编译兼容java版本        targetCompatibility JavaVersion.VERSION_1_8    }    kotlinOptions {        jvmTarget = '1.8'//kotlin运行的目标jvm版本    }    buildFeatures {        viewBinding true    }}dependencies {    implementation 'androidx.core:core-ktx:1.7.0'    implementation 'androidx.appcompat:appcompat:1.3.0'    implementation 'com.google.android.material:material:1.4.0'    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'    implementation 'androidx.navigation:navigation-fragment-ktx:2.3.5'    implementation 'androidx.navigation:navigation-ui-ktx:2.3.5'    testImplementation 'junit:junit:4.13.2'    androidTestImplementation 'androidx.test.ext:junit:1.1.3'    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'}</code></pre><p>接下来就需要一点点分析了，开头还是针对插件的引用，<code>'com.android.application'</code>代表这是一个应哟个程序模块，有时你可以建立一个<code>'com.android.library'</code>表示是库模块。而这最大区别在于，库模块依附于其他应用程序，而应用程序可以独立于运行。具体内容要了解可以看一下注释。</p><p>dependecies闭包是需要详细说一下的，</p><p>如需向项目添加依赖项，请在 <code>build.gradle</code> 文件的 <code>dependencies</code> 代码块中指定依赖项配置，如 <code>implementation</code>。</p><p>例如，应用模块的以下 <code>build.gradle</code> 文件包含三种不同类型的依赖项：</p><ul><li><strong>本地库模块依赖项</strong></li></ul><pre><code class="language-groovy">implementation project(':mylibrary')</code></pre><p>这声明了对一个名为“mylibrary”（此名称必须与在您的 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html"><code>settings.gradle</code></a> 文件中使用 <code>include:</code> 定义的库名称相符）的 <a href="https://developer.android.google.cn/studio/projects/android-library">Android 库模块</a>的依赖关系。在构建您的应用时，构建系统会编译该库模块，并将生成的编译内容打包到 APK 中。目前还没有用到用到时具体再说。</p><ul><li><strong>本地二进制文件依赖项</strong></li></ul><pre><code class="language-groovy">implementation fileTree(dir: 'libs', include: ['*.jar'])</code></pre><p>Gradle 声明了对项目的 <code>module_name/libs/</code> 目录中 JAR 文件的依赖关系（因为 Gradle 会读取 <code>build.gradle</code> 文件的相对路径）。</p><ul><li><strong>远程二进制文件依赖项</strong></li></ul><pre><code class="language-groovy">implementation 'com.example.android:app-magic:12.3'</code></pre><p>这声明了对“com.example.android”命名空间组内的 12.3 版“app-magic”库的依赖关系。</p><p>gradle在构建的时候会检查一下本低是否有这个库的缓存，如果没有会自动联网下载，在添加到目录中</p>]]></content>
    
    
    <summary type="html">第一个Android项目</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin与lambda）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E4%B8%8E%20lamda)/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E4%B8%8E%20lamda)/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-11-28T07:16:57.269Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin与lambda">Android开发笔记——快速入门（Kotlin与lambda）</span></h1><img src="https://s2.loli.net/2024/09/29/Y1eySEM3hX46p8C.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727617420599" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E4%B8%8Elambda">Kotlin与lambda</a><ul><li><a href="#kotlin%E7%9A%84%E9%9B%86%E5%90%88">Kotlin的集合</a><ul><li><a href="#kotlin%E7%9A%84list">kotlin的list</a></li><li><a href="#kotlin%E5%8F%AF%E5%8F%98%E7%9A%84list">kotlin可变的list</a><ul><li><a href="#kotlin%E7%9A%84arraylist">kotlin的ArrayList</a></li></ul></li><li><a href="#kotlin%E7%9A%84set">kotlin的set</a></li><li><a href="#kotlin%E7%9A%84map">kotlin的map</a></li></ul></li><li><a href="#kotlin%E7%9A%84lambda">kotlin的lambda</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BC%A0%E9%80%92lambda%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">什么时候需要传递lambda作为参数？</a></li><li><a href="#kotlin%E7%9A%84%E9%97%AD%E5%8C%85">kotlin的闭包</a><ul><li><a href="#kotlin%E5%87%BD%E6%95%B0%E5%BC%8Fapi">kotlin函数式API</a></li><li><a href="#kotlin%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">kotlin的函数式接口</a></li><li><a href="#java%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">Java的函数式接口作为参数</a></li><li><a href="#kotlin%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">kotlin的语法糖</a></li><li><a href="#java%E5%87%BD%E6%95%B0%E5%BC%8Fapi%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">Java函数式API的语法糖</a></li></ul></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin与lambda">Kotlin与lambda</span></h2><h3><span id="kotlin的集合">Kotlin的集合</span></h3><p>在介绍lambda表达式之前先介绍一下kotlin中的集合类，传统意义上的集合主要是list和set还有map。下面来一一介绍一下kotlin中这些内容如何使用。</p><h4><span id="kotlin的list">kotlin的list</span></h4><p><strong>list的主要实现类是ArrayList与LinkedList</strong>，这里主要是介绍<strong>List</strong>而不是它的具体实现类</p><p>List的特性很简单：</p><ul><li>允许出现重复的元素。</li><li>元素有序，存入和取出的顺序一致。</li><li>元素以一种线性的方式存储，在程序中可以通过索引来访问集合中的主要元素。</li></ul><p>使用传统的list像java一样通过函数一个一个初始化添加在kotlin中也是可以的：</p><pre><code class="language-kotlin">val list_test = ArrayList&lt;String&gt;()list_test.add("apple")list_test.add("pear")</code></pre><p>不过kotlin提供了更加方便的方法,我们使用<code>listof</code>来实现更加方便快捷:</p><pre><code class="language-kotlin">val list_kotlin = listOf&lt;String&gt;("apple","pear")for (list in list_kotlin)println(list)</code></pre><p>你可以注意到这里声明的list使用的是val关键字而不是var说明他是一个不可变的量，除了初始化添加的内容不允许再添加其他内容。</p><p>输出结果如下</p><pre><code class="language-shell">applepear</code></pre><h4><span id="kotlin可变的list">kotlin可变的list</span></h4><p>kotlin中使用可修改的list也很简单，更换关键字为<code>mutableListOf</code>即可：</p><pre><code class="language-kotlin">var list_var = mutableListOf("apple","pear")list_var.add("no fruits")println(list_var[0])println(list_var[2])</code></pre><p>可以看到调用了add来进行添加。</p><p>输出结果：</p><pre><code class="language-kotlin">appleno fruits</code></pre><h5><span id="kotlin的arraylist">kotlin的ArrayList</span></h5><p>List与ArrayList的不同点：</p><p>List实际上是接口并不是一个普通的类</p><p>ArrayList继承了几乎全部的<strong>MutableList</strong>的方法，除了继承的方法ArrayList类内部还实现了两个独特的方法：</p><pre><code class="language-kotlin">fun trimToSize()fun ensureCapacity(minCapacity: Int)</code></pre><p>分别是可以扩容和缩小占用内存，具体可以见：<a href="https://blog.csdn.net/gzheclipse/article/details/105956271">ArrayList的trimToSize</a>。</p><p>但是！你如果使用<strong>mutableListOf</strong>来实现一个可变的列表，它实际上返回的就是<strong>ArrayList！</strong></p><p>不信可以看源码：</p><pre><code class="language-kotlin">/** * Returns a new [MutableList] with the given elements. * @sample samples.collections.Collections.Lists.mutableList */public fun &lt;T&gt; mutableListOf(vararg elements: T): MutableList&lt;T&gt; =    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))</code></pre><p>ArrayList是List接口的一个实现类，它是程序中最常见的一种集合。</p><pre><code class="language-kotlin">val list_kotlin = arrayListOf("apple","pear")for (list in list_kotlin)    println(list)</code></pre><p>它的使用和list基本一致，当然效率相较于list可能会有些下降，因为ArrayList集合在增加或删除指定位置的数据时，会创建新的数组导致效率变低。</p><h4><span id="kotlin的set">kotlin的set</span></h4><p>set类与list的不同在于底层，set不允许集合内存在相同的内容，set的集合底层使用的是hash映射机制来存放数据的，因此集合的元素保证了内容的不重复，但同时也失去了顺序。</p><p>set的演示：</p><pre><code class="language-kotlin">//set 演示val set_kotlin = setOf("apple","pear","apple")for (set in set_kotlin)    println(set)</code></pre><p>可变set演示：</p><pre><code class="language-kotlin">var set_var = mutableSetOf("1","2","3","4")for (set in set_var)    println(set)</code></pre><h4><span id="kotlin的map">kotlin的map</span></h4><p>map类就不再多说，实际上就是通过键值和内容实现的映射集合，值得注意的是他的迭代方式有所不同：</p><pre><code class="language-kotlin">val map_test = HashMap&lt;String,Int&gt;()map_test["apple"] = 1map_test["banana"] = 2for ((fruit ,number) in map_test)    println("fruit is $fruit number is $number")</code></pre><p>前面介绍过for循环转变为了迭代器，这里就充分发挥了其迭代器的特性，可以同时迭代map中的内容和键值。可以看到输出结果：</p><pre><code class="language-kotlin">fruit is banana number is 2fruit is apple number is 1</code></pre><p>当然kotlin也提供了简洁的写法通过<code>to</code>来实现，键值与内容的映射，但to在这里并不是关键字而实更复杂的内容，我们到后边再说：</p><pre><code class="language-kotlin">val map_kotlin = mapOf("apple" to 1,"banana" to 2)for ((fruit ,number) in map_kotlin)    println("fruit is $fruit number is $number")</code></pre><p>输出结果：</p><pre><code class="language-kotlin">fruit is apple number is 1fruit is banana number is 2</code></pre><p>可以看到两次输出结果并不一致，这里先挖一个坑，当然你也注意到set并不能直接用【】类似于数组下标的方式访问，这些等以后再详细说明。</p><h3><span id="kotlin的lambda">kotlin的lambda</span></h3><p>集合的函数式API作为lambda表达式的演示再好不过了。</p><p>首先我们来说一说什么是lambda。</p><p><strong>Lambda就是一小段可以作为参数传递的代码</strong>，这就很厉害，因为常规情况下我们作为参数传递的都是变量，而参数转变为lambda表达式的时候就可以传递进去一段带有逻辑处理的代码。</p><p>对于一小段这个量词的定义并不明确，通产来说在能保持可读性的前提下可以尽量的短或长。</p><p>lambda的常规语法：</p><pre><code>{参数名1 ：参数类型，参数名2，参数类型 -&gt; 函数体（代码块）}</code></pre><p>首先最外层是一个大括号，如果有参数需要向lambda传递的话我们需要先声明参数列表，参数列表的结尾是一个“-&gt;”这代表着参数的结束和函数体的开始，<strong>函数体的最后一行会自动作为lambda表达式的返回值</strong>。</p><h4><span id="什么时候需要传递lambda作为参数">什么时候需要传递lambda作为参数？</span></h4><p>在Java里面lambda表达式出现所要替代的对象实际上Java的<strong>单抽像方法接口</strong>也可以被叫做<strong>函数式接口</strong>，他俩共同的所代表的意义就是：</p><p><strong>接口中有且仅有一个抽象方法需要被实现</strong>。</p><p><strong>换句话说就是接口里面只有一个需要被实现的方法。</strong></p><p>当<strong>这种类型的接口</strong>作为参数的时候，我们就需要传递一个内部匿名类来实现其抽象方法</p><p>这里为了方便下边讲解先说几个结论，并不完全，可自行推广：</p><ul><li>kotlin的函数式API</li><li>kotlin的函数式接口</li><li>Java的函数式接口作为参数</li></ul><h4><span id="kotlin的闭包">kotlin的闭包</span></h4><p>与其说Kotlin是一等公民，不如说是闭包才是一等公民。</p><p>闭包在kotlin中常常指的就是由{}构成的lambda表达式，之所以叫他闭包，实际上就是因为他与函数有很大的区别，比如闭包可以访问外部环境的变量，普通函数想要访问外部环境的变量是需要传入参数的，而闭包可以直接访问，并将其保存下来，具体可见参考文章。</p><p>参考文章：</p><p><a href="https://www.jianshu.com/p/b968524a0e95%E3%80%82">https://www.jianshu.com/p/b968524a0e95。</a></p><p><a href="https://kymjs.com/code/2017/04/09/01/#:~:text=%E9%97%AD%E5%8C%85%E5%BA%94%E8%AF%A5%E7%AE%97%E6%98%AF%20Kotlin%20%E6%9C%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%80%E4%BA%86%E3%80%82%20%E4%BD%BF%E7%94%A8%E5%A5%BD%E9%97%AD%E5%8C%85%E5%8F%AF%E4%BB%A5%E8%AE%A9%E4%BB%A3%E7%A0%81%E9%87%8F%E5%A4%A7%E5%A4%A7%E5%87%8F%E5%B0%91%EF%BC%8C%E4%BE%8B%E5%A6%82%20Kotlin%20%E6%9C%80%E8%91%97%E5%90%8D%E7%9A%84%E5%BC%80%E6%BA%90%E5%BA%93%EF%BC%9A%20Anko,%EF%BC%8C%E4%BD%BF%E7%94%A8%20Anko%20%E5%8E%BB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80%EF%BC%8C%E6%AF%94%E4%BD%BF%E7%94%A8%20Java%20%E4%BB%A3%E7%A0%81%E9%85%8D%E5%90%88%20xml%20%E8%A6%81%E6%9B%B4%E5%8A%A0%E7%AE%80%E6%B4%81%E3%80%82%20%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E5%85%85%E5%88%86%E8%BF%90%E7%94%A8%E4%BA%86%E9%97%AD%E5%8C%85%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7%EF%BC%8C%E7%9C%81%E7%95%A5%E4%BA%86%E5%BE%88%E5%A4%9A%E7%9A%84%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%82%E6%95%B0%E5%A3%B0%E6%98%8E%E3%80%82">闭包2</a>.</p><p>我在这里举一个例子方便大家理解一下，如果看不懂看完本文再回过头来看效果更好：</p><pre><code class="language-kotlin">    val list = listOf("Apple", "Banana", "Orange", "Pear",        "Grape", "Watermelon")    val newList = list.map() { fruit: String -&gt;        {fruit.uppercase() }}    for (fruit in newList) {        println(fruit)    }</code></pre><p>这里实际上输出的是闭包或者说是函数类型常量。</p><h5><span id="kotlin函数式api">kotlin函数式API</span></h5><p>我们先说明什么是kotlin函数式API：</p><p>先看一段代码，在最开始的一行我们定义了一个lambda表达式，他接受一个String类型的参数并返回字符的长度。</p><pre><code class="language-kotlin">//lambda 表达式演示val lambda = { fruit:String -&gt; fruit.length}val Max = list_test.maxOf(lambda)println(Max)</code></pre><p>我们跳转到maxof函数的定义去看看一看它的参数写的是什么：</p><pre><code class="language-kotlin">public inline fun &lt;T, R : Comparable&lt;R&gt;&gt; Iterable&lt;T&gt;.maxOf(selector: (T) -&gt; R): R {    val iterator = iterator()    if (!iterator.hasNext()) throw NoSuchElementException()    var maxValue = selector(iterator.next())    while (iterator.hasNext()) {        val v = selector(iterator.next())        if (maxValue &lt; v) {            maxValue = v        }    }    return maxValue}</code></pre><p>可以看到它的参数实际上就是一个lambda表达式：<code>selector: (T) -&gt; R</code></p><p>是不是很简单？很明了？我们再来看看什么是kotlin的函数式接口：</p><h5><span id="kotlin的函数式接口">kotlin的函数式接口</span></h5><p>在kotlin1.4中更新了函数接口，与java不同的是，kotlin需要显示的来定义一个函数接口，在<code>interface</code>接口添加一个<code>fun</code>关键字就可以实现把他转换为函数式接口：</p><pre><code class="language-kotlin">fun interface Eat{    fun eat_rice()}</code></pre><p>当函数式接口作为参数的时候就可以使用kotlin的lamda表达式：</p><pre><code class="language-kotlin">//lambdaval lambda2 = { -&gt; println("lambda is ok with kotlin interface")}test.lambda_tester(lambda2)</code></pre><p>因为原方法中并没有参数，所以前边也没有任何参数需要传递，我们可以简写成：</p><pre><code class="language-kotlin">//lambdaval lambda2 = { println("lambda is ok with kotlin interface")}test.lambda_tester(lambda2)</code></pre><h5><span id="java的函数式接口作为参数">Java的函数式接口作为参数</span></h5><p>如果我们在Kotlin代码中调用一个java方法，并且该方法只接收一个java单抽像方法接口作为参数，我们就可以使用lambda来传递参数：</p><p>我们这里来拿java的Thread类来举例子：</p><p>thread类的构造方法接收一个Runnable接口作为参数，Runnable是典型的函数式接口，里面只有一个run方法需要实现，当我们使用匿名内部类来实现的时候写法如下：</p><pre><code class="language-kotlin">Thread(object :Runnable{    override fun run() {        println("kotlin is  ok with anonymous")    }}).start()</code></pre><p>看起来很复杂，这里不再介绍匿名类的具体内容，你只需要知道 kotlin完全舍弃new关键字，这里的object类似于创建一个内部类，先尝试理解一下，实际上和这个感知还是有一定差距，到后面再说，我们直接来说如何用kotlin的lambda来实现java的函数式接口：</p><pre><code class="language-kotlin">Thread(    Runnable{-&gt; println("kotlin is ok with java")}).start()</code></pre><p>语法格式：</p><pre><code class="language-shell">接口名 { 参数 -&gt; 函数体 }</code></pre><p>讲到这里我想你应该明白什么时候用lambda什么参数的情况下使用lambda。</p><p>接下来我们顺着kotlin的设计思想，来讨论一下他的语法糖，上边为了你方便理解我并没有使用简写，但kotlin的最关键的还是他的语法糖，语法糖很甜。</p><h5><span id="kotlin的语法糖">kotlin的语法糖</span></h5><p>我们回到maxof方法：</p><pre><code class="language-kotlin">//lambda 表达式演示val lambda = { fruit:String -&gt; fruit.length}val Max = list_test.maxOf(lambda)</code></pre><p>实际上这里的lambda参数可以改写为：</p><pre><code class="language-kotlin">val Max = list_test.maxOf({ fruit:String -&gt; fruit.length})</code></pre><p>kotlin规定当lambda参数是函数的最后一个参数的时候可以放到括号外边：</p><pre><code class="language-kotlin">val Max = list_test.maxOf(){ fruit:String -&gt; fruit.length}</code></pre><p>接下来如果lambda表达式时函数唯一的参数的话还可以将括号省略：</p><pre><code class="language-kotlin">val Max = list_test.maxOf{ fruit:String -&gt; fruit.length}</code></pre><p>不要忘了kotlin具有很强的推导类型的能力，所以参数类型也可以省略：</p><pre><code class="language-kotlin">val Max = list_test.maxOf{ fruit -&gt; fruit.length}</code></pre><p>最后如果lambda表达式中只有一个参数的时候可以直接省略参数使用it来替代，同时“-&gt;”也可以省略：</p><pre><code class="language-kotlin">val Max = list_test.maxOf{ it.length}</code></pre><p>你会对这些省略规则感到复杂，其实抓住重点就是几条：</p><ul><li>最后一个参数 -&gt;移出到外边</li><li>唯一参数 - &gt; 省略和替代</li><li>参数类型-  &gt;可推导的省略</li></ul><p>我们按照这三个语法糖来实现代码优化：</p><h5><span id="java函数式api的语法糖">Java函数式API的语法糖</span></h5><pre><code class="language-kotlin">Thread(object :Runnable{    override fun run() {        println("kotlin is  ok with anonymous")    }}).start()</code></pre><p>首先Runnable接口是一个java的函数式接口，也就是其中只有一个抽象方法，并且对于Tread来说构造函数也只有这样一个接口参数，这两个唯一就符合上边的省略的替代策略。</p><p>省略接口名称，和重写方法的名称：</p><pre><code class="language-kotlin">Thread({        println("kotlin is ok with java")    }).start()</code></pre><p>同时他也是最后一个参数，也是唯一的参数省略括号和外移：</p><pre><code class="language-kotlin">Thread{        println("kotlin is ok with java")    }.start()</code></pre><p>牢记语法糖的实现规则，很方便的来优化代码。</p>]]></content>
    
    
    <summary type="html">Kotlin入门；Kotlin与lambda，list set map 闭包</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/categories/Android/Kotlin/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin的NULL）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84NULL)%20/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84NULL)%20/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-11-28T07:16:57.269Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门-kotlin与null">Android开发笔记——快速入门 (Kotlin与NULL)</span></h1><img src="https://s2.loli.net/2024/09/29/9rGTdRm4giweluL.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727617602165" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E7%A9%BA%E6%8C%87%E9%92%88%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7">Kotlin的空指针与辅助工具</a><ul><li><a href="#kotlin%E7%9A%84%E5%88%A4%E7%A9%BA">Kotlin的判空</a></li><li><a href="#kotlin%E7%9A%84%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B">Kotlin的可空类型</a></li><li><a href="#kotlin%E7%9A%84%E5%88%A4%E7%A9%BA%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7">Kotlin的判空辅助工具</a><ul><li><a href="#"><code>?.</code></a></li><li><a href="#"><code>?:</code></a></li><li><a href="#let%E5%87%BD%E6%95%B0">let函数</a></li></ul></li><li><a href="#kotlin%E5%88%A4%E7%A9%BA%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5">Kotlin判空的特殊情况</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的空指针与辅助工具">Kotlin的空指针与辅助工具</span></h2><h3><span id="kotlin的判空">Kotlin的判空</span></h3><p>在写java或者c的时候最让人难受的就是空指针的问题了，当你写了一大段代码，运行时来一个报错，心态是很爆炸的，怎么又找不到变量在哪里了？但是你如果正常情况下书写kotlin就不会遇到这些问题，为什么呢？</p><p>因为kotlin将判空过程不是放在运行时，而是放在了编译过程中，甚至有些在kotlin语言设计的时候就已经在考虑如何避免了，说起来可能很复杂，接下来详细介绍一下kotlin的判空机制。</p><p>先来看一段代码：</p><pre><code class="language-kotlin">class Zzy(val gender: String = "Boy") : Person(22,"zhuzeyu"){    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init    {        println(name+" is a "+gender+" age is "+age)    }}fun main(args: Array&lt;String&gt;){    //koltin 空指针检查 //这段代码没有空指针风险    val zzy = Zzy("boy")}</code></pre><p>我们构造了一个类并且继承了Person类，最后在主函数中调用这个类的构造方法，需要注意的是构造方法需要传入的一个字符串，如果传入的是一个空的字符串这里就会产生空指针问题，在java中是不给你任何提示的，但是在kotlin中就有所不同：</p><p><img src="https://s2.loli.net/2024/09/29/ob2dVHwq4IxAWSU.png" alt="image-20220408215120939"></p><p>可以看到kotlin因为传入空而报错，这不是最重要的，因为这里显式的传入了null，那如果我们传入的是一个变量呢？</p><p>这里为了方便演示再传入一段代码：</p><pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;){    //koltin 空指针检查 //这段代码没有空指针风险    val zzy = Zzy(null)    var fake_zzy :String = null;}</code></pre><p>实际上<code>var fake_zzy :String = null</code>是不能运行的，kotlin给出了错误提示：</p><p><img src="https://s2.loli.net/2024/09/29/ASvpMjH15egbKnd.png" alt="image-20220408222048233"></p><p>编译器知道你这里传入就是一个null，所以代码实际上是不能运行的。</p><p>可以看到Kotlin从编译层面就避免了空指针问题的发生，但是这就意味着null在kotlin中就没有用处了吗？当然不是，接下来来介绍kotlin的可空类型。</p><h3><span id="kotlin的可空类型">Kotlin的可空类型</span></h3><p>如果在某个情况下我需要根据传入的变量的情况（空或者不空）来进行操作，但是你意识到这里面所有的传递参数都不能是空，甚至连编译都没办法通过这怎么办？</p><p>kotlin其实提供了可空类型</p><p>我们来看一个例子：</p><p><img src="https://s2.loli.net/2024/09/29/q7HRpfNolbKTBs8.png" alt="image-20220408221845089"></p><p>你注意到String后边添加了一个？这事 String的变量不再报错了，对这就是可空的String类型。</p><p>当然不止String有，每个kotlin的类型都可以声明为可空类型，基本结构如下：</p><pre><code class="language-kotlin">var 变量名 ： 变量类型 ? = null</code></pre><p>当然你也许也注意到了方法传入的参数也被报错了，</p><p>其中test类是用来创建测试函数的，函数具体内容如下：</p><pre><code class="language-kotlin">fun eat_empty_food (person: Person) =     if (person != null)         person.eat_empty()     else        "empty"</code></pre><p>可以看到此方法接受一个Person类作为参数，而zzy类继承了People类正好可以作为参数传递进去，但是这里我们传入了一个null，编译器报错了，为什么呢？因为参数也需要设置成可空的类型：</p><pre><code class="language-kotlin">fun eat_empty_food (person: Person?) = if (person != null) person.eat_empty() else "empty"</code></pre><p>这段代码什么意思呢？就是如果传进来的参数不是null的就正常调用一个方法，如果是空的就返回empty字符串。</p><p>是不是很简单呢？这是kotlin为了避免空指针问题而做的隔离，完全将空指针和正常变量做了一个隔离。</p><h3><span id="kotlin的判空辅助工具">Kotlin的判空辅助工具</span></h3><p>在上面我们介绍了kotlin如何将空指针赶尽杀绝，但是我们有些时候也需要通过空指针来判断一些具体情况，Kotlin同时提供了一套完整、便捷的判断工具。</p><h4><span id><code>?.</code></span></h4><p>首先介绍：<code>?.</code></p><p>在上一节，如果你更改了参数为可空类型，实际上他还会报错，因为这时候函数使用的时候，就有可能遇到null问题，如何更改呢？就要使用<code>?.</code>。</p><pre><code class="language-kotlin">fun eat_empty_food_update (person: Person?) = person?.eat_empty()</code></pre><p><code>?.</code>当对象不为空的时候正常调用方法，当为空的时候什么也不做。这里的作用就是为了避免空指针调用方法，你会说这好鸡肋啊没什么用，先别急后边会有更方便的方法一起组合来使用。</p><h4><span id><code>?:</code></span></h4><p>我们先介绍第二个工具关键词：<code>?:</code></p><p>这个操作符左右两边都接受一个表达式，如果左边表达式的结果不为空就返回左边的表达式，否则就返回右边的表达式的结果。你如果问这个有什么用？我们返回去看一段代码：</p><pre><code class="language-kotlin">fun eat_empty_food (person: Person?) = if (person != null) person.eat_empty() else "empty"</code></pre><p><code>?:</code>就和if和else作用一摸一样，就是其的简写，这样看起来是不是很简单很方便？</p><pre><code class="language-kotlin">fun eat_empty_food_plus (person: Person?) = person?.eat() ?: "empty"</code></pre><p>当person为空的时候<code>?.</code>就会返回一个null这时候配合<code>?:</code>就实现了简化版的if else，从而避免了为null的情况。</p><h4><span id="let函数">let函数</span></h4><p>let函数是kotlin独特的一个函数，这个函数接收的参数是一个函数式API接口，也就是需要你传入进去一个lambda表达式来使用，如果你不懂就翻回去看上一篇。</p><p>我这里直接介绍let如何使用：</p><pre><code class="language-kotlin">obj.let{obj -&gt; //函数体}</code></pre><p>举个例子：</p><pre><code class="language-kotlin">private var special : String? = "empty_special"//let函数this.special?.let{it.length}输出结果：13</code></pre><p>你可以发现let函数默认将调用它的对象作为参数传入到了lambda表达式中，这有什么用呢？</p><p>如果存在一种情况，你需要判断的对象调用了两个方法，你要这样写吗？</p><pre><code class="language-kotlin">fun eat_twofood (person: Person?) = {    person?.eat_empty()    person?.eat()}</code></pre><p>这样一点也不优雅，打咩！</p><p>kotlin就是讲究优雅，我们改写以后使用let函数会将对象自动作为参数的特性：</p><pre><code class="language-kotlin">fun eat_twofood (person: Person?) = person?.let { it.eat_empty(); it.eat();  }</code></pre><p>kotlin的函数一行就足够了！</p><p>可以看到我们使用let函数的特性来实现了对单个对象引用多方法的判空处理，这样我们只需要判断一次就可以了，如果有多个方法调用，也只需要一次，省力又省时。我们只需要在let函数前使用<code>?.</code>判断一次即可,然后使用let函数的参数来调用对应方法。</p><h3><span id="kotlin判空的特殊情况">Kotlin判空的特殊情况</span></h3><p>Kotlin的判空并不是完美的，某些情况下会阻碍我们的书写，因此要提前预知从而避免。</p><pre><code class="language-kotlin">//特殊情况if (test.special!=null)    println(test.eat_empty_food_special())</code></pre><p>其中<code>eat_empty_food_specia</code>方法如下：</p><pre><code class="language-kotlin">fun eat_empty_food_special () = this.special.length</code></pre><p><img src="https://s2.loli.net/2024/09/29/lkxcVzMjhs3oUGq.png" alt="image-20220408232756812"></p><p>实际上这里是有报错的，因为这里编译器判定special可能为空，但是实际我们在函数的外，调用方法之前已经对其做了防空处理，但是IDE感知不到，但是问题不大，我们更换写法即可。</p>]]></content>
    
    
    <summary type="html">Kotlin的NULL</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/categories/Android/Kotlin/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin入门）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E5%85%A5%E9%97%A8)/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E5%85%A5%E9%97%A8)/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-11-28T07:16:57.269Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin入门">Android开发笔记——快速入门（Kotlin入门）</span></h1><img src="https://s2.loli.net/2024/09/29/gC5eQ3URr1qGApZ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727617280095" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#why-kotlin">Why Kotlin？</a><ul><li><a href="#kotlin%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2">Kotlin的发展历史</a></li><li><a href="#kotlin%E5%92%8Cjava%E7%9A%84%E6%AF%94%E8%BE%83%E4%BC%98%E7%82%B9">Kotlin和java的比较优点</a></li></ul><ul><li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8kotlin%E5%BC%80%E5%8F%91android">如何使用Kotlin开发Android？</a><ul><li><a href="#kotlin%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0">Kotlin的变量与函数</a><ul><li><a href="#kotlin%E7%9A%84%E5%8F%98%E9%87%8F">kotlin的变量</a></li><li><a href="#kotlin%E7%9A%84%E5%87%BD%E6%95%B0">Kotlin的函数</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6">Kotlin的逻辑控制</a><ul><li><a href="#kotlin%E7%9A%84if">Kotlin的if</a></li><li><a href="#kotlin%E7%9A%84when">Kotlin的when</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E5%BE%AA%E7%8E%AF">Kotlin的循环</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h1><span id="why-kotlin">Why Kotlin？</span></h1><h3><span id="kotlin的发展历史">Kotlin的发展历史</span></h3><p>2011年，JetBrains 发布了Kotlin的第一个版本，并在2012年将其开源。</p><p>2016年Kotlin发布了1.0正式版，代表着Kotlin语言已经足够成熟和稳定了，并且JetBrains 也在自家的旗舰IDE开发工具Intelli]IDEA中加入了Kotlin的支持。</p><p>2017年Google 宣布 Kotlin 正式成为Android开发一级语言，并且Android Studio 也加入了对 Kotlin的支持。</p><p>2019年Google正式宣布了Kotlin First，未来提供的官方API会以Kotlin为主。</p><p><strong>Kotlin</strong>作为<strong>Jetbrain</strong>全新开发的语言，虽然是基于<strong>JVM</strong>进行的开发但是却是<strong>JAVA</strong>的温和改良版本，如果说C是一个国色天香的感觉，那么<strong>Java</strong>就是窈窕淑女而<strong>Kotlin</strong>就是小家碧玉，端庄优雅的温柔。</p><p><strong>Kotlin</strong>是一个极其成功的开源项目，代表了目前编程语言的一个发展方向，<strong>Kotlin</strong>在编写代码时有如下优势：代码简洁高效、函数式编程、空指针安全、支持<strong>lambda</strong>表达式、流式API等。光说起来你会感觉很难懂到底在说什么，但是当你跨进<strong>Kotlin</strong>大门之后才能体会到运用<strong>Kotlin</strong>编程的快乐。</p><h3><span id="kotlin和java的比较优点">Kotlin和java的比较优点</span></h3><p>Kotlin是完全和java兼容的，怎么个兼容办法呢？</p><p>Kotlin可以做到和Java 100%兼容，这主要是得益于Java虚拟机的工作机制 ，其实Java虚拟机并不会直接和你编写的Java代码打交道，而是和编译之后生 成的class文件打交道 ，而Kotlin也有一个自己的编译器，它可以将Kotlin代码也编译成同样规格的 class文件 ，Java虚拟机不会关心class文件是从Java编译来的，还是从Kotlin编译来的， 只要是符合规格的class文件，它都能识别 ，也正是这个原因，JetBrains才能以一个第三方公司的身份设计出一门用来 开发Android应用程序的编程语言</p><p>Kotlin是完全兼容Java现有的代码库的，也就是说你可以跨语言调用对应的代码内容，甚至于还有C、C++互操作，更神奇的是Kotlin也可以完成Javascript的工作，他编写的代码可以编译成JS的代码来运行！</p><h2><span id="如何使用kotlin开发android">如何使用Kotlin开发Android？</span></h2><p>首先你需要安装<strong>Android Studio</strong>来进行开发，详细安装过程可以参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123426867">Android开发笔记——快速入门（壹)</a></p><p>根据教程创建一个基于<strong>Kotlin</strong>的Android项目：</p><p>具体如何创建项目可以参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123458305?spm=1001.2014.3001.5502">上一篇文章</a>。</p><p>创建完成以后，在相同包下创建一个Kotlin类：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/20/8b4f5bf6b35badac.png" alt="1"></p><p>Kotlin class的创建：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/20/acc3bdd49432536e.png" alt="2"></p><h3><span id="kotlin的变量与函数">Kotlin的变量与函数</span></h3><p>创建完成以后就可以愉快的，使用AS来进行kotlin的编写：</p><p>首先创建一个主函数：</p><pre><code class="language-Kotlin">package com.example.codewithkotlinfun main(){    println("Hello Kotlin!")}</code></pre><p>你可以点击左边的小箭头运行一下</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/20/d8f09d31972d0ae5.png" alt="3"></p><h4><span id="kotlin的变量">kotlin的变量</span></h4><p>kotlin的变量与Java有很大的不同，可以总结如下两点：</p><ul><li>定义时不需要指定类型，而是需要指定变量是否可变。</li><li>没有保留Java基本的数据类型，而是使用对象数据类型，在 Kotlin 中，所有东西都是对象。</li></ul><p>举例：</p><p>不需要指定变量类型，其会自动推导：</p><pre><code class="language-kotlin">fun main(){    val a=10    println("a is " + a)}</code></pre><p>指定数据类型时不会再自动推导：</p><pre><code class="language-kotlin">fun main(){    val a : Int=10    println("a is " + a)}</code></pre><p>输出结果：</p><pre><code class="language-shell">a is 10</code></pre><p>val与var是用来指定是否为变量的关键字，val类似于java的final，var就是常规的变量，为什么要这样设计你如果有编程基础你就知道变量是不安全的，val，var就是为了指定这个变量是否可变（强制要求显式定义），这有一个小技巧，定义变量时应该是都定义为val，只有你需要var的时候再回来将这个变量改定义为var，这样就保证了基本所有变量的安全。</p><h4><span id="kotlin的函数">Kotlin的函数</span></h4><p>kotlin的函数与Java中的方法其实很像，但是更自由，书写更方便。</p><p>fun（function的简写）是定义函数的关键字，无论你定义什么函数，都一定要使用fun来声明。当然这不包含函数表达式。</p><p>其基本定义格式如下：</p><pre><code class="language-kotlin">fun funName(param1 : Int,param2 :Int) ：returnvaluetype {return value}</code></pre><p>如果没有返回参数就可以省略<code>：returnvaluetype</code> 部分，从这里看出Kotlin的设计思想：</p><p><strong>能省就省</strong></p><p>简化以后就可以表现为：</p><pre><code class="language-kotlin">fun funName(param1 : Int,param2 :Int){}</code></pre><p>为了保持设计思想，Kotlin做出了更多的省略,当你的函数体只有一块作为返回值的代码时，可以直接省略大括号，用等号来连接,这里用一个返回最大值的函数来表示：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int):Int = max(num1,num2)</code></pre><p>但是我们说过Kotlin具有出色的推导机制，那么他能不能推断出这里一定返回的是和max函数返回相同的内容呢？当然可以。所谓我们进一步简化省略去返回值：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int)= max(num1,num2)</code></pre><p>使用Kotlin以后你就会发现能在一行就实现一个完整的函数，但这并不是我们想要的，因为这里我们只是对MAX函数进行了一个包装，里面并没有任何逻辑部分。下面我们来写一下如何写逻辑部分的内容，并对其进行简化，进一步体验其强大性。</p><h3><span id="kotlin的逻辑控制">Kotlin的逻辑控制</span></h3><h4><span id="kotlin的if">Kotlin的if</span></h4><p>if在使用的时候与传统的if并没有太大区别，但是他还有一个额外的功能，可以有返回值。为什么要给if来整一个返回值呢？返回值常常与函数相关，对于现在流行的函数式编程，Kotlin也对其做出了支持，if的返回值就是如此，<strong>if语句会自动返回其最后一条语句的返回值</strong>：</p><p>常规IF的写法如下：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int) ：Int{    var maxnumber =0    if(num1 &gt;= num2)        maxnumber = num1    else        maxnumber = num2    return maxnumber}</code></pre><p>使用其返回值如下，是不是看起来更简略一点了呢：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int):Int{    val maxnumber = if(num1 &gt;= num2)                        num1                    else                        num2    return maxnumber}</code></pre><p>其实还可以再简略一下我们可以把if和else看成一个语句，这样他就可以直接给函数返回内容，我们就可以省略函数体的括号和返回值类型：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int)=if(num1 &gt;= num2)num1 else num2</code></pre><p>这样就实现了最简洁的写法。</p><h4><span id="kotlin的when">Kotlin的when</span></h4><p>Kotlin的when就是Java，C中的Switch case，负责的是样例匹配的工作，当你需要匹配内容很多的时候用if，是很不优雅的，但是Kotlin的when提供了一种简介方便的方式。</p><p>我先提供一个写法：</p><pre><code class="language-kotlin">fun getGender(name : String) =    when (name)    {        "zzy"-&gt; println("boy")        "lxl"-&gt; println("girl")        "hrq"-&gt; println("boy")        else -&gt;  println("not a boy or girl")    }</code></pre><p>这段代码给我们提供了一个样例，我们通过传入任意一个类型的变量来使用when来进行匹配，when后面的括号就是要匹配的对象，下边的函数体就是要匹配的内容，你可以发现他取消了case等关键字而是使用**“-&gt;”<strong>来作为关键字，意义表达明确，而且你不用担心执行完成后没有</strong>break**会自动向下运行，每一个匹配后会执行完自己的逻辑代码然后退出。值得提醒的是你的逻辑代码只有一行的时候可以省略“{}”。</p><p>除了数据匹配之外，when语句还可以进行类型匹配，没错就是你想的那个数据类型，如果你想起来Kotlin中没有基本的数据类型，而是全部都是类数据，你就会意识到为什么要这样设计数据类型，为了类型匹配只是一小部分优点。</p><p>下面举一个例子：</p><pre><code class="language-kotlin">fun getType(number : Number) =    when (number)    {        is Int -&gt; println("Int type")        is Float-&gt; println("Float type")        is Long-&gt; println("Long type")        else -&gt;  println("not my type")    }</code></pre><p>通过设置输入的number为所有数字类型的父类Number，你可以输入任意类型的数据，然后使用<strong>is</strong>关键字来检测是不是对应的类型。</p><p>你可以看到When里边都是同一种类型的匹配模式，但是如果要使用不同的匹配模式呢，打个比方我一个想要分离出名字里面有是zzy的，另一个想要分离出名字是lxl怎么办？很简单这里去掉when后边的括号就好了，将匹配表达式写入大括号里面。</p><pre><code class="language-kotlin">fun getGender2(name : String) =    when    {        name.contentEquals("zzy")-&gt; println("a part of zzy")        name === "lxl"-&gt; println("girl")        else -&gt;  println("not Anyone")    }</code></pre><h3><span id="kotlin的循环">Kotlin的循环</span></h3><p>在介绍循环之前先介绍一个新的东西，区间</p><p>区间这个东西很简单，它的作用就是按照规律生成一组数列，我们举个例子试一试：</p><pre><code class="language-kotlin">fun rangeTest(){    val range = 1..10    val untils = 0 until 10    val downtos = 10 downTo 1    println(range)    println(untils)    println(downtos)}</code></pre><p>输出结果：</p><pre><code class="language-shell">1..100..910..1</code></pre><p>你可以看见这两个区间生成的数列区别，一个是包含左右边界，一格式只有左边界没有右边界。</p><p>有了区间以后就可以使用for来迭代，for循环在Kotlin中有了巨大的变化，我先来展示一下：</p><pre><code class="language-kotlin">fun rangeTest(){    val range = 1..10    val untils = 0 until 10    println(range)    println(untils)    for (i in 10 downTo 1)        println(i)}</code></pre><p>输出：</p><pre><code class="language-shell">1..100..910987654321</code></pre><p>你可以看到了一个和java c都不太像的for 更想java里面的增强for循环，你就意识到这里for转化为了一个迭代器的作用。在后边我再继续讲解for的强大之处。</p>]]></content>
    
    
    <summary type="html">Kotlin入门</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/categories/Android/Kotlin/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin的对象扩展与高阶函数深入）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95)%20/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95)%20/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-11-28T07:16:57.269Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门-kotlin的对象扩展与高阶函数深入">Android开发笔记——快速入门 (Kotlin的对象扩展与高阶函数深入)</span></h1><img src="https://s2.loli.net/2024/09/29/RU7cAxv8aTSKQf4.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727618114855" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95">Kotlin的对象扩展语法</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F">对象表达式</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F-1">对象表达式</a><ul><li><a href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AD%98%E5%9C%A8%E5%8F%82%E6%95%B0">父类的构造函数存在参数</a></li><li><a href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1">匿名对象</a></li><li><a href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC">匿名对象作为返回值</a></li></ul></li></ul></li></ul></li><li><a href="#kotlin%E7%9A%84%E7%B1%BB%E6%89%A9%E5%B1%95">Kotlin的类扩展</a></li><li><a href="#kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">Kotlin的高阶函数</a></li><li><a href="#%E7%B1%BB%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88">类扩展函数和高阶函数结合</a></li><li><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">深入理解高阶函数</a><ul><li><a href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">内联函数</a></li><li><a href="#noinline%E5%92%8Ccrossinline">noinline和crossinline</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的对象扩展语法">Kotlin的对象扩展语法</span></h2><h3><span id="对象表达式">对象表达式</span></h3><p>有时候，我们需要创建一个对某个类有轻微改动的类的实例化对象，就要再去继承原来的类声明一个子类，但是通过Kotlin的对象表达式就可以避免去创建一个只使用一次的类。</p><h4><span id="对象表达式">对象表达式</span></h4><p>要创建一个继承自某个类的匿名类对象，我们可以使用对象表达式来简化书写，通过对象表达式将<strong>匿名类</strong>的声明和<strong>匿名类对象</strong>的声明糅合在一起，为我们省去了很多代码。</p><p>通常来说我们在使用接口作为参数的的时候使用对象表达式的情况比较多，举个例子，如果我们使用Thread来创建一个线程的时候，Thread类的参数实际上就是一个Ruunable接口，这个Runnable接口就是Java中所说的函数式接口，如果我们不使用lambda来传递的话，就要使用一个实现了<strong>Ruunable接口类的对象</strong>作为参数传递进去。或者使用匿名类的实现（实际上匿名类的实现也是对象）来替代需要实现的类的对象。</p><p>对于对象表达式就类似于的java的匿名类，只不过他的功能更多，在这里你可以先理解为Java中匿名内部类。</p><p>举个例子：</p><pre><code class="language-kotlin">Thread(    object : Runnable {        override fun run() {            println("Kotlin is ok with Anonymous")        }    }).run()</code></pre><p>这里我们创建了一个对象表达式然后继承了Runnable接口，并实现了其中的run方法，最终对象表达式会自动创建一个这个类的对象并返回给Thread类。</p><p>代码运行结果如下：</p><pre><code class="language-shell">Kotlin is ok with AnonymousProcess finished with exit code 0</code></pre><p>当然对象表达式的作用不仅仅局限于函数式接口，它可以用于任何可继承的类，下面再来讨论几种特殊情况。</p><h5><span id="父类的构造函数存在参数">父类的构造函数存在参数</span></h5><p>我们有一个父类如下：</p><pre><code class="language-kotlin">package com.example.codewithkotlinopen class Person(var age :Int, val name:String){    fun study() = name + "love study"}</code></pre><p>父类的形式很简单，就是只有一个方法，两个成员变量。</p><p>我们存在一个函数，需要传入一个父类的对象，就可以使用对象表达式来构造。</p><p>函数如下：</p><pre><code class="language-kotlin">fun fatherargs_tester(person: Person){    println(person.name)}</code></pre><p>解决办法如下：</p><pre><code class="language-kotlin">/*父类的构造函数存在参数*/fatherargs_tester(    object :Person(18,"Jszszzy") {    override fun study() = "$name love studing kotlin"    })</code></pre><p>可以看到我们使用对象表达式创建了一个新的对象，并且将类里面的方法进行了重写，输出是结果如下：</p><pre><code class="language-shell">Jszszzy love studing kotlin</code></pre><p>同时表达式可以访问其所在作用域的变量：</p><pre><code class="language-kotlin">/*父类的构造函数存在参数*/val name = "Jszszzy"fatherargs_tester(    object :Person(18,name) {    override fun study() = "$name love studing kotlin"    })</code></pre><h5><span id="匿名对象">匿名对象</span></h5><p>对象表达式同时也可以构造<strong>匿名对象</strong>，即不继承任何类的匿名表达式。</p><p>举个例子：</p><pre><code class="language-kotlin">val anonymous_object = object {    val x = "test";}println(anonymous_object::class.java.toString())</code></pre><p>我们使用：：class方法来获取到对应的类是什么。</p><p>结果如下:</p><pre><code class="language-kotlin">class com.example.codewithkotlin.TestKt$main$anonymous_object$1</code></pre><p>看以看到是一个特殊的类，类的名称和创建的变量名有一定关系。</p><h5><span id="匿名对象作为返回值">匿名对象作为返回值</span></h5><p>这个是用的比较少，简单来说一下。</p><p>当匿名对象最为返回值的时候，</p><p>如果是一般的共有方法则返回类型自动转化为Any。</p><p>如果是私有办法则为返回类型为对应的匿名对象。</p><p>也就是说匿名对象，实际上其作用域仅限于他所处的类本身。</p><h2><span id="kotlin的类扩展">Kotlin的类扩展</span></h2><p>在某些情况下，我们希望在不修改某些类的源码的情况下（实际上你根本修改不了，大多数库代码都只是可读的）仍然可以为这个类添加新的功能，添加新的方法。就要使用到类的扩展了。</p><p>其基本使用结构如下：</p><pre><code class="language-kotlin">fun Classname.methodName(param1:type,param2:type):Int{return 0}</code></pre><p>可以看到实际上就是定义了一个函数，在前面加上想要添加的具体类名就可以了。注意的是你在在哪里声明的添加方法就会收到其作用域的影响，所以往往把添加的方法直接放到文件中，拥有顶层作用域来使用。</p><h2><span id="kotlin的高阶函数">Kotlin的高阶函数</span></h2><p>高阶函数和Lambda的关系密不可分，可以说高阶函数就是lambda应用的扩展。</p><p>高阶函数的定义是如果某个函数接收另一个函数作为参数或者返回值是一个函数就可以称之为高阶函数。你可能很难理解什么是函数类型？</p><p>实际上新一代语言中不止包含有我们常说的数据类型，大部分语言为了支持函数式编程，都添加了函数类型作为一种基础类型，他和其他基本类型一样，只不过其他基本类型传递的是一段二进制数据，函数类型传递的是一段可执行的代码。</p><p>对于一个lambda表达式来说，我们定义它其实很方便，举个例子，我们这里定义一个函数型变量（其实就是lambda表达式），并调用它输出它运行的结果：</p><pre><code class="language-kotlin">/*Kotlin的类扩展*/val lambda = { x:Int -&gt; x*x }println(lambda(3))</code></pre><p>我们其实也知道kotlin有优秀的推导机制，其实上一个Lambda在声明的时候并没有指明具体返回类型，返回类型是在编译的时候推理出来的。</p><p>但是有些时候，Kotlin无法推断具体类型的情况下，就要手动来声明具体类型来指定了，声明类型也很简单，具体方法如下：</p><pre><code class="language-kotlin">/*Kotlin的lambda使用*/val lambda : (Int) -&gt; Int =  {x -&gt; x*x }println(lambda(3))</code></pre><p>此处指明了lambda表达式的参数类型是Int、并且返回值类型依然是Int，最终输出的结果和上文一样。</p><p>说了这么多，这些又和高阶函数什么关系呢？</p><p>高阶函数的定义指明了要传递函数作为参数，那么如何定义函数参数呢？</p><p>没错就是lambda表达式来作为参数。</p><p>下面举一个例子，以下定义了一个高阶函数。</p><pre><code class="language-kotlin">fun advanced_function( func :(Int) -&gt; Int){    println(func(9))}</code></pre><p>此高阶函数中参数为func，传入的lambda表达式类型为<code>(Int) -&gt; Int</code>也就是说，接收一个输入参数为Int返回值Int的函数。</p><p>但是为什么要传入一个函数作为参数呢？发挥一下你的想象力，我们可以定义符合上述参数类型的lambda表达式，但是函数的逻辑内容可以完全不一样。举个例子：</p><p>我们仍然使用上述高阶函数，但是创建一个新的lambda表达式：</p><pre><code class="language-kotlin">/*Kotlin的高阶函数*/val lambda1 :(Int) -&gt;Int  = {x -&gt; x+x}advanced_function(lambda1)</code></pre><p>此时运算结果就变为了相加。</p><p>与此相对的，Kotlin也支持直接将lambda表达式传递进去，当高阶函数只有一个lambda参数的时候，我们可以直接省略小括号，最终效果和前边完全相同：</p><pre><code class="language-kotlin">/*高阶函数常规用法*/advanced_function{x -&gt; x+x}</code></pre><h2><span id="类扩展函数和高阶函数结合">类扩展函数和高阶函数结合</span></h2><p>当我们在前边使用apply函数的时候很方便就能获得一个上下文，这样调用对象的时候就可以避免重复书写对象，Kotlin同时也为高阶函数提供了类似的功能，我们先来尝试使用扩展函数和高阶函数结合一下：</p><pre><code class="language-kotlin">fun StringBuilder.build(block : () -&gt; Unit):StringBuilder{    block()    return  this}</code></pre><p>这一段函数所代表的意义就是为StringBuilder类扩展一个高阶函数build，其参数为:<code>（）-&gt;Unit</code>的函数。</p><p>在函数内调用传入的函数，并将处理后的对象返回。</p><p>但是这里就会遇到一个问题，我如果想在传入的函数中使用StringBuilder的方法怎么办？也就说这部分函数还是要调用扩展类的方法的，Kotlin为此设计了一个能提供上下文的办法，使用起来很简单效果如下：</p><pre><code class="language-kotlin">fun StringBuilder.build(block :  StringBuilder. () -&gt; Unit):StringBuilder{    block()    return  this}</code></pre><p>可以看到实际上就是在参数类型前边加上了ClassName.的前缀，这样就将要传入的函数参数定义在了在StringBuilder的里面，保证了函数可以自动获取StringBuilder的上下文。</p><p>举个实际例子：</p><pre><code class="language-kotlin">val result = StringBuilder().build {    append("jszszzy")}</code></pre><p>我们在传入的参数中加入了StringBuilder的上下文这样，就相当于获得了调用方法的时候创建的上下文，完整写法如下：</p><pre><code class="language-kotlin">val result = StringBuilder().build {    this.append("jszszzy")}</code></pre><p>最终结果也很简单，输出了添加的字符串：</p><pre><code class="language-shell">jszszzy</code></pre><h2><span id="深入理解高阶函数">深入理解高阶函数</span></h2><h3><span id="内联函数">内联函数</span></h3><p>我们始终要意识到一个问题，kotlin的代码最终都要被编译为java的字节码文件的，但是在java中我们并没有高阶函数的概念，那么Kotlin是如何实现的高阶函数呢？</p><p>这就要归功于Koltin的强大编译器了，在这里我还是要狠狠吹一波Kotlin！Kotlin可不仅仅适用于JVM运行，他甚至还有专门的编译器去编译成类似c语言的字节码直接运行，不依赖于JVM,详细请了解：<a href="https://book.kotlincn.net/text/multiplatform.html">Kotlin多平台</a>。</p><p>那么现在需要编译成JVM的字节码，他会怎么编译呢？我们还是拿上边的函数举个例子：</p><p>我们打开他的反编译java代码：</p><pre><code class="language-java">public static final void advanced_function(@NotNull Function1 func) {   Intrinsics.checkNotNullParameter(func, "func");   int var1 = ((Number)func.invoke(9)).intValue();   System.out.println(var1);}</code></pre><p>可以看到我们的函数类型参数转变为了一个Function1接口，这是神马？</p><p>我们打开看一看：</p><pre><code class="language-kotlin">/** A function that takes 1 argument. */public interface Function1&lt;in P1, out R&gt; : Function&lt;R&gt; {    /** Invokes the function with the specified argument. */    public operator fun invoke(p1: P1): R}</code></pre><p>里面有一个函数叫invoke，继承这个接口的话，那必须就要把这个函数给实现了。</p><p>可以看到原来我们执行传入的函数参数的位置被替换成了一行代码：</p><pre><code class="language-kotlin"> int var1 = ((Number)func.invoke(9)).intValue();</code></pre><p>原来的函数的调用被替换为了一个invoke()函数的调用。</p><p>实际上在调用高阶函数的时候，对应的代码被转换为了如下的样子：</p><pre><code class="language-kotlin">/*替换前源代码*/advanced_function{x -&gt; x+x}/*替换后*/advanced_function(    new Function(){        @Overrride        public Integer invoke(Integer x){            retaurn x+x;        }    })</code></pre><p>也就是说对应的lambda表达式位置被替换成了一个匿名类的实现，通过这个接口将对应的lambda表达式封装到了invoke函数里面，调用invoke函数就相当于使用了对应的lambda表达式！</p><p>但是这就产生了一个问题！我的每一个lambda不会都是这样实现的吧，这样就会造成很大的性能浪费，当你在上边愉快的书写lambda表达式，下边kotlin跑的匿名类累死。</p><p>kotlin为了消除这个问题，又创建了一个方法，这就是内联函数，内联函数是干什么的呢？</p><p>他会使Kotlin编译器将内联函数中的代码在编译的时候替换到对应的地方。实现真正的代码传递。这样在运行的时候就不存在任何运行开销了。说起来可能不太容易，我们做个演示，替换后调用的位置是什么样的:</p><p>使用inline来修饰：</p><pre><code class="language-kotlin">inline fun advanced_function( func :(Int) -&gt; Int){    println(func(9))}</code></pre><p>对应调用位置的代码：</p><pre><code class="language-kotlin">/*使用内联函数替代后*/println(x+x)</code></pre><p>你会发现他把原来你调用的函数给替掉了，实际上就是把lambda表达式融合进函数里面最终在再把函数内所有的代码都拿出来替换掉调用的地方。</p><p>当然他的替换过程可能没有那么简单，因为在内联函数的内部可能存在return等语句所以我们在这里不再详细介绍具体的实现过程，我们不妨来说一说一个便捷的理解方法。</p><ul><li>Kotlin编译器首先将Lambda表达式中的代码替换到内联函数调用函数型参数的地方。</li><li>接下来，再将内联函数中的全部代码再反向替换到内联函数调用的地方</li><li>左后将内联函数中的return等操作省略，将return的表达式或者值直接省略替换成对应的表达式。</li></ul><h3><span id="noinline和crossinline">noinline和crossinline</span></h3><p>接下来我们再来讨论一下，使用inline关键字的内联函数特殊情况。</p><p>在某些情况下你需要打断lambda表达式的运行，就是需要在lambda表达式中使用return，这时候就麻烦了lambda表达式中一般是不允许使用return的，你当然也可以使用特殊的关键字<code>return@内联函数名称</code>，使用以后lambda表达式剩余的内容就不会执行。</p><p>举个例子：</p><pre><code class="language-kotlin">/*Kotlin 内联函数*/advanced_function{        x -&gt;    return@advanced_function x*x    x+x}</code></pre><p>这里运行的结果就是返回一个x*x.而不是下面的x+x。</p><p>那我如果使用inline关键字呢？</p><p>回想上文所说的，inline关键字实际上是代码替代，所以可以直接使用return来返回，不过注意的是这里return会导致调用函数直接return！</p><p>这就是高阶函数使用inline关键字的第一个关注点。</p><p>第二个关键点在于高阶函数内部的lambda表达式需要使用函数型参数作为lambda表达式的内容会因为return关键字产生冲突。</p><p>看起来很复杂实际上是一种嵌套的情况，我们来举个例子：</p><p><img src="https://s2.loli.net/2024/09/29/OAh7siKrDbE3MN5.png" alt="image-20220617175447968"></p><p>可以看到这里报错了，这里的代码实际上在匿名类中调用了传入的函数类型参数。</p><p>因为使用了inline，所以可能会导致Runnable接口的lambda中包含了全局返回使用的return。</p><p>但是我们如果lambda中其实并没有包含return呢？有什么办法绕开这个错误呢？</p><p>当然！</p><pre><code class="language-kotlin">inline fun advanced_function_withlambda( crossinline func :(Int) -&gt; Int){    val runnable = Runnable {        func(9)    }}</code></pre><p>crossinline本质上解决的问题是在声明了inline关键字的高阶函数内部的lambda表达式需要使用函数型参数作为lambda表达式的内容而产生的冲突。再本质一点的问题是，lambda表达式和匿名类一样只允许函数局部返回，而对于内联操作使用的确实为全局返回。</p><p>总的来说如果你的高阶函数的lambda表达式使用了return关键字，那么你就应该考虑到以上的关键字和return带来的具体影响。</p>]]></content>
    
    
    <summary type="html">Kotlin的对象扩展与高阶函数深入</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/categories/Android/Kotlin/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门 (Kotlin的延迟初始化与Viewbinding、密封类)</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E4%B8%8E%E5%AF%86%E5%B0%81%E7%B1%BB)%20/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E4%B8%8E%E5%AF%86%E5%B0%81%E7%B1%BB)%20/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-11-28T07:16:57.269Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门-kotlin的延迟初始化与viewbinding-密封类">Android开发笔记——快速入门 (Kotlin的延迟初始化与Viewbinding、密封类)</span></h1><img src="https://s2.loli.net/2024/09/29/kAI59OWGPqluiQN.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727618527687" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B">Kotlin的延迟初始</a><ul><li><a href="#%E9%82%A3%E4%B9%88%E5%88%B0%E5%BA%95%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%A8">那么到底该怎么用？</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E5%AF%86%E5%B0%81%E7%B1%BB%E5%92%8Cwhen">Kotlin的密封类和When</a></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的延迟初始">Kotlin的延迟初始</span></h2><p>鉴于Kotlin的判空机制，在编译的时候就会检测变量是否存在空的可能，这就导致了一个麻烦，你需要额外多写代码来处理那些可能为空的类，即使在逻辑上他也不可能是NULL的，kotlin的判空机制还是会强制让你增加判空，不过这也不是没有解决办法，下面介绍一个关键字延迟初始化：<code>lateinit</code></p><p>当你遇到这样一种场景：</p><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {    private lateinit var binding :ActivityMainBinding         override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding= ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)    }}</code></pre><p>我想在MainActivity类里面调用一个viewbinding，可是这个viewbinding只有在oncreate方法里面才能对他进行初始化你如果在类里面直接进行初始化就会产生错误，实际上绑定类调用的<code>layoutInflater</code>并没有在ACT刚开始的时候就完成了初始化，你如果直接调用就会导致报错：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/facbd8d00ebeb0e3.png" alt="2"></p><pre><code class="language-shell"> Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'android.view.LayoutInflater android.view.Window.getLayoutInflater()' on a null object reference    at android.app.Activity.getLayoutInflater(Activity.java:5310)    at com.example.listviewtest.MainActivity.&lt;init&gt;(MainActivity.kt:16)    at java.lang.Class.newInstance(Native Method)    at android.app.AppComponentFactory.instantiateActivity(AppComponentFactory.java:95)    at androidx.core.app.CoreComponentFactory.instantiateActivity(CoreComponentFactory.java:45)    at android.app.Instrumentation.newActivity(Instrumentation.java:1287)    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:4148)    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:4463)     at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:111)     at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:149)     at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:103)     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2665)     at android.os.Handler.dispatchMessage(Handler.java:109)     at android.os.Looper.loopOnce(Looper.java:206)     at android.os.Looper.loop(Looper.java:296)     at android.app.ActivityThread.main(ActivityThread.java:8899)</code></pre><p>如果你对Context不够了解，你会很奇怪到底为什么？</p><p>不妨先推荐你按照如下顺序阅读下面几篇文章：</p><p>因为获取绑定类的时候使用的是layoutInflate所以关键问题就在于layoutInflate之上：</p><p><a href="https://blog.csdn.net/guolin_blog/article/details/121889703?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165215148016780357214066%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165215148016780357214066&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-121889703-null-null.nonecase&amp;utm_term=layoutinflater&amp;spm=1018.2226.3001.4450">再看LayoutInflater</a></p><p><a href="https://blog.csdn.net/guolin_blog/article/details/12921889?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165215148016780357214066%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165215148016780357214066&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-12921889-null-null.nonecase&amp;utm_term=layoutinflater&amp;spm=1018.2226.3001.4450">Android LayoutInflater原理分析，带你一步步深入了解View</a>。</p><p>等你看完了以后你会意识到LayoutInflater本质上和Context脱不了干系，每次都调用**LayoutInflater的from()**方法去获取一个LayoutInflater的实例，为什么要传context呢？</p><p>其实本质上只有一种写法：</p><pre><code class="language-kotlin">LayoutInflater layoutInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</code></pre><p>只是Android给我们做了一下封装而已。得到了LayoutInflater的实例之后就可以调用它的inflate()方法来加载布局了。这里不在多讨论这个，我们再来看一下什么是Context：</p><p><a href="https://blog.csdn.net/guolin_blog/article/details/47028975?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165232423116782248586882%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165232423116782248586882&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-6-47028975-null-null.nonecase&amp;utm_term=onCreate&amp;spm=1018.2226.3001.4450">Android Context完全解析</a>。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/1df15d4972330b74.png" alt="img"></p><p>对于ACT来说，执行过程也是大差不大，但是，ACT的layoutInflate是调用的方法获取的对象，为什么会和本ACT中的Context有关系呢？</p><p>我们再来看一下ACT到底如何获取LayoutInflate对象：</p><p><a href="https://blog.csdn.net/ruancoder/article/details/51760942?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165232543116782350911197%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165232543116782350911197&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-51760942-null-null.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Econtrol&amp;utm_term=getLayoutInflater&amp;spm=1018.2226.3001.4187">获取LayoutInflater的三种方式分析</a>。</p><p>可以看到本质上ACT调用的还是<code>LayoutInflater.from(context)</code>方法，而context方法在onCreate方法之前是没有进行加载的，所以会产生NULL报错。</p><h3><span id="那么到底该怎么用">那么到底该怎么用？</span></h3><p>回到最初的问题，那我们该怎么办呢？在合适的位置进行初始话的话就要使用lateinit关键字，通过lateinit就可以把对应的全局变量在合适的位置进行初始化。</p><p>当然Kotlin也提供了一个固定语法来检测在某个位置的全局变量，注意！是全局变量是否进行了初始化代码如下：</p><pre><code class="language-kotlin">companion object  {      private lateinit var tester: Zzy      var signal : Boolean = true      fun laterinit_tester()      {          if(!::tester.isInitialized) {              tester = Zzy()              //如果你不太清楚Zzy类是什么或者不太懂Kotlin的类请参考我的专栏文章关于Kotlin的类          }          //Log.d("tester", tester.gender)          println(tester.gender)      }}</code></pre><p><code>::tester.isInitialized</code>来获取对应变量是否进行了初始化，我们在对他取！就可以完成对他的判断了，在没有初始化的地方对其进行初始化。</p><p>zzy类的代码：</p><pre><code class="language-kotlin">class Zzy(val gender: String = "Boy") : Person(22,"zhuzeyu"){    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init    {        println(name+" is a "+gender+" age is "+age)    }    //方法调用省略this关键字演示如下：    fun this_test()    {        eat_empty()    }    fun this_tester2()    {        this_test()    }}</code></pre><p>最后运行结果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/b053645a3d413608.png" alt="4"></p><p>最后完整的代码在我的Gitee上全部开源：<a href="https://gitee.com/jszszzy/android_kotlin">Gitee地址</a>。下载压缩包即可。</p><h2><span id="kotlin的密封类和when">Kotlin的密封类和When</span></h2><p>先来回忆一下，When是如何使用的，请参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123688687?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165234161016781685335776%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165234161016781685335776&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-123688687-null-null.nonecase&amp;utm_term=when&amp;spm=1018.2226.3001.4450">When的用法</a>。</p><p>我们新建一个类，用来反馈某些操作的结果：</p><pre><code class="language-kotlin">interface Resultclass  Success(val msg :String) :Resultclass  Failure(val error :Exception) :Result</code></pre><p>可以看到<strong>Success、Failure</strong>都是继承于Result接口的实现。</p><p>我们再来创建一个方法用识别返回的是成功还是失败。</p><pre><code class="language-kotlin">fun When_tester(result: Result){    when(result)    {        is Success -&gt; println(result.msg)        is Failure -&gt; println(result.error)    }}</code></pre><p>写完以后你觉得需要简写一下，因为函数只有一条语句，于是改成如下操作：</p><pre><code class="language-kotlin">fun When_tester(result: Result) =   when(result)    {        is Success -&gt; println(result.msg)        is Failure -&gt; println(result.error)    }</code></pre><p>万恶的编译检查竟然给你报错！</p><pre><code class="language-kotlin">e: D:\Android\Projects\CodeWithKotlin\app\src\main\java\com\example\codewithkotlin\Utils.kt: (25, 14): 'when' expression must be exhaustive, add necessary 'else' branch</code></pre><p>问题不大，实际上的简写原则是这样的：</p><p>当你的函数体只有 <strong>一块</strong> 作为返回值的代码时，<strong>可以直接省略大括号，用等号来连接,并且省略return关键字，因为等号足以包含返回值的意思</strong>。</p><p>也就是说你这样写他也是报错的：</p><pre><code class="language-kotlin">fun When_tester(result: Result){    return  when(result)    {        is Success -&gt; println(result.msg)        is Failure -&gt; println(result.error)    }}</code></pre><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/5ea08f7acc81ce69.png" alt="5"></p><p>实际上你的类就这样两种可能，基本没有可能出现else内的情况，但是！万恶的编译检查竟然给你报错！</p><p>不过Kotlin也针对这种情况给出了解决办法：<strong>密封类</strong>。</p><p>使用方法很简单我们把对应的接口更改成sealed class即可：</p><pre><code class="language-kotlin">sealed class Result class  Success(val msg :String) :Result()class  Failure(val error :Exception) :Result()</code></pre><p>记得把括号带上，因为这时候是class需要调用父类的构造方法。</p><p>修改好以后就发现报错消失了。可以愉快的避免else的编译检查了。</p><p>最后完整的代码在我的Gitee上全部开源：<a href="https://gitee.com/jszszzy/android_kotlin">Gitee地址</a>。下载压缩包即可。</p>]]></content>
    
    
    <summary type="html">Kotlin的延迟初始化与Viewbinding、密封类</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Viewbinding" scheme="http://neonexusx.github.io/tags/Viewbinding/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin的标准函数和静态方法）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95)/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95)/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-11-28T07:16:57.269Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin的标准函数和静态方法">Android开发笔记——快速入门（Kotlin的标准函数和静态方法）</span></h1><img src="https://s2.loli.net/2024/10/04/Ash97EO3iRUGNo4.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727980663756" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Kotlin的标准函数和静态方法</a><ul><li><a href="#kotlin%E7%9A%84with%E5%87%BD%E6%95%B0">Kotlin的with函数</a></li><li><a href="#kotlin%E7%9A%84run%E5%87%BD%E6%95%B0">Kotlin的run函数</a></li><li><a href="#kotlin%E7%9A%84apply%E5%87%BD%E6%95%B0">Kotlin的apply函数</a></li><li><a href="#koltin%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Koltin的静态方法</a><ul><li><a href="#koltin%E7%9A%84%E7%9C%9F%E6%AD%A3%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Koltin的真正静态方法</a><ul><li><a href="#jvmstatic%E6%B3%A8%E8%A7%A3"><code>@JvmStatic</code>注解</a></li><li><a href="#%E9%A1%B6%E5%B1%82%E6%96%B9%E6%B3%95">顶层方法</a></li></ul></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的标准函数和静态方法">Kotlin的标准函数和静态方法</span></h2><p>Kotlin的标准函数指的是Standard.kt文件中定义的函数，任何Kotlin代码都可以自由调用所有标准函数</p><p>比如上一次所说的Let函数就是标准函数之一。</p><h3><span id="kotlin的with函数">Kotlin的with函数</span></h3><p>with函数的参数：</p><ul><li>第一个为任意类型的对象</li><li>第二个是Lambda表达式</li></ul><p>with函数的作用：</p><ul><li>在lambda表达式中提供第一个参数作为对应的上下文</li><li>使用表达式中最后一行代码的返回值作为返回值返回</li></ul><p>那么这个函数具体有什么作用呢？看一下示例代码：</p><p>我们通过<strong>Stringbuilder</strong>对象来实现将ArrayList对象中保存的People实例转化成一个同一的字符串</p><p><img src="https://s2.loli.net/2024/10/04/1dlNVDtcP3SnJp9.png" alt="1"></p><pre><code class="language-kotlin">fun withFunTester(){    val string = StringBuilder()    val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))    with(string){        for ( people in list_people)        {            append(people).append("\n")        }        val result =string.toString()        println(result)    }}</code></pre><p>可以看到我们为了更简介的去构造这个字符串通过with函数将构造字符串的对象作为上下文来引用这样就省去了多次调用Stringbuilder的对象的麻烦。</p><p>调用结果如下：</p><p><img src="https://s2.loli.net/2024/10/04/F7zLdsUaeEBvJRc.png" alt="image-20220429233250384"></p><p>因为People类是自定义的类并没有直接重写tostring方法所以返回的是对象的的具体信息</p><h3><span id="kotlin的run函数">Kotlin的run函数</span></h3><p>run函数的参数：</p><ul><li>第一个就是Lambda表达式</li><li>需要对象直接调用此函数</li></ul><p>run函数的作用：</p><ul><li>在lambda表达式把调用对象作为对应的上下文</li><li>使用lambda表达式中最后一行代码的返回值作为返回值返回</li></ul><p>我们改写一下上一个函数使用run函数来实现：</p><pre><code class="language-kotlin">fun runFunTester(){    val string = StringBuilder()    val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))    val runFunTester= string.run {        for ( people in list_people)        {            append(people).append("\n")        }        string.toString()    }    println(runFunTester)}</code></pre><p>输出结果和上一个相同，这里不再赘述。</p><h3><span id="kotlin的apply函数">Kotlin的apply函数</span></h3><p>apply函数的参数：</p><ul><li>第一个就是Lambda表达式</li><li>需要对象直接调用此函数</li></ul><p>apply函数的作用：</p><ul><li>在lambda表达式把调用对象作为对应的上下文</li><li>apply无法指定返回值而将调用对象作为返回值返回</li></ul><p>举个例子：</p><p>可以看到实际上函数里面并没有写任何作为返回值的表达式，其返回的正是Stringbuilder的对象，只不过println自动调用的是对象的tostring方法。</p><pre><code class="language-kotlin">fun applyFunTester(){    val string = StringBuilder()    val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))    val applyFunTester= string.apply {        for ( people in list_people)        {            append(people).append("\n")        }    }    println(applyFunTester)}</code></pre><h3><span id="koltin的静态方法">Koltin的静态方法</span></h3><p>Kotlin的设计者一直在弱化静态方法这个概念，为了什么呢？因为从本质上来说Kotlin已经提供了更方便的方法来实现类似于静态方法的操作。</p><p>举个例子：</p><p>Kotlin提供了一个单例类作为静态方法的实现办法。</p><p>我们创建一个单例类，实际上JVM已经替我们创建好了一个对象，找个对象不需要你自己手动创建，而是帮你创建好了和类名相同的对象，直接</p><p><code>类名.方法</code>即可实现方法调用。</p><p>这里我们创建一个Utils类，把刚才使用的函数都放入Util类中来进行调用。</p><pre><code class="language-kotlin">object Utils{    fun withFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val withFunTester=with(string){            for ( people in list_people)            {                append(people).append("\n")            }            val result =string.toString()            println(result)        }    }    fun runFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val runFunTester= string.run {            for ( people in list_people)            {                append(people).append("\n")            }            string.toString()        }        println(runFunTester)    }    fun applyFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val applyFunTester= string.apply {            for ( people in list_people)            {                append(people).append("\n")            }        }        println(applyFunTester)    }}</code></pre><p>在main函数中直接调用即可：</p><pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;){Utils.runFunTester()}</code></pre><p>当然你会注意到有个问题，在Utils类中所有方法都是静态的，那如果我想部分函数是静态的怎么办呢？</p><p>Kotlin也提供了一个方法,<strong>伴生对象</strong>。</p><p>通过伴生对象就可以实现在一个类中既有静态也有一般方法。</p><p>我们将Utills类改为一般的类，然后使用伴生对象来实现静态和一般调用。</p><pre><code class="language-kotlin">class Utils{    fun withFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val withFunTester=with(string){            for ( people in list_people)            {                append(people).append("\n")            }            val result =string.toString()            println(result)        }    }        companion object    {        fun runFunTester()        {            val string = StringBuilder()            val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))            val runFunTester= string.run {                for ( people in list_people)                {                    append(people).append("\n")                }                string.toString()            }            println(runFunTester)        }        fun applyFunTester()        {            val string = StringBuilder()            val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))            val applyFunTester= string.apply {                for ( people in list_people)                {                    append(people).append("\n")                }            }            println(applyFunTester)        }    }}</code></pre><p>伴生对象的使用很简单，直接在普通的类中这样即可：</p><pre><code class="language-kotlin">class objext1{companion object    {        }}</code></pre><p><code>companion object</code>大括号中的内容就是伴生对象的**‘’静态方法‘’**,但需要注意的是实际上这两种方法都不是真正的静态方法，而是通过系统创建的同名对象实现的。</p><h4><span id="koltin的真正静态方法">Koltin的真正静态方法</span></h4><p>Kotlin同样提供了两种方法，来实现真正的静态方法。对于上边两种假的静态方法，如果你的代码需要在Java里面以静态的方法去调用，你会发现这些方法实际上根本不存在。而如果我们需要真正的静态方法呢？</p><h5><span id="jvmstatic注解"><code>@JvmStatic</code>注解</span></h5><p><code>@JvmStatic</code>注解只能作用在单例类或者伴生类中的方法上，如果你尝试在普通类的方法是使用这个注解就会产生报错。</p><p>举个例子：</p><pre><code class="language-kotlin">companion object{    @JvmStatic    fun applyFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val applyFunTester= string.apply {            for ( people in list_people)            {                append(people).append("\n")            }        }        println(applyFunTester)    }}</code></pre><p>那么如何调用呢？</p><p>调用的方式也很简单，就是静态方法的调用模式：</p><pre><code class="language-Kotlin">fun main(args: Array&lt;String&gt;){    Utils.runFunTester()    Utils.applyFunTester()}</code></pre><p>可以看到上边两种方法虽然在Kotlin中看起来一摸一样实际上原理并不相同。</p><h5><span id="顶层方法">顶层方法</span></h5><p>我们在前几张说过main函数有些特殊他是直接写在一个文件里面的，里面并没有包含任何类，就像这样：</p><p><img src="https://s2.loli.net/2024/10/04/QYeV3D6cK2OoiXm.png" alt="image-20220502094322826"></p><p>Kotlin的编译器会将所有顶层方法全部编译成静态方法，因此只要你定义了一个顶层方法，那么他一定是静态方法。在前几节我们使用test类作为单例类来创建静态的main方法，这里我们抛弃多余的test类，然后使用顶层方法作为mian方法让JVM调用，效果如上图所示。</p><p>那么对于顶层方法如何调用呢？</p><p>我们再将<code>withFunTester</code>方法作为顶层方法来看看如何使用：</p><p>创建一个Kotlin File后直接把方法放进去即可，效果如下：</p><p><img src="https://s2.loli.net/2024/10/04/3QR6kJuKiEzcU1j.png" alt="image-20220502095102381"></p><p>我们在main函数直接调用即可！对!不需要管路径，也不用创建实例，直接键入方法名即可：</p><p><img src="https://s2.loli.net/2024/10/04/OAltvENwy5pfSJh.png" alt="image-20220502095418638"></p><p>当然这里还是要提一嘴，如果要在java中调用Kotlin编写的静态方法怎么办？</p><p>我们创建的文件名为：Statictester.kt</p><p>当编译完成的时候，Kotlin的编译器实际上创建了一个Statictesterkt类，静态方法就按照java的静态形式定义在类里面，所以按照文件名.方法的形式来调用就行了。</p>]]></content>
    
    
    <summary type="html">Kotlin的延迟初始化与Viewbinding、密封类</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android开发笔记——快速入门（Kotlin的面对对象）</title>
    <link href="http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1)%20/"/>
    <id>http://neonexusx.github.io/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1)%20/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2025-11-28T07:16:57.269Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin的面对对象">Android开发笔记——快速入门（Kotlin的面对对象）</span></h1><img src="https://s2.loli.net/2024/10/04/TU4j1YWLER9caFp.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727980774295" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1">Kotlin的面对对象</a><ul><li><a href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1">类与对象</a></li><li><a href="#kotlin%E7%9A%84%E6%96%B9%E6%B3%95">Kotlin的方法</a></li><li><a href="#kotlin%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%9E%84%E9%80%A0">Kotlin的继承与构造</a></li><li><a href="#kotlin%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B">Kotlin的接口与面向接口编程</a><ul><li><a href="#%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%A2%84%E5%85%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">在接口中预先实现一个方法（默认实现）</a></li><li><a href="#%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B">面向接口编程</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6">Kotlin的可见性修饰符</a></li><li><a href="#kotlin%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%92%8C%E5%8D%95%E4%BE%8B%E7%B1%BB">Kotlin的数据类和单例类</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB">数据类</a></li><li><a href="#%E5%8D%95%E4%BE%8B%E7%B1%BB">单例类</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的面对对象">Kotlin的面对对象</span></h2><h4><span id="类与对象">类与对象</span></h4><p>在上一节我们创建了一个类但是并没有使用，所有的代码都是通过函数实现的，这并不符合面向对象的编程的要求。至于什么是面向对象编程这里就不再多说了有兴趣的或不了解的可以去知乎看一看。</p><p>这里我们再新建一个class名叫Person。Kotlin 中使用关键字 <code>class</code> 声明类。</p><p><img src="https://s2.loli.net/2024/10/04/DF2Pz5Yp9vkL1ar.png" alt="1"></p><p>类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的； 如果一个类没有类体，可以省略花括号。</p><pre><code class="language-kotlin">class Person</code></pre><p>这样也是完全正确的。</p><p>给他添加一些字段：</p><pre><code class="language-Kotlin">package com.example.codewithkotlinclass Person{    var  age :Int =0 ;    val name  = "";}</code></pre><p>可以看到我这里使用了两种写法来提示你字段也能自动推导类型。</p><p>下面我们来考虑一下如何实例化这个类：</p><pre><code class="language-kotlin">package com.example.codewithkotlinclass Person{    var  age :Int =0 ;    val name  = "";}fun main(){    var jack = Person()    println(jack.age)}</code></pre><p>首先看到代码时你如果有Java的编程基础你会有疑问，main为什么不在类里面？而且也不是静态方法？这里暂且先放一放，我们到后边再来说这个我问题，这里先接受它，能运行，是一个程序的入口。</p><p>具体在里面呢我们实例化了一个类，你可以看看非常轻巧简单，保持着<strong>能省就省</strong>的原则，不需要类型名，不需要new关键字，直接调用类名+（）就实现了初始化：</p><pre><code class="language-Kotlin">fun main(){    var jack = Person()    println(jack.age)}</code></pre><h4><span id="kotlin的方法">Kotlin的方法</span></h4><p>方法也没什么好说的，他和函数的语法糖一摸一样，连关键字也一摸一样，你可以用一行来写一个方法的简单明了，调用的时候也是实例+.+方法。例子如下：</p><pre><code class="language-kotlin">package com.example.codewithkotlinclass Person{    var  age :Int =0 ;    val name  = "";    fun study() =  "zzy love study"}fun main(){    var zzy = Person()    println(zzy.age)    println(zzy.study())}</code></pre><p>输出结果如下：</p><p><img src="https://s2.loli.net/2024/10/04/NpirAk83Z72XQGm.png" alt="2"></p><h4><span id="kotlin的继承与构造">Kotlin的继承与构造</span></h4><p>关于继承的概念也不再详细解释，感兴趣请移步知乎。</p><p>这里直接介绍用法和技巧.</p><p>为了验证使用我们这里需要新建一个类：</p><p><img src="https://s2.loli.net/2024/10/04/UmjrRzg1743pfxh.png" alt="3"></p><p>继承的方法很简单，kotlin将关键字extends替换位：，写起来相对简单一些。可以看到如下就继承了Person类，同时也继承了其类内部的字段。</p><pre><code class="language-kotlin">class Zzy : Person(){}</code></pre><p>这里也许你会产生疑问，为啥后边还会跟一个（）？这不就是打破了能省就省的设计思想了吗？当然不是啦！</p><p>这个（）就是每个面向对象不可或缺的构造函数，只不过我们目前构造的都是无参的构造函数，在类后边就不需要写无参构造函数的括号。</p><p>在前边我们说过Kotlin的类的声明中可以省略类体和类头，在 Kotlin 中的一个类可以有一个<em>主构造函数</em>以及一个或多个<em>次构造函数</em>。主构造函数是类头的一部分：它跟在类名与可选的类型参数后。</p><pre><code class="language-kotlin">class Person constructor() { /*……*/ }</code></pre><p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 <code>constructor</code> 关键字。</p><pre><code class="language-kotlin">class Person() { /*……*/ }</code></pre><p>如果构造函数有注解或可见性修饰符，这个 <code>constructor</code> 关键字是必需的，并且这些修饰符在它前面：</p><pre><code class="language-kotlin">class Customer public @Inject constructor(name: String) { /*……*/ }</code></pre><p>那么在没有修饰符的情况下，有参数的构造函数如何写呢？我们反过来修改一下父类：</p><pre><code class="language-kotlin">open class Person(age :Int, name:String){    fun study() = name + "love study"}</code></pre><p>可以看到需要在构造函数里声明的字段就写好了，在实例化的时候就需要传入这些字段的参数：</p><pre><code class="language-kotlin">open class Person(age :Int, name:String){    val name :String = name;    var age :Int = age;    fun study() = name + "love study"}</code></pre><p>这里值得注意的是，这里的age，name和下面字段所指并不是一个，构造函数的参数只是个构造函数的局部变量，而不是成员变量，你如果想直接声明成字段的话就要显示的指定他是val还是var，指定后默认将其作为字段来初始化。</p><pre><code class="language-kotlin">open class Person(var age :Int, val name:String){    fun study() = name + "love study"}</code></pre><p>你可能还会有疑问，那我想写一些逻辑处理函数怎么办呢？Kotlin同时也提供了构造函数的函数体：</p><pre><code class="language-kotlin">open class Person(age :Int, name:String){    val name :String = name;    var age :Int = 0;//这里不初始化等到init再来初始化它。    init {        this.age = age;    }    fun study() = name + "love study"}</code></pre><p>我们再回到继承上来说，有参的父类怎么继承？很简单在对应的位置输入构造参数就行了：</p><pre><code class="language-Kotlin">package com.example.codewithkotlinclass Zzy(gender: String) : Person(22,"zhuzeyu"){}</code></pre><p>同样你也可以使用它的构造参数：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"){init {    println(name+" is a "+gender+" age is "+age)}}//输出结果zhuzeyuis a man age is 22</code></pre><p>在我们讨论完了主构造函数以后，既然有主构造函数那么一定有次构造函数，来看看他如何使用：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"){    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init {    println(name+" is a "+gender+" age is "+age)    }}</code></pre><p>使用很简单，constructor关键字就是来创建构造函数的，kotlin规定次构造函数必须要调用主构造函数，所以你可以看到this关键字来调用主构造函数。与主构造函数不同的是此构造函数有函数体，并且次构造函数没办法直接声明成员，这里需要注意一下，参数的作用范围只有在此构造函数之中。</p><p>调用实例：</p><pre><code class="language-kotlin">fun main(){    var zzy = Zzy(120,100)}输出结果：zhuzeyu is a man age is 22his iq is 120 eq is 100</code></pre><h4><span id="kotlin的接口与面向接口编程">Kotlin的接口与面向接口编程</span></h4><p>kotlin和java一样都不是多继承的面向对象编程，也就是说你只能继承一个父类，但是对于子类来说需要多继承的时候就很麻烦了，所以这里选择接口会更方便。</p><p>接口和普通类的界限在逐渐变得模糊，不管是针对java还是kotlin都是一样，可以继承多个接口，接口的继承演示如下：</p><p>继承的关键字同样被<code>：</code>所替代，和继承的父类可以直接一起使用，将它们分开就可以同时继承。</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"),Eat{    //实现了两个接口中的函数    override fun drink_soap() {        println("drink soap")    }    override fun eat_rice() {       println("eat rice")    }    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init {    println(name+" is a "+gender+" age is "+age)    }}</code></pre><p>Eat接口：</p><pre><code class="language-kotlin">interface Eat{    fun drink_soap()    fun eat_rice()}</code></pre><p>为什么说接口和普通类正在变得模糊呢？我们再来看一个操作：</p><h5><span id="在接口中预先实现一个方法默认实现">在接口中预先实现一个方法（默认实现）</span></h5><p>如果你在接口中实现了一个方法：</p><pre><code class="language-kotlin">interface Eat{    fun drink_soap(){        println("drink soap")    }    fun eat_rice()}</code></pre><p>在类的实例就可以直接不需要重写他们，IDEA也不会报错：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"),Eat{    override fun eat_rice()     {       println("eat rice")    }    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init     {        println(name+" is a "+gender+" age is "+age)    }}</code></pre><p>在使用的时候直接调用即可：</p><pre><code class="language-kotlin">fun main(){    var zzy = Zzy(120,100)    zzy.drink_soap()}</code></pre><h5><span id="面向接口编程">面向接口编程</span></h5><p>你如果了解面向对象，你也一定可以明白什么是面向接口，如果面向对象的方法参数传递的是对象，那么面向接口，就是传递的是接口：</p><p>我们来看一个复杂一点的例子：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"),Eat{// 以上代码省略，新添加一个方法    fun  eat_drink_together( eat : Eat)    {        eat.drink_soap()        eat_rice()    }}</code></pre><p>在这里调用新方法，传入自己作为参数：</p><pre><code class="language-kotlin">fun main(){    var zzy = Zzy(120,100)    zzy.eat_drink_together(zzy)}</code></pre><p>这段代码可能有点稍微难理解他的目的是什么，注意看到<code>eat_drink_together</code>方法的参数实际上是一个接口，因为zzy类实现了这个接口当然也可以传入作为参数，顺理成章地调用其中的实现的抽象的方法，这里就可以叫接口的多态。</p><h4><span id="kotlin的可见性修饰符">Kotlin的可见性修饰符</span></h4><p>kotlin的修饰符存在很大的与java的不同：</p><p>可以参考一下表：</p><p><img src="https://s2.loli.net/2024/10/04/OYCuzypwlLreh1D.png" alt="3"></p><p>可以看到最大的区别有几点</p><ul><li>Kotlin中默认的类型是public而不是default。</li><li>Kotlin中没有default类型，也就是没有包级可见，Kotlin的protect类型同一包路径下也不可见（牢记没有包可见）。</li><li>新增internal类型，在同一模块下可见。</li></ul><p>可以看到kotlin和android设计首选的语言并不是全无道理，抛弃了原来java的文件构建模式，转而支持更多的android的文件架构，关于模块等到写到的时候再说。</p><h4><span id="kotlin的数据类和单例类">Kotlin的数据类和单例类</span></h4><h5><span id="数据类">数据类</span></h5><p>数据类常常用于将服务器端或数据库中的数据集映射到内存中，为编程提供数据模型的支持。简单来说就是专门用来管理数据在内存中的类。</p><p>在java中为了实现一个数据类我们通常要实现equals（）、hashCode（）方法等。kotlin保持着能省就省的原则，这些没有实际逻辑意义的代码都应该被替换掉，被替换成什么了呢？</p><p>就一个关键字：<code>data</code></p><pre><code class="language-KOTLIN">data class Exam(val exameername:String,val examname:String,val examgrade:Int)</code></pre><p>你可能会疑问为什么后边没有{}呢，在提示一下语法糖，没有代码的话可以省略的。</p><p>那么数据类怎么使用呢？</p><p>我这里定义的是考试类，参数分别是考试人名称，考试名称，考试成绩。</p><p>这里我们创建两个实体对象然后调用，.equals()方法进行匹配：</p><pre><code class="language-kotlin">val exam1 = Exam("zzy","exam1",100)val exam2 = Exam("zzy","exam1",100)if (exam1 == exam2)println("same")if(exam1.equals(exam2))println("yesyes")</code></pre><pre><code class="language-shell">sameyesyes</code></pre><h5><span id="单例类">单例类</span></h5><p>单例类是针对单例模式而特殊设计的类，它可以避免创造重复的对象，当我们希望某个类在全局最多只有一个实例的时候们就可以使用单例类。</p><p>对于java我们不再赘述，将构造函数私有化等就可以实现单例类，虽然java实现的并不复杂但是kotlin明显做的更好，我们只需要将关键字class改为object即可，不需要自己去写实现方法，操作简单。</p><p>演示：</p><p>其实在前面我们都是通过直接定义main函数来直接运行的，但是在面向对象的时候大多是是没有函数的概念，这里我们借助单例类来实现类似于java类中的main方法：</p><pre><code class="language-kotlin">object test{    @JvmStatic    fun main(args: Array&lt;String&gt;)    {        //继承等演示        var zzy = Zzy(120,100)        zzy.eat_drink_together(zzy)        //数据类演示        val exam1 = Exam("zzy","exam1",100)        val exam2 = Exam("zzy","exam1",100)        if (exam1 == exam2)            println("same")        if(exam1.equals(exam2))            println("yesyes")        //单例类演示        test.tester();    }    // 单例类方法    fun tester()    {        println("test")    }}</code></pre><p>可以看到创建了一个单例类，并且声明了两个方法，分别是main和tester方法</p><p>你可以看到main上边有一个注释@JvmStatic，你可以意识到这里的main其实并不是static的</p><p>实际上kotlin并没有static这个关键字，这个先留到以后再说，这里的main就是程序的入口，调用单例类的方法很简单而且不需要自己实例化，在启动的时候kotlin已经自动帮忙创建了所有单例类的实例化，在作用范围内调用很简单：</p><pre><code class="language-kotlin">//单例类演示test.tester();</code></pre><p>直接类名+方法即可，注意这里要和java的静态方法区别开，只是结构类似，本质完全不同，并不是静态的数据类型。</p>]]></content>
    
    
    <summary type="html">Kotlin的面对对象</summary>
    
    
    
    <category term="Android" scheme="http://neonexusx.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://neonexusx.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://neonexusx.github.io/tags/Kotlin/"/>
    
  </entry>
  
</feed>
