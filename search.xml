<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux Bash Shell 脚本入门（3）——Linux常用命令介绍</title>
      <link href="/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%203/"/>
      <url>/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%203/</url>
      
        <content type="html"><![CDATA[<h1><span id="linux-bash-shell-脚本入门3linux常用命令介绍">Linux Bash Shell 脚本入门（3）——Linux常用命令介绍</span></h1><p>[TOC]</p><!-- toc --><ul><li><a href="#%E9%80%9A%E8%BF%87man%E6%9D%A5%E4%BA%86%E8%A7%A3%E4%BB%BB%E4%BD%95%E5%91%BD%E4%BB%A4">通过man来了解任何命令</a><ul><li><a href="#%E6%B5%8F%E8%A7%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">浏览文件系统</a><ul><li><a href="#l%E7%9A%84%E9%95%BF%E5%88%97%E8%A1%A8%E4%BF%A1%E6%81%AF">l的长列表信息</a></li><li><a href="#%E8%BF%87%E6%BB%A4%E8%BE%93%E5%87%BA%E5%88%97%E8%A1%A8">过滤输出列表</a></li></ul></li></ul></li><li><a href="#%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95">复制文件和目录</a></li><li><a href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9">删除文件和文件夹</a><ul><li><a href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9">删除文件夹</a></li></ul></li><li><a href="#%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6">链接文件</a><ul><li><a href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E8%BD%AF%E8%BF%9E%E6%8E%A5">符号链接（软连接）</a></li><li><a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5">硬链接</a></li><li><a href="#%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A1%AC%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB">软连接和硬连接的区别</a></li></ul></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6">查看文件</a><ul><li><a href="#cat%E5%91%BD%E4%BB%A4">cat命令</a></li><li><a href="#%E5%8F%AA%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9">只查看文件部分内容</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%9C%AB%E5%B0%BEtail%E5%91%BD%E4%BB%A4">查看文件末尾（tail命令）</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8head%E5%91%BD%E4%BB%A4">查看文件头部（head命令）</a></li></ul></li></ul></li></ul><!-- tocstop --><img src="https://s2.loli.net/2025/03/12/U4dGpMnVZgOzsvA.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1741776068525" style="zoom:67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1695021721029" style="zoom: 50%;"><h2><span id="通过man来了解任何命令">通过man来了解任何命令</span></h2><p>man命令可以访问linux系统的手册页，尤其是当你想要弄清命令行参数的时候，就可以查看对应的命令介绍来了解。</p><p>这对刚入门的新手是非常友好的，这里简单介绍一下man命令的使用以及效果，man使用格式如下：</p><pre><code class="language-sh">man  command-name</code></pre><p>我们最常用的ls命令来举例：</p><pre><code class="language-bash">man ls</code></pre><img src="https://s2.loli.net/2024/04/20/VGBnDJ6O9lhTWHq.png" alt="image-20240420160532398" style="zoom:67%;"><p>当使用man手册的时候实际上是linux的pager程序来显示的，分页显示是一种实用工具，能够逐页逐行显示文本，只需要使用<strong>Space</strong>来进行翻页或者<strong>Enter</strong>逐行查看，假设你使用仿真终端支持箭头翻阅,也可以使用<strong>箭头向前或者向后</strong>滚动手册页的内容，至于什么是仿真终端和真的终端有什么区别，详见上一篇。</p><p>向下翻页我们可以看到<strong>DESCRIPTION</strong>这一小节，浏览手册不是按部就班的学习而是作为快速参考来使用的，<strong>DESCRIPTION</strong>小节描述了这个命令的一般性描述。每一小节都有一定的内容，我们常用的小节有：</p><ul><li>SYNOPSIS：命令的语法</li><li>DESCRIPTION ：命令的一般性描述</li><li>OPTIONS ： 命令选项的描述</li></ul><p>一般来说命令的使用遵循：</p><pre><code class="language-bash">COMMAND-NAME [OPTION] ... [ARGUMENT]...</code></pre><p>OPTION 是用于修改命令的行为选项，可添加的OPTION 通常不只有一个，<code>[ ]</code>表明这内容不是必须的，<code>...</code>表明可以一次指定多个OPTION， <code>[ARGUMENT]</code>是传递给命令的参数，以指明命令的操作对象，从中括号可以看出，ARGUMENT也不是必选的，同时可以指定多个ARGUMENT来使用。</p><p>为了完整介绍命令的格式，我们再找来tar来举个例子，tar是用来归档和压缩的命令：</p><pre><code>tar {A|c|d|r|t|u|x}[GnSkUWOmpsMBiajJzZhPlRvwo] [ARG...]</code></pre><p><code>{ }</code>这一部分是必须的，大括号 <code>{ }</code> 通常表示一组选项或者占位符，用于表示替换选项或参数的选择，所以使用的时候必须要带上至少一个参数，后边的<code>[ ]</code>表明<code>GnSkUWOmpsMBiajJzZhPlRvwo</code>是作为可选参数被加入到命令之中的，相对的<code>A|c|d|r|t|u|x</code>是必选的，如果仔细看后边的<code>[ARG...]</code>也比较神奇，推测省略号是否在外面这两种写法没有太大区别，在全网也没有找到合适的解释，这里就暂且认为二者一致。</p><h3><span id="浏览文件系统">浏览文件系统</span></h3><p>我们使用ls的时候常常只是ls但是默认的ls显示的内容常常具有误导性，我们举个例子：</p><pre><code class="language-bash">Neo@Bionet:~$ ls cudnn-local-repo-ubuntu2204-9.0.0   Downloads   Public            snap              thinclient_drives Desktop                             Music       PycharmProjects  'Sunlogin Files'   Videos Documents                           Pictures    Share_Space       Templates         WorkSpaceNeo@Bionet:~$ ls -aFltotal 1420drwxr-x--- 41 Neo  Neo    4096  4月 20 14:43  ./drwxr-xr-x 45 root root   4096  4月 18 19:03  ../drwxrwxr-x  3 Neo  Neo    4096  3月 25 12:27  .anaconda/drwxrwxr-x  3 Neo  Neo    4096  3月 25 12:03  .astropy/-rw-------  1 Neo  Neo   27327  4月 20 16:09  .bash_history............................etc-rw-r--r--  1 Neo  Neo   24921  4月  3 15:03  .xorgxrdp.18.log.old</code></pre><p>ls带参数和不带参数二者有巨大的区别，我们通过man可以看到参数的意思如下：</p><pre><code class="language-bash">   -a, --all          do not ignore entries starting with .             -F, --classify          append indicator (one of */=&gt;@|) to entries             -l     use a long listing format      -h, --human-readable          with -l and -s, print sizes like 1K 234M 2G etc.</code></pre><ul><li>F 会在目录名之后添加/。在可执行文件之后添加*，以帮助用户区分对应的内容，但是对于彩色终端不同类型的文件有不同的颜色，所以这个可以省略</li><li>a 会显示隐藏文件</li><li>l 会以长列表的形式列出来所有文件及其信息。</li><li>h 会将显示的大小修改为人类可读的类型</li></ul><p>对于使用来说：</p><pre><code class="language-bash">ls -alh</code></pre><p>已经完全够用，且方便记忆。</p><h4><span id="l的长列表信息">l的长列表信息</span></h4><p>让我们来解析一下这里面的内容：</p><pre><code class="language-bash">drwxrwxr-x  3 Neo  Neo    4096  3月 25 12:27  .anaconda/</code></pre><ul><li>第1字母，d代表了文件的类型，比如目录（d），文件是（-）、链接文件（l）、字符设备（c）、块设备（b）。</li><li>第2-10的字母和数字，代表了读写权限，这一部分内容会留到权限篇章介绍，具体可先参看下图。</li><li>第11位的数字，代表了文件的硬链接数目，参看链接小节的内容。</li><li>后边的一组字符，代表了文件的属主。</li><li>后边的一组字符，代表了文件的属组。</li><li>然后是文件的大小，以字节的形式表示，这里表示目录本身的索引信息占据了4096个字节，并不是代表目录占据了4096字节。</li><li>文件的上次修改时间。</li><li>文件名或者目录名。</li></ul><img src="https://s2.loli.net/2024/03/24/oRCPZhtelAB8xuX.png" alt="image-20240324211953007" style="zoom:80%;"><h4><span id="过滤输出列表">过滤输出列表</span></h4><p>ls 默认情况下会显示所有非隐藏文件，但是有时候文件太多，我们就需要使用过滤器来实现过滤，过滤器是一个字符串，可用作简单的文本匹配，可将其作为命令行参数，放置在选项之后使用，举个例子：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ ls -alh pytorch221_cuda122-rw------- 1 root root 13G  3月 26 14:02 pytorch221_cuda122</code></pre><p>其基本格式如下：</p><pre><code class="language-bash">ls -alh Filename</code></pre><p>当然其威力不仅仅于此，对于filename，其支持标准通配符（wildcard），我们可以尝试如下例子：</p><pre><code class="language-bash">ls -alh pytor*</code></pre><p>当然效果上，我们可以看到：</p><img src="https://s2.loli.net/2024/04/20/cpw8xHgXouyKflU.png" alt="image-20240420203626775" style="zoom: 80%;"><p>也会将对应的文件显示出来，通配符也包括<code>？、[ ]、!</code> ,效果如下：</p><img src="https://s2.loli.net/2024/04/20/SHL1FUPydMYzukT.png" alt="image-20240420203943906" style="zoom:80%;"><p>当然匹配符有很多，这里就不再一一赘述。</p><img src="https://s2.loli.net/2024/04/20/Z98N1QBwkSfFdVU.png" alt="image-20240420204333227" style="zoom:80%;"><pre><code class="language-bash">Neo@Bionet:~/Desktop$ ls -alhitotal 13G26083455 drwxr-xr-x  2 Neo  Neo  4.0K  4月 20 22:23 .26083329 drwxr-x--- 43 Neo  Neo  4.0K  4月 20 22:28 ..26088183 -rw-r--r--  1 root root    7  4月 20 21:28 1.txt26086399 -rw-r--r--  1 root root    7  4月 20 21:33 2.txt26083364 -rwxrwxrwx  1 root root 1.4K  4月 20 18:39 creatematlab.sh26088522 -rwxrwxrwx  1 root root  571  4月  1 11:58 c.sh26084449 -rwxrwxrwx  1 Neo  Neo  1.7K  4月 11 17:16 devel_level.df26083390 lrwxrwxrwx  1 Neo  Neo    32  4月 20 22:23 ln_createusr -&gt; /home/some_scripts/createuser.sh26084386 -rw-------  1 root root  13G  3月 26 14:02 pytorch221_cuda122</code></pre><p><code>ls -alhi</code>中的i显示了inode编号，<strong>文件或目录的inode编号是内核分配给文件系统中每一个对象的唯一标识</strong>。</p><h2><span id="复制文件和目录">复制文件和目录</span></h2><p>cp命令是将文件和目录从文件系统的一个位置复制到另一个位置，其最基本的用法如下：</p><pre><code class="language-bash">cp --helpUsage: cp [OPTION]... [-T] SOURCE DEST  or:  cp [OPTION]... SOURCE... DIRECTORY  or:  cp [OPTION]... -t DIRECTORY SOURCE...Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.</code></pre><p>可以看到cp支持的表达式如下：</p><pre><code class="language-bash">cp [OPTION]... [-T] SOURCE DEST</code></pre><p>通常情况下，如果 <code>cp</code> 命令的目标路径是一个目录，则会将源文件复制到目标目录中。但是，如果你希望将源文件复制到一个普通文件中，并且目标路径可能会被解释为目录，那么你可以使用 <code>-T</code> 选项来强制 <code>cp</code> 将目标路径视为普通文件。</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ sudo cp -T 1.txt 2.txt</code></pre><p>需要注意的是这里的的复制指的是将1的内容直接覆盖到2上。如果需要强制询问是否需要覆盖已有文件：</p><pre><code class="language-bash">$ sudo cp -Ti  1.txt 2.txtcp: overwrite '2.txt'? y</code></pre><p>回答y之后就会覆盖，任何不是y的回答都取消覆盖。</p><pre><code class="language-bash">cp -Ri Share_Space/ newshare/</code></pre><p>会直接将<code>Share_Space/</code>的内容直接复制到新的文件夹<code>newshare/</code>当中，递归的包含所有的内容。</p><p>当然cp也支持使用通配符，举个例子，我们使用cp命令将当前目录下的所有sh脚本复制到路径/home/some_scripts/下中：</p><pre><code class="language-bash">:~/Desktop$ sudo cp -i ./*.sh /home/some_scripts/cp: overwrite '/home/some_scripts/creatematlab.sh'? ncp: overwrite '/home/some_scripts/createuser.sh'? ncp: overwrite '/home/some_scripts/c.sh'? n</code></pre><p>此操作会将桌面的所有sh脚本复制过去，因为我已经提前复制了，所以会一个一个询问是否要覆盖。</p><h2><span id="删除文件和文件夹">删除文件和文件夹</span></h2><p>linux中最常用且最危险的命令莫过于rm了。在linux中删除被叫做移除（removing）。bash shell 中用于删除文件的命令是rm。rm命令的基本格式非常简单：</p><pre><code class="language-bash">SYNOPSIS       rm [OPTION]... [FILE]...</code></pre><p>举个例子，我们查看当前目录下面的内容，并尝试删除一个文件：</p><p><img src="https://s2.loli.net/2024/05/03/CfWec4gY7jP3lDh.png" alt="image-20240503220346917"></p><p>可以看到有一个Dockerfile.swp文件这是一个缓存的交换文件，并没有什么用，我们将其删除：</p><pre><code class="language-bash">rm -i .Dockefile.swp</code></pre><p>删除之后我们可以看到：</p><p><img src="https://s2.loli.net/2024/05/03/bTzZSFigO7I3QaK.png" alt="image-20240503220637952"></p><p>此处加入i参数目的是为了提醒自己要删除对应的文件了，shell的删除命令并不存在垃圾箱这种东西，如果一旦不小心删除那么就永远也找不回来了，所以要养成加入i参数的好习惯。</p><p>rm的文件参数同时也支持通配符，也就是说可以通过rm一次性删除很多文件，这是非常有用的，当你想删除某一类文件的时候就可以使用：</p><pre><code class="language-bash">rm -i *.sh</code></pre><p>此操作会删除所有的sh脚本文件。</p><h3><span id="删除文件夹">删除文件夹</span></h3><p>对于非空目录rmdir命令足以，但是大多数情况下，目录中都有内容，我们就必须使用rm命令来实现了。</p><pre><code class="language-bash">rm -ri 目录名或路径 </code></pre><p><code>-r/R</code>（没错此处Rr效果是一样的）参数会向下进入到目录中将其内容全部删除，在这个过程中会一个一个询问你是否删除，如果不想这样，且确认数据真的没有用处了，我们可以选择<code>-rf</code>参数。</p><p>效果如下，有以下文件夹：</p><p><img src="https://s2.loli.net/2024/05/03/mcAO758vHoQZ2gI.png" alt="image-20240503223624129"></p><p>使用命令进入删除：</p><p><img src="https://s2.loli.net/2024/05/03/G3W4wgqejYERMJp.png" alt="image-20240503223554291"></p><h2><span id="链接文件">链接文件</span></h2><p>链接文件可以说是linux系统的优势，如果需要在系统中维护同一个文件的两个或者多个副本的时候可以使用单个物理副本+多个虚拟副本(链接)的方法代替创建多个物理副本，链接是目录中指向文件真实位置的占位符，在linux中有两种类型的文件链接：</p><ul><li>符号链接（软连接）</li><li>硬链接</li></ul><p>创建链接的命令如下：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ ln --helpUsage: ln [OPTION]... [-T] TARGET LINK_NAME  or:  ln [OPTION]... TARGET  or:  ln [OPTION]... TARGET... DIRECTORY  or:  ln [OPTION]... -t DIRECTORY TARGET...In the 1st form, create a link to TARGET with the name LINK_NAME.In the 2nd form, create a link to TARGET in the current directory.In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.Create hard links by default, symbolic links with --symbolic</code></pre><p>可以看到不仅可以创造针对文件的链接，也可以创造针对目录的链接。</p><h3><span id="符号链接软连接">符号链接（软连接）</span></h3><p>符号链接是一个实实在在的文件，只不过文件的内容是指向的是虚拟文件系统中的另一个地方的文件，这两个以符号方式连接在一起的文件彼此的内容并不相同。</p><p>举个例子，我们将刚刚复制的脚本在桌面删除，然后以不同的方式链接回来看看。</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ sudo rm ./createuser.sh Neo@Bionet:~/Desktop$ ln -s /home/some_scripts/createuser.sh ./ln_createusr# 链接完成之后，显示当前实际上是一个链接文件：Neo@Bionet:~/Desktop$ ls -alhlrwxrwxrwx  1 Neo  Neo    32  4月 20 22:23 ln_createusr -&gt; /home/some_scripts/createuser.sh# 源文件并没有任何变换：Neo@Bionet:~/Desktop$ ls -alh /home/some_scripts/createuser.sh -rwxr-xr-x 1 root root 859  4月 20 22:07 /home/some_scripts/createuser.sh</code></pre><p>可以看到通过命令：</p><pre><code class="language-bash">ln -s /home/some_scripts/createuser.sh ./ln_createusr</code></pre><p>我们创造了一个从对应目录下的文件的软连接到桌面的一个新文件叫<code>ln_createusr</code>。</p><p>使用ls来查看的时候其文件名部分被替换成了<code>ln_createusr -&gt; /home/some_scripts/createuser.sh</code>的内容，而不是本身的文件名，这里的 <code>-&gt;</code>代表了该文件是连接到文件<code>/home/some_scripts/createuser.sh</code>的一个符号链接。</p><p>我们通过上文中两个 <code>ls -alh</code>文件看到，两个文件的大小并不相同，源文件有859个字节，而链接文件只有32个字节</p><p>而我们尝试打开链接文件，可以看到：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ vim ./ln_createusr </code></pre><img src="https://s2.loli.net/2024/04/20/SUrzaQJtpcmqbwk.png" alt="image-20240420224944397" style="zoom:67%;"><p>显示内容和源文件保持一致。当我们尝试修改的时候因为源文件权限的问题，无法修改：</p><img src="https://s2.loli.net/2024/04/20/YwyBM5mHhdxNeJV.png" alt="image-20240420225031627" style="zoom:67%;"><p>当我们修改权限以后：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ sudo chmod 777 /home/some_scripts/createuser.sh </code></pre><p>文件就可以正常修改了，这里说明链接文件的权限取决于源文件，二者的权限保持一致。</p><h3><span id="硬链接">硬链接</span></h3><p>硬链接创建的是一个独立的虚拟文件，其中包含了原始文件的信息和位置，但是二者本质上是同一个文件，这是和符号链接的最大区别。</p><p>我们再举一个例子：同样将上文中复制的文件从桌面删除再以硬连接的方式连接回来。</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ rm ./creatematlab.sh     Neo@Bionet:~/Desktop$ sudo ln /home/some_scripts/creatematlab.sh  ln_creatematlabNeo@Bionet:~/Desktop$ ls -alhi109051906 -rwxr-xr-x  2 root root 1.4K  4月 20 22:07 ln_creatematlabNeo@Bionet:~/Desktop$ ls -alhi /home/some_scripts/creatematlab.sh 109051906 -rwxr-xr-x 2 root root 1.4K  4月 20 22:07 /home/some_scripts/creatematlab.sh</code></pre><p>通过<code>sudo ln /home/some_scripts/creatematlab.sh  ln_creatematlab</code>创建链接之后，我们可以看到：</p><p>二者共用一个inode号码，说明二者是一个文件。省略参数的情况下，其意思是默认在当前目录这里创建一个名字一样的硬链接，虽然下图创建失败了，但是其详细展示了创建的内容：</p><p><img src="https://s2.loli.net/2024/05/03/txdviqWJwUNMjRz.png" alt="image-20240503213411568"></p><h3><span id="软连接和硬连接的区别">软连接和硬连接的区别</span></h3><ol><li><strong>软连接（Symbolic Link）</strong>：<ul><li>软连接类似于Windows系统中的快捷方式（Shortcut）。</li><li>它是一个特殊的文件，包含了对另一个文件或目录的引用路径。</li><li>软连接不依赖于原始文件的文件名，即使原始文件被移动或重命名，软连接依然有效。</li><li>软连接可以跨文件系统，即可以链接到不同文件系统中的文件。</li><li>删除原始文件会导致软连接失效，因为它只是指向原始文件的一个路径。</li></ul></li><li><strong>硬连接（Hard Link）</strong>：<ul><li>硬连接直接指向文件的物理位置，即文件的inode节点。</li><li>硬连接与原始文件共享同一个inode，因此它们实际上是同一个文件。</li><li>硬连接不能跨文件系统，只能在同一文件系统中创建。</li><li>硬连接不能链接到目录，只能链接到文件。</li><li>删除原始文件不会影响硬连接，因为只要有一个硬连接存在，文件内容就不会被删除。</li></ul></li></ol><p>硬链接（Hard Link）不会占用两倍的空间。实际上，硬链接与原始文件共享相同的存储空间，它们指向同一个inode节点。这意味着，无论有多少个硬链接指向同一个文件，它们都只占用原始文件所占用的存储空间。</p><p>在UNIX和类UNIX系统中，文件的内容和文件的元数据（如文件名、权限、所有者等）是分开存储的。文件的内容存储在数据块中，而元数据存储在inode节点中。硬链接和原始文件都指向同一个inode节点，因此它们共享相同的数据块。</p><p>举个例子我想查看如何使用 tar 命令进行归档的压缩和解压就可以使用：</p><pre><code class="language-shell">man tar</code></pre><p>效果如下：</p><img src="https://s2.loli.net/2024/04/20/jqhmYyKxe3lD5gT.png" alt="image-20240420145521695" style="zoom:67%;"><img src="https://s2.loli.net/2024/04/20/W4yvErVod9tN58c.png" alt="image-20240420150802190" style="zoom:67%;"><p>这里tar的语法描述如下：</p><pre><code class="language-shell">SYNOPSIS   Traditional usage       tar {A|c|d|r|t|u|x}[GnSkUWOmpsMBiajJzZhPlRvwo] [ARG...]          UNIX-style usage       tar -A [OPTIONS] ARCHIVE ARCHIVE.......       tar -x [-f ARCHIVE] [OPTIONS] [MEMBER...]   GNU-style usage       tar --create [--file ARCHIVE] [OPTIONS] [FILE...].......       tar {--extract|--get} [-f ARCHIVE] [OPTIONS] [MEMBER...]</code></pre><p>这一部分描述了常用的方式：</p><pre><code class="language-bash">Traditional usage       tar {A|c|d|r|t|u|x}[GnSkUWOmpsMBiajJzZhPlRvwo] [ARG...]</code></pre><p>参数了解之后，可以看看这些参数有什么用：</p><p>关于参数的内容linux的运行手册有的内容非常多而且不一致，我们可以换个方式来快速查看， 大多数命令都支持-h选项来实现，更快速的信息获取：</p><pre><code class="language-shell">Neo@Bionet:~/Desktop$ tar --helpUsage: tar [OPTION...] [FILE]...GNU 'tar' saves many files together into a single tape or disk archive, and canrestore individual files from the archive.Examples:  tar -cf archive.tar foo bar  # Create archive.tar from files foo and bar.  tar -tvf archive.tar         # List all files in archive.tar verbosely.  tar -xf archive.tar          # Extract all files from archive.tar. Main operation mode:  -A, --catenate, --concatenate   append tar files to an archive  -c, --create               create a new archive      --delete               delete from the archive (not on mag tapes!)  -d, --diff, --compare      find differences between archive and file system  -r, --append               append files to the end of an archive      --test-label           test the archive volume label and exit  -t, --list                 list the contents of an archive  -u, --update               only append files newer than copy in archive  -x, --extract, --get       extract files from an archive Operation modifiers:      --check-device         check device numbers when creating incremental                             archives (default)  -g, --listed-incremental=FILE   handle new GNU-format incremental backup  -G, --incremental          handle old GNU-format incremental backup      --hole-detection=TYPE  technique to detect holes      --ignore-failed-read   do not exit with nonzero on unreadable files      --level=NUMBER         dump level for created listed-incremental archive      --no-check-device      do not check device numbers when creating                             incremental archives</code></pre><p>获取的信息，截取了一部分，这样就避免了翻页程序过于正式的效果，反而看清楚该如何使用命令。</p><p>我们找到解压的参数 <code>-x</code>作为主参数，同时浏览一下常用的vf参数是什么意思：</p><p><code>-f, --file=ARCHIVE         use archive file or device ARCHIVE</code></p><h2><span id="查看文件">查看文件</span></h2><p>查看文件是linux最重要的特性，有了这些查看命令的支持，相较于windows那些操作系统，在有大文件的时候linux不仅能打开，并且能快速查看当中的内容。</p><p>当你手头有一个很大的文本文件，你可能会想看一看到底是什么，linux有几个经典的命令来实现这个操作，我们只介绍当中比较常用的命令。</p><h3><span id="cat命令">cat命令</span></h3><p>cat命令是最基础的文件探查命令，当你查找资料的时候经常能看到，所以这里介绍一下：</p><p>我们有一个test文件里面包含多行的内容：</p><img src="https://s2.loli.net/2024/05/03/f6vskCKxOaSPNY9.png" alt="image-20240503230813839" style="zoom: 80%;"><p>我们使用cat来查看一下：</p><pre><code class="language-bash">cat -n test</code></pre><p>效果如下：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop$ cat -n test     1123456     212345     31234     4123     512     61     7     8</code></pre><p>这里就没有什么特别的，其显示的内容就是对应的信息，其中有多种变形的参数，这里<code>-n</code>代表显示行号，同时还有<code>-b</code>选项只给有文本的行加上行号，效果如下：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop$ cat -b test     1123456     212345     31234     4123     512     61neo@NeoNeuxs:~/Desktop$ </code></pre><p>对于cat来说当其应对大文件尤其是超大文件的时候他会不停的刷新模拟终端的内容来显示，我们无法查看到底有什么，为了解决这个问题我们可以使用less。</p><p>less命令提供了非常多的实用特性，能够实现文本文件中的前后翻动，还有一些高级搜索功能。最主要的是less能够实现在完全读取文件之前，显示文件的部分内容，cat和more是无法实现的，为了验证这个功能我们来找一个大的文件来进行操作，</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop/PTM/Dataset/uniprot$ less ./uniprotkb_AND_reviewed_true_AND_model_o_2024_04_25.tsv </code></pre><p>uniprotkb是一个蛋白质库，其中记录了许多蛋白质序列，我们使用less来查看里面的内容，显示如下：</p><p><img src="https://s2.loli.net/2024/05/03/abhLBQX83YleS9O.png" alt="image-20240503232813500"></p><p>由于数据的每一行都非长的长，当达到屏幕极限的时候就会换行，less是按页来显示的，我们可以通过键盘的pgup、pgdn，或者空格来翻页查看，其加载速度并不取决于文件大小而在于每一页的内容，这样当你使用vcode、等编辑器无法一下打开查看信息的时候就是less大发神威的时候，如下图，此文件达到了100多MB,算是比较小的，但是使用其他文件阅读器打开还是比较慢，less在一瞬间就可以打开，并查看其中的内容。</p><img src="https://s2.loli.net/2024/05/03/BlaurX6792TROQf.png" alt="image-20240503233216985" style="zoom:67%;"><p><img src="https://s2.loli.net/2024/05/03/J8RSrN1jftEz9Ls.png" alt="image-20240503233340449"></p><h3><span id="只查看文件部分内容">只查看文件部分内容</span></h3><p>你需要查看的文件有时候经常位于文件的开头或者结尾，当文件很大的时候，你就只能干等着cat或more来载入整个文件，当然linux也提供了专门的命令来解决这个问题，下面就会介绍 tail、head命令。</p><h4><span id="查看文件末尾tail命令">查看文件末尾（tail命令）</span></h4><p>tail命令会显示文件的末尾的内容，默认情况下会显示文件末尾的最后10行，我们还是使用刚才的文件来检测：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop/PTM/Dataset/uniprot$ tail ./dbPTM_PhosphorylationZO3_HUMANO95049919Phosphorylation18669648KKFMRVHDAESSDEDGYDWGPZO3_HUMANO95049920Phosphorylation18669648KFMRVHDAESSDEDGYDWGPAZO3_HUMANO95049925Phosphorylation18669648HDAESSDEDGYDWGPATDL--ZRAB2_HUMANO95218-29Phosphorylation18669648--MSTKNFRVSDGDWICPDKKZRAB2_HUMANO95218-2114Phosphorylation18669648GGFNERENVEYIEREESDGEYZRAB2_HUMANO95218-2120Phosphorylation18669648ENVEYIEREESDGEYDEFGRKZRAB2_HUMANO95218-2153Phosphorylation18669648SILKEVEDKESEGEEEDEDEDZRAB2_HUMANO95218-2181Phosphorylation18669648EDEDEDDADLSKYNLDASEEEZRAB2_HUMANO95218-2183Phosphorylation18669648EDEDDADLSKYNLDASEEEDSZRAB2_HUMANO95218-2188Phosphorylation18669648ADLSKYNLDASEEEDSNKKKS</code></pre><p><code>-n</code>可以显示指定行数，效果如下：</p><pre><code class="language-bash">neo@NeoNeuxs:~/Desktop/PTM/Dataset/uniprot$ tail -n 1 ./dbPTM_PhosphorylationZRAB2_HUMANO95218-2188Phosphorylation18669648ADLSKYNLDASEEEDSNKKKS</code></pre><p><strong>tail最重要的参数是<code>-f</code>其可以实现在线刷新的效果，当有新的数据写到文件的时候会自动刷新。</strong></p><h4><span id="查看文件头部head命令">查看文件头部（head命令）</span></h4><p>head命令的使用方式几乎和tail一样，只不过显示的内容是头部的，相同的命令参数-n也可以指定当前显示的行数。</p><p><img src="https://s2.loli.net/2024/05/04/CqGdyjZbElXwSum.png" alt="image-20240504003518940"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Bash Shell 脚本入门（1）——Linux内核功能介绍</title>
      <link href="/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/"/>
      <url>/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1><span id="linux-bash-shell-脚本入门1linux内核功能介绍">Linux Bash Shell 脚本入门（1）——Linux内核功能介绍</span></h1><p>[TOC]</p><!-- toc --><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#linux%E5%88%9D%E6%8E%A2">Linux初探</a><ul><li><a href="#linux%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84">Linux系统架构</a></li><li><a href="#linux-%E5%86%85%E6%A0%B8">linux 内核</a><ul><li><a href="#%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">系统内存管理</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86">软件程序管理</a></li><li><a href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86">硬件设备管理</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">文件管理系统</a></li></ul></li></ul></li></ul><!-- tocstop --><img src="https://s2.loli.net/2025/03/12/ns1Fc3hg9ztLBpY.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1741766727606" style="zoom:67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1695021721029" style="zoom: 50%;"><h2><span id="前言">前言</span></h2><p>本文为《Linux命令行与shell脚本编程大全》第四版的读书笔记，突发奇想想看看这本书，实际上是图书馆关于Linux的书正好就这一本了，没想到看起来还不错，遂借出来看看。</p><p>Linux算是接触的比较多了，虽然接触了很多但是并不明白其原理和架构是怎么样的，整本书包含了部分linux架构的内容，重点在于shell脚本编写实战，这个非常重要，能够书写bash脚本，在某些时候能达到事半功倍的效果，同时对系统的维护工作也是有益的。</p><h2><span id="linux初探">Linux初探</span></h2><h3><span id="linux系统架构">Linux系统架构</span></h3><p>Linux系统有很多版本，我们常见的是Ubuntu、Debian等等，这些版本大同小异，但最关键的系统架构是几乎一致的，一般发行版的linux系统由四部分组成：</p><ul><li>Linux内核</li><li>GNU工具</li><li>图形化桌面环境</li><li>应用软件</li></ul><p>每一部分都有各自的职责，实际上是一个层次结构的关系，如下图所示：</p><pre class="mermaid">graph TB;A("应用程序软件") &lt;--&gt; E("窗口管理软件")E&lt;--&gt; B("GNU系统工具")  C &lt;--&gt; E("窗口管理软件(图形化桌面环境)")B &lt;--&gt; C("Linux内核")C &lt;--&gt; D("计算机硬件")</pre><h3><span id="linux-内核">linux 内核</span></h3><p>linux系统的核心就是linux内核，创始人linus在赫尔辛基大学上学的时候就开发了第一版linux内核，目前他主要负责编写和审阅linux内核的代码，时至今日linux的开发仍遵循这一思路，只不过不仅仅是linus一个人来进行，目前有一组开发人员负责这项任务。</p><p>内核主要负责的功能有：</p><ul><li>系统内存管理</li><li>软件程序管理</li><li>硬件设备管理</li><li>文件系统管理</li></ul><h4><span id="系统内存管理">系统内存管理</span></h4><p>linux系统的内存管理，不仅仅在于物理内存，还可以创建并管理虚拟内存，内核通过硬盘上称为交换空间来实现虚拟内存，内核通过在实际物理内存和虚拟内存之间不停的交换，来使系统的内存容量扩大到远大于物理内存的大小，内核会将内存划分为若干页，内核会将每个内存页面置于物理内存或者交换内存之中。内核会维护一张内存页面表，指明那些页面位于物理内存，那些页面被交换到了磁盘。</p><p>内核会记录哪些内存页面正在使用中，自动把一段时间为访问的内存页面复制到交换区域（这操作称为换出，swapping out），当程序要访问一个已经被换出的内存页面，内核就会将物理内存中的另一个页面换出来为其腾出空间，然后从交换空间实行换入操作（swapping in）。显然，这个过程取决于硬盘的读写性能上限和当前的运行状态中是否有较高的读写占用，一般来说这个换入和换出的操作会拖慢程序的运行速度，只要linux系统在运行这个过程就不会停止，因为内核会将长时间不用的内存页面换出，即使当前还有内存可以使用。</p><p>关于系统的交换分区和交换文件的设置，可以参考本人另一篇文章：<a href="https://www.cnblogs.com/NeoNexus/p/17999581">Ubuntu22.04 &amp; Win11 双系统hibernate冷切换实现</a>，里面详细讲述了交换文件和交换分区的内容，并由此为引子实现了双系统的冷切换操作。</p><h4><span id="软件程序管理">软件程序管理</span></h4><p>Linux下运行的程序被称为进程，进程可以在前台运行，显示在屏幕之上，也可以后台运行，隐藏到幕后。内核控制Linux系统如何管理运行在系统中的所有进程。</p><p>内核通过创建init进程来启动系统中所有的其他进程，当内核启动的时候，它会将init进程载入到虚拟内存。内核启动进程的时候，会在虚拟内存中分配一块专有区域，来存储进程用到的数据和代码。</p><p>在linux中，有很多init进程实现的方式，目前最流行的有一下两种：</p><ul><li>SysVinit：Linux最初使用的就是这种方法，该方法基于Unix System V初始方法，目前很多发行版已经不再使用了，但在一些旧的Linux发行版中还能找到其身影。</li><li>systemd：systemd初始化方法诞生于2010年，systemd不仅包含初始化过程，同时包含进程管理的功能。</li></ul><p>关于SysVinit初始化方法已经被淘汰，这里就主要介绍systemd的方法，systemd进步在于能够依据不同的事件启动进程，比如一下事件：</p><ul><li>系统启动时</li><li>连接到特定的硬件设备时</li><li>服务启动时</li><li>建立好网络连接时</li><li>计时器到期时</li></ul><p>systemd方法通过将事件与单元文件（Unit file）链接来决定运行哪些进程，每个单元文件定义了特定事件发生时要启动的程序。</p><p>Unit 文件是 systemd 管理资源的基本单位，定义了如何控制一个**服务（Service）、设备（Device）、挂载点（Mount）、定时器（Timer）**等。</p><ul><li>每个 Unit 文件对应一种资源，例如：<ul><li><code>nginx.service</code>（服务）</li><li><code>home.mount</code>（挂载点）</li><li><code>graphical.target</code>（目标）</li></ul></li></ul><p>systemctl程序允许启动、停止和列出系统中当前运行的单元文件。</p><pre><code class="language-shell">systemctl list-units --type=service</code></pre><img src="https://s2.loli.net/2024/02/11/H57EPWd2tYDxXkG.png" alt="image-20240211125107649" style="zoom:80%;"><p>systemd方法将单元文件划归为目标（target），目标定义了Linux系统的特定状态，在某个目标（target）中就包含了很多单元文件（Unit file），需要注意的是target文件本身就是一种Unit文件类型，二者并不是从属关系的存在。</p><p>比如在系统启动的时候，default.target单元定义了要启动的所有单元文件，可以使用systemctl命令查看当前默认目标：</p><pre><code class="language-shell">neo@NeoNeuxs:/etc$ systemctl get-defaultgraphical.target</code></pre><p>graphical.target单元文件定义了多用户图形 环境运行时要启动的进程。</p><p>这里我们使用systemctl 来启动一个服务，这里的服务是一个云盘的挂载软件：</p><pre><code class="language-shell">systemctl enable --now clouddrive.serviceFailed to enable unit: Unit file clouddrive.service does not exist.</code></pre><p>可以看到报错，没有找到对应的service的Unit单元文件。</p><h4><span id="硬件设备管理">硬件设备管理</span></h4><p>所谓硬件设备管理，就是通过对应的硬件的驱动，来完成硬件和内核的数据交互。</p><p>Linux系统将硬件设备视为一种特殊文件，称为设备文件。设备文件分为3种：</p><ul><li>字符设备文件：对应每次只能处理一个字符的设备，大多数类型的调制解调器和终端是作为字符设备文件创建的。</li><li>块设备文件：对应于每次以块的形式处理数据的设备，比如硬盘。</li><li>网络设备文件：对应于采用数据包发送和接受数据的设备，包含网卡和本地的网络回环设备。网络回环对应的是linux系统允许以常规网络编程的方式同自身通信一般地址127.0.0.1</li></ul><p>Linux会为每一个设备创建一种节点的特殊文件，与设备所有的通信都是通过设备节点完成的，每个节点都有一个唯一的数值对，来供linux内核标识，数值对包括一个主设备号和一个次设备号，类似的设备会被划分到主设备号下面，次设备号用于标识主设备下某个特定的设备。</p><p>例如，如果你有多个SATA硬盘，它们会共享相同的主设备号，但每个硬盘会有不同的次设备号来区分。</p><h4><span id="文件管理系统">文件管理系统</span></h4><p>Linux内核支持多种类型数据的读取，同时支持读写其他操作系统的的文件系统，内核必须在编译时就加入对所有要用到的文件系统的支持。常见的文件系统有：</p><ul><li>EXT1-4: ext是Linux扩展文件系统，最早的Linux文件系统，后续推出了ext2、ext3、ext4,ext4是目前常用的文件系统，支持高级日志功能。</li><li>EXFAT：扩展windos文件系统，常用于大容量移动设备。</li><li>NTFS：NTFS（New Technology File System）是由Microsoft开发的一个文件系统，最初在Windows NT 3.1中引入，并在后续的Windows操作系统中得到广泛应用，包括Windows 2000、Windows XP、Windows Vista、Windows 7、Windows 8、Windows 10以及Windows Server系列。NTFS替代了之前的FAT（File Allocation Table）和HPFS（High Performance File System）文件系统，提供了许多改进和新特性</li><li>SMB：最初由IBM开发，后来由Microsoft进一步扩展和标准化，成为Windows网络环境中文件和打印服务的核心协议。SMB工作在客户端/服务器模型上，允许客户端（通常是计算机或移动设备）通过发送请求消息给服务器（通常是文件服务器或打印服务器）来访问网络上的资源。服务器接收到请求后，处理请求并返回相应的响应给客户端。因此常被用来作为网络硬盘的功能。</li></ul><p>内核采用虚拟文件系统作为和各种文件系统互相交互的接口，linux内核与其他类型的文件系统之间的通信提供了一个标准接口，当文件系统被挂载和使用的时候，VFS会在内存中缓存相关信息。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Bash Shell 脚本入门（2）——GNU</title>
      <link href="/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%202/"/>
      <url>/2025/03/12/Linux%20Bash%20Shell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%202/</url>
      
        <content type="html"><![CDATA[<h1><span id="linux-bash-shell-脚本入门2gnu">Linux Bash Shell 脚本入门（2）——GNU</span></h1><p>[TOC]</p><!-- toc --><ul><li><a href="#gnu%E4%B8%8Elinux">GNU与Linux</a><ul><li><a href="#gnu">GNU</a><ul><li><a href="#gnu%E7%9A%84%E7%BB%84%E6%88%90">GNU的组成</a></li></ul></li><li><a href="#shell">Shell</a></li><li><a href="#gnome%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83">GNOME桌面环境</a><ul><li><a href="#x-window-%E8%BD%AF%E4%BB%B6">X Window 软件</a></li></ul></li><li><a href="#gnome">GNOME</a></li></ul></li></ul><!-- tocstop --><img src="https://s2.loli.net/2025/03/12/FvsRHCyO4QK9Tlb.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1741775577228" style="zoom:67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1695021721029" style="zoom: 50%;"><p>可点击内容，大部分来自维基百科，可以点击了解详情。</p><h2><span id="gnu与linux">GNU与Linux</span></h2><h3><span id="gnu">GNU</span></h3><p>GNU操作系统起源于<a href="https://zh.m.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83">GNU计划</a>，由<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>在<a href="https://zh.m.wikipedia.org/wiki/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%B8%E9%99%A2">麻省理工学院</a>人工智能实验室发起，希望发展出一套完整的开放源代码操作系统来取代Unix，计划中的操作系统，名为GNU。</p><p><img src="https://s2.loli.net/2022/08/12/jQLouxXq39ZigGR.png" alt="246px-Heckert_GNU_white.svg"></p><p>GNU的商标是一个<a href="https://zh.m.wikipedia.org/wiki/%E7%89%9B%E7%BE%9A">牛羚</a>头。原先版本是Etienne Suvasa所设计，而今比较流行的粗体版本则是Aurelio Heckert所设计。</p><p><strong>GNU</strong>是一个<a href="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BB%9F%E9%AB%94">自由</a>的<a href="https://zh.m.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1">操作系统</a>，其内容软件完全以<a href="https://zh.m.wikipedia.org/wiki/GPL">GPL</a>方式发布（什么是GPL下文会介绍）。这套操作系统是<a href="https://zh.m.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83">GNU计划</a>的主要目标，名称来自GNU’s Not Unix!的<a href="https://zh.m.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E7%B8%AE%E5%AF%AB">递归缩写</a>，因为GNU的设计类似<a href="https://zh.m.wikipedia.org/wiki/Unix">Unix</a>，但它不包含具著作权的Unix代码。</p><p>读到这里你可能会难以理解，我从来没听说过GNU操作系统，像是Linux，Unix这种都是很有名的，但GNU到底是什么？</p><p>1983年9月27日，<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>在 net.unix-wizards 和 net.usoft<a href="https://zh.m.wikipedia.org/wiki/%E6%96%B0%E8%81%9E%E7%BE%A4%E7%B5%84">新闻组</a>中公布这项GNU计划。斯托曼的目标是成立一个完全自由的操作系统，他希望电脑用户是能够“自由使用”的。</p><p>为什么要在这里强调自由使用呢？因为在20世纪60年代和70年代 - 大多数人都能自由学习软件的源代码，自由地与他人分享的软件，可自由修改软件，自由发布软件修改后的版本。也就是说早些年软件几乎不存在著作权，每个人都可以自由地使用和修改。</p><p>1984年1月5日，理查德正式开始开发软件，为了防止这些软件将来可能被主张所有权，影响到Free Software的发展，斯托曼辞去了在实验室的工作。</p><p>理查德·斯托曼使用<a href="https://zh.m.wikipedia.org/w/index.php?title=%E4%B8%8D%E5%85%BC%E5%AE%B9%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1&amp;action=edit&amp;redlink=1">不兼容分时系统</a>（英语：<a href="https://en.wikipedia.org/wiki/Incompatible_Timesharing_System">Incompatible Timesharing System</a>） (ITS)<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-intervention-6">[6]</a>（一种早期的操作系统，使用<a href="https://zh.m.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">汇编语言</a>撰写，因其所运行的被称为 <a href="https://zh.m.wikipedia.org/wiki/PDP-10">PDP-10</a>的电脑系统架构停止发展而变得过时）的经验，决定了需要设计一种可移植系统。由此，会议决定，将开发新的系统，并使用 <a href="https://zh.m.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">C</a> 和<a href="https://zh.m.wikipedia.org/wiki/Lisp">Lisp</a>作为系统编程语言。<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-8">[8]</a> GNU将与UNIX兼容。<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-9">[9]</a> 当时，UNIX已经是一个流行的专有操作系统。而Unix的设计是模块化的，所以它可以被逐步分块的实现。</p><p>Unix在学术机构和大型企业中得到了广泛的应用，当时的UNIX拥有者<a href="https://zh.m.wikipedia.org/wiki/AT%26T">AT&amp;T</a>公司以低廉甚至免费的许可将Unix源码授权给学术机构做研究或教学之用，许多机构在此源码基础上加以扩展和改进，形成了所谓的“Unix变种”，这些变种反过来也促进了Unix的发展。</p><p>后来<a href="https://zh.m.wikipedia.org/wiki/AT%26T">AT&amp;T</a>意识到了Unix的商业价值，不再将Unix源码授权给学术机构，并对之前的Unix及其变种声明了著作权权利。BSD在Unix的历史发展中具有相当大的影响力，被很多商业厂家采用，成为很多商用Unix的基础。其不断增大的影响力终于引起了AT&amp;T的关注，于是开始了一场持久的著作权官司，至此人们意识到我们需要一个完全免费的操作系统。</p><p>1984年，开始发展编辑器<a href="https://zh.m.wikipedia.org/wiki/Emacs">Emacs</a>等软件。1985年，发表<a href="https://zh.m.wikipedia.org/wiki/GNU%E5%AE%A3%E8%A8%80">GNU宣言</a>。1989年，发表<a href="https://zh.m.wikipedia.org/zh-cn/GNU_General_Public_License">GNU通用公共许可协议</a>。这个公共开源许可协议，你如果开源过项目一定见过，它叫GPL协议，GPL是<a href="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BB%9F%E4%BB%B6">自由软件</a>和<a href="https://zh.m.wikipedia.org/wiki/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6">开源软件</a>的最流行许可证<a href="https://zh.m.wikipedia.org/zh-cn/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81#cite_note-18">[18]</a>。到2004年4月，GPL已占<a href="https://zh.m.wikipedia.org/w/index.php?title=Freshmeat&amp;action=edit&amp;redlink=1&amp;variant=zh-cn">Freshmeat</a>（英语：<a href="https://en.wikipedia.org/wiki/Freshmeat">Freshmeat</a>）上所列的自由软件的约75%，<a href="https://zh.m.wikipedia.org/wiki/SourceForge">SourceForge</a>的约68%。类似的，2001年一项关于<a href="https://zh.m.wikipedia.org/wiki/Red_Hat_Linux">Red Hat Linux</a> 7.1的调查显示一般的代码都以GPL发布。著名的GPL自由软件包括<a href="https://zh.m.wikipedia.org/wiki/Emacs">Emacs</a>，<a href="https://zh.m.wikipedia.org/wiki/Linux">Linux</a>核心（并非所有<a href="https://zh.m.wikipedia.org/wiki/Linux%E7%99%BC%E8%A1%8C%E7%89%88">Linux发行版</a>的核心都是开源的）和<a href="https://zh.m.wikipedia.org/wiki/GCC">GCC</a>。</p><p>我们回到GNU的操作系统来，因为许多必要的软件需要从零开始写起来，但是有很多已经存在的第三方组件如 <a href="https://zh.m.wikipedia.org/wiki/TeX">TeX</a>、<a href="https://zh.m.wikipedia.org/wiki/X_Window_System">X Window System</a><a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-internethist-4">[4]</a>和<a href="https://zh.m.wikipedia.org/wiki/Mach">Mach</a>微内核等等都可以进行利用，其中GNU最关键系统内核，是在<a href="https://zh.m.wikipedia.org/zh-cn/GNU_Mach">GNU Mach</a><a href="https://zh.m.wikipedia.org/wiki/%E5%BE%AE%E5%85%A7%E6%A0%B8">微内核</a>基础上进行开发，<strong>理查德·马修·斯托曼</strong>认为可以借此加速操作系统的开发，但因为一直不确定<a href="https://zh.m.wikipedia.org/wiki/%E5%8D%A1%E5%86%85%E5%9F%BA%E6%A2%85%E9%9A%86%E5%A4%A7%E5%AD%A6">卡内基梅隆大学</a>何时要将核心源代码发布，造成计划延宕三年。他在之后承认这是个错误。</p><p>下图是大佬的照片：</p><img src="https://s3.bmp.ovh/imgs/2022/08/12/b0dde8c65ef4b8b8.jpg" alt="Richard_Stallman_at_LibrePlanet_2019" style="zoom: 33%;"><p>除了上述的第三方组件外，大多数的GNU软件是由许多志愿者，在他们的空闲时间，或由公司、教育机构和非营利性组织赞助下撰写。</p><p>到 1990 年代初期，操作系统中所需的许多程序（例如库、<a href="https://en.wikipedia.org/wiki/Compiler">编译器</a>、<a href="https://en.wikipedia.org/wiki/Text_editor">文本编辑器</a>、<a href="https://en.wikipedia.org/wiki/Shell_(computing)#Command-line_shells">命令行 shell</a>和<a href="https://en.wikipedia.org/wiki/Windowing_system">窗口系统</a>）已完成，尽管一些底层元素如称为<a href="https://en.wikipedia.org/wiki/GNU_Hurd">GNU Hurd的</a><a href="https://en.wikipedia.org/wiki/Device_driver">设备驱动程序</a>、<a href="https://en.wikipedia.org/wiki/Daemon_(computer_software)">守护进程</a>和<a href="https://en.wikipedia.org/wiki/Kernel_(computer_science)">内核</a>都停滞不前且不完整。</p><p>1991年，Linux出现。1993年，<a href="https://zh.m.wikipedia.org/wiki/FreeBSD">FreeBSD</a>发布。FreeBSD就是当年与Unix著作权持有公司达成协议重写的免费版Unix，所有GNU计划中，运行于用户空间的软件，都可以在Linux或FreeBSD上使用。许多开发者转向于Linux或FreeBSD。其中，Linux成为常见的GNU计划软件运行平台。<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>主张，Linux操作系统使用了许多GNU计划软件，应正名为<a href="https://zh.m.wikipedia.org/wiki/GNU/Linux">GNU/Linux</a>，但没有得到Linux社群的一致认同，形成<a href="https://zh.m.wikipedia.org/wiki/GNU/Linux%E5%91%BD%E5%90%8D%E7%88%AD%E8%AD%B0">GNU/Linux命名争议</a>。</p><p><a href="https://zh.m.wikipedia.org/wiki/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9">林纳斯·托瓦兹</a>（Linus）开始在<a href="https://zh.m.wikipedia.org/wiki/MINIX">MINIX</a>上开发<a href="https://zh.m.wikipedia.org/wiki/Linux%E5%85%A7%E6%A0%B8">Linux内核</a>，为<a href="https://zh.m.wikipedia.org/wiki/MINIX">MINIX</a>写的软件也可以在<a href="https://zh.m.wikipedia.org/wiki/Linux%E5%85%A7%E6%A0%B8">Linux内核</a>上使用。1991年Linus[<a href="https://zh.m.wikipedia.org/zh-cn/Linux#cite_note-16">16]</a>后来使用GNU软件代替MINIX的软件，因为使用从GNU系统来的源代码可以自由使用，这对Linux的发展有益。同时在GPL的规定下，使用GNU GPL协议的源代码可以被其他项目所使用，只要这些项目使用同样的协议发布源码。</p><p>对于GNU来说没有构成自己的操作系统是失败的，但是这个失败确实促进了行业进步与发展，<a href="https://zh.m.wikipedia.org/zh-cn/%E6%9E%97%E7%B4%8D%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E8%8C%B2">林纳斯·托瓦兹</a>曾说过如果GNU内核在1991年时可以用，他不会自己去写一个。实际上现在GNU代指的是当年发展下来的一系列软件。</p><h4><span id="gnu的组成">GNU的组成</span></h4><p>该系统的基本组成包括</p><ul><li>GNU编译器套装（<a href="https://zh.m.wikipedia.org/wiki/GCC">GCC</a>）</li><li>GNU的C库（<a href="https://zh.m.wikipedia.org/wiki/Glibc">glibc</a>）</li><li>GNU核心工具组（<a href="https://zh.m.wikipedia.org/wiki/Coreutils">coreutils</a>）</li><li>GNU调试器（<a href="https://zh.m.wikipedia.org/wiki/GDB">GDB</a>）</li><li>GNU<a href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">编程语言</a>工具程序（<a href="https://zh.m.wikipedia.org/wiki/Binutils">binutils</a>）</li><li><a href="https://zh.m.wikipedia.org/w/index.php?title=GNU_Bash">GNU Bash</a> shell<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-linuxinterface-10">[10]</a></li><li>GNOME桌面环境</li></ul><p>GNU开发人员已经转向GNU应用程序和工具的Linux 移植 ，现在也广泛应用在其它操作系统中使用，上文我们提到的MinGW实际上叫Minimalist GNU for Windows，也就是向Windows移植的GNU最小套件，是将<a href="https://zh.wikipedia.org/wiki/GCC">GCC</a>编译器和<a href="https://zh.wikipedia.org/wiki/GNU_Binutils">GNU Binutils</a>移植到Win32平台下的产物，包括一系列头文件（<a href="https://zh.wikipedia.org/wiki/Windows_API">Win32API</a>）、<a href="https://zh.wikipedia.org/wiki/%E9%9D%9C%E6%85%8B%E9%80%A3%E7%B5%90%E5%87%BD%E5%BC%8F%E5%BA%AB">库</a>和<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a>。另有可用于产生32位及64位Windows可执行文件的<a href="https://zh.wikipedia.org/wiki/Mingw-w64"><strong>MinGW-w64</strong></a>项目，是从原本MinGW产生的分支。</p><h3><span id="shell">Shell</span></h3><p>shell是种特殊的交互工具，为用户提供了启动程序，管理文件系统中的文件及运行在Linux系统中的进程的途径。shell的核心就是命令行提示符，负责shell的交互部分，允许用户输入文本命令，然后解释命令并在内核中执行。</p><p>常见的命令被用来复制、移动、重命名文件等，你用鼠标实现的操作，在shell中都可以实现，除此之外，shell也允许在命令行提示符中输入程序的名称，他会将程序名称传递给内核以启动程序。</p><p>同时也允许，将多个shell命令放入文件中作为程序执行。这些文件成为shell脚本。凡是能在命令行中执行的命令都可以放入shell脚本中作为一组命令执行。</p><p>linux中所有发行版的默认几乎都是bash shell，bash shell 是<a href="https://zh.m.wikipedia.org/w/index.php?title=GNU_Bash">GNU Bash</a> shell<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-linuxinterface-10">[10]</a> ，目的是为了替代老版本Unix系统中的Unix shell，Bash shell名字的由来非常有意思，其名字来源于一个谐音梗 Bourne Again Shell （念作 born again）的缩写，Linux 中当然不仅仅包括GNU的 Bash Shell 也包含其他的shell比如：</p><ul><li>ash：轻量级别的shell,适合运行在内存受限的环境中，比如嵌入式等。</li><li>korn：一种与Born Shell兼容的shell,但支持一些高级特性，浮点运算等。</li><li>tcsh：一种包含了一些C语言特性引入到shell脚本的shell。</li><li>zsh：一种结合了bash、korn、tcsh的特性的shell。</li></ul><p>关于shell的内容会在以后的内容中详细介绍，这里就不再赘述。</p><h3><span id="gnome桌面环境">GNOME桌面环境</span></h3><p>随着Linux系统的发展，最初的操作系统文本界面到图形化的发展，操作系统不仅仅服务于计算机开发人员，逐渐走向大众化，用户不再满足于陈旧的文本命令行交互，图形化的操作界面的日渐强烈，当然完成工作的方式不只有一种，Linux一直以来都以此为闻名。图形化桌面更是如此。Linux有多种图形化桌面可供选择。接下来会介绍一种属于GNU项目的桌面环境。</p><h4><span id="x-window-软件">X Window 软件</span></h4><p>有两个基本要素决定了你的视频环境，显卡和显示器，显卡如何让显示器显示就需要软件来实现，Linux中负责这一部分的就是X Window，X Window是图形现实的核心部分，控制Linux应用如何在显示器上呈现漂亮的窗口和图形。X Window System，通常简称为X11或X，是一个基于位图的显示系统，用于在位图显示器上提供图形用户界面（GUI）。</p><p>X Window System的关键特性包括：</p><ul><li><strong>网络透明性</strong>：X Window系统设计之初就考虑到了网络支持，允许应用程序的图形界面可以在网络上的任何地方显示，实现了客户端与服务器之间的通信。这意味着，一个运行在网络中某台计算机上的应用程序可以将其图形界面显示在连接到同一网络的另一台计算机上。</li><li><strong>客户端-服务器架构</strong>：在X Window系统中，"服务器"是运行在用户机器上的程序，它管理屏幕、键盘、鼠标等输入输出设备。"客户端"是指任何请求服务器服务的程序，比如图形应用程序。这里的“服务器”和“客户端”的概念与常规意义上的网络服务和使用者相反。</li><li><strong>设备和网络独立性</strong>：X Window系统与具体的硬件设备和网络协议无关，可以在各种不同的硬件和网络环境中运行。</li><li><strong>灵活性和扩展性</strong>：X Window提供了基本的框架和协议，开发者可以在其之上构建各种窗口管理器和桌面环境，如GNOME、KDE等，这使得用户界面可以高度定制化。</li></ul><p>尽管X Window本身不是驱动程序，但它依赖于底层的硬件驱动程序来进行图形渲染和设备输入输出操作。例如，X服务器需要与显卡的驱动程序交互，以控制屏幕上的图形显示。因此，为了使X Window系统正常工作，相应的硬件设备（如显卡、键盘、鼠标等）需要有正确安装的驱动程序。</p><p>Linux中能够实现  X window的软件不止有一种，Linux中最常见用的有：</p><ul><li>wayland</li><li><a href="http://X.org">X.org</a></li></ul><p>X.org基于最初的Unix X Windos System版本11 ，后来大家把他简称为X11,属于常用的两种的比较老的版本，新版的linux正在向wayland迁移，虽然这样说，但是目前Ubuntu22.04默认的还是X11:</p><img src="https://s2.loli.net/2024/02/11/hdk7HJRvCAWS5Zz.png" alt="image-20240211210131407" style="zoom: 67%;"><p>在首次安装Ubuntu的时X11会检测显卡和显示器，然后创建一个含有必要信息的X Window配置文件。在安装过程中，安装程序会检测一次显示器，以确定所支持的视频模式。有时这会造成显示器黑屏几秒。由于显卡和显示器的种类繁多，因此这个过程可能需要花费一点时间。</p><p>核心的X Window 软件能够生常图形化现实环境，但仅此而已。尽管这已足以运行单独的应用程序，但在日常的计算机使用中并不是特别有用，因为毕竟没有提供桌面环境，用户无法知道该如何启动程序，操作文件，为此需要在此基础上建立一个桌面环境。</p><p>注意一下，下图驱动部分是Nouveau 驱动，是X11的下层驱动：</p><p><img src="https://s2.loli.net/2024/02/11/HRAUjEODPgsiutK.png" alt="image-20240211211054589"></p><p>至于想搞明白每一个环节的具体工作可以参考：</p><h3><span id="gnome">GNOME</span></h3><img src="https://s2.loli.net/2024/02/11/IkGQJ24R6WjDlVH.png" alt="image-20240211215028684" style="zoom:67%;"><p>Gnome桌面工作在Xorg-Server的上层，提供给用户相应的桌面环境，其全称是（GNU Network object model enviroment，GNU网络对象模型环境）是另一个流行的Linux桌面环境，GNOME于1990年首次发布，现已成为许多Linux发行版默认的桌面环境。</p><p>随着发展GNOME已经度过了很多个版本，可以通过以下命令来查看当前的GNOME版本：</p><pre><code class="language-shell">neo@NeoNeuxs:~/Desktop$ gnome-shell --versionGNOME Shell 42.9</code></pre><p>GNOME桌面环境又被称为GNOME-Shell，为什么会有shell这个单词呢？</p><p>“Shell”（壳）在这里的含义与其在计算机科学中的一般含义相似，指的是一个提供用户界面的软件层，用户可以通过这个界面与系统的更深层次的功能进行交互，在操作系统中，"shell"通常指的是提供与用户交互的界面，这可以是命令行界面（CLI）或图形用户界面（GUI）。GNOME Shell 是后者的一个例子，它提供了一个图形界面供用户启动程序、管理窗口、切换任务等。</p><p>一个新版的Gnome-shell如下：</p><p><img src="https://s2.loli.net/2024/02/11/7lv8XCqNnodGhca.png" alt="Snipaste_2024-02-11_22-25-07"></p><p>参考：</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JaP Photo Album (Part Two) -- 上野、渋谷、池袋、秋叶原</title>
      <link href="/2025/03/12/JaP_Photo_Album(2)%20/"/>
      <url>/2025/03/12/JaP_Photo_Album(2)%20/</url>
      
        <content type="html"><![CDATA[<h1><span id="jap影集贰上野-渋谷-池袋-秋叶原">JaP影集（贰）–上野、渋谷、池袋、秋叶原</span></h1><p>不做任何评价，没有政治观点，屏蔽所有人物信息。</p><img src="https://s2.loli.net/2024/10/04/k5V3S6I7TJhj1ex.png" alt="image-20241004204650666" style="zoom:50%;"><p>[TOC]</p><h2><span id="东京">东京</span></h2><h3><span id="上野">上野</span></h3><p>本来去上野去买羽毛球拍，最后都没货了。路过了很饿，就先吃饭了。所以这次从拉面开始：</p><p>具体位置我也忘记了，在御徒町駅北口 コインロッカー附近，附近很多吃的。</p><img src="https://s2.loli.net/2024/10/04/amGvEQTAYPIdhCt.jpg" alt="IMG_20240219_140241" style="zoom:80%;"><p>由于是下雨天，没有很多人，在东京几乎每一家店外国人走进去服务员都能接待，我吃着的时候来了一个老外，吃的老香了，少见的放了豆芽的拉面，大块的五花肉好像是经过油炸的，汤味道很浓厚适合重口味的来品尝，趁着店员忙做饭偷拍了两张，记录下做饭的过程。</p><p>标记的地方貌似是熬好的汤底，有中预制菜的感觉，不过算便宜的了，要什么自行车～</p><p><img src="https://s2.loli.net/2024/10/04/6rSIDgL4UtnlA2o.png" alt="image-20241004185214492"></p><p>御徒町駅北口出来不远的地方就是<strong>摩利支天徳大寺</strong>，说着很大其实是个小破庙，我记得里面好像祭祀的是个人骑着猪，由于不方便拍照，就没记录下来：</p><p>去Google街景找了一下：</p><p><img src="https://s2.loli.net/2024/10/04/6RVN4otEnq2XxYj.png" alt="image-20241004185718218"></p><p>庙里面有很多许愿牌：</p><p><img src="https://s2.loli.net/2024/10/04/kFSgqAIoYhsaVO2.png" alt="image-20241004185935831"></p><p>大多数都是发财考试，还有个世界和平～，看来大家愿望都差不多。</p><p>走之前使用胶片相机拍了两张，由于是阴天效果并不太好，可以和google街景做一个对比：</p><p><img src="https://s2.loli.net/2024/10/04/quvx84rE9jbXzZn.png" alt="image-20241004190053444"></p><p><img src="https://s2.loli.net/2024/10/04/Zk5sWcT98eI3it6.png" alt="image-20241004190152957"></p><p>路过的杂货店，对面就是车站（也是使用胶片拍摄，一点都没有违和感）：</p><p>二木果子就在阿美橫町，二战后，该处是贩卖美军物资的黑市，“阿美”一词即相信源自美国。由于当时有许多售卖饴的店家聚集于此，故又名“饴横丁”。 近年货品种类已经包罗万有，除了糖果外，亦有售卖食品、衣饰、钟表、化妆品、日本土产等，除了本地居民光顾之外，也成为外国观光客造访的景点。</p><p><img src="https://s2.loli.net/2024/10/04/YLWF1AoKa6QCyU3.png" alt="image-20241004190245977"></p><p>在车站拍摄，日本的电车几乎承担了大部分公共交通运输，车站几乎都一模一样，有的车站年龄比我大多了，最早的地铁是80年代就有了，使用胶片拍摄也是一点违和感都没有：</p><p><img src="https://s2.loli.net/2024/10/04/nYEH3lLjzbMWTq5.png" alt="image-20241004190635932"></p><p><img src="https://s2.loli.net/2024/10/04/mjlMCD2oVRahczB.png" alt="image-20241004190613269"></p><h2><span id="渋谷">渋谷</span></h2><p>渋谷站出门：</p><p><img src="https://s2.loli.net/2024/10/04/X2SvsQBTz381fuO.png" alt="image-20241004191422673"></p><p>一些街景，全部都是各种商店，年轻人的聚集地。</p><p><img src="https://s2.loli.net/2024/10/04/AEYMIijTXwlVRKz.jpg" alt="IMG_6213"></p><p><img src="https://s2.loli.net/2024/10/04/3YlChBPHxEKLRpg.jpg" alt="IMG_6214"></p><p><img src="https://s2.loli.net/2024/10/04/3YlChBPHxEKLRpg.jpg" alt></p><p><img src="https://s2.loli.net/2024/10/04/Nco48qrCLWjwGIm.jpg" alt="IMG_6216"></p><p>东京骑自行车的还真不少：</p><p><img src="https://s2.loli.net/2024/10/04/qirM6JDXU79x2hw.jpg" alt="IMG_20240220_190701"></p><p><img src="https://s2.loli.net/2024/10/04/ZfSOiUVFm1WYdkb.jpg" alt="IMG_20240220_190717"></p><p><img src="https://s2.loli.net/2024/10/04/WDGrbCKoV1SMqOU.jpg" alt="IMG_20240220_190748"></p><p>某个路牌上贴满了贴纸：</p><p><img src="https://s2.loli.net/2024/10/04/MISoA5VbnGwCE1N.jpg" alt="IMG_20240221_231723"></p><p>抓拍到消防车，但是被挡住了：</p><p><img src="https://s2.loli.net/2024/10/04/uh3tP4ZvwgFBUxs.jpg" alt="IMG_6219"></p><p>MODI Store：</p><p>Chiikawa在日本真是爆火：</p><p><img src="https://s2.loli.net/2024/10/04/jXx3qYN1CSVgezJ.jpg" alt="IMG_20240220_171355"></p><p><img src="https://s2.loli.net/2024/10/04/Fobkuny9saRBvN6.jpg" alt="IMG_20240220_171351"></p><p>当时以为是炸鸡皮店，吃了以后才发现其实是素鸡皮，甜甜的配上啤酒好吃，怪不得那么便宜～</p><p><img src="https://s2.loli.net/2024/10/04/zvkT2efW68HlXgE.png" alt="image-20241004193611112"></p><h2><span id="池袋">池袋</span></h2><p>池袋这里我拍摄了很多胶片，但是由于当天天气并不好，并且受到X光影响，损失了很多照片。抢救下来只剩下：</p><p>欠曝下只剩闪烁的广告牌：</p><p><img src="https://s2.loli.net/2024/10/04/sKdQ357btieFCME.png" alt="image-20241004193123193"></p><p><img src="https://s2.loli.net/2024/10/04/sIzTPH7QqO2lvia.png" alt="image-20241004193142825"></p><p><img src="https://s2.loli.net/2024/10/04/YsApyJu3M4QTK8k.png" alt="image-20241004193155598"></p><p><img src="https://s2.loli.net/2024/10/04/7hivCYl5BdokMV1.png" alt="image-20241004193206737"></p><p><img src="https://s2.loli.net/2024/10/04/KZY3RxD9ptfWUrQ.png" alt="image-20241004193219574"></p><p><img src="https://s2.loli.net/2024/10/04/oG9BcwCYdvJQUhb.png" alt="image-20241004193246146"></p><p><img src="https://s2.loli.net/2024/10/04/zN1PZBWcGQXsFph.png" alt="image-20241004193233077"></p><p>来池袋主要是为了买EVA周边，买了很多这里就不放图片了。</p><h2><span id="秋叶原">秋叶原</span></h2><p>秋叶原<strong>AKIBA</strong>，秋叶原最初以旧品店和家电量贩店为中心，之后电子游戏浪潮时大量游戏店来到此地，伴随而生的爱好店与动漫店陆续开业。近年因都市再开发，秋叶原站周围兴建许多复合大楼，访客年龄与客层呈现多样化。同时随着动漫的发展，秋叶原也成为了二次元爱好者的聚集地。</p><p><img src="https://s2.loli.net/2024/10/04/jkIpYAaVQmb3U6r.png" alt="image-20241004201037015"></p><p>秋叶原的广告牌，特殊的咖啡厅，这算是一种包容？</p><p><img src="https://s2.loli.net/2024/10/04/axEi78fkUDgPbR2.jpg" alt="IMG_20240218_150026"></p><p>原神入侵全世界：</p><p><img src="https://s2.loli.net/2024/10/04/9b7yrYuE85w6Pos.jpg" alt="IMG_20240218_163423"></p><p>可以看到马路这个时候是不走车的，变成了步行街</p><p><img src="https://s2.loli.net/2024/10/04/7wIzYQGxqJc98eE.jpg" alt="IMG_20240218_163353"></p><p>很多大商场都是免税的，也就是所有物品九折：</p><p><img src="https://s2.loli.net/2024/10/04/1NKCLVDkayA4g9O.jpg" alt="IMG_20240218_153853"></p><p>日本本国的商品价格优势非常大，但是电子产品尤其是台湾和大陆产出的，完全没有优势，都不如京东便宜，所以完全没必要买日行。这样的电子配件在国内不值钱，来日本翻了三倍。</p><p><img src="https://s2.loli.net/2024/10/04/nByxAegtOGwU8bZ.jpg" alt="IMG_20240218_142612"></p><p>![](<img src="https://s2.loli.net/2024/10/04/1aw35AgFLMqyJVs.jpg" alt="wx_camera_1708239123844"></p><p>找了些酒，价格都不错，可惜飞机带上去比较困难：</p><p><img src="https://s2.loli.net/2024/10/04/ALFsUoPNbe8KrC3.jpg" alt="IMG_20240218_151933"></p><p>在派对吃饭的时候，看到了个有趣的贴纸：</p><p><img src="https://s2.loli.net/2024/10/04/u6Ge7x4whkbDIXU.jpg" alt="IMG_20240218_181611"></p><p><img src="https://s2.loli.net/2024/10/04/EwaLFYrfeWx3lqA.jpg" alt="IMG_20240218_181614"></p><p>派对1个小时，终于吃上了饭，店里面竟然还有中文菜单，由于不让拍照，只能厨房非常井然有序，那种西餐的厨房一样，主厨安排一切，牛肉非常好吃，价格也不贵。一定要去，和牛盖饭：</p><p><img src="https://s2.loli.net/2024/10/04/e9Tgrmhbq3VHoGX.png" alt="image-20241004202944243"></p><p><img src="https://s2.loli.net/2024/10/04/g1y2dSmRDhz54tn.jpg" alt="IMG_20240218_190020"></p><p>大多数成人商店都是不允许拍照的，以下内容为18禁：</p><p><img src="https://s2.loli.net/2024/10/04/ZcUGY8zlLgeHCER.jpg" alt="IMG_20240218_140310"></p><p><img src="https://s2.loli.net/2024/10/04/64xqz5fmp2OIWdk.jpg" alt="IMG_20240218_171512"></p><p>电器街剪影：</p><p><img src="https://s2.loli.net/2024/10/04/Jy25w6pWL3fveaN.png" alt="image-20241004194150843"></p><p>日本的电车和地铁很相似，但是由于其轨道经常走上地面，把城市建筑都分割开来，所以和地铁区别还是很大的</p><p><img src="https://s2.loli.net/2024/10/04/w8JqpiahkyGNTjl.png" alt="image-20241004200332930"></p><p>秋叶原有很多商店都是在楼上的，每一栋楼上边都有很多不同的商店。</p><p><img src="https://s2.loli.net/2024/10/04/ft4mKQjp5rieqJI.png" alt="image-20241004200352296"></p><p><img src="https://s2.loli.net/2024/10/04/yQM8ASecRmGXzNk.png" alt="image-20241004200640182"></p><p><img src="https://s2.loli.net/2024/10/04/Z2AmNqcUa4Oi63j.png" alt="image-20241004200812913"></p><p><img src="https://s2.loli.net/2024/10/04/jbPOYvLVfyJg6ae.png" alt="image-20241004200702735"></p><p>在马路中间赶快拍了一张：</p><p><img src="https://s2.loli.net/2024/10/04/jbJ9K3gMFI5NXAv.png" alt="image-20241004200851005"></p><p>日本人很喜欢的招牌夸张hhh，世界曲目最多的ktv：</p><p><img src="https://s2.loli.net/2024/10/04/wucJjUX8WeRKDmd.png" alt="image-20241004200757599"></p><p>夜晚的车站：</p><p><img src="https://s2.loli.net/2024/10/04/UHed74OAiyw3k6z.png" alt="image-20241004200946249"></p>]]></content>
      
      
      <categories>
          
          <category> JAP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JaP Photo Album (Part One) -- Asakusa</title>
      <link href="/2025/03/12/JaP_Photo_Album(1)/"/>
      <url>/2025/03/12/JaP_Photo_Album(1)/</url>
      
        <content type="html"><![CDATA[<h1><span id="jap影集壹浅草">JaP影集（壹）–浅草</span></h1><p>不做任何评价，没有政治观点，屏蔽所有人物信息。</p><img src="https://s2.loli.net/2024/10/03/1wLtRXqNyoTaH2M.png" alt="image-20241003015854172" style="zoom:80%;"><p>[TOC]</p><h2><span id="东京">东京</span></h2><p>成田机场至东京市中心路上的广告，其实是个很魔性的视频我只拍了结尾：</p><img src="https://s2.loli.net/2024/10/02/hwA1o2YdsqcpxGj.jpg" alt="IMG_6151" style="zoom: 50%;"><p>和某国一样多的肛肠科广告，当然目的还是拍摄很多的太阳能板和日本帅哥：</p><img src="https://s2.loli.net/2024/10/03/t5FfVXugaC1TEne.jpg" alt="IMG_6154" style="zoom:80%;"><h3><span id="浅草寺周围及浅草寺">浅草寺周围及浅草寺</span></h3><p>浅草寺正大门：</p><p>雷门是公元942年为祈求天下太平和五谷丰登而建造的。几经火灾焚毁，后于1960年重建。雷门<a href="https://baike.baidu.com/item/%E6%AD%A3%E9%97%A8/8500116?fromModule=lemma_inlink">正门</a>入口处左右威风凛凛的风神和雷神二将，镇守着浅草寺。</p><img src="https://s2.loli.net/2024/10/03/iMDg6vj53AQFnKR.jpg" alt="IMG_6156" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/ZQGOdluv9KEARXj.jpg" alt="IMG_6157" style="zoom:80%;"><p>浅草寺西南角有一座五重塔，仅次于京都<a href="https://baike.baidu.com/item/%E4%B8%9C%E5%AF%BA/1865740?fromModule=lemma_inlink">东寺</a>的五重塔，为日本第二高佛塔，正午12点左右：</p><img src="https://s2.loli.net/2024/10/03/cKr1XMoAfql6ZYF.jpg" alt="IMG_6158" style="zoom:80%;"><p>由于我居住在浅草寺周围，所以有难得一见的夜景：</p><img src="https://s2.loli.net/2024/10/03/JOc2vbNEdlHnh9a.jpg" alt="IMG_20240217_204658" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/nKmWSAqkfjrI35o.jpg" alt="IMG_20240217_204701" style="zoom:80%;"><p>正门拍摄的人和正门的大灯笼：</p><img src="https://s2.loli.net/2024/10/03/xm2PLWDpyQAqs7o.jpg" alt="IMG_20240217_204834" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/1cRSbwU6mLjAdlH.jpg" alt="IMG_20240217_204804" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/HxvUW6ubA3dlB2Q.jpg" alt="IMG_20240217_205633" style="zoom:80%;"><p>五重塔正门：</p><img src="https://s2.loli.net/2024/10/03/3Ow5BinSpUdhgfF.jpg" alt="IMG_20240217_205044" style="zoom:80%;"><p>浅草寺售卖的御守，护身符：</p><img src="https://s2.loli.net/2024/10/03/VMRJZnHdbrItoy5.jpg" alt="IMG_20240219_121837" style="zoom:80%;"><p>浅草寺有名的出抽签，投入100就可以选一个：</p><img src="https://s2.loli.net/2024/10/03/x43KT8ogEvktJ7H.jpg" alt="IMG_20240222_123720" style="zoom: 80%;"><p>如果抽到不好的签需要邦上去，但是我抽了两次（五天路过又来了一次），都是吉：</p><img src="https://s2.loli.net/2024/10/03/7x6TCyAbK4BuV89.jpg" alt="IMG_20240222_124247" style="zoom:80%;"><p>浅草周围的商业圈和卖场夜晚：</p><img src="https://s2.loli.net/2024/10/03/nuziZBa9Wd8jICm.jpg" alt="IMG_20240218_224417" style="zoom:80%;"><p>需要说明的是，这里正好是地铁站，福州等也有很类似的商业街。</p><img src="https://s2.loli.net/2024/10/03/AfRxPXqnzOLt1KD.jpg" alt="IMG_20240218_224850" style="zoom:80%;"><p>浅草五丁目：</p><img src="https://s2.loli.net/2024/10/03/awKCQROzqVxSn3U.jpg" alt="IMG_6169" style="zoom:80%;"><p>浅草五丁目，一路向前就是浅草寺：</p><img src="https://s2.loli.net/2024/10/03/uaFxLvIG8s4jKTr.jpg" alt="IMG_6170" style="zoom:80%;"><p>路过的日共海报：</p><img src="https://s2.loli.net/2024/10/03/CAjgESHDUXBr169.jpg" alt="IMG_6168" style="zoom:80%;"><p>浅草寺后广场，可以看到晴空塔：</p><p>受拍摄设备限制，比较糊：</p><img src="https://s2.loli.net/2024/10/03/heHKdntbCyTf4k8.jpg" alt="IMG_20240219_204823" style="zoom:80%;"><p>我住在浅草寺后面的居民区，晚上有人在维修道路，可以看到一个圈有好几个维护人，不作评价：</p><img src="https://s2.loli.net/2024/10/03/wXIcJWmsdSHnRGE.jpg" alt="IMG_20240218_231242" style="zoom:80%;"><p>路过一个小学的课后教室：</p><img src="https://s2.loli.net/2024/10/03/c8TXPiryzHkbtIO.jpg" alt="IMG_20240219_210136" style="zoom:80%;"><p>使用胶片拍摄的，由于我是胶片新手，曝光没有控制好，就在这个教室旁边，有一个很日本的摇篮：</p><p>条纹是由于x光导致的，海关的X光。</p><img src="https://s2.loli.net/2024/10/03/1COhr2SPaGbzBVf.png" alt="image-20241003012607161" style="zoom:80%;"><p>过了几个路口，就到了我住的红灯区：没错你没听错，这里确实是有名的红灯区，夜晚都是来找送人的出租车，这里是红灯区和居民区的分界线：</p><img src="https://s2.loli.net/2024/10/03/gwnqDGPX7pYuc5x.jpg" alt="IMG_20240219_210524" style="zoom:80%;"><p>路过的红灯区：</p><img src="https://s2.loli.net/2024/10/03/l1KI7BCqFfEQMbh.jpg" alt="IMG_20240218_232514" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/5bxnGDwYPAltF3a.jpg" alt="IMG_20240222_112047" style="zoom:80%;"><p>很暴露的写真广告：</p><img src="https://s2.loli.net/2024/10/03/Zwep5SivbmTAECY.jpg" alt="IMG_20240220_220132" style="zoom:80%;"><p>迷路的时候看到的炸鸡店，最后没找到去吃：</p><img src="https://s2.loli.net/2024/10/03/3qVHR58gDUyQv1j.jpg" alt="IMG_20240220_213604" style="zoom:80%;"><p>迷路的时候路过的吉原神社，门口有一个洗手池子：</p><img src="https://s2.loli.net/2024/10/03/kuCvtG79b6DNgQY.jpg" alt="IMG_6164" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/LeGwhAW6U3uHMbv.jpg" alt="IMG_6165" style="zoom:80%;"><p>红灯区的牌坊，反黑帮证，很资本主义：</p><img src="https://s2.loli.net/2024/10/03/ERWYsKaNkwVnHLP.jpg" alt="IMG_6160" style="zoom:80%;"><p>浅草寺周围的拉面店里，这时我在日本吃的第一餐，使用富士的一次性胶片相机拍摄，屏蔽了人物信息。</p><p><img src="https://s2.loli.net/2024/10/03/c8FANdBHSYGjMRi.png" alt="image-20241003004626915"></p><p>第一顿饭永远是最香的：</p><p>浅草寺五丁目往前走，的一家酱油拉面店，非常好吃，第一次使用售票机购餐，由于在店里面不方便拍摄，只留下了最珍贵的两张，餐厅是那种开放式的，购买餐券之后交给厨师，英语交流也很ok毕竟是在景区周围：</p><img src="https://s2.loli.net/2024/10/03/a86mRTjiycQK5ve.jpg" alt="IMG_6161" style="zoom:80%;"><p>这家拉面店对面的另外一家拉面，拉面大多数都是猪骨熬汤，这家店比较特殊，当然价格也比较贵：</p><img src="https://s2.loli.net/2024/10/03/xJunIHf3ZoDvUdE.jpg" alt="IMG_6171" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/b4v5NEISTHVJFPc.jpg" alt="IMG_6172" style="zoom:80%;"><p>周围卖的小吃，玉团子，其实就是年糕外边裹了糖浆，很粘牙：</p><p><img src="https://s2.loli.net/2024/10/03/rSadwgDNj1fp53U.png" alt="image-20241003011339841"></p><p>吃旋转寿司：</p><img src="https://s2.loli.net/2024/10/03/x2vNWY3Gud7hcsz.jpg" alt="IMG_20240218_123432" style="zoom:80%;"><p><img src="https://s2.loli.net/2024/10/03/Kk5r8s2nMHDUgu3.png" alt="image-20241003021246348"></p><p>两个人吃的还不少：</p><img src="https://s2.loli.net/2024/10/03/x7l9JQr5TPFY4wt.jpg" alt="IMG_20240218_130359" style="zoom:80%;"><p>晚上在浅草寺周围商圈的居酒屋，喝啤酒，进去之后店员看我年龄很小，很奇怪hhh，点餐用的APP，这是唯一一个在日本见到可以用app点餐的。</p><img src="https://s2.loli.net/2024/10/03/eMw4pQybc5A6GLm.jpg" alt="IMG_20240219_200430" style="zoom:80%;"><p>啤酒很爽口，但烤肉很咸：</p><img src="https://s2.loli.net/2024/10/03/olLcGiVKDMYItnp.jpg" alt="IMG_20240219_201847" style="zoom:80%;"><p>路过一家卖烤饭的店，很有特色的是他们家把套餐的所有都做成模型来展示：</p><img src="https://s2.loli.net/2024/10/03/5Albry8ST1DezaO.jpg" alt="IMG_20240220_202357" style="zoom:80%;"><p>看起来很少，吃起来竟然是很饱。有一说一这个价格在这地段很不错了，米也比国内大部分店里面的更好吃。</p><p><img src="https://s2.loli.net/2024/10/03/HqEivJu7wkdnKbW.jpg" alt="IMG_20240220_203651"></p><p>第二天路过的时候又去吃了一次，不仅是好吃，店员有个很卡哇伊的。</p><img src="https://s2.loli.net/2024/10/03/DhL5lsZyYzJGErk.jpg" alt="IMG_20240221_113049" style="zoom:80%;"><p>浅草寺周围有一个唐吉克德，就是日本开的和比较多的超市大卖场：</p><p><img src="https://s2.loli.net/2024/10/03/NSa4EKxALZikyGq.png" alt="image-20241003013229300"></p><p>门口还有一个鳗鱼：</p><img src="https://s2.loli.net/2024/10/03/tykpIv3U7iXNquY.png" alt="image-20241003013117902" style="zoom:80%;"><p>售卖的各种烟，需要找店员才能看到实物：</p><img src="https://s2.loli.net/2024/10/03/TOitmdR9G1JFeUQ.jpg" style="zoom:80%;"><img src="https://s2.loli.net/2024/10/03/TOitmdR9G1JFeUQ.jpg" alt="IMG_20240219_204005" style="zoom:80%;"><p>店内的牛奶价格，只能说很便宜还好喝，我买了两种，看到好像是由于工艺不同，国内大部分是巴氏杀菌，日本好像是相反的冷处理。</p><p>看了下国内价格，进口进来基本都在三倍以上。</p><img src="https://s2.loli.net/2024/10/03/zXO9B2dviAVopqN.jpg" alt="IMG_20240218_225738" style="zoom:80%;">]]></content>
      
      
      <categories>
          
          <category> JAP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git(2)</title>
      <link href="/2024/10/22/Git__Base(2)/"/>
      <url>/2024/10/22/Git__Base(2)/</url>
      
        <content type="html"><![CDATA[<h1><span id="git分支管理2">Git——分支管理（2）</span></h1><img src="https://s2.loli.net/2024/10/22/zFJb9U6fiaprvdR.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1729527720427" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:50%;"><h2><span id="提示图床在国外且动图比较多的情况下需要时间加载">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2><h2><span id="目录">目录：</span></h2><!-- toc --><ul><li><a href="#git%E5%9F%BA%E7%A1%80">Git基础</a><ul><li><a href="#git%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8Ehead">Git的分支与HEAD</a><ul><li><a href="#git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6">Git的存储机制</a></li><li><a href="#git%E7%9A%84%E5%88%86%E6%94%AF%E6%8C%87%E9%92%88">Git的分支指针</a></li></ul></li><li><a href="#git%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">Git的远程仓库</a></li><li><a href="#git%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">Git的远程分支管理</a></li></ul></li><li><a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86">远程分支和本地仓库的冲突处理</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E6%83%85%E5%86%B5">查看当前分支情况</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="git基础">Git基础</span></h2><p>关于Git的基础请参考上一篇基础的教程，这里主要是关于Git的分支管理的内容，在讲解完成之后会以实战的形式让各位更好的理解如何使用Git这一个强大的工具。</p><h3><span id="git的分支与head">Git的分支与HEAD</span></h3><h4><span id="git的存储机制">Git的存储机制</span></h4><p>当你发起提交的时候，Git存储的是提交对象，其中包含了指向暂存区快照的指针。</p><p>Git在仓库区一般会这样保存对象：</p><pre class="mermaid">graph LRA("提交对象") --&gt; C("Tree对象") --&gt;B("Blob1对象")C--&gt;D("Blob2对象")</pre><ul><li><p>提交对象，一次提交包含着元数据以及指向项目根目录的树对象的指针，以便需要的时候重新创建这次快照。</p><img src="https://pic4.zhimg.com/80/v2-b8b7d634df1cf8a9d079c762fc2781b3_720w.webp" alt="image.png" style="zoom:80%;"></li><li><p>Blob 对象，只用于存储单个文件内容，一般都是二进制的数据文件，不包含任何其他文件信息，比如不包含文件名和其他元数据,可以同时有多个。</p></li><li><p>Tree 对象，对应文件系统的目录结构，里面主要有：子目录 (tree)，文件列表 (blob)，文件类型以及一些数据文件权限模型等。</p></li></ul><p>Git将文件的快照存储为对象，每个对象都有一个唯一的哈希值。当文件发生变化时，Git会计算新文件的哈希值，并将其作为新对象存储在对象数据库中。当Git检测到两个文件版本相似时，它会计算差异（即两个版本之间的不同之处），并将这些差异作为一个新的对象存储。这个差异对象会引用原始文件的哈希值，以便可以重构原始文件的内容。</p><h4><span id="git的分支指针">Git的分支指针</span></h4><p>Git的分支只不过是一个指向某次提交的轻量级的可以移动指针，Git默认的分支名是master,当你发起提交的时候就有了一个指向最后一次提交的master分支。每次提交时他都会自己向前移动。</p><p>举个例子：</p><pre class="mermaid">graph LRH("HEAD")  --&gt;GG("master") ==&gt; Commit_C    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C</pre><p>也就是说分支其实就是指针，指针指向某一次提交。其中比较特殊的是HEAD指针，是用来指向当前分支指针的指针，表示当前在master分支上。</p><h3><span id="git的远程仓库">Git的远程仓库</span></h3><p>远程分支是指远程仓库的分支指针，这些指针存在于本地且无法被移动，当你与服务器进行网络通信的时候，他会自动更新，也就是使用pull等命令的时候，远程分支有点像书签，会提示你上一次连接服务器时远程仓库中每个分支的位置。</p><pre class="mermaid">graph LRG("master") ==&gt; Commit_C    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C     H("remote") ==&gt; Commit_C</pre><p>remote指针同master指针一样，都是一个指针而已。</p><h3><span id="git的远程分支管理">Git的远程分支管理</span></h3><p>合并冲突</p><p>Fast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>main节点落后于服务器上的main（以后都称之为origin/main），<strong>此时执行Fast-forward操作就是把本地分支main合并到orgin/main之上</strong>，此时main指针会向前走一个，这样的操作就是Fast-forward。</p><p>合并之后结果如下：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_C    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>merge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_A --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。</p><pre class="mermaid">graph LR    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end         subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end         subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end                   subgraph merge_commit        direction TB        G("提交对象C") --&gt; H("文件对象C")     end          Commit_A --&gt; Commit_B     Commit_A --&gt; Commit_C     Commit_C --&gt; merge_commit     Commit_B --&gt; merge_commit     merge_commit --&gt; J("orgin/main")     merge_commit --&gt; I("main")</pre><p>Rebase操作指的是在上述情况之上直接将某个分支之上所有提交的更改在另一个分支上重现一遍。</p><p>为了Rebase需要先找到两个要整合的分支的共同祖先，然后取得当前所在分支的每次提交引入的变更，并把这些变更保存成文件，这之后将当前分支重置为要整合到的分支，然后在该分支上依次引入之前保存的每个更改。</p><p>在合并之前分支已成这个样子：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_A --&gt; Commit_C     H("orgin/main") ==&gt; Commit_C</pre><p>当我们想把远程分支的内容整合到main分支之上（就是将orgin/main rebase到 main）的话就会有如下情况，合并之后：</p><pre class="mermaid">graph LRG("main") ==&gt; Commit_B    direction LR    subgraph Commit_A        direction TB        A("提交对象A") --&gt; B("文件对象A")     end    subgraph Commit_B        direction TB        C("提交对象B") --&gt; D("文件对象B")     end     Commit_A --&gt; Commit_B    subgraph Commit_C+        direction TB        E("提交对象C") --&gt; F("文件对象C")     end     Commit_B --&gt; Commit_C+     H("orgin/main") ==&gt; Commit_C+</pre><p>可以看到这里实际上变化成了Fast-forward所处理的情况，再次执行Fast-forward（merge）即可完成操作。</p><h2><span id="远程分支和本地仓库的冲突处理">远程分支和本地仓库的冲突处理</span></h2><h3><span id="查看当前分支情况">查看当前分支情况</span></h3><p>查看当前分支信息：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch* main  test</code></pre><p>加上参数v可以显示当前每个分支的最新提交和其的提交信息，加上a则会包括当前的远程分支：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av* main                dd0258f [ahead 3] Merge branch 'test'  test                8eafb31 update git rm pycharm  remotes/origin/HEAD -&gt; origin/main  remotes/origin/main e5d18d7 del copy</code></pre><p><code>*</code>代表了HEAD指针所处位置，也就是当前所在的分支。 <code>update git rm pycharm</code>就是对应的提交信息。<code>e5d18d7</code>就是提交对象的散列值。</p><p>如果要查看已并入当前的分支的所有分支信息可以使用：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av --merged* main                dd0258f [ahead 3] Merge branch 'test'  test                8eafb31 update git rm pycharm  remotes/origin/HEAD -&gt; origin/main  remotes/origin/main e5d18d7 del copy</code></pre><p>相反的，显示没有并入分支的命令可以使用（注意这里和上文并不是一个仓库，你可以看到对应的路径不同）：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/Desktop/Essays$ git branch -av --no-merged  remotes/origin/HEAD -&gt; origin/main  remotes/origin/main e5d18d7 del copy</code></pre><p>但是以上的方式都不够明显展示分支的变化及历史，所以推荐还是使用如下命令：</p><pre><code class="language-bash">git log --graph --decorate --oneline --all</code></pre><p>如图展示了两个本地的仓库，其中二者的远程仓库是保持一致的，也就是说二者都有一样的远程信息，但是本地却差别很大，我们的工作就是尽量合并二者的内容并优化分支结构。</p><img src="https://s2.loli.net/2024/05/06/lrENoDWkt92Fd36.png" alt="image-20240506012058410" style="zoom:67%;"><p>在看到二者的分支图的时候我们就能看到：</p><p>图中的领先指的是领先远程仓库的意思。</p><img src="https://s2.loli.net/2024/05/06/zuK2aUAx384oBr6.png" alt="image-20240506012643030" style="zoom: 67%;"><p>简单来说我们的解决方案如下</p><p>首先rebase仓库A,将仓库A的main分支rebase到远程上然后push到服务器。</p><p>然后将远程新的内容pull到仓库B，再进行一次rebase然后将内容push到服务器。最终再pull，仓库A、仓库B、服务器三者就可以实现同步。</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/Desktop/Essays$ git rebase origin/mainSuccessfully rebased and updated refs/heads/main.</code></pre><p>reabase之后：</p><img src="https://s2.loli.net/2024/05/06/v1zQSXFucd45ROx.png" alt="image-20240506020430611" style="zoom:67%;"><p>由于仓库B还有部分内容没有提交，这里就再提交一次：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~/git_test/Essays$ git commit -a -m "finished git 1"[main e2fdc30] finished git 1 1 file changed, 61 insertions(+), 6 deletions(-)</code></pre><p>提交之后分支如下,本次提交并不影响合并方案，只是单纯多加了一次提交而已。</p><img src="https://s2.loli.net/2024/05/06/ixv7hQX3VoBcWlN.png" alt="image-20240506020817574" style="zoom:67%;"><pre><code class="language-bash">git pull --rebase# 等价于：git fetch origin/maingit rebase origin/main</code></pre><img src="https://s2.loli.net/2024/05/06/Dy1olHPMKZExYLT.png" alt="image-20240506023005761" style="zoom:67%;"><p>其中的分支变化如下：</p><img src="https://s2.loli.net/2024/05/06/6XujLS5UyvFc4pf.png" alt="image-20240506032249539"><p>关于rebase的变化的解释：</p><p>根据精通Git（第二版）的内容，其变基按照如下的方式：</p><ul><li>判断出分支上那些工作是本地独有的（245d、8ea、dd02、e2fdc）。</li><li>判断出哪些提交不是合并提交（245d、8ea、e2fdc）。</li><li>判断出哪些提交并没有被重写到基分支上（orgin/master）（245d、8ea、e2fdc）。</li><li>把筛选出来的分支重写到基分支上</li></ul><p>Git会将合并提交的更改拆分成多个单独的提交，并将它们重新应用在远程分支的顶部。这意味着原始的合并提交（在这个例子中是 <code>dd0258f</code>）不再存在于变基后的分支历史中。</p><p>245df5e提交和e5d18提交完全一致，并不是有效提交，所以被舍弃。</p><p><img src="https://s2.loli.net/2024/05/06/AXrHNwx89vnEa2I.png" alt="image-20240506025758663"></p><p>需要注意的是，没有手动推送上图中test分支，服务器上实际上是没有245df5e,8eafb31的信息的。</p><p>参考：精通Git（第二版）</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> branch </tag>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git(1)</title>
      <link href="/2024/10/22/Git__Base(1)/"/>
      <url>/2024/10/22/Git__Base(1)/</url>
      
        <content type="html"><![CDATA[<h1><span id="git关于git的一些补充1">Git——关于Git的一些补充（1）</span></h1><img src="https://s2.loli.net/2024/10/22/zrPTFChwRB1jf9g.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1729527526564" style="zoom: 50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h2><span id="提示图床在国外且动图比较多的情况下需要时间加载">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2><h2><span id="目录">目录：</span></h2><!-- toc --><ul><li><a href="#git%E5%9F%BA%E7%A1%80">Git基础</a><ul><li><a href="#git%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Git文件的生命周期</a></li><li><a href="#git%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86">Git文件的存储空间的划分</a></li><li><a href="#git%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">Git安装过程补充说明</a></li><li><a href="#git%E7%9A%84%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C">Git的撤销操作</a><ul><li><a href="#%E4%BF%AE%E6%AD%A3%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E6%8F%90%E4%BA%A4">修正上一次的提交</a></li><li><a href="#%E6%92%A4%E9%94%80%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6">撤销暂存区的文件</a></li></ul></li><li><a href="#git%E7%9A%84rm%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85">Git的rm命令补充</a></li><li><a href="#git%E7%9A%84diff%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85">Git的diff命令补充</a><ul><li><a href="#git-diff-%E8%A7%A3%E6%9E%90">Git diff 解析</a></li></ul></li></ul></li><li><a href="#git%E7%9A%84mv%E5%91%BD%E4%BB%A4">Git的mv命令</a></li><li><a href="#github-windows-version-install">Github Windows Version Install</a></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="git基础">Git基础</span></h2><p>基础内容请参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰Git教程</a>，这里只做一点概念的补充，来方便理解。</p><h3><span id="git文件的生命周期">Git文件的生命周期</span></h3><p>此部分补充上述教程中<strong>创建版本库</strong>的部分内容</p><p>Git所管理的文件可以处于以下五种状态：</p><p>未跟踪（untracked）、未修改（clean）、已修改（modified）、已暂存（staged）、已提交（committed）</p><pre class="mermaid">sequenceDiagramparticipant untrackedclean -&gt;&gt; untracked:(rm)clean  --&gt;&gt; modified:(edit data or code)untracked --&gt;&gt; staged:(add)modified --&gt;&gt; staged: (add)staged --&gt;&gt; +committed:(commit)committed -&gt;&gt;-clean: (committed)</pre><p>上图中（浏览器右侧有切换到浅色主题的按钮，使用之后看的更清楚），线上的命令代表了在各个状态变化中使用的命令名称，状态clean和其翻译并对不上，其原因是clean代表的是刚刚完成克隆或者刚刚提交完成之后的仓库状态，详细状态切换及使用的命令的参数可以参考廖雪峰的教程。其中committed部分指的是每次提交完成之后工作区的代码又返回了clean状态，即没有变化，更改的意思，并没有其对应的命令。</p><p>由此五种状态的转变可以引出——什么是<strong>仓库</strong>?</p><p>Git是如何在存储空间中划分的?</p><p>是如何将的代码在各个状态中进行保存的？</p><h3><span id="git文件的存储空间的划分">Git文件的存储空间的划分</span></h3><ul><li>**工作目录(Working Directory)：**工作目录实际上是项目中某一个版本的单次检出（check out）。这些文件是从Git目录下的压缩数据库内被提取出，放置在磁盘上以供使用和修改。也就是你能看到的项目内容。</li><li><strong>暂存区(Stage/Index)：暂存区是一个文件，一般位于Git目录中</strong>，保存了下次提交内容的相关信息。有时候也被称之为<strong>索引</strong>。</li><li><strong>Git目录(Repository)：</strong>：Git目录是保存项目元数据和对象数据库的地方。这是Git最重要的部分，也是其他计算机中克隆仓库时复制的内容。</li></ul><p>在你使用命令之后整个工作流程 上划分如下：</p><pre class="mermaid">sequenceDiagrambox rgb(30,144,255, .5) Working Directoryparticipant untrackedparticipant cleanparticipant modifiedendbox rgb(0,255,255, .5) Indexparticipant stagedendbox rgb(255,65,81,.8) Repositoryparticipant committedendclean -&gt;&gt; untracked:(rm)clean  --&gt;&gt; modified:(edit data or code)untracked --&gt;&gt; staged:(add)modified --&gt;&gt; staged: (add)staged --&gt;&gt; +committed:(commit)committed -&gt;&gt;-clean: (committed)</pre><p>蓝色部分是你的工作区域，也就是你修改的或者使用的代码皆是存在于此的,其中比较重要的是add和commit命令，使用这两个命令或者操作会将文件拉入Index区或者Repository区。受限于mermaid画图无法嵌套，实际上Index应是Repository区的一部分。</p><h3><span id="git安装过程补充说明">Git安装过程补充说明</span></h3><img src="https://s2.loli.net/2024/03/20/Az8EiRo5dcKFJyU.png" alt="git_pull" style="zoom: 80%;"><p>在安装过程中，git会让你选择pull操作的逻辑：</p><p>Fast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：</p><pre class="mermaid">sequenceDiagram  main --&gt;&gt; orgin/main : pull</pre><p>main节点落后于服务器上的main（以后都称之为origin/main），此时执行Fast-forward操作就是将当把服务器的远程分支合并到main之上，也就是执行merge操作，此时main指针会向前走一个，这样的操作就是Fast-forward。</p><p>merge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：</p><pre class="mermaid">graph LRFirst_commit--&gt;Second_commitFirst_commit --&gt; Remote_commitSecond_commit --&gt;merge_commitRemote_commit --&gt;merge_commit</pre><p>在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。</p><p>Rebase操作指的是在上述情况之上直接将Remote_commit修改，再合并到Second_commit之上：</p><pre class="mermaid">graph LRFirst_commit--&gt;Second_commitSecond_commit --&gt;Remote_commit_changed</pre><p>这里选择默认即可。当然git pull --rebase操作不仅仅能实现这种效果，更多内容请参考下一篇，关于分支管理的内容。</p><h3><span id="git的撤销操作">Git的撤销操作</span></h3><h4><span id="修正上一次的提交">修正上一次的提交</span></h4><p>撤销上一次的提交指的是上一次的提交会被这次新的提交所覆盖，假设你的commit信息在上次输入错误了，我们就可以使用：</p><pre><code class="language-bash">git commit --amend</code></pre><p>来再次进行提交，这次提交还是会打开输入信息框，修改后信息就会更新，且上一次提交就被覆盖了或者说应该是被修正了。</p><p>第一次提交：</p><img src="https://s2.loli.net/2024/05/04/aiWVk9C2Pxw6l7N.png" alt="image-20240504170607739" style="zoom: 80%;"><p>第二次提交：</p><img src="https://s2.loli.net/2024/05/04/C2itf4nJyqeI58h.png" alt="image-20240504170440919" style="zoom:80%;"><h4><span id="撤销暂存区的文件">撤销暂存区的文件</span></h4><p>如果你不小心提交了不该提交的内容到index区，我们可以使用：</p><pre><code class="language-bash">git reset HEAD filename</code></pre><p>来将其从暂存区中删除，记得不要使用rm，rm同时也会把其从工作区一起删除，这是二者的区别。</p><h3><span id="git的rm命令补充">Git的rm命令补充</span></h3><p>要从版本管理系统中移除某一个文件，你需要把它先从已跟踪文件列表里面删除，然后再提交修改才可以，这里就要使用rm命令来实现，如果没有使用git rm，而是简单的直接从文件列表删除，就会产生如下后果：</p><p>我们将copy结尾的文件删除，其已经被修改后提交：</p><img src="https://s2.loli.net/2024/05/04/qAQYlBJtoOypmdi.png" alt="image-20240504161643586" style="zoom: 80%;"><p>我们将其手动删除，查看git的状态。</p><p><img src="https://s2.loli.net/2024/05/04/wcDiKaIsxWnbSTq.png" alt="image-20240504162813549"></p><p>这里就会提示你有一个删除操作没有提交到暂存区，你需要手动使用</p><pre><code class="language-bash">git add .</code></pre><p>来将删除操作暂存，并用commit命令提交到committed区。</p><p><img src="https://s2.loli.net/2024/05/04/CiKJpLdIoen9gDO.png" alt="image-20240504163209617"></p><p>这样的操作略显麻烦，不过问题不大，我们可以直接使用rm命令来进行操作。<strong>rm命令会将文件从暂存区和工作区直接删除</strong>，这样提交的时候就不会有未跟踪的文件提示了。</p><p><img src="https://s2.loli.net/2024/05/04/vlLWsxwRzoQd31B.png" alt="image-20240504163329446"></p><h3><span id="git的diff命令补充">Git的diff命令补充</span></h3><p>在安装完成之后，我们使用git bash 来查看 diff，在diff查看之前我们应该有一个已经committed的版本，方便我们来查看不同之处，这里使用的就是本篇文章的存储库来查看，</p><p>写到这里，我们使用命令：</p><pre><code class="language-bash">git diff</code></pre><p>效果如下：</p><img src="https://s2.loli.net/2024/05/04/Cda3xO4zrnKjIMQ.png" alt="image-20240504065415466" style="zoom:67%;"><p>上图红红绿绿的部分，就是代表了修改的内容，这个表格是用来查看你相对于索引（index）（下次提交的暂存区域）所做的修改。 换句话说，这些差异是你_可以告诉 Git 进一步添加到索引中，但你仍然没有。，我们从头开始，解析这一段代表的是什么意思。</p><h4><span id="git-diff-解析">Git diff 解析</span></h4><p>git所使用的diff是1990年，GNU diff率先推出了"合并格式"的diff，将需要比较文件的上下文合并在一起显示的一种diff格式、不同的diff格式不同，目前比较多的是GNU diff格式，git在此基础上添加了一些信息，用来显示一些内容。</p><p>第一部分实际上是文件的基本信息，用来显示git的对象：</p><p>一般格式如下：</p><pre><code class="language-bash">　　diff --git a/f1 b/f1</code></pre><p>进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。</p><p>由于我的文件包含中文，所以中文被解析成了对应的字符，仔细看实际上是能发现对应的内容的：</p><p><img src="https://s2.loli.net/2024/05/04/h21MAUDnIKNGZci.png" alt="image-20240504071327934"></p><p>然后一行显示的是两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）</p><pre><code class="language-bash">index a7a1862..fcf1525 100644</code></pre><p>第三行表示进行比较的两个文件。</p><p><img src="https://s2.loli.net/2024/05/04/rx3Rhn2KuSql5sJ.png" alt="image-20240504071546670"></p><p>"—“表示变动前的版本，”+++"表示变动后的版本。</p><p>第二部分，变动的位置用两个@作为起首和结束。</p><pre><code class="language-bash">@@ -33,14 +33,18 @@</code></pre><p><code>-33</code>中<code>-</code>代表第一个文件也就是上一个版本的文件，33代表第33行，<code>14</code>代表连续14行，合在一起意思就是从33行起连续14行，同样的，<code>+</code>代表变动后的文件，从33行开始一直到18行。</p><p>第三部分，就是具体的修改内容了：</p><p><img src="https://s2.loli.net/2024/05/04/NDy3dtEzwSjgGiC.png" alt="image-20240504160151147"></p><p>文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。图片中的<code>+- --</code> 均为文档自身包含一个-号，与git无关。</p><p>参考：<a href="https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">读懂diff - 阮一峰的网络日志 (ruanyifeng.com)</a></p><h2><span id="git的mv命令">Git的mv命令</span></h2><p>git并不会显式的跟踪文件的移动，如果你在文件管理系统中，直接重名了文件，git并不能发觉，会将其认为是一个新的文件，如此这般我们就需要将文件重新加入到跟踪队列，实际上我们可以说使用git mv命令来实现更快捷的操作：</p><p>如图我们直接修改文件夹中的README.md文件为README，此时git会发觉到：</p><p><img src="https://s2.loli.net/2024/05/05/8WlI4OXQTgKF6zB.png" alt="image-20240505201754780"></p><p>不过问题不大我们可以直接用mv来修改，这样git就会自动将其加入到追踪文件中：</p><pre><code class="language-bash">git mv README.md README</code></pre><p>此时可以看到对应的文件被变成了这个样子：</p><p><img src="https://s2.loli.net/2024/05/05/XiM13yEHIQYtPhj.png" alt="image-20240505201925068"></p><p>我们直接提交修改即可。需要注意的是，这一个操作相当于将其改名之后，并将其提交到stage区域，如果你想改回来，就需要将暂存区的内容清空使用上文的reset命令，最后再手动将名字修改回来。</p><h2><span id="github-windows-version-install">Github Windows Version Install</span></h2><p>很多人上来就要安装Git for windows项目，我是不推荐的，Github针对Git开发了更方便的Github Desktop软件，主要包含GUI和操作，同时也针对了PowerShell做了兼容，这一点非常好。便于跨平台的使用。(这是比较老的说法了，实际上他们放弃了维护CLI部分，专注使用GUI部分，详见：<a href="https://stackoverflow.com/questions/34565238/where-does-github-desktop-install-command-line-version-of-git">Where does Github desktop install command line version of Git - Stack Overflow</a>)，但对新手来说GUI更适合一点，虽然无法使用全部的Git命令，但GUI已经足够了。</p><p>下载地址如下：<a href="https://desktop.github.com/">GitHub Desktop | Simple collaboration from your desktop</a></p><p>下载后注册账号登陆即可：</p><img src="https://s2.loli.net/2024/03/19/KMDWurV9LT4BEks.png" alt="image-20240319230316232" style="zoom:67%;"><p>设置本地Git信息也是易如反掌，我的建议是对于工具类不需要太过深入了解，但是要有求知的心，建议看完Git for Windows项目的教程之后再来看这个会更加理解，本人入门的时候也是用的Git for Windows来进行配置的，整个过程受益颇多。</p><img src="https://s2.loli.net/2024/03/19/dP9IvSoFAfQ6gLR.png" alt="image-20240319231027438" style="zoom:67%;"><p>我们可以简单过一遍教程：</p><img src="https://s2.loli.net/2024/03/19/X7RhIFyA136Gv95.png" alt="image-20240319231115582" style="zoom:67%;"><p>这里省略了几个验证的细节，只需要点点就可以了，来到正式的界面：</p><img src="https://s2.loli.net/2024/03/19/eCDZ7wXPvxYk5RL.png" alt="image-20240319231404949" style="zoom:67%;"><p>右侧写了教程的步骤，这里要我们创建一个新的分支，分支的含义在这里已经详细阐述了，简单来说就是可以允许不同版本的代码同时在相同仓库下进行开发。点击创建新的分支之后：</p><img src="https://s2.loli.net/2024/03/19/62jQlzivfNc5npk.png" alt="image-20240319231619311" style="zoom:67%;"><img src="https://s2.loli.net/2024/03/19/g3HRmj8wDQfIlAi.png" alt="image-20240319231712553" style="zoom: 80%;"><p>会使用系统默认的编辑器打开对应文本文件：</p><img src="https://s2.loli.net/2024/03/19/d6F8ScXOKLpyTIP.png" alt="image-20240319231807726" style="zoom:67%;"><p>在下方添加以下总结信息，这对参与项目者十分重要，来标识你干了什么。</p><img src="https://s2.loli.net/2024/03/19/AeWmqkO4jX2CQrs.png" alt="image-20240319231917272" style="zoom:67%;"><p>最后将分支推送到Github之上：</p><img src="https://s2.loli.net/2024/03/19/CbuW9apGqoK5VHj.png" alt="image-20240319232010779" style="zoom:67%;"><p>pull request，是将你修改好的代码推送到审核人员那里，在审核人员将你实现的功能合并到主分支或者某一个分支之上。</p><img src="https://s2.loli.net/2024/03/19/NQGVcslxkqAomgY.png" alt="image-20240319232103905" style="zoom:67%;"><p>跳转到网页进行申请处理</p><img src="https://s2.loli.net/2024/03/19/GfbUMrgaVCxk5O2.png" alt="image-20240319232223793" style="zoom: 80%;"><p>审核人员审核之后也就是分支合并之后，可以选择删除你的开发分支，删除之后GIt上就剩下了一个分支。</p><img src="https://s2.loli.net/2024/03/19/6xujJ7V1TZhek8P.png" alt="image-20240319232351124" style="zoom: 80%;">]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> branch </tag>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（第一个Android项目）</title>
      <link href="/2024/10/22/Android/"/>
      <url>/2024/10/22/Android/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门第一个android项目">Android开发笔记——快速入门（第一个Android项目）</span></h1><img src="https://s2.loli.net/2024/09/29/MrYRTUN64jDSZ5c.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727615445573" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><p>[TOC]</p><!-- toc --><ul><li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAandroid%E9%A1%B9%E7%9B%AE">第一个Android项目</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAandroid%E6%A8%A1%E6%8B%9F%E5%99%A8">创建一个Android模拟器</a></li><li><a href="#%E9%A1%B9%E7%9B%AE%E5%86%85%E5%AE%B9%E5%88%86%E6%9E%90">项目内容分析</a></li><li><a href="#androidmainifestxml%E7%9A%84%E5%88%86%E6%9E%90">AndroidMainifest.xml的分析</a></li><li><a href="#buildgradle%E7%9A%84%E5%88%86%E6%9E%90">build.gradle的分析</a><ul><li><a href="#buildgradle%E7%9A%84%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE">build.gradle的模块配置</a></li></ul></li></ul><!-- tocstop --><h2><span id="第一个android项目">第一个Android项目</span></h2><p>首先你需要安装<strong>Android Studio</strong>来进行开发，详细安装过程可以参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123426867">Android开发笔记——快速入门（壹)</a></p><p>根据教程创建一个基于<strong>Kotlin</strong>的项目：</p><p>选择新建一个项目以后，选择<strong>Empty Activity</strong>，点击next。</p><p><img src="https://s2.loli.net/2024/09/29/o35u4nGSqmU6cgl.png" alt="13"></p><p>接下来配置项目一些属性，</p><p><strong>Name</strong>代表了项目的名称；</p><p><strong>Package name</strong>表示项目的包名，在<strong>Android</strong>中项目的包名可以用来区分不同的应用程序这个一定要保持唯一性，通常会根据<strong>Name</strong>来自动设定；</p><p><strong>Save Location</strong>表示代码存放的位置，看个人喜好设定；</p><p><strong>Language</strong>选择<strong>Kotlin</strong>；</p><p>**Minimum SDK：**SDK最小支持的 JAVA API level等级；</p><p>最下边的选项是<strong>Android support library</strong>是否支持，目前谷歌已经几乎淘汰了<strong>Android support library</strong></p><p>，替换成了<strong>Android X</strong>。详细了解可以看：<a href="https://blog.csdn.net/guolin_blog/article/details/97142065">Android X</a>。</p><p><img src="https://s2.loli.net/2024/09/29/nJ3FsBmuyVHqSi7.png" alt="2"></p><p>点击Finish后项目会进行预加载会进行一段时间。</p><h2><span id="创建一个android模拟器">创建一个Android模拟器</span></h2><p>在环境搭建部分已经安装了模拟器这里直接运行一个就ok，</p><p><img src="https://s2.loli.net/2024/09/29/WEuiCwO3aStKB9L.png" alt="3"></p><p><img src="https://s2.loli.net/2024/09/29/y4iVG7sbzC6RqwX.png" alt="4"></p><p><img src="https://s2.loli.net/2024/09/29/vgykp8BzCdW9wNs.png" alt="5"></p><h2><span id="项目内容分析">项目内容分析</span></h2><p><img src="https://s2.loli.net/2024/09/29/nSVXrWzBxKtbNaQ.png" alt="6"></p><p>在一般情况下，默认创建的<strong>Android</strong>项目并不是磁盘上的结构，这是因为AS替我们隐藏了一些不必要的信息，但是为了详细了解还是打开<strong>Project模式</strong>看一看：</p><p><img src="https://s2.loli.net/2024/09/29/YCda9rR82G75yJx.png" alt="7"></p><p><strong>.idea</strong>和.<strong>gradled</strong> 是由<strong>AS</strong>所自动产生的gradle配置工具和idea所需要的配置信息，这里不需要深入了解。</p><p><strong>app</strong>就是我们开发所最关心的目录，打开可以看到：</p><p><img src="https://s2.loli.net/2024/09/29/LeTp1IWEGAnmgKk.png" alt="8"></p><ul><li>里面分别还有一个<strong>build文件夹</strong>，这个是存放编译app代码后的地方；</li><li>当你需要使用外部的<strong>Jar</strong>包的时候将外部的<strong>jar</strong>包放入<strong>libs文件夹</strong>，就可以在编译的时候实现自动引用；</li><li><strong>src文件夹</strong>就是存放的我们需要写的代码了；</li><li>在<strong>src</strong>文件夹的<strong>res</strong>目录下存放着整个项目需要的所有资源，包括图片、布局、字符等，后边使用会详细讲；</li><li>在<strong>src文件夹</strong>的<strong>java</strong>目录下存放着整个项目的代码；</li><li>在<strong>src文件夹</strong>的<strong>AndroidMainifest.xml</strong>,这个是整个Android项目的配置文件，需要使用的组件都需要在这里注册，并给应用程序添加权限声明。</li></ul><p>回到主目录</p><p><strong>gradle文件夹</strong>包含了gradle wrapper，gradle wrapper是针对gradle的一种配置工具，<a href="https://blog.csdn.net/sinat_31311947/article/details/81084689">具体可以看这里</a>；</p><p><strong>build.gradle</strong>是全局的gradle构建脚本，稍后会详细分析；</p><p><strong>gradle.properties</strong>是针对gradle构建的全局配置文件，包含了需要配置的构建属性，更改这个会影响全局gradle构建脚本 <a href="https://blog.csdn.net/u013553529/article/details/55011602">具体可以参考这里；</a></p><p><strong>gradle.bat</strong>是在Windos环境下使用的命令行；</p><p><strong>settings.gradle</strong>这个文件指定的是项目所有引用的模块，一般只有app模块，通常情况下是自动完成引用的；</p><h2><span id="androidmainifestxml的分析">AndroidMainifest.xml的分析</span></h2><p><img src="https://s2.loli.net/2024/09/29/z3uvANDVnyU8Zr7.png" alt="9"></p><p>这个xml看起来一大堆的，看起来很麻烦，这波就来一个庖丁解牛分析：</p><p>先回忆一下，<strong>AndroidMainifest</strong>是整个安卓项目的配置文件，所以里面的内容一定是和项目的各个属性相关的，最外层的标签你可以猜到是用来表示这个应用的最外层，标签以内都是这个应用的属性，大眼一扫你可以看到一个很熟悉的关键字<strong>activity</strong>，这段代码实际上是为应用注册了一个名字为<strong>MainActivity</strong>的组件，在<strong>activity</strong>标签里面还有一个<strong>intent-filter</strong>标签是过滤器标签节点，通过<strong>Action</strong>属性和<strong>category</strong>分别实现了把<strong>Activity</strong>设为主<strong>Activity</strong>和启动<strong>Activity</strong>。，在手机上点击图标首先启动的就是这个<strong>Activity</strong>。</p><p>看回到外层，可以看到许多这样的形式：<code>android:icon="@mipmap/ic_launcher</code>，这些是干什么的呢？在这里就要回想一个东西：<strong>res文件夹</strong>，通过英文名称你也能猜到这表示的是某个图标，而后面的就是图标存放的位置，事实的确如此，打开res文件夹可以看到有着相同路径的内容，这里的@语法就是引用的意思：</p><p><img src="https://s2.loli.net/2024/09/29/6M21mqdNGWDh3Yz.png" alt="10"></p><p>看到图片你会想到一个问题，为什么有这么多Mipmap开头的文件夹？其实后缀是针对不同的分辨率，现在主流的分辨率还是xxhdpi，你如果有合适的图标就可放进去。</p><h2><span id="buildgradle的分析">build.gradle的分析</span></h2><p>gradle是一种新型构建工具，不同于传统的XML，使用基于Groovy的领域特定语言（目前还不太懂，挖个坑）。</p><p>其实在app目录下和项目根目录下都有一个build.gradle脚本，我们先来看看最外层的脚本：</p><pre><code class="language-groovy">// Top-level build file where you can add configuration options common to all sub-projects/modules.plugins {    id 'com.android.application' version '7.1.2' apply false    id 'com.android.library' version '7.1.2' apply false    id 'org.jetbrains.kotlin.android' version '1.5.30' apply false}task clean(type: Delete) {    delete rootProject.buildDir}</code></pre><p>和老版小雪狐的不太相同的是小蜜蜂版本出现了许多位置变化，可以参考：<a href="https://blog.csdn.net/sinat_38167329/article/details/123175556">Gradle新版变化</a>。</p><p>参考以上链接：</p><p>工程的build.gradle的<strong>dependencies</strong>修改为plugins，替代了引用原来的Gradle版本。</p><pre><code class="language-groovy">plugins {    id 'com.android.application' version '7.1.2' apply false    id 'com.android.library' version '7.1.2' apply false    id 'org.jetbrains.kotlin.android' version '1.5.30' apply false}</code></pre><p>功能位置迁移，原来在工程build.gradle的<strong>buildscript</strong>和<strong>allprojects</strong>移动至<strong>setting.gradle</strong>并改名为<strong>pluginManagement</strong> 和<strong>dependencyResolutionManagement</strong>。里面的东西依旧可以按照原来的copy过来。</p><pre><code class="language-groovy">pluginManagement {    repositories     {        gradlePluginPortal()        google()        mavenCentral()    }}dependencyResolutionManagement {    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)    repositories    {        google()        mavenCentral()    }}rootProject.name = "My Application"include ':app'</code></pre><p>两个repositories分别中的的   <code>google(）  mavenCentral()</code>分别对应了两个官方仓库，通过这两个配置可以在项目中引用这两个仓库中的所有依赖。</p><h3><span id="buildgradle的模块配置">build.gradle的模块配置</span></h3><pre><code class="language-groovy">plugins {    id 'com.android.application'    id 'org.jetbrains.kotlin.android'}android {    compileSdk 32// 编译时用的SDK版本    defaultConfig {        applicationId "com.example.myapplication"//应用标识名称，这里默认使用应用名字，系统根据这个区分不同应用，应用的唯一标识        minSdk 21//最小SDK兼容版本        targetSdk 32//测试使用的sdk版本        versionCode 1//代码的版本        versionName "1.0"        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"    }    buildTypes {        release {            minifyEnabled false//是否对代码进行混淆            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'//混淆规则        }    }    compileOptions {        sourceCompatibility JavaVersion.VERSION_1_8//编译兼容java版本        targetCompatibility JavaVersion.VERSION_1_8    }    kotlinOptions {        jvmTarget = '1.8'//kotlin运行的目标jvm版本    }    buildFeatures {        viewBinding true    }}dependencies {    implementation 'androidx.core:core-ktx:1.7.0'    implementation 'androidx.appcompat:appcompat:1.3.0'    implementation 'com.google.android.material:material:1.4.0'    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'    implementation 'androidx.navigation:navigation-fragment-ktx:2.3.5'    implementation 'androidx.navigation:navigation-ui-ktx:2.3.5'    testImplementation 'junit:junit:4.13.2'    androidTestImplementation 'androidx.test.ext:junit:1.1.3'    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'}</code></pre><p>接下来就需要一点点分析了，开头还是针对插件的引用，<code>'com.android.application'</code>代表这是一个应哟个程序模块，有时你可以建立一个<code>'com.android.library'</code>表示是库模块。而这最大区别在于，库模块依附于其他应用程序，而应用程序可以独立于运行。具体内容要了解可以看一下注释。</p><p>dependecies闭包是需要详细说一下的，</p><p>如需向项目添加依赖项，请在 <code>build.gradle</code> 文件的 <code>dependencies</code> 代码块中指定依赖项配置，如 <code>implementation</code>。</p><p>例如，应用模块的以下 <code>build.gradle</code> 文件包含三种不同类型的依赖项：</p><ul><li><strong>本地库模块依赖项</strong></li></ul><pre><code class="language-groovy">implementation project(':mylibrary')</code></pre><p>这声明了对一个名为“mylibrary”（此名称必须与在您的 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html"><code>settings.gradle</code></a> 文件中使用 <code>include:</code> 定义的库名称相符）的 <a href="https://developer.android.google.cn/studio/projects/android-library">Android 库模块</a>的依赖关系。在构建您的应用时，构建系统会编译该库模块，并将生成的编译内容打包到 APK 中。目前还没有用到用到时具体再说。</p><ul><li><strong>本地二进制文件依赖项</strong></li></ul><pre><code class="language-groovy">implementation fileTree(dir: 'libs', include: ['*.jar'])</code></pre><p>Gradle 声明了对项目的 <code>module_name/libs/</code> 目录中 JAR 文件的依赖关系（因为 Gradle 会读取 <code>build.gradle</code> 文件的相对路径）。</p><ul><li><strong>远程二进制文件依赖项</strong></li></ul><pre><code class="language-groovy">implementation 'com.example.android:app-magic:12.3'</code></pre><p>这声明了对“com.example.android”命名空间组内的 12.3 版“app-magic”库的依赖关系。</p><p>gradle在构建的时候会检查一下本低是否有这个库的缓存，如果没有会自动联网下载，在添加到目录中</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（Kotlin与lambda）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E4%B8%8E%20lamda)/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E4%B8%8E%20lamda)/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin与lambda">Android开发笔记——快速入门（Kotlin与lambda）</span></h1><img src="https://s2.loli.net/2024/09/29/Y1eySEM3hX46p8C.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727617420599" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E4%B8%8Elambda">Kotlin与lambda</a><ul><li><a href="#kotlin%E7%9A%84%E9%9B%86%E5%90%88">Kotlin的集合</a><ul><li><a href="#kotlin%E7%9A%84list">kotlin的list</a></li><li><a href="#kotlin%E5%8F%AF%E5%8F%98%E7%9A%84list">kotlin可变的list</a><ul><li><a href="#kotlin%E7%9A%84arraylist">kotlin的ArrayList</a></li></ul></li><li><a href="#kotlin%E7%9A%84set">kotlin的set</a></li><li><a href="#kotlin%E7%9A%84map">kotlin的map</a></li></ul></li><li><a href="#kotlin%E7%9A%84lambda">kotlin的lambda</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BC%A0%E9%80%92lambda%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">什么时候需要传递lambda作为参数？</a></li><li><a href="#kotlin%E7%9A%84%E9%97%AD%E5%8C%85">kotlin的闭包</a><ul><li><a href="#kotlin%E5%87%BD%E6%95%B0%E5%BC%8Fapi">kotlin函数式API</a></li><li><a href="#kotlin%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">kotlin的函数式接口</a></li><li><a href="#java%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">Java的函数式接口作为参数</a></li><li><a href="#kotlin%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">kotlin的语法糖</a></li><li><a href="#java%E5%87%BD%E6%95%B0%E5%BC%8Fapi%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">Java函数式API的语法糖</a></li></ul></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin与lambda">Kotlin与lambda</span></h2><h3><span id="kotlin的集合">Kotlin的集合</span></h3><p>在介绍lambda表达式之前先介绍一下kotlin中的集合类，传统意义上的集合主要是list和set还有map。下面来一一介绍一下kotlin中这些内容如何使用。</p><h4><span id="kotlin的list">kotlin的list</span></h4><p><strong>list的主要实现类是ArrayList与LinkedList</strong>，这里主要是介绍<strong>List</strong>而不是它的具体实现类</p><p>List的特性很简单：</p><ul><li>允许出现重复的元素。</li><li>元素有序，存入和取出的顺序一致。</li><li>元素以一种线性的方式存储，在程序中可以通过索引来访问集合中的主要元素。</li></ul><p>使用传统的list像java一样通过函数一个一个初始化添加在kotlin中也是可以的：</p><pre><code class="language-kotlin">val list_test = ArrayList&lt;String&gt;()list_test.add("apple")list_test.add("pear")</code></pre><p>不过kotlin提供了更加方便的方法,我们使用<code>listof</code>来实现更加方便快捷:</p><pre><code class="language-kotlin">val list_kotlin = listOf&lt;String&gt;("apple","pear")for (list in list_kotlin)println(list)</code></pre><p>你可以注意到这里声明的list使用的是val关键字而不是var说明他是一个不可变的量，除了初始化添加的内容不允许再添加其他内容。</p><p>输出结果如下</p><pre><code class="language-shell">applepear</code></pre><h4><span id="kotlin可变的list">kotlin可变的list</span></h4><p>kotlin中使用可修改的list也很简单，更换关键字为<code>mutableListOf</code>即可：</p><pre><code class="language-kotlin">var list_var = mutableListOf("apple","pear")list_var.add("no fruits")println(list_var[0])println(list_var[2])</code></pre><p>可以看到调用了add来进行添加。</p><p>输出结果：</p><pre><code class="language-kotlin">appleno fruits</code></pre><h5><span id="kotlin的arraylist">kotlin的ArrayList</span></h5><p>List与ArrayList的不同点：</p><p>List实际上是接口并不是一个普通的类</p><p>ArrayList继承了几乎全部的<strong>MutableList</strong>的方法，除了继承的方法ArrayList类内部还实现了两个独特的方法：</p><pre><code class="language-kotlin">fun trimToSize()fun ensureCapacity(minCapacity: Int)</code></pre><p>分别是可以扩容和缩小占用内存，具体可以见：<a href="https://blog.csdn.net/gzheclipse/article/details/105956271">ArrayList的trimToSize</a>。</p><p>但是！你如果使用<strong>mutableListOf</strong>来实现一个可变的列表，它实际上返回的就是<strong>ArrayList！</strong></p><p>不信可以看源码：</p><pre><code class="language-kotlin">/** * Returns a new [MutableList] with the given elements. * @sample samples.collections.Collections.Lists.mutableList */public fun &lt;T&gt; mutableListOf(vararg elements: T): MutableList&lt;T&gt; =    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))</code></pre><p>ArrayList是List接口的一个实现类，它是程序中最常见的一种集合。</p><pre><code class="language-kotlin">val list_kotlin = arrayListOf("apple","pear")for (list in list_kotlin)    println(list)</code></pre><p>它的使用和list基本一致，当然效率相较于list可能会有些下降，因为ArrayList集合在增加或删除指定位置的数据时，会创建新的数组导致效率变低。</p><h4><span id="kotlin的set">kotlin的set</span></h4><p>set类与list的不同在于底层，set不允许集合内存在相同的内容，set的集合底层使用的是hash映射机制来存放数据的，因此集合的元素保证了内容的不重复，但同时也失去了顺序。</p><p>set的演示：</p><pre><code class="language-kotlin">//set 演示val set_kotlin = setOf("apple","pear","apple")for (set in set_kotlin)    println(set)</code></pre><p>可变set演示：</p><pre><code class="language-kotlin">var set_var = mutableSetOf("1","2","3","4")for (set in set_var)    println(set)</code></pre><h4><span id="kotlin的map">kotlin的map</span></h4><p>map类就不再多说，实际上就是通过键值和内容实现的映射集合，值得注意的是他的迭代方式有所不同：</p><pre><code class="language-kotlin">val map_test = HashMap&lt;String,Int&gt;()map_test["apple"] = 1map_test["banana"] = 2for ((fruit ,number) in map_test)    println("fruit is $fruit number is $number")</code></pre><p>前面介绍过for循环转变为了迭代器，这里就充分发挥了其迭代器的特性，可以同时迭代map中的内容和键值。可以看到输出结果：</p><pre><code class="language-kotlin">fruit is banana number is 2fruit is apple number is 1</code></pre><p>当然kotlin也提供了简洁的写法通过<code>to</code>来实现，键值与内容的映射，但to在这里并不是关键字而实更复杂的内容，我们到后边再说：</p><pre><code class="language-kotlin">val map_kotlin = mapOf("apple" to 1,"banana" to 2)for ((fruit ,number) in map_kotlin)    println("fruit is $fruit number is $number")</code></pre><p>输出结果：</p><pre><code class="language-kotlin">fruit is apple number is 1fruit is banana number is 2</code></pre><p>可以看到两次输出结果并不一致，这里先挖一个坑，当然你也注意到set并不能直接用【】类似于数组下标的方式访问，这些等以后再详细说明。</p><h3><span id="kotlin的lambda">kotlin的lambda</span></h3><p>集合的函数式API作为lambda表达式的演示再好不过了。</p><p>首先我们来说一说什么是lambda。</p><p><strong>Lambda就是一小段可以作为参数传递的代码</strong>，这就很厉害，因为常规情况下我们作为参数传递的都是变量，而参数转变为lambda表达式的时候就可以传递进去一段带有逻辑处理的代码。</p><p>对于一小段这个量词的定义并不明确，通产来说在能保持可读性的前提下可以尽量的短或长。</p><p>lambda的常规语法：</p><pre><code>{参数名1 ：参数类型，参数名2，参数类型 -&gt; 函数体（代码块）}</code></pre><p>首先最外层是一个大括号，如果有参数需要向lambda传递的话我们需要先声明参数列表，参数列表的结尾是一个“-&gt;”这代表着参数的结束和函数体的开始，<strong>函数体的最后一行会自动作为lambda表达式的返回值</strong>。</p><h4><span id="什么时候需要传递lambda作为参数">什么时候需要传递lambda作为参数？</span></h4><p>在Java里面lambda表达式出现所要替代的对象实际上Java的<strong>单抽像方法接口</strong>也可以被叫做<strong>函数式接口</strong>，他俩共同的所代表的意义就是：</p><p><strong>接口中有且仅有一个抽象方法需要被实现</strong>。</p><p><strong>换句话说就是接口里面只有一个需要被实现的方法。</strong></p><p>当<strong>这种类型的接口</strong>作为参数的时候，我们就需要传递一个内部匿名类来实现其抽象方法</p><p>这里为了方便下边讲解先说几个结论，并不完全，可自行推广：</p><ul><li>kotlin的函数式API</li><li>kotlin的函数式接口</li><li>Java的函数式接口作为参数</li></ul><h4><span id="kotlin的闭包">kotlin的闭包</span></h4><p>与其说Kotlin是一等公民，不如说是闭包才是一等公民。</p><p>闭包在kotlin中常常指的就是由{}构成的lambda表达式，之所以叫他闭包，实际上就是因为他与函数有很大的区别，比如闭包可以访问外部环境的变量，普通函数想要访问外部环境的变量是需要传入参数的，而闭包可以直接访问，并将其保存下来，具体可见参考文章。</p><p>参考文章：</p><p><a href="https://www.jianshu.com/p/b968524a0e95%E3%80%82">https://www.jianshu.com/p/b968524a0e95。</a></p><p><a href="https://kymjs.com/code/2017/04/09/01/#:~:text=%E9%97%AD%E5%8C%85%E5%BA%94%E8%AF%A5%E7%AE%97%E6%98%AF%20Kotlin%20%E6%9C%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%80%E4%BA%86%E3%80%82%20%E4%BD%BF%E7%94%A8%E5%A5%BD%E9%97%AD%E5%8C%85%E5%8F%AF%E4%BB%A5%E8%AE%A9%E4%BB%A3%E7%A0%81%E9%87%8F%E5%A4%A7%E5%A4%A7%E5%87%8F%E5%B0%91%EF%BC%8C%E4%BE%8B%E5%A6%82%20Kotlin%20%E6%9C%80%E8%91%97%E5%90%8D%E7%9A%84%E5%BC%80%E6%BA%90%E5%BA%93%EF%BC%9A%20Anko,%EF%BC%8C%E4%BD%BF%E7%94%A8%20Anko%20%E5%8E%BB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80%EF%BC%8C%E6%AF%94%E4%BD%BF%E7%94%A8%20Java%20%E4%BB%A3%E7%A0%81%E9%85%8D%E5%90%88%20xml%20%E8%A6%81%E6%9B%B4%E5%8A%A0%E7%AE%80%E6%B4%81%E3%80%82%20%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E5%85%85%E5%88%86%E8%BF%90%E7%94%A8%E4%BA%86%E9%97%AD%E5%8C%85%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7%EF%BC%8C%E7%9C%81%E7%95%A5%E4%BA%86%E5%BE%88%E5%A4%9A%E7%9A%84%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%82%E6%95%B0%E5%A3%B0%E6%98%8E%E3%80%82">闭包2</a>.</p><p>我在这里举一个例子方便大家理解一下，如果看不懂看完本文再回过头来看效果更好：</p><pre><code class="language-kotlin">    val list = listOf("Apple", "Banana", "Orange", "Pear",        "Grape", "Watermelon")    val newList = list.map() { fruit: String -&gt;        {fruit.uppercase() }}    for (fruit in newList) {        println(fruit)    }</code></pre><p>这里实际上输出的是闭包或者说是函数类型常量。</p><h5><span id="kotlin函数式api">kotlin函数式API</span></h5><p>我们先说明什么是kotlin函数式API：</p><p>先看一段代码，在最开始的一行我们定义了一个lambda表达式，他接受一个String类型的参数并返回字符的长度。</p><pre><code class="language-kotlin">//lambda 表达式演示val lambda = { fruit:String -&gt; fruit.length}val Max = list_test.maxOf(lambda)println(Max)</code></pre><p>我们跳转到maxof函数的定义去看看一看它的参数写的是什么：</p><pre><code class="language-kotlin">public inline fun &lt;T, R : Comparable&lt;R&gt;&gt; Iterable&lt;T&gt;.maxOf(selector: (T) -&gt; R): R {    val iterator = iterator()    if (!iterator.hasNext()) throw NoSuchElementException()    var maxValue = selector(iterator.next())    while (iterator.hasNext()) {        val v = selector(iterator.next())        if (maxValue &lt; v) {            maxValue = v        }    }    return maxValue}</code></pre><p>可以看到它的参数实际上就是一个lambda表达式：<code>selector: (T) -&gt; R</code></p><p>是不是很简单？很明了？我们再来看看什么是kotlin的函数式接口：</p><h5><span id="kotlin的函数式接口">kotlin的函数式接口</span></h5><p>在kotlin1.4中更新了函数接口，与java不同的是，kotlin需要显示的来定义一个函数接口，在<code>interface</code>接口添加一个<code>fun</code>关键字就可以实现把他转换为函数式接口：</p><pre><code class="language-kotlin">fun interface Eat{    fun eat_rice()}</code></pre><p>当函数式接口作为参数的时候就可以使用kotlin的lamda表达式：</p><pre><code class="language-kotlin">//lambdaval lambda2 = { -&gt; println("lambda is ok with kotlin interface")}test.lambda_tester(lambda2)</code></pre><p>因为原方法中并没有参数，所以前边也没有任何参数需要传递，我们可以简写成：</p><pre><code class="language-kotlin">//lambdaval lambda2 = { println("lambda is ok with kotlin interface")}test.lambda_tester(lambda2)</code></pre><h5><span id="java的函数式接口作为参数">Java的函数式接口作为参数</span></h5><p>如果我们在Kotlin代码中调用一个java方法，并且该方法只接收一个java单抽像方法接口作为参数，我们就可以使用lambda来传递参数：</p><p>我们这里来拿java的Thread类来举例子：</p><p>thread类的构造方法接收一个Runnable接口作为参数，Runnable是典型的函数式接口，里面只有一个run方法需要实现，当我们使用匿名内部类来实现的时候写法如下：</p><pre><code class="language-kotlin">Thread(object :Runnable{    override fun run() {        println("kotlin is  ok with anonymous")    }}).start()</code></pre><p>看起来很复杂，这里不再介绍匿名类的具体内容，你只需要知道 kotlin完全舍弃new关键字，这里的object类似于创建一个内部类，先尝试理解一下，实际上和这个感知还是有一定差距，到后面再说，我们直接来说如何用kotlin的lambda来实现java的函数式接口：</p><pre><code class="language-kotlin">Thread(    Runnable{-&gt; println("kotlin is ok with java")}).start()</code></pre><p>语法格式：</p><pre><code class="language-shell">接口名 { 参数 -&gt; 函数体 }</code></pre><p>讲到这里我想你应该明白什么时候用lambda什么参数的情况下使用lambda。</p><p>接下来我们顺着kotlin的设计思想，来讨论一下他的语法糖，上边为了你方便理解我并没有使用简写，但kotlin的最关键的还是他的语法糖，语法糖很甜。</p><h5><span id="kotlin的语法糖">kotlin的语法糖</span></h5><p>我们回到maxof方法：</p><pre><code class="language-kotlin">//lambda 表达式演示val lambda = { fruit:String -&gt; fruit.length}val Max = list_test.maxOf(lambda)</code></pre><p>实际上这里的lambda参数可以改写为：</p><pre><code class="language-kotlin">val Max = list_test.maxOf({ fruit:String -&gt; fruit.length})</code></pre><p>kotlin规定当lambda参数是函数的最后一个参数的时候可以放到括号外边：</p><pre><code class="language-kotlin">val Max = list_test.maxOf(){ fruit:String -&gt; fruit.length}</code></pre><p>接下来如果lambda表达式时函数唯一的参数的话还可以将括号省略：</p><pre><code class="language-kotlin">val Max = list_test.maxOf{ fruit:String -&gt; fruit.length}</code></pre><p>不要忘了kotlin具有很强的推导类型的能力，所以参数类型也可以省略：</p><pre><code class="language-kotlin">val Max = list_test.maxOf{ fruit -&gt; fruit.length}</code></pre><p>最后如果lambda表达式中只有一个参数的时候可以直接省略参数使用it来替代，同时“-&gt;”也可以省略：</p><pre><code class="language-kotlin">val Max = list_test.maxOf{ it.length}</code></pre><p>你会对这些省略规则感到复杂，其实抓住重点就是几条：</p><ul><li>最后一个参数 -&gt;移出到外边</li><li>唯一参数 - &gt; 省略和替代</li><li>参数类型-  &gt;可推导的省略</li></ul><p>我们按照这三个语法糖来实现代码优化：</p><h5><span id="java函数式api的语法糖">Java函数式API的语法糖</span></h5><pre><code class="language-kotlin">Thread(object :Runnable{    override fun run() {        println("kotlin is  ok with anonymous")    }}).start()</code></pre><p>首先Runnable接口是一个java的函数式接口，也就是其中只有一个抽象方法，并且对于Tread来说构造函数也只有这样一个接口参数，这两个唯一就符合上边的省略的替代策略。</p><p>省略接口名称，和重写方法的名称：</p><pre><code class="language-kotlin">Thread({        println("kotlin is ok with java")    }).start()</code></pre><p>同时他也是最后一个参数，也是唯一的参数省略括号和外移：</p><pre><code class="language-kotlin">Thread{        println("kotlin is ok with java")    }.start()</code></pre><p>牢记语法糖的实现规则，很方便的来优化代码。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（Kotlin入门）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E5%85%A5%E9%97%A8)/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E5%85%A5%E9%97%A8)/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin入门">Android开发笔记——快速入门（Kotlin入门）</span></h1><img src="https://s2.loli.net/2024/09/29/gC5eQ3URr1qGApZ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727617280095" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#why-kotlin">Why Kotlin？</a><ul><li><a href="#kotlin%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2">Kotlin的发展历史</a></li><li><a href="#kotlin%E5%92%8Cjava%E7%9A%84%E6%AF%94%E8%BE%83%E4%BC%98%E7%82%B9">Kotlin和java的比较优点</a></li></ul><ul><li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8kotlin%E5%BC%80%E5%8F%91android">如何使用Kotlin开发Android？</a><ul><li><a href="#kotlin%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0">Kotlin的变量与函数</a><ul><li><a href="#kotlin%E7%9A%84%E5%8F%98%E9%87%8F">kotlin的变量</a></li><li><a href="#kotlin%E7%9A%84%E5%87%BD%E6%95%B0">Kotlin的函数</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6">Kotlin的逻辑控制</a><ul><li><a href="#kotlin%E7%9A%84if">Kotlin的if</a></li><li><a href="#kotlin%E7%9A%84when">Kotlin的when</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E5%BE%AA%E7%8E%AF">Kotlin的循环</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h1><span id="why-kotlin">Why Kotlin？</span></h1><h3><span id="kotlin的发展历史">Kotlin的发展历史</span></h3><p>2011年，JetBrains 发布了Kotlin的第一个版本，并在2012年将其开源。</p><p>2016年Kotlin发布了1.0正式版，代表着Kotlin语言已经足够成熟和稳定了，并且JetBrains 也在自家的旗舰IDE开发工具Intelli]IDEA中加入了Kotlin的支持。</p><p>2017年Google 宣布 Kotlin 正式成为Android开发一级语言，并且Android Studio 也加入了对 Kotlin的支持。</p><p>2019年Google正式宣布了Kotlin First，未来提供的官方API会以Kotlin为主。</p><p><strong>Kotlin</strong>作为<strong>Jetbrain</strong>全新开发的语言，虽然是基于<strong>JVM</strong>进行的开发但是却是<strong>JAVA</strong>的温和改良版本，如果说C是一个国色天香的感觉，那么<strong>Java</strong>就是窈窕淑女而<strong>Kotlin</strong>就是小家碧玉，端庄优雅的温柔。</p><p><strong>Kotlin</strong>是一个极其成功的开源项目，代表了目前编程语言的一个发展方向，<strong>Kotlin</strong>在编写代码时有如下优势：代码简洁高效、函数式编程、空指针安全、支持<strong>lambda</strong>表达式、流式API等。光说起来你会感觉很难懂到底在说什么，但是当你跨进<strong>Kotlin</strong>大门之后才能体会到运用<strong>Kotlin</strong>编程的快乐。</p><h3><span id="kotlin和java的比较优点">Kotlin和java的比较优点</span></h3><p>Kotlin是完全和java兼容的，怎么个兼容办法呢？</p><p>Kotlin可以做到和Java 100%兼容，这主要是得益于Java虚拟机的工作机制 ，其实Java虚拟机并不会直接和你编写的Java代码打交道，而是和编译之后生 成的class文件打交道 ，而Kotlin也有一个自己的编译器，它可以将Kotlin代码也编译成同样规格的 class文件 ，Java虚拟机不会关心class文件是从Java编译来的，还是从Kotlin编译来的， 只要是符合规格的class文件，它都能识别 ，也正是这个原因，JetBrains才能以一个第三方公司的身份设计出一门用来 开发Android应用程序的编程语言</p><p>Kotlin是完全兼容Java现有的代码库的，也就是说你可以跨语言调用对应的代码内容，甚至于还有C、C++互操作，更神奇的是Kotlin也可以完成Javascript的工作，他编写的代码可以编译成JS的代码来运行！</p><h2><span id="如何使用kotlin开发android">如何使用Kotlin开发Android？</span></h2><p>首先你需要安装<strong>Android Studio</strong>来进行开发，详细安装过程可以参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123426867">Android开发笔记——快速入门（壹)</a></p><p>根据教程创建一个基于<strong>Kotlin</strong>的Android项目：</p><p>具体如何创建项目可以参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123458305?spm=1001.2014.3001.5502">上一篇文章</a>。</p><p>创建完成以后，在相同包下创建一个Kotlin类：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/20/8b4f5bf6b35badac.png" alt="1"></p><p>Kotlin class的创建：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/20/acc3bdd49432536e.png" alt="2"></p><h3><span id="kotlin的变量与函数">Kotlin的变量与函数</span></h3><p>创建完成以后就可以愉快的，使用AS来进行kotlin的编写：</p><p>首先创建一个主函数：</p><pre><code class="language-Kotlin">package com.example.codewithkotlinfun main(){    println("Hello Kotlin!")}</code></pre><p>你可以点击左边的小箭头运行一下</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/20/d8f09d31972d0ae5.png" alt="3"></p><h4><span id="kotlin的变量">kotlin的变量</span></h4><p>kotlin的变量与Java有很大的不同，可以总结如下两点：</p><ul><li>定义时不需要指定类型，而是需要指定变量是否可变。</li><li>没有保留Java基本的数据类型，而是使用对象数据类型，在 Kotlin 中，所有东西都是对象。</li></ul><p>举例：</p><p>不需要指定变量类型，其会自动推导：</p><pre><code class="language-kotlin">fun main(){    val a=10    println("a is " + a)}</code></pre><p>指定数据类型时不会再自动推导：</p><pre><code class="language-kotlin">fun main(){    val a : Int=10    println("a is " + a)}</code></pre><p>输出结果：</p><pre><code class="language-shell">a is 10</code></pre><p>val与var是用来指定是否为变量的关键字，val类似于java的final，var就是常规的变量，为什么要这样设计你如果有编程基础你就知道变量是不安全的，val，var就是为了指定这个变量是否可变（强制要求显式定义），这有一个小技巧，定义变量时应该是都定义为val，只有你需要var的时候再回来将这个变量改定义为var，这样就保证了基本所有变量的安全。</p><h4><span id="kotlin的函数">Kotlin的函数</span></h4><p>kotlin的函数与Java中的方法其实很像，但是更自由，书写更方便。</p><p>fun（function的简写）是定义函数的关键字，无论你定义什么函数，都一定要使用fun来声明。当然这不包含函数表达式。</p><p>其基本定义格式如下：</p><pre><code class="language-kotlin">fun funName(param1 : Int,param2 :Int) ：returnvaluetype {return value}</code></pre><p>如果没有返回参数就可以省略<code>：returnvaluetype</code> 部分，从这里看出Kotlin的设计思想：</p><p><strong>能省就省</strong></p><p>简化以后就可以表现为：</p><pre><code class="language-kotlin">fun funName(param1 : Int,param2 :Int){}</code></pre><p>为了保持设计思想，Kotlin做出了更多的省略,当你的函数体只有一块作为返回值的代码时，可以直接省略大括号，用等号来连接,这里用一个返回最大值的函数来表示：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int):Int = max(num1,num2)</code></pre><p>但是我们说过Kotlin具有出色的推导机制，那么他能不能推断出这里一定返回的是和max函数返回相同的内容呢？当然可以。所谓我们进一步简化省略去返回值：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int)= max(num1,num2)</code></pre><p>使用Kotlin以后你就会发现能在一行就实现一个完整的函数，但这并不是我们想要的，因为这里我们只是对MAX函数进行了一个包装，里面并没有任何逻辑部分。下面我们来写一下如何写逻辑部分的内容，并对其进行简化，进一步体验其强大性。</p><h3><span id="kotlin的逻辑控制">Kotlin的逻辑控制</span></h3><h4><span id="kotlin的if">Kotlin的if</span></h4><p>if在使用的时候与传统的if并没有太大区别，但是他还有一个额外的功能，可以有返回值。为什么要给if来整一个返回值呢？返回值常常与函数相关，对于现在流行的函数式编程，Kotlin也对其做出了支持，if的返回值就是如此，<strong>if语句会自动返回其最后一条语句的返回值</strong>：</p><p>常规IF的写法如下：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int) ：Int{    var maxnumber =0    if(num1 &gt;= num2)        maxnumber = num1    else        maxnumber = num2    return maxnumber}</code></pre><p>使用其返回值如下，是不是看起来更简略一点了呢：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int):Int{    val maxnumber = if(num1 &gt;= num2)                        num1                    else                        num2    return maxnumber}</code></pre><p>其实还可以再简略一下我们可以把if和else看成一个语句，这样他就可以直接给函数返回内容，我们就可以省略函数体的括号和返回值类型：</p><pre><code class="language-kotlin">fun maxNumber(num1 :Int ,num2 :Int)=if(num1 &gt;= num2)num1 else num2</code></pre><p>这样就实现了最简洁的写法。</p><h4><span id="kotlin的when">Kotlin的when</span></h4><p>Kotlin的when就是Java，C中的Switch case，负责的是样例匹配的工作，当你需要匹配内容很多的时候用if，是很不优雅的，但是Kotlin的when提供了一种简介方便的方式。</p><p>我先提供一个写法：</p><pre><code class="language-kotlin">fun getGender(name : String) =    when (name)    {        "zzy"-&gt; println("boy")        "lxl"-&gt; println("girl")        "hrq"-&gt; println("boy")        else -&gt;  println("not a boy or girl")    }</code></pre><p>这段代码给我们提供了一个样例，我们通过传入任意一个类型的变量来使用when来进行匹配，when后面的括号就是要匹配的对象，下边的函数体就是要匹配的内容，你可以发现他取消了case等关键字而是使用**“-&gt;”<strong>来作为关键字，意义表达明确，而且你不用担心执行完成后没有</strong>break**会自动向下运行，每一个匹配后会执行完自己的逻辑代码然后退出。值得提醒的是你的逻辑代码只有一行的时候可以省略“{}”。</p><p>除了数据匹配之外，when语句还可以进行类型匹配，没错就是你想的那个数据类型，如果你想起来Kotlin中没有基本的数据类型，而是全部都是类数据，你就会意识到为什么要这样设计数据类型，为了类型匹配只是一小部分优点。</p><p>下面举一个例子：</p><pre><code class="language-kotlin">fun getType(number : Number) =    when (number)    {        is Int -&gt; println("Int type")        is Float-&gt; println("Float type")        is Long-&gt; println("Long type")        else -&gt;  println("not my type")    }</code></pre><p>通过设置输入的number为所有数字类型的父类Number，你可以输入任意类型的数据，然后使用<strong>is</strong>关键字来检测是不是对应的类型。</p><p>你可以看到When里边都是同一种类型的匹配模式，但是如果要使用不同的匹配模式呢，打个比方我一个想要分离出名字里面有是zzy的，另一个想要分离出名字是lxl怎么办？很简单这里去掉when后边的括号就好了，将匹配表达式写入大括号里面。</p><pre><code class="language-kotlin">fun getGender2(name : String) =    when    {        name.contentEquals("zzy")-&gt; println("a part of zzy")        name === "lxl"-&gt; println("girl")        else -&gt;  println("not Anyone")    }</code></pre><h3><span id="kotlin的循环">Kotlin的循环</span></h3><p>在介绍循环之前先介绍一个新的东西，区间</p><p>区间这个东西很简单，它的作用就是按照规律生成一组数列，我们举个例子试一试：</p><pre><code class="language-kotlin">fun rangeTest(){    val range = 1..10    val untils = 0 until 10    val downtos = 10 downTo 1    println(range)    println(untils)    println(downtos)}</code></pre><p>输出结果：</p><pre><code class="language-shell">1..100..910..1</code></pre><p>你可以看见这两个区间生成的数列区别，一个是包含左右边界，一格式只有左边界没有右边界。</p><p>有了区间以后就可以使用for来迭代，for循环在Kotlin中有了巨大的变化，我先来展示一下：</p><pre><code class="language-kotlin">fun rangeTest(){    val range = 1..10    val untils = 0 until 10    println(range)    println(untils)    for (i in 10 downTo 1)        println(i)}</code></pre><p>输出：</p><pre><code class="language-shell">1..100..910987654321</code></pre><p>你可以看到了一个和java c都不太像的for 更想java里面的增强for循环，你就意识到这里for转化为了一个迭代器的作用。在后边我再继续讲解for的强大之处。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（Kotlin的NULL）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84NULL)%20/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84NULL)%20/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门-kotlin与null">Android开发笔记——快速入门 (Kotlin与NULL)</span></h1><img src="https://s2.loli.net/2024/09/29/9rGTdRm4giweluL.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727617602165" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E7%A9%BA%E6%8C%87%E9%92%88%E4%B8%8E%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7">Kotlin的空指针与辅助工具</a><ul><li><a href="#kotlin%E7%9A%84%E5%88%A4%E7%A9%BA">Kotlin的判空</a></li><li><a href="#kotlin%E7%9A%84%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B">Kotlin的可空类型</a></li><li><a href="#kotlin%E7%9A%84%E5%88%A4%E7%A9%BA%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7">Kotlin的判空辅助工具</a><ul><li><a href="#"><code>?.</code></a></li><li><a href="#"><code>?:</code></a></li><li><a href="#let%E5%87%BD%E6%95%B0">let函数</a></li></ul></li><li><a href="#kotlin%E5%88%A4%E7%A9%BA%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5">Kotlin判空的特殊情况</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的空指针与辅助工具">Kotlin的空指针与辅助工具</span></h2><h3><span id="kotlin的判空">Kotlin的判空</span></h3><p>在写java或者c的时候最让人难受的就是空指针的问题了，当你写了一大段代码，运行时来一个报错，心态是很爆炸的，怎么又找不到变量在哪里了？但是你如果正常情况下书写kotlin就不会遇到这些问题，为什么呢？</p><p>因为kotlin将判空过程不是放在运行时，而是放在了编译过程中，甚至有些在kotlin语言设计的时候就已经在考虑如何避免了，说起来可能很复杂，接下来详细介绍一下kotlin的判空机制。</p><p>先来看一段代码：</p><pre><code class="language-kotlin">class Zzy(val gender: String = "Boy") : Person(22,"zhuzeyu"){    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init    {        println(name+" is a "+gender+" age is "+age)    }}fun main(args: Array&lt;String&gt;){    //koltin 空指针检查 //这段代码没有空指针风险    val zzy = Zzy("boy")}</code></pre><p>我们构造了一个类并且继承了Person类，最后在主函数中调用这个类的构造方法，需要注意的是构造方法需要传入的一个字符串，如果传入的是一个空的字符串这里就会产生空指针问题，在java中是不给你任何提示的，但是在kotlin中就有所不同：</p><p><img src="https://s2.loli.net/2024/09/29/ob2dVHwq4IxAWSU.png" alt="image-20220408215120939"></p><p>可以看到kotlin因为传入空而报错，这不是最重要的，因为这里显式的传入了null，那如果我们传入的是一个变量呢？</p><p>这里为了方便演示再传入一段代码：</p><pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;){    //koltin 空指针检查 //这段代码没有空指针风险    val zzy = Zzy(null)    var fake_zzy :String = null;}</code></pre><p>实际上<code>var fake_zzy :String = null</code>是不能运行的，kotlin给出了错误提示：</p><p><img src="https://s2.loli.net/2024/09/29/ASvpMjH15egbKnd.png" alt="image-20220408222048233"></p><p>编译器知道你这里传入就是一个null，所以代码实际上是不能运行的。</p><p>可以看到Kotlin从编译层面就避免了空指针问题的发生，但是这就意味着null在kotlin中就没有用处了吗？当然不是，接下来来介绍kotlin的可空类型。</p><h3><span id="kotlin的可空类型">Kotlin的可空类型</span></h3><p>如果在某个情况下我需要根据传入的变量的情况（空或者不空）来进行操作，但是你意识到这里面所有的传递参数都不能是空，甚至连编译都没办法通过这怎么办？</p><p>kotlin其实提供了可空类型</p><p>我们来看一个例子：</p><p><img src="https://s2.loli.net/2024/09/29/q7HRpfNolbKTBs8.png" alt="image-20220408221845089"></p><p>你注意到String后边添加了一个？这事 String的变量不再报错了，对这就是可空的String类型。</p><p>当然不止String有，每个kotlin的类型都可以声明为可空类型，基本结构如下：</p><pre><code class="language-kotlin">var 变量名 ： 变量类型 ? = null</code></pre><p>当然你也许也注意到了方法传入的参数也被报错了，</p><p>其中test类是用来创建测试函数的，函数具体内容如下：</p><pre><code class="language-kotlin">fun eat_empty_food (person: Person) =     if (person != null)         person.eat_empty()     else        "empty"</code></pre><p>可以看到此方法接受一个Person类作为参数，而zzy类继承了People类正好可以作为参数传递进去，但是这里我们传入了一个null，编译器报错了，为什么呢？因为参数也需要设置成可空的类型：</p><pre><code class="language-kotlin">fun eat_empty_food (person: Person?) = if (person != null) person.eat_empty() else "empty"</code></pre><p>这段代码什么意思呢？就是如果传进来的参数不是null的就正常调用一个方法，如果是空的就返回empty字符串。</p><p>是不是很简单呢？这是kotlin为了避免空指针问题而做的隔离，完全将空指针和正常变量做了一个隔离。</p><h3><span id="kotlin的判空辅助工具">Kotlin的判空辅助工具</span></h3><p>在上面我们介绍了kotlin如何将空指针赶尽杀绝，但是我们有些时候也需要通过空指针来判断一些具体情况，Kotlin同时提供了一套完整、便捷的判断工具。</p><h4><span id><code>?.</code></span></h4><p>首先介绍：<code>?.</code></p><p>在上一节，如果你更改了参数为可空类型，实际上他还会报错，因为这时候函数使用的时候，就有可能遇到null问题，如何更改呢？就要使用<code>?.</code>。</p><pre><code class="language-kotlin">fun eat_empty_food_update (person: Person?) = person?.eat_empty()</code></pre><p><code>?.</code>当对象不为空的时候正常调用方法，当为空的时候什么也不做。这里的作用就是为了避免空指针调用方法，你会说这好鸡肋啊没什么用，先别急后边会有更方便的方法一起组合来使用。</p><h4><span id><code>?:</code></span></h4><p>我们先介绍第二个工具关键词：<code>?:</code></p><p>这个操作符左右两边都接受一个表达式，如果左边表达式的结果不为空就返回左边的表达式，否则就返回右边的表达式的结果。你如果问这个有什么用？我们返回去看一段代码：</p><pre><code class="language-kotlin">fun eat_empty_food (person: Person?) = if (person != null) person.eat_empty() else "empty"</code></pre><p><code>?:</code>就和if和else作用一摸一样，就是其的简写，这样看起来是不是很简单很方便？</p><pre><code class="language-kotlin">fun eat_empty_food_plus (person: Person?) = person?.eat() ?: "empty"</code></pre><p>当person为空的时候<code>?.</code>就会返回一个null这时候配合<code>?:</code>就实现了简化版的if else，从而避免了为null的情况。</p><h4><span id="let函数">let函数</span></h4><p>let函数是kotlin独特的一个函数，这个函数接收的参数是一个函数式API接口，也就是需要你传入进去一个lambda表达式来使用，如果你不懂就翻回去看上一篇。</p><p>我这里直接介绍let如何使用：</p><pre><code class="language-kotlin">obj.let{obj -&gt; //函数体}</code></pre><p>举个例子：</p><pre><code class="language-kotlin">private var special : String? = "empty_special"//let函数this.special?.let{it.length}输出结果：13</code></pre><p>你可以发现let函数默认将调用它的对象作为参数传入到了lambda表达式中，这有什么用呢？</p><p>如果存在一种情况，你需要判断的对象调用了两个方法，你要这样写吗？</p><pre><code class="language-kotlin">fun eat_twofood (person: Person?) = {    person?.eat_empty()    person?.eat()}</code></pre><p>这样一点也不优雅，打咩！</p><p>kotlin就是讲究优雅，我们改写以后使用let函数会将对象自动作为参数的特性：</p><pre><code class="language-kotlin">fun eat_twofood (person: Person?) = person?.let { it.eat_empty(); it.eat();  }</code></pre><p>kotlin的函数一行就足够了！</p><p>可以看到我们使用let函数的特性来实现了对单个对象引用多方法的判空处理，这样我们只需要判断一次就可以了，如果有多个方法调用，也只需要一次，省力又省时。我们只需要在let函数前使用<code>?.</code>判断一次即可,然后使用let函数的参数来调用对应方法。</p><h3><span id="kotlin判空的特殊情况">Kotlin判空的特殊情况</span></h3><p>Kotlin的判空并不是完美的，某些情况下会阻碍我们的书写，因此要提前预知从而避免。</p><pre><code class="language-kotlin">//特殊情况if (test.special!=null)    println(test.eat_empty_food_special())</code></pre><p>其中<code>eat_empty_food_specia</code>方法如下：</p><pre><code class="language-kotlin">fun eat_empty_food_special () = this.special.length</code></pre><p><img src="https://s2.loli.net/2024/09/29/lkxcVzMjhs3oUGq.png" alt="image-20220408232756812"></p><p>实际上这里是有报错的，因为这里编译器判定special可能为空，但是实际我们在函数的外，调用方法之前已经对其做了防空处理，但是IDE感知不到，但是问题不大，我们更换写法即可。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（Kotlin的对象扩展与高阶函数深入）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95)%20/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95)%20/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门-kotlin的对象扩展与高阶函数深入">Android开发笔记——快速入门 (Kotlin的对象扩展与高阶函数深入)</span></h1><img src="https://s2.loli.net/2024/09/29/RU7cAxv8aTSKQf4.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727618114855" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95">Kotlin的对象扩展语法</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F">对象表达式</a><ul><li><a href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F-1">对象表达式</a><ul><li><a href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AD%98%E5%9C%A8%E5%8F%82%E6%95%B0">父类的构造函数存在参数</a></li><li><a href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1">匿名对象</a></li><li><a href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC">匿名对象作为返回值</a></li></ul></li></ul></li></ul></li><li><a href="#kotlin%E7%9A%84%E7%B1%BB%E6%89%A9%E5%B1%95">Kotlin的类扩展</a></li><li><a href="#kotlin%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">Kotlin的高阶函数</a></li><li><a href="#%E7%B1%BB%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88">类扩展函数和高阶函数结合</a></li><li><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">深入理解高阶函数</a><ul><li><a href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">内联函数</a></li><li><a href="#noinline%E5%92%8Ccrossinline">noinline和crossinline</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的对象扩展语法">Kotlin的对象扩展语法</span></h2><h3><span id="对象表达式">对象表达式</span></h3><p>有时候，我们需要创建一个对某个类有轻微改动的类的实例化对象，就要再去继承原来的类声明一个子类，但是通过Kotlin的对象表达式就可以避免去创建一个只使用一次的类。</p><h4><span id="对象表达式">对象表达式</span></h4><p>要创建一个继承自某个类的匿名类对象，我们可以使用对象表达式来简化书写，通过对象表达式将<strong>匿名类</strong>的声明和<strong>匿名类对象</strong>的声明糅合在一起，为我们省去了很多代码。</p><p>通常来说我们在使用接口作为参数的的时候使用对象表达式的情况比较多，举个例子，如果我们使用Thread来创建一个线程的时候，Thread类的参数实际上就是一个Ruunable接口，这个Runnable接口就是Java中所说的函数式接口，如果我们不使用lambda来传递的话，就要使用一个实现了<strong>Ruunable接口类的对象</strong>作为参数传递进去。或者使用匿名类的实现（实际上匿名类的实现也是对象）来替代需要实现的类的对象。</p><p>对于对象表达式就类似于的java的匿名类，只不过他的功能更多，在这里你可以先理解为Java中匿名内部类。</p><p>举个例子：</p><pre><code class="language-kotlin">Thread(    object : Runnable {        override fun run() {            println("Kotlin is ok with Anonymous")        }    }).run()</code></pre><p>这里我们创建了一个对象表达式然后继承了Runnable接口，并实现了其中的run方法，最终对象表达式会自动创建一个这个类的对象并返回给Thread类。</p><p>代码运行结果如下：</p><pre><code class="language-shell">Kotlin is ok with AnonymousProcess finished with exit code 0</code></pre><p>当然对象表达式的作用不仅仅局限于函数式接口，它可以用于任何可继承的类，下面再来讨论几种特殊情况。</p><h5><span id="父类的构造函数存在参数">父类的构造函数存在参数</span></h5><p>我们有一个父类如下：</p><pre><code class="language-kotlin">package com.example.codewithkotlinopen class Person(var age :Int, val name:String){    fun study() = name + "love study"}</code></pre><p>父类的形式很简单，就是只有一个方法，两个成员变量。</p><p>我们存在一个函数，需要传入一个父类的对象，就可以使用对象表达式来构造。</p><p>函数如下：</p><pre><code class="language-kotlin">fun fatherargs_tester(person: Person){    println(person.name)}</code></pre><p>解决办法如下：</p><pre><code class="language-kotlin">/*父类的构造函数存在参数*/fatherargs_tester(    object :Person(18,"Jszszzy") {    override fun study() = "$name love studing kotlin"    })</code></pre><p>可以看到我们使用对象表达式创建了一个新的对象，并且将类里面的方法进行了重写，输出是结果如下：</p><pre><code class="language-shell">Jszszzy love studing kotlin</code></pre><p>同时表达式可以访问其所在作用域的变量：</p><pre><code class="language-kotlin">/*父类的构造函数存在参数*/val name = "Jszszzy"fatherargs_tester(    object :Person(18,name) {    override fun study() = "$name love studing kotlin"    })</code></pre><h5><span id="匿名对象">匿名对象</span></h5><p>对象表达式同时也可以构造<strong>匿名对象</strong>，即不继承任何类的匿名表达式。</p><p>举个例子：</p><pre><code class="language-kotlin">val anonymous_object = object {    val x = "test";}println(anonymous_object::class.java.toString())</code></pre><p>我们使用：：class方法来获取到对应的类是什么。</p><p>结果如下:</p><pre><code class="language-kotlin">class com.example.codewithkotlin.TestKt$main$anonymous_object$1</code></pre><p>看以看到是一个特殊的类，类的名称和创建的变量名有一定关系。</p><h5><span id="匿名对象作为返回值">匿名对象作为返回值</span></h5><p>这个是用的比较少，简单来说一下。</p><p>当匿名对象最为返回值的时候，</p><p>如果是一般的共有方法则返回类型自动转化为Any。</p><p>如果是私有办法则为返回类型为对应的匿名对象。</p><p>也就是说匿名对象，实际上其作用域仅限于他所处的类本身。</p><h2><span id="kotlin的类扩展">Kotlin的类扩展</span></h2><p>在某些情况下，我们希望在不修改某些类的源码的情况下（实际上你根本修改不了，大多数库代码都只是可读的）仍然可以为这个类添加新的功能，添加新的方法。就要使用到类的扩展了。</p><p>其基本使用结构如下：</p><pre><code class="language-kotlin">fun Classname.methodName(param1:type,param2:type):Int{return 0}</code></pre><p>可以看到实际上就是定义了一个函数，在前面加上想要添加的具体类名就可以了。注意的是你在在哪里声明的添加方法就会收到其作用域的影响，所以往往把添加的方法直接放到文件中，拥有顶层作用域来使用。</p><h2><span id="kotlin的高阶函数">Kotlin的高阶函数</span></h2><p>高阶函数和Lambda的关系密不可分，可以说高阶函数就是lambda应用的扩展。</p><p>高阶函数的定义是如果某个函数接收另一个函数作为参数或者返回值是一个函数就可以称之为高阶函数。你可能很难理解什么是函数类型？</p><p>实际上新一代语言中不止包含有我们常说的数据类型，大部分语言为了支持函数式编程，都添加了函数类型作为一种基础类型，他和其他基本类型一样，只不过其他基本类型传递的是一段二进制数据，函数类型传递的是一段可执行的代码。</p><p>对于一个lambda表达式来说，我们定义它其实很方便，举个例子，我们这里定义一个函数型变量（其实就是lambda表达式），并调用它输出它运行的结果：</p><pre><code class="language-kotlin">/*Kotlin的类扩展*/val lambda = { x:Int -&gt; x*x }println(lambda(3))</code></pre><p>我们其实也知道kotlin有优秀的推导机制，其实上一个Lambda在声明的时候并没有指明具体返回类型，返回类型是在编译的时候推理出来的。</p><p>但是有些时候，Kotlin无法推断具体类型的情况下，就要手动来声明具体类型来指定了，声明类型也很简单，具体方法如下：</p><pre><code class="language-kotlin">/*Kotlin的lambda使用*/val lambda : (Int) -&gt; Int =  {x -&gt; x*x }println(lambda(3))</code></pre><p>此处指明了lambda表达式的参数类型是Int、并且返回值类型依然是Int，最终输出的结果和上文一样。</p><p>说了这么多，这些又和高阶函数什么关系呢？</p><p>高阶函数的定义指明了要传递函数作为参数，那么如何定义函数参数呢？</p><p>没错就是lambda表达式来作为参数。</p><p>下面举一个例子，以下定义了一个高阶函数。</p><pre><code class="language-kotlin">fun advanced_function( func :(Int) -&gt; Int){    println(func(9))}</code></pre><p>此高阶函数中参数为func，传入的lambda表达式类型为<code>(Int) -&gt; Int</code>也就是说，接收一个输入参数为Int返回值Int的函数。</p><p>但是为什么要传入一个函数作为参数呢？发挥一下你的想象力，我们可以定义符合上述参数类型的lambda表达式，但是函数的逻辑内容可以完全不一样。举个例子：</p><p>我们仍然使用上述高阶函数，但是创建一个新的lambda表达式：</p><pre><code class="language-kotlin">/*Kotlin的高阶函数*/val lambda1 :(Int) -&gt;Int  = {x -&gt; x+x}advanced_function(lambda1)</code></pre><p>此时运算结果就变为了相加。</p><p>与此相对的，Kotlin也支持直接将lambda表达式传递进去，当高阶函数只有一个lambda参数的时候，我们可以直接省略小括号，最终效果和前边完全相同：</p><pre><code class="language-kotlin">/*高阶函数常规用法*/advanced_function{x -&gt; x+x}</code></pre><h2><span id="类扩展函数和高阶函数结合">类扩展函数和高阶函数结合</span></h2><p>当我们在前边使用apply函数的时候很方便就能获得一个上下文，这样调用对象的时候就可以避免重复书写对象，Kotlin同时也为高阶函数提供了类似的功能，我们先来尝试使用扩展函数和高阶函数结合一下：</p><pre><code class="language-kotlin">fun StringBuilder.build(block : () -&gt; Unit):StringBuilder{    block()    return  this}</code></pre><p>这一段函数所代表的意义就是为StringBuilder类扩展一个高阶函数build，其参数为:<code>（）-&gt;Unit</code>的函数。</p><p>在函数内调用传入的函数，并将处理后的对象返回。</p><p>但是这里就会遇到一个问题，我如果想在传入的函数中使用StringBuilder的方法怎么办？也就说这部分函数还是要调用扩展类的方法的，Kotlin为此设计了一个能提供上下文的办法，使用起来很简单效果如下：</p><pre><code class="language-kotlin">fun StringBuilder.build(block :  StringBuilder. () -&gt; Unit):StringBuilder{    block()    return  this}</code></pre><p>可以看到实际上就是在参数类型前边加上了ClassName.的前缀，这样就将要传入的函数参数定义在了在StringBuilder的里面，保证了函数可以自动获取StringBuilder的上下文。</p><p>举个实际例子：</p><pre><code class="language-kotlin">val result = StringBuilder().build {    append("jszszzy")}</code></pre><p>我们在传入的参数中加入了StringBuilder的上下文这样，就相当于获得了调用方法的时候创建的上下文，完整写法如下：</p><pre><code class="language-kotlin">val result = StringBuilder().build {    this.append("jszszzy")}</code></pre><p>最终结果也很简单，输出了添加的字符串：</p><pre><code class="language-shell">jszszzy</code></pre><h2><span id="深入理解高阶函数">深入理解高阶函数</span></h2><h3><span id="内联函数">内联函数</span></h3><p>我们始终要意识到一个问题，kotlin的代码最终都要被编译为java的字节码文件的，但是在java中我们并没有高阶函数的概念，那么Kotlin是如何实现的高阶函数呢？</p><p>这就要归功于Koltin的强大编译器了，在这里我还是要狠狠吹一波Kotlin！Kotlin可不仅仅适用于JVM运行，他甚至还有专门的编译器去编译成类似c语言的字节码直接运行，不依赖于JVM,详细请了解：<a href="https://book.kotlincn.net/text/multiplatform.html">Kotlin多平台</a>。</p><p>那么现在需要编译成JVM的字节码，他会怎么编译呢？我们还是拿上边的函数举个例子：</p><p>我们打开他的反编译java代码：</p><pre><code class="language-java">public static final void advanced_function(@NotNull Function1 func) {   Intrinsics.checkNotNullParameter(func, "func");   int var1 = ((Number)func.invoke(9)).intValue();   System.out.println(var1);}</code></pre><p>可以看到我们的函数类型参数转变为了一个Function1接口，这是神马？</p><p>我们打开看一看：</p><pre><code class="language-kotlin">/** A function that takes 1 argument. */public interface Function1&lt;in P1, out R&gt; : Function&lt;R&gt; {    /** Invokes the function with the specified argument. */    public operator fun invoke(p1: P1): R}</code></pre><p>里面有一个函数叫invoke，继承这个接口的话，那必须就要把这个函数给实现了。</p><p>可以看到原来我们执行传入的函数参数的位置被替换成了一行代码：</p><pre><code class="language-kotlin"> int var1 = ((Number)func.invoke(9)).intValue();</code></pre><p>原来的函数的调用被替换为了一个invoke()函数的调用。</p><p>实际上在调用高阶函数的时候，对应的代码被转换为了如下的样子：</p><pre><code class="language-kotlin">/*替换前源代码*/advanced_function{x -&gt; x+x}/*替换后*/advanced_function(    new Function(){        @Overrride        public Integer invoke(Integer x){            retaurn x+x;        }    })</code></pre><p>也就是说对应的lambda表达式位置被替换成了一个匿名类的实现，通过这个接口将对应的lambda表达式封装到了invoke函数里面，调用invoke函数就相当于使用了对应的lambda表达式！</p><p>但是这就产生了一个问题！我的每一个lambda不会都是这样实现的吧，这样就会造成很大的性能浪费，当你在上边愉快的书写lambda表达式，下边kotlin跑的匿名类累死。</p><p>kotlin为了消除这个问题，又创建了一个方法，这就是内联函数，内联函数是干什么的呢？</p><p>他会使Kotlin编译器将内联函数中的代码在编译的时候替换到对应的地方。实现真正的代码传递。这样在运行的时候就不存在任何运行开销了。说起来可能不太容易，我们做个演示，替换后调用的位置是什么样的:</p><p>使用inline来修饰：</p><pre><code class="language-kotlin">inline fun advanced_function( func :(Int) -&gt; Int){    println(func(9))}</code></pre><p>对应调用位置的代码：</p><pre><code class="language-kotlin">/*使用内联函数替代后*/println(x+x)</code></pre><p>你会发现他把原来你调用的函数给替掉了，实际上就是把lambda表达式融合进函数里面最终在再把函数内所有的代码都拿出来替换掉调用的地方。</p><p>当然他的替换过程可能没有那么简单，因为在内联函数的内部可能存在return等语句所以我们在这里不再详细介绍具体的实现过程，我们不妨来说一说一个便捷的理解方法。</p><ul><li>Kotlin编译器首先将Lambda表达式中的代码替换到内联函数调用函数型参数的地方。</li><li>接下来，再将内联函数中的全部代码再反向替换到内联函数调用的地方</li><li>左后将内联函数中的return等操作省略，将return的表达式或者值直接省略替换成对应的表达式。</li></ul><h3><span id="noinline和crossinline">noinline和crossinline</span></h3><p>接下来我们再来讨论一下，使用inline关键字的内联函数特殊情况。</p><p>在某些情况下你需要打断lambda表达式的运行，就是需要在lambda表达式中使用return，这时候就麻烦了lambda表达式中一般是不允许使用return的，你当然也可以使用特殊的关键字<code>return@内联函数名称</code>，使用以后lambda表达式剩余的内容就不会执行。</p><p>举个例子：</p><pre><code class="language-kotlin">/*Kotlin 内联函数*/advanced_function{        x -&gt;    return@advanced_function x*x    x+x}</code></pre><p>这里运行的结果就是返回一个x*x.而不是下面的x+x。</p><p>那我如果使用inline关键字呢？</p><p>回想上文所说的，inline关键字实际上是代码替代，所以可以直接使用return来返回，不过注意的是这里return会导致调用函数直接return！</p><p>这就是高阶函数使用inline关键字的第一个关注点。</p><p>第二个关键点在于高阶函数内部的lambda表达式需要使用函数型参数作为lambda表达式的内容会因为return关键字产生冲突。</p><p>看起来很复杂实际上是一种嵌套的情况，我们来举个例子：</p><p><img src="https://s2.loli.net/2024/09/29/OAh7siKrDbE3MN5.png" alt="image-20220617175447968"></p><p>可以看到这里报错了，这里的代码实际上在匿名类中调用了传入的函数类型参数。</p><p>因为使用了inline，所以可能会导致Runnable接口的lambda中包含了全局返回使用的return。</p><p>但是我们如果lambda中其实并没有包含return呢？有什么办法绕开这个错误呢？</p><p>当然！</p><pre><code class="language-kotlin">inline fun advanced_function_withlambda( crossinline func :(Int) -&gt; Int){    val runnable = Runnable {        func(9)    }}</code></pre><p>crossinline本质上解决的问题是在声明了inline关键字的高阶函数内部的lambda表达式需要使用函数型参数作为lambda表达式的内容而产生的冲突。再本质一点的问题是，lambda表达式和匿名类一样只允许函数局部返回，而对于内联操作使用的确实为全局返回。</p><p>总的来说如果你的高阶函数的lambda表达式使用了return关键字，那么你就应该考虑到以上的关键字和return带来的具体影响。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门 (Kotlin的延迟初始化与Viewbinding、密封类)</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E4%B8%8E%E5%AF%86%E5%B0%81%E7%B1%BB)%20/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E4%B8%8E%E5%AF%86%E5%B0%81%E7%B1%BB)%20/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门-kotlin的延迟初始化与viewbinding-密封类">Android开发笔记——快速入门 (Kotlin的延迟初始化与Viewbinding、密封类)</span></h1><img src="https://s2.loli.net/2024/09/29/kAI59OWGPqluiQN.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727618527687" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B">Kotlin的延迟初始</a><ul><li><a href="#%E9%82%A3%E4%B9%88%E5%88%B0%E5%BA%95%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%A8">那么到底该怎么用？</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E5%AF%86%E5%B0%81%E7%B1%BB%E5%92%8Cwhen">Kotlin的密封类和When</a></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的延迟初始">Kotlin的延迟初始</span></h2><p>鉴于Kotlin的判空机制，在编译的时候就会检测变量是否存在空的可能，这就导致了一个麻烦，你需要额外多写代码来处理那些可能为空的类，即使在逻辑上他也不可能是NULL的，kotlin的判空机制还是会强制让你增加判空，不过这也不是没有解决办法，下面介绍一个关键字延迟初始化：<code>lateinit</code></p><p>当你遇到这样一种场景：</p><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {    private lateinit var binding :ActivityMainBinding         override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding= ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)    }}</code></pre><p>我想在MainActivity类里面调用一个viewbinding，可是这个viewbinding只有在oncreate方法里面才能对他进行初始化你如果在类里面直接进行初始化就会产生错误，实际上绑定类调用的<code>layoutInflater</code>并没有在ACT刚开始的时候就完成了初始化，你如果直接调用就会导致报错：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/facbd8d00ebeb0e3.png" alt="2"></p><pre><code class="language-shell"> Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'android.view.LayoutInflater android.view.Window.getLayoutInflater()' on a null object reference    at android.app.Activity.getLayoutInflater(Activity.java:5310)    at com.example.listviewtest.MainActivity.&lt;init&gt;(MainActivity.kt:16)    at java.lang.Class.newInstance(Native Method)    at android.app.AppComponentFactory.instantiateActivity(AppComponentFactory.java:95)    at androidx.core.app.CoreComponentFactory.instantiateActivity(CoreComponentFactory.java:45)    at android.app.Instrumentation.newActivity(Instrumentation.java:1287)    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:4148)    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:4463)     at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:111)     at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:149)     at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:103)     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2665)     at android.os.Handler.dispatchMessage(Handler.java:109)     at android.os.Looper.loopOnce(Looper.java:206)     at android.os.Looper.loop(Looper.java:296)     at android.app.ActivityThread.main(ActivityThread.java:8899)</code></pre><p>如果你对Context不够了解，你会很奇怪到底为什么？</p><p>不妨先推荐你按照如下顺序阅读下面几篇文章：</p><p>因为获取绑定类的时候使用的是layoutInflate所以关键问题就在于layoutInflate之上：</p><p><a href="https://blog.csdn.net/guolin_blog/article/details/121889703?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165215148016780357214066%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165215148016780357214066&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-121889703-null-null.nonecase&amp;utm_term=layoutinflater&amp;spm=1018.2226.3001.4450">再看LayoutInflater</a></p><p><a href="https://blog.csdn.net/guolin_blog/article/details/12921889?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165215148016780357214066%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165215148016780357214066&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-12921889-null-null.nonecase&amp;utm_term=layoutinflater&amp;spm=1018.2226.3001.4450">Android LayoutInflater原理分析，带你一步步深入了解View</a>。</p><p>等你看完了以后你会意识到LayoutInflater本质上和Context脱不了干系，每次都调用**LayoutInflater的from()**方法去获取一个LayoutInflater的实例，为什么要传context呢？</p><p>其实本质上只有一种写法：</p><pre><code class="language-kotlin">LayoutInflater layoutInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</code></pre><p>只是Android给我们做了一下封装而已。得到了LayoutInflater的实例之后就可以调用它的inflate()方法来加载布局了。这里不在多讨论这个，我们再来看一下什么是Context：</p><p><a href="https://blog.csdn.net/guolin_blog/article/details/47028975?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165232423116782248586882%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165232423116782248586882&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-6-47028975-null-null.nonecase&amp;utm_term=onCreate&amp;spm=1018.2226.3001.4450">Android Context完全解析</a>。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/1df15d4972330b74.png" alt="img"></p><p>对于ACT来说，执行过程也是大差不大，但是，ACT的layoutInflate是调用的方法获取的对象，为什么会和本ACT中的Context有关系呢？</p><p>我们再来看一下ACT到底如何获取LayoutInflate对象：</p><p><a href="https://blog.csdn.net/ruancoder/article/details/51760942?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165232543116782350911197%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165232543116782350911197&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-51760942-null-null.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Econtrol&amp;utm_term=getLayoutInflater&amp;spm=1018.2226.3001.4187">获取LayoutInflater的三种方式分析</a>。</p><p>可以看到本质上ACT调用的还是<code>LayoutInflater.from(context)</code>方法，而context方法在onCreate方法之前是没有进行加载的，所以会产生NULL报错。</p><h3><span id="那么到底该怎么用">那么到底该怎么用？</span></h3><p>回到最初的问题，那我们该怎么办呢？在合适的位置进行初始话的话就要使用lateinit关键字，通过lateinit就可以把对应的全局变量在合适的位置进行初始化。</p><p>当然Kotlin也提供了一个固定语法来检测在某个位置的全局变量，注意！是全局变量是否进行了初始化代码如下：</p><pre><code class="language-kotlin">companion object  {      private lateinit var tester: Zzy      var signal : Boolean = true      fun laterinit_tester()      {          if(!::tester.isInitialized) {              tester = Zzy()              //如果你不太清楚Zzy类是什么或者不太懂Kotlin的类请参考我的专栏文章关于Kotlin的类          }          //Log.d("tester", tester.gender)          println(tester.gender)      }}</code></pre><p><code>::tester.isInitialized</code>来获取对应变量是否进行了初始化，我们在对他取！就可以完成对他的判断了，在没有初始化的地方对其进行初始化。</p><p>zzy类的代码：</p><pre><code class="language-kotlin">class Zzy(val gender: String = "Boy") : Person(22,"zhuzeyu"){    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init    {        println(name+" is a "+gender+" age is "+age)    }    //方法调用省略this关键字演示如下：    fun this_test()    {        eat_empty()    }    fun this_tester2()    {        this_test()    }}</code></pre><p>最后运行结果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/b053645a3d413608.png" alt="4"></p><p>最后完整的代码在我的Gitee上全部开源：<a href="https://gitee.com/jszszzy/android_kotlin">Gitee地址</a>。下载压缩包即可。</p><h2><span id="kotlin的密封类和when">Kotlin的密封类和When</span></h2><p>先来回忆一下，When是如何使用的，请参考：<a href="https://blog.csdn.net/qq_20540901/article/details/123688687?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165234161016781685335776%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165234161016781685335776&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-123688687-null-null.nonecase&amp;utm_term=when&amp;spm=1018.2226.3001.4450">When的用法</a>。</p><p>我们新建一个类，用来反馈某些操作的结果：</p><pre><code class="language-kotlin">interface Resultclass  Success(val msg :String) :Resultclass  Failure(val error :Exception) :Result</code></pre><p>可以看到<strong>Success、Failure</strong>都是继承于Result接口的实现。</p><p>我们再来创建一个方法用识别返回的是成功还是失败。</p><pre><code class="language-kotlin">fun When_tester(result: Result){    when(result)    {        is Success -&gt; println(result.msg)        is Failure -&gt; println(result.error)    }}</code></pre><p>写完以后你觉得需要简写一下，因为函数只有一条语句，于是改成如下操作：</p><pre><code class="language-kotlin">fun When_tester(result: Result) =   when(result)    {        is Success -&gt; println(result.msg)        is Failure -&gt; println(result.error)    }</code></pre><p>万恶的编译检查竟然给你报错！</p><pre><code class="language-kotlin">e: D:\Android\Projects\CodeWithKotlin\app\src\main\java\com\example\codewithkotlin\Utils.kt: (25, 14): 'when' expression must be exhaustive, add necessary 'else' branch</code></pre><p>问题不大，实际上的简写原则是这样的：</p><p>当你的函数体只有 <strong>一块</strong> 作为返回值的代码时，<strong>可以直接省略大括号，用等号来连接,并且省略return关键字，因为等号足以包含返回值的意思</strong>。</p><p>也就是说你这样写他也是报错的：</p><pre><code class="language-kotlin">fun When_tester(result: Result){    return  when(result)    {        is Success -&gt; println(result.msg)        is Failure -&gt; println(result.error)    }}</code></pre><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/5ea08f7acc81ce69.png" alt="5"></p><p>实际上你的类就这样两种可能，基本没有可能出现else内的情况，但是！万恶的编译检查竟然给你报错！</p><p>不过Kotlin也针对这种情况给出了解决办法：<strong>密封类</strong>。</p><p>使用方法很简单我们把对应的接口更改成sealed class即可：</p><pre><code class="language-kotlin">sealed class Result class  Success(val msg :String) :Result()class  Failure(val error :Exception) :Result()</code></pre><p>记得把括号带上，因为这时候是class需要调用父类的构造方法。</p><p>修改好以后就发现报错消失了。可以愉快的避免else的编译检查了。</p><p>最后完整的代码在我的Gitee上全部开源：<a href="https://gitee.com/jszszzy/android_kotlin">Gitee地址</a>。下载压缩包即可。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Viewbinding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（Kotlin的标准函数和静态方法）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95)/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95)/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin的标准函数和静态方法">Android开发笔记——快速入门（Kotlin的标准函数和静态方法）</span></h1><img src="https://s2.loli.net/2024/10/04/Ash97EO3iRUGNo4.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727980663756" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Kotlin的标准函数和静态方法</a><ul><li><a href="#kotlin%E7%9A%84with%E5%87%BD%E6%95%B0">Kotlin的with函数</a></li><li><a href="#kotlin%E7%9A%84run%E5%87%BD%E6%95%B0">Kotlin的run函数</a></li><li><a href="#kotlin%E7%9A%84apply%E5%87%BD%E6%95%B0">Kotlin的apply函数</a></li><li><a href="#koltin%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Koltin的静态方法</a><ul><li><a href="#koltin%E7%9A%84%E7%9C%9F%E6%AD%A3%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">Koltin的真正静态方法</a><ul><li><a href="#jvmstatic%E6%B3%A8%E8%A7%A3"><code>@JvmStatic</code>注解</a></li><li><a href="#%E9%A1%B6%E5%B1%82%E6%96%B9%E6%B3%95">顶层方法</a></li></ul></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的标准函数和静态方法">Kotlin的标准函数和静态方法</span></h2><p>Kotlin的标准函数指的是Standard.kt文件中定义的函数，任何Kotlin代码都可以自由调用所有标准函数</p><p>比如上一次所说的Let函数就是标准函数之一。</p><h3><span id="kotlin的with函数">Kotlin的with函数</span></h3><p>with函数的参数：</p><ul><li>第一个为任意类型的对象</li><li>第二个是Lambda表达式</li></ul><p>with函数的作用：</p><ul><li>在lambda表达式中提供第一个参数作为对应的上下文</li><li>使用表达式中最后一行代码的返回值作为返回值返回</li></ul><p>那么这个函数具体有什么作用呢？看一下示例代码：</p><p>我们通过<strong>Stringbuilder</strong>对象来实现将ArrayList对象中保存的People实例转化成一个同一的字符串</p><p><img src="https://s2.loli.net/2024/10/04/1dlNVDtcP3SnJp9.png" alt="1"></p><pre><code class="language-kotlin">fun withFunTester(){    val string = StringBuilder()    val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))    with(string){        for ( people in list_people)        {            append(people).append("\n")        }        val result =string.toString()        println(result)    }}</code></pre><p>可以看到我们为了更简介的去构造这个字符串通过with函数将构造字符串的对象作为上下文来引用这样就省去了多次调用Stringbuilder的对象的麻烦。</p><p>调用结果如下：</p><p><img src="https://s2.loli.net/2024/10/04/F7zLdsUaeEBvJRc.png" alt="image-20220429233250384"></p><p>因为People类是自定义的类并没有直接重写tostring方法所以返回的是对象的的具体信息</p><h3><span id="kotlin的run函数">Kotlin的run函数</span></h3><p>run函数的参数：</p><ul><li>第一个就是Lambda表达式</li><li>需要对象直接调用此函数</li></ul><p>run函数的作用：</p><ul><li>在lambda表达式把调用对象作为对应的上下文</li><li>使用lambda表达式中最后一行代码的返回值作为返回值返回</li></ul><p>我们改写一下上一个函数使用run函数来实现：</p><pre><code class="language-kotlin">fun runFunTester(){    val string = StringBuilder()    val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))    val runFunTester= string.run {        for ( people in list_people)        {            append(people).append("\n")        }        string.toString()    }    println(runFunTester)}</code></pre><p>输出结果和上一个相同，这里不再赘述。</p><h3><span id="kotlin的apply函数">Kotlin的apply函数</span></h3><p>apply函数的参数：</p><ul><li>第一个就是Lambda表达式</li><li>需要对象直接调用此函数</li></ul><p>apply函数的作用：</p><ul><li>在lambda表达式把调用对象作为对应的上下文</li><li>apply无法指定返回值而将调用对象作为返回值返回</li></ul><p>举个例子：</p><p>可以看到实际上函数里面并没有写任何作为返回值的表达式，其返回的正是Stringbuilder的对象，只不过println自动调用的是对象的tostring方法。</p><pre><code class="language-kotlin">fun applyFunTester(){    val string = StringBuilder()    val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))    val applyFunTester= string.apply {        for ( people in list_people)        {            append(people).append("\n")        }    }    println(applyFunTester)}</code></pre><h3><span id="koltin的静态方法">Koltin的静态方法</span></h3><p>Kotlin的设计者一直在弱化静态方法这个概念，为了什么呢？因为从本质上来说Kotlin已经提供了更方便的方法来实现类似于静态方法的操作。</p><p>举个例子：</p><p>Kotlin提供了一个单例类作为静态方法的实现办法。</p><p>我们创建一个单例类，实际上JVM已经替我们创建好了一个对象，找个对象不需要你自己手动创建，而是帮你创建好了和类名相同的对象，直接</p><p><code>类名.方法</code>即可实现方法调用。</p><p>这里我们创建一个Utils类，把刚才使用的函数都放入Util类中来进行调用。</p><pre><code class="language-kotlin">object Utils{    fun withFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val withFunTester=with(string){            for ( people in list_people)            {                append(people).append("\n")            }            val result =string.toString()            println(result)        }    }    fun runFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val runFunTester= string.run {            for ( people in list_people)            {                append(people).append("\n")            }            string.toString()        }        println(runFunTester)    }    fun applyFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val applyFunTester= string.apply {            for ( people in list_people)            {                append(people).append("\n")            }        }        println(applyFunTester)    }}</code></pre><p>在main函数中直接调用即可：</p><pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;){Utils.runFunTester()}</code></pre><p>当然你会注意到有个问题，在Utils类中所有方法都是静态的，那如果我想部分函数是静态的怎么办呢？</p><p>Kotlin也提供了一个方法,<strong>伴生对象</strong>。</p><p>通过伴生对象就可以实现在一个类中既有静态也有一般方法。</p><p>我们将Utills类改为一般的类，然后使用伴生对象来实现静态和一般调用。</p><pre><code class="language-kotlin">class Utils{    fun withFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val withFunTester=with(string){            for ( people in list_people)            {                append(people).append("\n")            }            val result =string.toString()            println(result)        }    }        companion object    {        fun runFunTester()        {            val string = StringBuilder()            val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))            val runFunTester= string.run {                for ( people in list_people)                {                    append(people).append("\n")                }                string.toString()            }            println(runFunTester)        }        fun applyFunTester()        {            val string = StringBuilder()            val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))            val applyFunTester= string.apply {                for ( people in list_people)                {                    append(people).append("\n")                }            }            println(applyFunTester)        }    }}</code></pre><p>伴生对象的使用很简单，直接在普通的类中这样即可：</p><pre><code class="language-kotlin">class objext1{companion object    {        }}</code></pre><p><code>companion object</code>大括号中的内容就是伴生对象的**‘’静态方法‘’**,但需要注意的是实际上这两种方法都不是真正的静态方法，而是通过系统创建的同名对象实现的。</p><h4><span id="koltin的真正静态方法">Koltin的真正静态方法</span></h4><p>Kotlin同样提供了两种方法，来实现真正的静态方法。对于上边两种假的静态方法，如果你的代码需要在Java里面以静态的方法去调用，你会发现这些方法实际上根本不存在。而如果我们需要真正的静态方法呢？</p><h5><span id="jvmstatic注解"><code>@JvmStatic</code>注解</span></h5><p><code>@JvmStatic</code>注解只能作用在单例类或者伴生类中的方法上，如果你尝试在普通类的方法是使用这个注解就会产生报错。</p><p>举个例子：</p><pre><code class="language-kotlin">companion object{    @JvmStatic    fun applyFunTester()    {        val string = StringBuilder()        val list_people = arrayListOf(Person(19,"jszszzy"), Person(20,"jszslxl"))        val applyFunTester= string.apply {            for ( people in list_people)            {                append(people).append("\n")            }        }        println(applyFunTester)    }}</code></pre><p>那么如何调用呢？</p><p>调用的方式也很简单，就是静态方法的调用模式：</p><pre><code class="language-Kotlin">fun main(args: Array&lt;String&gt;){    Utils.runFunTester()    Utils.applyFunTester()}</code></pre><p>可以看到上边两种方法虽然在Kotlin中看起来一摸一样实际上原理并不相同。</p><h5><span id="顶层方法">顶层方法</span></h5><p>我们在前几张说过main函数有些特殊他是直接写在一个文件里面的，里面并没有包含任何类，就像这样：</p><p><img src="https://s2.loli.net/2024/10/04/QYeV3D6cK2OoiXm.png" alt="image-20220502094322826"></p><p>Kotlin的编译器会将所有顶层方法全部编译成静态方法，因此只要你定义了一个顶层方法，那么他一定是静态方法。在前几节我们使用test类作为单例类来创建静态的main方法，这里我们抛弃多余的test类，然后使用顶层方法作为mian方法让JVM调用，效果如上图所示。</p><p>那么对于顶层方法如何调用呢？</p><p>我们再将<code>withFunTester</code>方法作为顶层方法来看看如何使用：</p><p>创建一个Kotlin File后直接把方法放进去即可，效果如下：</p><p><img src="https://s2.loli.net/2024/10/04/3QR6kJuKiEzcU1j.png" alt="image-20220502095102381"></p><p>我们在main函数直接调用即可！对!不需要管路径，也不用创建实例，直接键入方法名即可：</p><p><img src="https://s2.loli.net/2024/10/04/OAltvENwy5pfSJh.png" alt="image-20220502095418638"></p><p>当然这里还是要提一嘴，如果要在java中调用Kotlin编写的静态方法怎么办？</p><p>我们创建的文件名为：Statictester.kt</p><p>当编译完成的时候，Kotlin的编译器实际上创建了一个Statictesterkt类，静态方法就按照java的静态形式定义在类里面，所以按照文件名.方法的形式来调用就行了。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（Kotlin的面对对象）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1)%20/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20(Kotlin%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1)%20/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门kotlin的面对对象">Android开发笔记——快速入门（Kotlin的面对对象）</span></h1><img src="https://s2.loli.net/2024/10/04/TU4j1YWLER9caFp.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727980774295" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#kotlin%E7%9A%84%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1">Kotlin的面对对象</a><ul><li><a href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1">类与对象</a></li><li><a href="#kotlin%E7%9A%84%E6%96%B9%E6%B3%95">Kotlin的方法</a></li><li><a href="#kotlin%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%9E%84%E9%80%A0">Kotlin的继承与构造</a></li><li><a href="#kotlin%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B">Kotlin的接口与面向接口编程</a><ul><li><a href="#%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%A2%84%E5%85%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">在接口中预先实现一个方法（默认实现）</a></li><li><a href="#%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B">面向接口编程</a></li></ul></li><li><a href="#kotlin%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6">Kotlin的可见性修饰符</a></li><li><a href="#kotlin%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%92%8C%E5%8D%95%E4%BE%8B%E7%B1%BB">Kotlin的数据类和单例类</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB">数据类</a></li><li><a href="#%E5%8D%95%E4%BE%8B%E7%B1%BB">单例类</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="kotlin的面对对象">Kotlin的面对对象</span></h2><h4><span id="类与对象">类与对象</span></h4><p>在上一节我们创建了一个类但是并没有使用，所有的代码都是通过函数实现的，这并不符合面向对象的编程的要求。至于什么是面向对象编程这里就不再多说了有兴趣的或不了解的可以去知乎看一看。</p><p>这里我们再新建一个class名叫Person。Kotlin 中使用关键字 <code>class</code> 声明类。</p><p><img src="https://s2.loli.net/2024/10/04/DF2Pz5Yp9vkL1ar.png" alt="1"></p><p>类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的； 如果一个类没有类体，可以省略花括号。</p><pre><code class="language-kotlin">class Person</code></pre><p>这样也是完全正确的。</p><p>给他添加一些字段：</p><pre><code class="language-Kotlin">package com.example.codewithkotlinclass Person{    var  age :Int =0 ;    val name  = "";}</code></pre><p>可以看到我这里使用了两种写法来提示你字段也能自动推导类型。</p><p>下面我们来考虑一下如何实例化这个类：</p><pre><code class="language-kotlin">package com.example.codewithkotlinclass Person{    var  age :Int =0 ;    val name  = "";}fun main(){    var jack = Person()    println(jack.age)}</code></pre><p>首先看到代码时你如果有Java的编程基础你会有疑问，main为什么不在类里面？而且也不是静态方法？这里暂且先放一放，我们到后边再来说这个我问题，这里先接受它，能运行，是一个程序的入口。</p><p>具体在里面呢我们实例化了一个类，你可以看看非常轻巧简单，保持着<strong>能省就省</strong>的原则，不需要类型名，不需要new关键字，直接调用类名+（）就实现了初始化：</p><pre><code class="language-Kotlin">fun main(){    var jack = Person()    println(jack.age)}</code></pre><h4><span id="kotlin的方法">Kotlin的方法</span></h4><p>方法也没什么好说的，他和函数的语法糖一摸一样，连关键字也一摸一样，你可以用一行来写一个方法的简单明了，调用的时候也是实例+.+方法。例子如下：</p><pre><code class="language-kotlin">package com.example.codewithkotlinclass Person{    var  age :Int =0 ;    val name  = "";    fun study() =  "zzy love study"}fun main(){    var zzy = Person()    println(zzy.age)    println(zzy.study())}</code></pre><p>输出结果如下：</p><p><img src="https://s2.loli.net/2024/10/04/NpirAk83Z72XQGm.png" alt="2"></p><h4><span id="kotlin的继承与构造">Kotlin的继承与构造</span></h4><p>关于继承的概念也不再详细解释，感兴趣请移步知乎。</p><p>这里直接介绍用法和技巧.</p><p>为了验证使用我们这里需要新建一个类：</p><p><img src="https://s2.loli.net/2024/10/04/UmjrRzg1743pfxh.png" alt="3"></p><p>继承的方法很简单，kotlin将关键字extends替换位：，写起来相对简单一些。可以看到如下就继承了Person类，同时也继承了其类内部的字段。</p><pre><code class="language-kotlin">class Zzy : Person(){}</code></pre><p>这里也许你会产生疑问，为啥后边还会跟一个（）？这不就是打破了能省就省的设计思想了吗？当然不是啦！</p><p>这个（）就是每个面向对象不可或缺的构造函数，只不过我们目前构造的都是无参的构造函数，在类后边就不需要写无参构造函数的括号。</p><p>在前边我们说过Kotlin的类的声明中可以省略类体和类头，在 Kotlin 中的一个类可以有一个<em>主构造函数</em>以及一个或多个<em>次构造函数</em>。主构造函数是类头的一部分：它跟在类名与可选的类型参数后。</p><pre><code class="language-kotlin">class Person constructor() { /*……*/ }</code></pre><p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 <code>constructor</code> 关键字。</p><pre><code class="language-kotlin">class Person() { /*……*/ }</code></pre><p>如果构造函数有注解或可见性修饰符，这个 <code>constructor</code> 关键字是必需的，并且这些修饰符在它前面：</p><pre><code class="language-kotlin">class Customer public @Inject constructor(name: String) { /*……*/ }</code></pre><p>那么在没有修饰符的情况下，有参数的构造函数如何写呢？我们反过来修改一下父类：</p><pre><code class="language-kotlin">open class Person(age :Int, name:String){    fun study() = name + "love study"}</code></pre><p>可以看到需要在构造函数里声明的字段就写好了，在实例化的时候就需要传入这些字段的参数：</p><pre><code class="language-kotlin">open class Person(age :Int, name:String){    val name :String = name;    var age :Int = age;    fun study() = name + "love study"}</code></pre><p>这里值得注意的是，这里的age，name和下面字段所指并不是一个，构造函数的参数只是个构造函数的局部变量，而不是成员变量，你如果想直接声明成字段的话就要显示的指定他是val还是var，指定后默认将其作为字段来初始化。</p><pre><code class="language-kotlin">open class Person(var age :Int, val name:String){    fun study() = name + "love study"}</code></pre><p>你可能还会有疑问，那我想写一些逻辑处理函数怎么办呢？Kotlin同时也提供了构造函数的函数体：</p><pre><code class="language-kotlin">open class Person(age :Int, name:String){    val name :String = name;    var age :Int = 0;//这里不初始化等到init再来初始化它。    init {        this.age = age;    }    fun study() = name + "love study"}</code></pre><p>我们再回到继承上来说，有参的父类怎么继承？很简单在对应的位置输入构造参数就行了：</p><pre><code class="language-Kotlin">package com.example.codewithkotlinclass Zzy(gender: String) : Person(22,"zhuzeyu"){}</code></pre><p>同样你也可以使用它的构造参数：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"){init {    println(name+" is a "+gender+" age is "+age)}}//输出结果zhuzeyuis a man age is 22</code></pre><p>在我们讨论完了主构造函数以后，既然有主构造函数那么一定有次构造函数，来看看他如何使用：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"){    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init {    println(name+" is a "+gender+" age is "+age)    }}</code></pre><p>使用很简单，constructor关键字就是来创建构造函数的，kotlin规定次构造函数必须要调用主构造函数，所以你可以看到this关键字来调用主构造函数。与主构造函数不同的是此构造函数有函数体，并且次构造函数没办法直接声明成员，这里需要注意一下，参数的作用范围只有在此构造函数之中。</p><p>调用实例：</p><pre><code class="language-kotlin">fun main(){    var zzy = Zzy(120,100)}输出结果：zhuzeyu is a man age is 22his iq is 120 eq is 100</code></pre><h4><span id="kotlin的接口与面向接口编程">Kotlin的接口与面向接口编程</span></h4><p>kotlin和java一样都不是多继承的面向对象编程，也就是说你只能继承一个父类，但是对于子类来说需要多继承的时候就很麻烦了，所以这里选择接口会更方便。</p><p>接口和普通类的界限在逐渐变得模糊，不管是针对java还是kotlin都是一样，可以继承多个接口，接口的继承演示如下：</p><p>继承的关键字同样被<code>：</code>所替代，和继承的父类可以直接一起使用，将它们分开就可以同时继承。</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"),Eat{    //实现了两个接口中的函数    override fun drink_soap() {        println("drink soap")    }    override fun eat_rice() {       println("eat rice")    }    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init {    println(name+" is a "+gender+" age is "+age)    }}</code></pre><p>Eat接口：</p><pre><code class="language-kotlin">interface Eat{    fun drink_soap()    fun eat_rice()}</code></pre><p>为什么说接口和普通类正在变得模糊呢？我们再来看一个操作：</p><h5><span id="在接口中预先实现一个方法默认实现">在接口中预先实现一个方法（默认实现）</span></h5><p>如果你在接口中实现了一个方法：</p><pre><code class="language-kotlin">interface Eat{    fun drink_soap(){        println("drink soap")    }    fun eat_rice()}</code></pre><p>在类的实例就可以直接不需要重写他们，IDEA也不会报错：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"),Eat{    override fun eat_rice()     {       println("eat rice")    }    constructor(iq:Int, eq:Int) : this("man")    {        println("his iq is "+iq+" eq is " + eq)    }    init     {        println(name+" is a "+gender+" age is "+age)    }}</code></pre><p>在使用的时候直接调用即可：</p><pre><code class="language-kotlin">fun main(){    var zzy = Zzy(120,100)    zzy.drink_soap()}</code></pre><h5><span id="面向接口编程">面向接口编程</span></h5><p>你如果了解面向对象，你也一定可以明白什么是面向接口，如果面向对象的方法参数传递的是对象，那么面向接口，就是传递的是接口：</p><p>我们来看一个复杂一点的例子：</p><pre><code class="language-kotlin">class Zzy(val gender: String) : Person(22,"zhuzeyu"),Eat{// 以上代码省略，新添加一个方法    fun  eat_drink_together( eat : Eat)    {        eat.drink_soap()        eat_rice()    }}</code></pre><p>在这里调用新方法，传入自己作为参数：</p><pre><code class="language-kotlin">fun main(){    var zzy = Zzy(120,100)    zzy.eat_drink_together(zzy)}</code></pre><p>这段代码可能有点稍微难理解他的目的是什么，注意看到<code>eat_drink_together</code>方法的参数实际上是一个接口，因为zzy类实现了这个接口当然也可以传入作为参数，顺理成章地调用其中的实现的抽象的方法，这里就可以叫接口的多态。</p><h4><span id="kotlin的可见性修饰符">Kotlin的可见性修饰符</span></h4><p>kotlin的修饰符存在很大的与java的不同：</p><p>可以参考一下表：</p><p><img src="https://s2.loli.net/2024/10/04/OYCuzypwlLreh1D.png" alt="3"></p><p>可以看到最大的区别有几点</p><ul><li>Kotlin中默认的类型是public而不是default。</li><li>Kotlin中没有default类型，也就是没有包级可见，Kotlin的protect类型同一包路径下也不可见（牢记没有包可见）。</li><li>新增internal类型，在同一模块下可见。</li></ul><p>可以看到kotlin和android设计首选的语言并不是全无道理，抛弃了原来java的文件构建模式，转而支持更多的android的文件架构，关于模块等到写到的时候再说。</p><h4><span id="kotlin的数据类和单例类">Kotlin的数据类和单例类</span></h4><h5><span id="数据类">数据类</span></h5><p>数据类常常用于将服务器端或数据库中的数据集映射到内存中，为编程提供数据模型的支持。简单来说就是专门用来管理数据在内存中的类。</p><p>在java中为了实现一个数据类我们通常要实现equals（）、hashCode（）方法等。kotlin保持着能省就省的原则，这些没有实际逻辑意义的代码都应该被替换掉，被替换成什么了呢？</p><p>就一个关键字：<code>data</code></p><pre><code class="language-KOTLIN">data class Exam(val exameername:String,val examname:String,val examgrade:Int)</code></pre><p>你可能会疑问为什么后边没有{}呢，在提示一下语法糖，没有代码的话可以省略的。</p><p>那么数据类怎么使用呢？</p><p>我这里定义的是考试类，参数分别是考试人名称，考试名称，考试成绩。</p><p>这里我们创建两个实体对象然后调用，.equals()方法进行匹配：</p><pre><code class="language-kotlin">val exam1 = Exam("zzy","exam1",100)val exam2 = Exam("zzy","exam1",100)if (exam1 == exam2)println("same")if(exam1.equals(exam2))println("yesyes")</code></pre><pre><code class="language-shell">sameyesyes</code></pre><h5><span id="单例类">单例类</span></h5><p>单例类是针对单例模式而特殊设计的类，它可以避免创造重复的对象，当我们希望某个类在全局最多只有一个实例的时候们就可以使用单例类。</p><p>对于java我们不再赘述，将构造函数私有化等就可以实现单例类，虽然java实现的并不复杂但是kotlin明显做的更好，我们只需要将关键字class改为object即可，不需要自己去写实现方法，操作简单。</p><p>演示：</p><p>其实在前面我们都是通过直接定义main函数来直接运行的，但是在面向对象的时候大多是是没有函数的概念，这里我们借助单例类来实现类似于java类中的main方法：</p><pre><code class="language-kotlin">object test{    @JvmStatic    fun main(args: Array&lt;String&gt;)    {        //继承等演示        var zzy = Zzy(120,100)        zzy.eat_drink_together(zzy)        //数据类演示        val exam1 = Exam("zzy","exam1",100)        val exam2 = Exam("zzy","exam1",100)        if (exam1 == exam2)            println("same")        if(exam1.equals(exam2))            println("yesyes")        //单例类演示        test.tester();    }    // 单例类方法    fun tester()    {        println("test")    }}</code></pre><p>可以看到创建了一个单例类，并且声明了两个方法，分别是main和tester方法</p><p>你可以看到main上边有一个注释@JvmStatic，你可以意识到这里的main其实并不是static的</p><p>实际上kotlin并没有static这个关键字，这个先留到以后再说，这里的main就是程序的入口，调用单例类的方法很简单而且不需要自己实例化，在启动的时候kotlin已经自动帮忙创建了所有单例类的实例化，在作用范围内调用很简单：</p><pre><code class="language-kotlin">//单例类演示test.tester();</code></pre><p>直接类名+方法即可，注意这里要和java的静态方法区别开，只是结构类似，本质完全不同，并不是静态的数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（从入门ACT到Fragment放肆）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Fragment%E4%B8%AD%E4%BD%BF%E7%94%A8Viewbinding%EF%BC%89/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Fragment%E4%B8%AD%E4%BD%BF%E7%94%A8Viewbinding%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门从入门act到fragment放肆">Android开发笔记——快速入门（从入门ACT到Fragment放肆）</span></h1><img src="https://s2.loli.net/2024/09/29/Y6ROSXiaEBhjVMG.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727616948149" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><p>[TOC]</p><!-- toc --><ul><li><a href="#%E4%BB%8E%E5%85%A5%E9%97%A8act%E5%88%B0fragment%E6%94%BE%E8%82%86">从入门ACT到Fragment放肆</a></li><li><a href="#%E8%BF%87%E5%BA%A6%E5%88%B0fragment">过度到Fragment</a><ul><li><a href="#%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8viewbinding%E9%85%8D%E5%90%88activity%E7%9A%84fragment">优雅的使用Viewbinding配合Activity的Fragment</a></li></ul></li></ul><!-- tocstop --><h2><span id="从入门act到fragment放肆">从入门ACT到Fragment放肆</span></h2><p>学习了那么多的ACT，你有没有考虑过一个问题？</p><p><strong>ACT的布局是如何和ACT的显示内容关联起来的？</strong></p><p>在理解这个问题之前需要先理解几个个问题：</p><p>什么是view？view的本质是什么？如何把布局转化为view？</p><p>接下来你可以参考文章：</p><h2><span id="过度到fragment">过度到Fragment</span></h2><p>我们都知道，Android上的界面展示都是通过Activity实现的，Activity实在是太常用了，他的缺点也很明显，同样的Activity界面在手机上显示可能很好看，在平板上就未必了，因为平板的屏幕非常大，手机的界面放在平板上可能会有过分被拉长、控件间距过大等情况。这个时候更好的体验效果是在Activity中嵌入"小Activity"，然后每个"小Activity"又可以拥有自己的布局。</p><p>这个"小Activity"就被称为<strong>Fragment</strong>。</p><p>这里使用郭神的图片来做个演示：</p><p>如果现在程序运行竖屏模式的平板或手机上，Fragment 1可能嵌入在一个Activity中，而Fragment 2可能嵌入在另一个Activity中，如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/MZJDRmSqnQ8r3j1.png" alt="image-20220621110817903"></p><p>而如果现在程序运行在横屏模式的平板上，两个Fragment就可以嵌入在同一个Activity中了，如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/TUuAlf6NBIiqLgY.png" alt="f91c86ce1773d8be"></p><p>由此可以看出，使用Fragment可以让我们更加充分地利用平板的屏幕空间，下面我们一起来探究下如何使用Fragment。</p><p>使用Fragment很简单，类似于创建Activity一样，具体操作可以参考《Anodroid第一行代码》的内容，我们这里就从View的角度去考虑Act是如何将Fragment导入到其中的。</p><p>对于一个ACT来说想要让其显示到手机上，只需要一个布局文件和一个ACT类来将布局文件加载进来就可以了，对于一个Fragment来说同样也是这样。首先我们创建两个Fragment的布局文件，让他等下填充一个ACT，简单来说就是把一个ACT用两个Fragment布局来填充。</p><p>创建的布局文件如下：</p><p><code>left_fragment.xml</code></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    android:orientation="vertical"    tools:context=".Left_fragment"&gt;    &lt;Button        android:id="@+id/button"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:layout_gravity="center_horizontal"        android:layout_marginBottom="683dp"        android:text="Button"        app:layout_constraintBottom_toBottomOf="parent"        app:layout_constraintEnd_toEndOf="parent"        app:layout_constraintStart_toStartOf="parent"        app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p>右布局如下：</p><p><code>right_fragment.xml</code></p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    android:orientation="vertical"    android:background="#00ff00"    tools:context=".Right_fragment"&gt;    &lt;!-- TODO: Update blank fragment layout --&gt;    &lt;TextView        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:layout_gravity="center_horizontal"        android:textSize="24sp"        android:text="This is right Fragment" /&gt;&lt;/LinearLayout&gt;</code></pre><p>为了直观一点我把左右布局的放上来看一看：</p><p>左布局情况：</p><p>实际上左布局就是通过约束布局在上边放置了一个水平中间对齐的按钮。</p><p><img src="https://s2.loli.net/2024/09/29/245eJwsVId3OBfZ.png" alt="image-20220621104941190"></p><p>右部局情况：</p><p>右边的布局更简单，使用线性布局并将背景颜色设置为绿色，在中间设置了一个对齐的Textview，来显示一段文字。</p><p><img src="https://s2.loli.net/2024/09/29/EIvNkZVmqOHfaud.png" alt="image-20220621105020844"></p><p>布局文件有了就是具体的类了，AS创建新的Fragment很简单，可以通过直接UI引导工具创建也可以自己新建一个Kotlin类作为Fragmen类只要继承 Fragment()就好了。</p><p>通过UI创建：</p><p><img src="https://s2.loli.net/2024/09/29/PgXhOlYuW3kGfaV.png" alt="image-20220621105240034"></p><p>左LeftFragment代码如下，如果你是通过UI创建的会帮写好很多重写的方法，目前还用不到，可以直接删除重写，具体代码如下：</p><pre><code class="language-kotlin">class Left_fragment : Fragment() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)    }    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View? {         return layoutInflater.inflate(R.layout.left_fragment,container,false)    }}</code></pre><p>通过上边针对layoutInflater的学习，我相信你能很快的理解这里onCreateView是如何工作的，在调用这个方法之前肯定是通过context对象来获取了一个LayoutInflater，我们只要正常使用这个LayoutInflater的inflate方法就可以将对应的布局加载进来，这里有个小细节是<strong>这里inflate()方法的最后一个参数一定要传入false</strong>。</p><p>在Fragment的相关源码，你会发现它会自动将我们在onCreateView()方法中返回的View添加到一个Container当中：</p><pre><code class="language-kotlin">void addViewToContainer() {    // Ensure that our new Fragment is placed in the right index    // based on its relative position to Fragments already in the    // same container    int index = mFragmentStore.findFragmentIndexInContainer(mFragment);    mFragment.mContainer.addView(mFragment.mView, index);}//版权声明：本文为CSDN博主「guolin」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/guolin_blog/article/details/121889703</code></pre><p>也就是说，后续Fragment自己会有一个addView的操作，如果我们将inflate()方法的第三个参数传入true，那么就会直接将inflate出来的布局添加到父布局当中。这样后面再次addView的时候就会发现它已经有一个父布局了，从而抛出崩溃信息。</p><p><strong>总的来说就是使用 layoutInflater来向Fragment加载了布局。</strong></p><p>同样的右Fragment的代码如下：</p><pre><code class="language-kotlin">class Right_fragment : Fragment() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)    }    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View? {        return layoutInflater.inflate(R.layout.right_fragment,container,false)    }}</code></pre><p>代码基本一摸一样没什么好说的。</p><p>接下来就是在ACT的布局中引入两个Fragment，这个更简单：</p><p>我们直接在ACT的布局中引入两个Fragment即可然后通过ID指定是布局文件中哪个Fragment，</p><p><code>android:id="@+id/rightFragment"</code>。</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".MainActivity" &gt;    &lt;fragment        android:id="@+id/rightFragment"        android:name="com.example.fragmenttest.Right_fragment"        android:layout_width="0dp"        android:layout_height="match_parent"        android:layout_weight="1"        app:layout_constraintBottom_toBottomOf="parent"        app:layout_constraintEnd_toStartOf="@+id/leftFragment"        app:layout_constraintHorizontal_weight="1"        app:layout_constraintStart_toStartOf="parent"        app:layout_constraintTop_toTopOf="parent"        app:layout_constraintVertical_bias="0.0" /&gt;    &lt;fragment        android:id="@+id/leftFragment"        android:name="com.example.fragmenttest.Left_fragment"        android:layout_width="0dp"        android:layout_height="match_parent"        android:layout_weight="1"        app:layout_constraintBottom_toBottomOf="parent"        app:layout_constraintEnd_toEndOf="parent"        app:layout_constraintHorizontal_weight="1"        app:layout_constraintStart_toEndOf="@+id/rightFragment"        app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p>我们通过        <code>app:layout_constraintHorizontal_weight="1"</code>属性来将约束布局的占比调整成1：1，最终实现效果如下：</p><p><img src="https://s2.loli.net/2024/09/29/QpG38ikaRU5XJ46.png" alt="image-20220621105739852"></p><p>当然只是使用Fragment不能算是放肆，我们来结合一点新的东西：</p><h3><span id="优雅的使用viewbinding配合activity的fragment">优雅的使用Viewbinding配合Activity的Fragment</span></h3><p>viewbinding已经出来很久了，他和LayoutInflater的最大区别在于，当我使用LayoutInflater获取加载的View对象的时候，我们只是获取了一个view对象，我们无法直接获得view中的组件，打个比方你如果其中包含了一个button的话你是无法直接获得一个button的，你需要这样：</p><p><code>view.findViewById()</code></p><p>我并不推荐这样，因为对于一个项目来说如果其中包含了大量的控件的话，<code>findViewById()</code>是通过遍历他的组件树来查找某个组件的，这会造成性能问题，虽然现在性能很强了，但是小细节还是要注意。</p><p>我们如果使用Viewbinding的话，这些问题都可以迎刃而解了，首先你如果还不太懂如何使用viewbinding的话请参考我的前一篇文章，先学习一下如何在Activity中使用viewbinding。</p><p>我们首先在Activity中创建两个绑定类，首先是Activity的绑定类，其次是左Fragment的绑定类，我们在这里先把左Fragemnt加载进来，右边的就先不要考虑。</p><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {    private lateinit var binding :ActivityMainBinding    private lateinit var leftbinding  : LeftFragmentBinding        override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        //使用viewbinding填充Activity视图        binding = ActivityMainBinding.inflate(layoutInflater)        val left_fragment: View = binding.????????        setContentView(binding.root)    }}</code></pre><p>在绑定类创建完成的时候，我们不能直接对他初始化，如果你仔细看了Viewbinding的关于Context类的介绍就知道，这时候Activity的Context还没完成，直接调用的话就会造成空指针问题。</p><p>接下来和Act中一样使用layoutInflater来将布局加载进来，加载的时候同时也将布局中的Fragment一并加载进来，这时候你就会有疑问了，那么我的Fragment在哪里呢？为什么绑定类无法获取到我的Fragment？</p><p><img src="https://s2.loli.net/2024/09/29/OQgDSIPWT8vBise.png" alt="image-20220621113055061"></p><p>实际上Fragment是一个container而不是一个Viewgroup，所以在layoutInflater中无法获取到对应的Fragment。关于Fragment并不是一个view类型，在Stackoverflow上有这样的说：</p><p><img src="https://s2.loli.net/2024/09/29/Lps6K74hyjgztn9.png" alt="10"></p><p>Fragment 标签( <code>&lt;fragment&gt;</code>) 并不是一个 <code>view</code>而是一个<code>container</code>类型，所以Viewbinding是无法直接获取到的，即使我在Fragment布局文件中包含了某个Fragment的id。如下图：</p><p><img src="/home/neo/%E6%96%87%E7%AB%A0/Android/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Fragment%E4%B8%AD%E4%BD%BF%E7%94%A8Viewbinding%EF%BC%89.assets/12.png" alt="12"></p><p>实际上即使有ID的但是还是无法获取，我同时在stackoverflow上看到了这样的介绍，我觉得是最容易理解的：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/21/3ce882914ef5dafd.png" alt="13"></p><p>普通的Lauout都是直接继承于ViewGroup，像是<code>LinearLayout</code>，<code>RelativeLayout</code>这些实际上是继承于ViewGroup的类，这些类的后缀之中都包含着<code>Lauout</code>。</p><p>而<code>container</code>类型更像是view的桶，里面放着动态的内容他相对于Views他可以继承一个Layouts类同样也可以不继承，其中很多实际上没有直接继承<code>Viewgroup</code>像<code>Listview</code>，而有些直接就选择不继承，像<code>VideoView</code>就是这样虽然<code>container</code>标签被用于在AS中，但它不是任何一个类的名称。</p><p>你可能会想这还不简单？我这样写就能创建一个<code>Fragement</code>的绑定类了：</p><pre><code class="language-kotlin">leftbinding =LeftFragmentBinding.inflate(layoutInflater,binding.root,true)</code></pre><p>错！仔细看上文中<code>layoutInflater</code>的介绍，<code>LayoutInflater</code>的inflate方法实际上是唯一加载布局的方法，加载布局就是把布局转化为view对象，我们在这里调用了一个<code>LeftFragmentBinding.inflate()</code>方法实际上是重新加载了一个布局，而不是使用Activity中的Fragement！</p><p>效果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/21/fed6d742e3c3afcf.png" alt="image-20220621113929146"></p><p>这当然不是我们想要的，那么到底如何访问到Fragment的button组件呢？</p><p>其实很简单，我们只需要将绑定类绑定到Activity的中Fragment中即可</p><pre><code class="language-kotlin">leftbinding = LeftFragmentBinding.bind(binding.root)</code></pre><p>这时候这个绑定类实际上就是Activity中的Fragment的绑定类！</p><p>我们就可以通过这个绑定类来获取到button组件。</p><p>完整代码如下：</p><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {    private lateinit var binding :ActivityMainBinding    private lateinit var leftbinding  : LeftFragmentBinding        override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding = ActivityMainBinding.inflate(layoutInflater)        //绑定对应的Fragment视图上        leftbinding =LeftFragmentBinding.bind(binding.root)        leftbinding.button.setOnClickListener {             //button的点击操作        }        setContentView(binding.root)    }    }</code></pre><p>你觉得这样就完成了吗！大错特错！能运行就说明你用的对吗？</p><p>我们在这里打破砂锅问到底！</p><p>这里需要注意的细节是并不是所有布局都可以随意绑定的，在Activity中的Fragment实际上是囊括在一个约束布局之中的,我们回忆一下，Fragment实际上并不是一个view而是一个存放view的容器。</p><p><img src="Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Fragment%E4%B8%AD%E4%BD%BF%E7%94%A8Viewbinding%EF%BC%89.assets/14.png" alt="14"></p><p>我们再来回看一个例子，说为什么这里将Fragment绑定到binding.root上是不正确的。</p><p>我们看一下我刚刚绑定的左边的Fragment，还有一个右边的Fragment我们没有尝试绑定：</p><p>他的布局是什么呢？</p><pre><code class="language-kotlin">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    android:orientation="vertical"    android:background="#00ff00"    tools:context=".Right_fragment"&gt;    &lt;TextView        android:id="@+id/text"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:layout_gravity="center_horizontal"        android:textSize="24sp"        android:text="This is right Fragment" /&gt;&lt;/LinearLayout&gt;</code></pre><p>是一个由<code>LinearLayout</code>内部包含的<code>TextView</code>组成的布局，按道理来说绑定也很简单对吧：</p><pre><code class="language-kotlin">rightbinding=RightFragmentBinding.bind(binding.root)    </code></pre><p>当我们尝试绑定的结果是什么呢？</p><p>竟然报错啦！</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/21/f4faea41eb14ede6.png" alt="0"></p><pre><code class="language-shell">E/AndroidRuntime: FATAL EXCEPTION: main    Process: com.example.fragmenttest, PID: 27502    java.lang.RuntimeException: Unable to start activity ComponentInfo{com.example.fragmenttest/com.example.fragmenttest.MainActivity}: java.lang.ClassCastException: androidx.constraintlayout.widget.ConstraintLayout cannot be cast to android.widget.LinearLayout</code></pre><p>怎么会报错呢？<code>java.lang.ClassCastException: androidx.constraintlayout.widget.ConstraintLayout cannot be cast to android.widget.LinearLayout</code></p><p>为什么说是把<code>ConstraintLayout</code> 强转成<code>LinearLayout</code>失败呢？</p><p>要了解这个问题我们就要去看看bind的代码是什么，可惜的是由于它是以插件辅助的形式存在，实际上你是无法直接访问到对应的绑定类的，这就基本告别了bind方法是如何实现的，不过好在我找到了Google的开发人员书写的Viewbinding的指南</p><p><a href="https://medium.com/androiddevelopers/use-view-binding-to-replace-findviewbyid-c83942471fc">原文链接</a>。</p><p>对于bind方法他大致的样子是这样的：</p><pre><code class="language-java"> @NonNull  public static 某个bidning类 bind(@NonNull View rootView)   {    /* Edit: Simplified code – the real generated code is an optimized version */    TextView textview = rootView.findViewById(R.id.subtext);         if (textview != null)     {      return new 某个bidning类的构造方法 ((ConstraintLayout) rootView, textview);//注意这里有一个强转操作    }    throw new NullPointerException("Missing required view […]");  }</code></pre><p>他的方法很简单，就是将这个布局里面的所有组件通过<code>findViewById</code>方法获取到<code>view</code>对象，然后通过构造方法构造一个绑定类进行返回。</p><p>我们再来看一下绑定类的构造方法：</p><pre><code class="language-kotlin">private 某个bidning类的构造方法 (@NonNull 根布局的类型 rootView, @NonNull TextView textview/*此处应包含所有的子组件，这里只有一个textview所以只需要传入一下textview就可以*/){ … }</code></pre><p>虽然没有详细写，但是我们知道根据视图生成的绑定类实际上的rootview是整个布局的根布局，对于<code>rightbinding</code>来说我们实际上的rootview应该是一个<code>LinearLayout</code>，我们调用bind方法的时候获取的<code>binding.root</code>实际上是Activity的根部局，是<code>constraintlayout</code>，所以产生了强转错误，也就是说我们绑定的对象根本不对！实际上应该怎么写呢？</p><p>我们先来确认一下对于Activity加载进来的view对象构成是什么样，rightFragment的父组件是什么？rightFragment是什么布局？我们通过Log来输出以下结果：</p><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {                                                                                        private lateinit var binding :ActivityMainBinding              private lateinit var leftbinding  : LeftFragmentBinding        private lateinit var rightbinding  : RightFragmentBinding                                                                     override fun onCreate(savedInstanceState: Bundle?)             {                                                                  super.onCreate(savedInstanceState)                             binding = ActivityMainBinding.inflate(layoutInflater)          setContentView(binding.root)                       val rightfragment: View =findViewById(R.id.rightFragmen)        val Textview :View = findViewById(R.id.text)                                            Log.e("tester",Textview.parent.toString())                     Log.e("tester",Textview.parent.parent.toString())                  Log.e("tester",rightfragment.toString())                       Log.e("tester",rightfragment.parent.toString())                        Log.e("tester",binding.root.toString())                        Log.e("tester",binding.root.rootView.toString())          }}</code></pre><p>这里通过万能的<code>findViewById</code>来获取Activity中Fragment的组件，将其中的textview和fragment本身提取出来，输出看一下其对应的类型和父类对应的类型。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/21/d754d43aa68a0b02.png" alt="15"></p><pre><code class="language-shell">2022-05-18 23:29:47.132 12020-12020/com.example.fragmenttest E/tester: android.widget.LinearLayout{aa4256a V.E...... ......ID 0,0-0,0 #7f08012b app:id/rightFragment}2022-05-18 23:29:47.132 12020-12020/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0}2022-05-18 23:29:47.132 12020-12020/com.example.fragmenttest E/tester: android.widget.LinearLayout{aa4256a V.E...... ......ID 0,0-0,0 #7f08012b app:id/rightFragment}2022-05-18 23:29:47.132 12020-12020/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0}2022-05-18 23:29:47.132 12020-12020/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0}</code></pre><p>可以看到textview的父类其实是一个<code>Linearlayout</code>，而<code>Linearlayout</code>的父类其实是一个<code>ConstraintLayout</code>也就是Activity布局文件的最外层的<code>ConstraintLayout</code>。</p><p>而bind方法你也能看到,实际上它是将现有view绑定到这个类之中，所以我们应该绑定的是其对应的Fragment，而不是对应的<code>ConstraintLayout</code>。获取到对应的Fragment的外层布局也很简单，我们只要通过</p><pre><code class="language-kotlin">val rightfragment: View =findViewById(R.id.rightFragment)</code></pre><p>获取即可，有人说我用viewbinding不就是为了避免用<code>findViewById</code>吗？这个问题需要得到正视，因为在</p><p>bind方法中实际上也是使用<code>findViewById</code>来获取的，view binding的核心在于类型安全和快捷，减少多余的代码量，实际上是一种<code>findViewById</code>的封装。</p><p>最后在针对上文的错误结果查看一下：</p><p>对于绑定的布局我们再次输出他的根部局类型和他本身的布局类型：</p><pre><code class="language-kotlin">Log.e("tester",leftbinding.root.toString())Log.e("tester",leftbinding.button.parent.toString())//修正绑定对象val left_fragment: View =findViewById(R.id.leftFragment)leftbinding =LeftFragmentBinding.bind(left_fragment)Log.e("tester",leftbinding.root.toString())  Log.e("tester",leftbinding.button.parent.toString())</code></pre><p>结果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/21/7f0507d081ce62b9.png" alt="16"></p><pre><code class="language-shell">2022-05-19 08:18:31.215 10392-10392/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{aa4256a V.E...... ......I. 0,0-0,0}2022-05-19 08:18:31.215 10392-10392/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0 #7f0800c9 app:id/leftFragment}2022-05-19 08:18:31.216 10392-10392/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0 #7f0800c9 app:id/leftFragment}2022-05-19 08:18:31.216 10392-10392/com.example.fragmenttest E/tester: androidx.constraintlayout.widget.ConstraintLayout{5466a5b V.E...... ......I. 0,0-0,0 #7f0800c9 app:id/leftFragment}</code></pre><p>可以看到当使用binding.root直接作为绑定对象的时候，leftbinding的根部局是错误的不应该为Act的外层布局，修正以后变为Fragment的根部局。有时候代码能运行完全就是运气！</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Fragment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（入门Service）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Service%EF%BC%89/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Service%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门入门service">Android开发笔记——快速入门（入门Service）</span></h1><img src="https://s2.loli.net/2024/10/04/GgvAfI4DCxnYPJT.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727980973253" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#android%E7%9A%84service">Android的Service</a></li><li><a href="#android%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C">Android的多线程操作</a></li><li><a href="#android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6">Android异步消息处理机制</a><ul><li><a href="#asynctask">AsyncTask</a></li><li><a href="#android-%E7%9A%84service">Android 的Service</a><ul><li><a href="#%E4%B8%8Eactivity%E7%B4%A7%E5%AF%86%E7%BB%93%E5%90%88">与Activity紧密结合</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%9C%A8act%E4%B8%AD%E7%BB%91%E5%AE%9Aservice">如何在Act中绑定Service？</a></li></ul></li></ul></li><li><a href="#%E6%B3%A8%E6%84%8F">注意</a><ul><li><a href="#service%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Service生命周期</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><h2><span id="android的service">Android的Service</span></h2><p>Service是为了解决那些不需要和用户通过界面交互但还是需要长期运行的程序需求，Service的运行不依赖于任何界面，即使程序切换到后台，或者用户打开了另一个应用程序，Service依然能在后台稳定运行。</p><p>不过Service的实现并不是单独创建了一个进程，而是依赖于创建Service的进程，当某个程序被kiil掉之后，依赖于该进程的Service也会被Kill掉。</p><p>更需要注意的是，Service不会自动开启线程去处理内部的操作，实际上是需要你手动开启线程来处理操作，否则就有可能导致主界面内容不刷新（主线程操作被Service占满了）。</p><p>下面来介绍一下，Android如何开启线程。</p><h2><span id="android的多线程操作">Android的多线程操作</span></h2><p>Android的多线程操作基本就是移植Java的操作，在kotlin中使用Java的API我们常常是用lambda表达式来创建一个线程，类似于如下所示：</p><pre><code class="language-kotlin">Thread(){    println("YES")}.start()</code></pre><p>实际上Kotlin提供了更方便快捷的函数来实现操作：</p><pre><code class="language-kotlin"> thread {      println("YES") }</code></pre><p>他实现的方法就是对Java接口的再封装：</p><pre><code class="language-kotlin">public fun thread(    start: Boolean = true,    isDaemon: Boolean = false,    contextClassLoader: ClassLoader? = null,    name: String? = null,    priority: Int = -1,    block: () -&gt; Unit): Thread {    val thread = object : Thread() {        public override fun run() {            block()        }    }    if (isDaemon)        thread.isDaemon = true    if (priority &gt; 0)        thread.priority = priority    if (name != null)        thread.name = name    if (contextClassLoader != null)        thread.contextClassLoader = contextClassLoader    if (start)        thread.start()    return thread}</code></pre><h2><span id="android异步消息处理机制">Android异步消息处理机制</span></h2><p>我们知道多线程的情况下，有可能存在线程数据不安全的问题，Android提供了一套异步处理机制，来保证数据的安全，当你需要在一个线程中去操作另一个线程中的内容的时候，就可以使用这一套机制来实现数据修改。</p><p>在Android中所有的UI界面显示的数据都是线程不安全的，也就是说你无法在其他线程直接访问UI的数据并修改其中的内容，因为这样会导致抛出线程不安全的异常。有些时候，我们必须在子线程里面执行一些耗时的任务，然后根据任务结果来更新UI的内容。</p><p>在讨论这个部分之前，请先参考部分Kotlin语法的内容。在完全了解异步线程机制的之前，我们不妨来先写一个试试。</p><p>下面我们来举个例子：</p><p>我们为了实现音乐播放器在暂停的时候显示音乐已经暂停的文本，我们在界面之中放置一个TextView来显示一些信息，再通过一个线程来修改它，具体代码如下：</p><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {    lateinit var binding : ActivityMainBinding    val SongisPause = 1    val handler = object : Handler(Looper.getMainLooper()) {        override fun handleMessage(msg: Message) {            super.handleMessage(msg)            when (msg.what){                SongisPause -&gt; binding.textView.text ="Song is Pause"            }        }    }             override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding= ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)                 binding.stop.setOnClickListener {            thread {                val msg = Message()                msg.what = SongisPause                handler.sendMessage(msg)            }        }     }    }</code></pre><p>这段代码看起来很复杂难以理解，我们不妨在再拆开看一看：</p><p>在类的开始我们初始化了一些变量和对象：</p><pre><code class="language-kotlin">lateinit var binding : ActivityMainBindingval SongisPause = 1val handler = object : Handler(Looper.getMainLooper()) {    override fun handleMessage(msg: Message) {        super.handleMessage(msg)        when (msg.what){            SongisPause -&gt; binding.textView.text ="Song is Pause"        }    }}</code></pre><p>前两个就不再多说分别是一个绑定对象和一个一般的变量，需要仔细了解的是下面的这一个对象，这个handler使用了对象表达式来构造自己，他继承了Handler类，看到名字你也应该能猜到他是具体干什么的，他就是处理，具体去操作的函数。不过为什么这里要声明一个具体操作的函数，其背后原理的概念我们晚点再说，这里先理解最后线程的操作归咎于这里。</p><pre><code class="language-kotlin">binding.stop.setOnClickListener {    thread {        val msg = Message()        msg.what = SongisPause        handler.sendMessage(msg)    }}</code></pre><p>我们又在onCreate函数里面为暂停按钮绑定了一个回调函数，在回调函数里面我们使用thread函数创建了一个线程去处理暂停的操作，实际上我们是创建了一个message来向刚才创建的handler发送了一条消息，提示他该暂停了，当handler接收到了消息以后就会执行刚刚注册到handler的操作。</p><p>最终先效果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/26/ba6f7fd04f661604.png" alt="And"></p><p>看完以后你可能一脸懵，什么鬼？我们再来讨论一下，其背后实现的原理。</p><p>实际上我们可以注意到，接受收消息处理的操作还是在主线程中完成的，并不是在子线程中完成的，子线程实际上只是发送了meaasge，可是，message、handler和隐藏在背后的looper、MessageQueue都是什么呢？</p><p>Message：</p><p>是在线程中间传递的消息，它可以携带少量的内部信息，用于在不同线程之间传递数据，上一节我们使用了Message的what字段，除此之外他还包含arg1、arg2字段，用来携带一些整型数据，还有obj字段用来携带一个Object对象。</p><p>Handler：</p><p>它主要用于发送和处理信息，发送消息一般使用sendMessage和Post方法，而发出的消息经过内部处理以后，最终会传递到Handler的handleMessage方法当中。</p><p>MessageQueue：</p><p>是隐藏在消息背后的数据解构，里面以队列的形式存放着所有通过Handler发送的消息。这部分消息会一直存放在队列中，直到被取出后处理。每一个线程中最多只允许存在一个MessageQueue对象。</p><p>Looper</p><p>Looper是每个线程中的管家，调用Looper以后会进入到loop方法中，这是一个无限循环，每当MessageQueue中存放着一条消息的时候们就会将它自动取出来，并将消息内容传递到handleMessage()方法中。</p><p>我们主要来说一说Looper和MessageQueue是在哪里创建的，以及他们是如何串起来工作的。</p><p>Loop很简单，在主线创建的时候，就会自动产生一个属于主线程的looper对象，我们一般通过以下方式获取到looper对象：</p><ol><li>使用Looper静态方法getMainLooper()</li><li>使用Looper的静态方法获取到当前线程的Looper对象。</li></ol><pre><code class="language-kotlin">Looper.getMainLooper()</code></pre><p>一般情况下我们不会去手动创建一个loop去和某个线程产生关联，大多数直接调用拥有Looper的线程，比如主线程，如果想要创建的话请参考：<a href="https://developer.android.google.cn/reference/android/os/Looper#getMainLooper%28%29">Looper文档</a>。</p><p>MessageQueue其中的技术细节我们不探讨，我只考虑如何创建的MessageQueue以及MessageQueue是如何前边几个对象产生关联的。</p><p>在Hnadler接口的初始化函数里面我们可以看到：</p><pre><code class="language-java">@UnsupportedAppUsagepublic Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) {    mLooper = looper;    mQueue = looper.mQueue;    mCallback = callback;    mAsynchronous = async;}</code></pre><p>队列直接和looper是相互存在的，我们在looper的内部构造函数中可以看到，在Looper创建的时候就会创建配套的MessageQueue。</p><pre><code class="language-kotlin">private Looper(boolean quitAllowed) {    mQueue = new MessageQueue(quitAllowed);    mThread = Thread.currentThread();}</code></pre><p>也就是说在一个线程里面，创建了Looper就相当于创建好了两个通信组件，Looper和MessageQueue是相互绑定的。</p><p>那么Looper是如何和Handler来产生关联的呢？</p><p>很简单就在Handler的构造函数啊，可别忘了我们是传入了一个Looper进去的。</p><pre><code class="language-kotlin">val handler = object : Handler(Looper.getMainLooper())</code></pre><p>那么在looper里面是如何调用我传入的处理函数呢？详细解答请看：stackoverflow上一个大佬的解释：<a href="https://stackoverflow.com/questions/14030534/how-the-looper-knows-to-send-the-message-to-handler">连接</a>。</p><p>这里不再做过多解释。最后放一张图来帮助你理解：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/26/b0df7efa37bcc9bf.png" alt="Servic-1"></p><p>当然更具体的详解可以看：</p><p><a href="https://blog.csdn.net/qq_39431405/article/details/113716185">同步异步消息详解</a>。</p><p><a href="https://stackoverflow.com/questions/38818642/android-what-is-message-queue-native-poll-once-in-android">为什么looper一直循环却不占满cpu？</a></p><h3><span id="asynctask">AsyncTask</span></h3><p>AsyncTask是另一种多线程工具， 借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单的从子线程切换到主线程。当然Async背后也是上述异步消息处理机制构成的，只是Android提供了更好的封装组成了的AsyncTask。</p><p>首先我们来看一下用法：</p><p>AsyncTask是个抽象类，如果我们想使用它，就必须创建一个子类去继承他，在继承的时候，可以为其指定三个泛型参数，这三个参数的用途如下：</p><p>Params  在执行AsyncTask时候需要传入的参数，可用于后台任务中使用。</p><p>Progress 在后台任务执行的时候，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为单位。</p><p>Result 当任务执行完毕以后，如果需要对结果进行返回，则这里指定的泛型作为返回值类型。</p><pre><code class="language-kotlin">inner class Download: AsyncTask&lt;Unit, Int, Boolean&gt;() {}</code></pre><p>我们在这里将Params设置为Unit代表线程是不需要参数的设置为Unit。至于这样设置效果是什么请看下边的方法，同时还存在四个需要重写的方法：</p><ul><li>onPreExecute()</li></ul><p>​这个方法会在后台任务开始之前调用，用于进行一些界面上的初始化操作，比如显示一下进度条对话框等。</p><ul><li>doInBackground(Params )</li></ul><p>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有耗时的任务。任务一旦完成，就可以通过return语句将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Unit，就可以不返回任务执行结果.注意此方法中是不可以进行UI操作的，因为此时实际上是在另一个线程并不是在主线程。如果需要反馈任务进度，可以调用publishProgress来实现。</p><ul><li>onProgressUpdate(Progress)</li></ul><p>当后台任务调用了 pulishProgress（Progress）方法以后，onProgressUpdate方法就很快会被调用，该方法中携带的参数是在后台任务传递过来的。在这个方法中可以针对UI进行操作，利用参数中的数值，可以对界面元素进行更新。</p><ul><li>onPostExecute(Result)</li></ul><p>当后台任务之执行完毕并通过return语句进行返回的时候，这个方法很快就会被调用，返回的数据会作为参数传递到此方法当中。可以利用返回的数据进行一些UI操作，比如提醒任务执行的结果，以及关闭进度条等。</p><pre><code class="language-kotlin">inner class Download: AsyncTask&lt;Unit, Int, Boolean&gt;() {     override fun onPreExecute() {         super.onPreExecute()         binding.progressBar.visibility=View.VISIBLE     }     override fun onPostExecute(result: Boolean?) {         super.onPostExecute(result)         if(result == true) {             binding.progressBar.setProgress(100,true)             binding.textView.text="Jszszzy"         }     }    override fun doInBackground(vararg params: Unit?): Boolean {        Log.d("doInBackground","This is background")        publishProgress(10)        return true    }    override fun onProgressUpdate(vararg values: Int?) {         super.onProgressUpdate(*values)        values[0]?.let { binding.progressBar.setProgress(it,true) }        Toast.makeText(baseContext,"Downloading",Toast.LENGTH_SHORT).show()     } }</code></pre><p>我们将第二参数设置为Int，这样调用publishProgress()的时候，切换到主线程，并且给主线程的方法传入一个参数为Int,这样我们就可以获得具体的参数，并且在主线程中更新U。</p><p>可惜的是，目前AsyncTask API 在Android10 已经被弃用，目前推荐的是使用协程来实现相同的操作，这个我们在Kotlin专栏里面再去讨论，接下来直接进入Service。</p><h3><span id="android-的service">Android 的Service</span></h3><p>创建一个Service，我们在项目的顶层包下右键，new-&gt;Service-&gt;Service。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/26/169026e4d4df6fea.png" alt="service"></p><p>创建一个以后我们再来重写几个方法：</p><pre><code class="language-kotlin">class PlayerService : Service() {    override fun onBind(intent: Intent): IBinder {    }    override fun onCreate() {        super.onCreate()    }    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {        return super.onStartCommand(intent, flags, startId)    }    override fun onDestroy() {        super.onDestroy()    }}</code></pre><p>其中：</p><p>onCreate方法在Service创建的时候调用。</p><p>onStartCommand方法在每次Service启动的时候调用。</p><p>onDestory方法会在Service销毁的调用。</p><p>关于具体的生命周期和调用我们留到生命周期部分再来详细说。</p><p>实际上在我们通过Service向导创建以后，AS在Manifest文件中帮我们声明好了对应的Service，所有的Service都需要在Manifest文件中声明以后才能使用。实际上Android的四大组件都需要在Manifest文件中来声明。</p><pre><code class="language-xml">&lt;service    android:name=".PlayerService"    android:enabled="true"    android:exported="true"&gt;&lt;/service&gt;</code></pre><h4><span id="与activity紧密结合">与Activity紧密结合</span></h4><p>虽然Service是在Activity中启动的，但是启动了之后好像与Activty并没有什么太大关系了，但是如果我们想让Service和Act有一点交流呢？比如传递个参数什么的，比如我们有些时候需要在Act中去控制Service的一些方法，让他去进行一些任务的操作，这就需要我们刚刚专门没有说的onBind()方法了。</p><p>修改Service类，创建一个Binder对象，用来向Act提供内部的方法。</p><pre><code class="language-kotlin">inner class PlayerBinder:Binder() {     fun initPlayer(){         initMediaPlayer()     } }</code></pre><p>在类里面创建成员：</p><pre><code class="language-kotlin">private val mBinder = PlayerBinder()</code></pre><p>同时在onBind方法中返回对象，在Act绑定的时候会带调用这个方法，并将绑定对象返回给Act中的绑定方法。</p><pre><code class="language-kotlin">override fun onBind(intent: Intent?): IBinder {    return mBinder}</code></pre><h5><span id="如何在act中绑定service">如何在Act中绑定Service？</span></h5><p>首先创建一个与Service连接的类，这里我们使用对象表达式，连同对应的对象一起创建了：</p><pre><code class="language-kotlin">private  val connection = object : ServiceConnection{        override fun onServiceConnected(name: ComponentName?, service: IBinder) {        playerBinder = service as PlayerService.PlayerBinder        Log.e("jszszzy",playerBinder.toString())        playerBinder.initPlayer()    }        override fun onServiceDisconnected(name: ComponentName?) {    }}</code></pre><p>创建ServiceConnection的实体对象需要实现其中的量抽象方法：</p><p>onServiceConnected是在Act与Service建立连接完成的时候回调的，传入的参数包含binder对象，实际上就是通过刚才创建的binder类构造的，在创建的时候会调用Service的onBind方法来返回一个binder对象。</p><p>我们当然可以在这个方法中获取到对应的绑定对象，通过绑定对象就可以在下文代码中使用Binder对象中的方法。</p><p>比如在这里我们使用了一个初始化播放器的方法，就是直接调用binder对象中的的方法。当然你也可以直接在Act中创建一类成员（<code>lateinit var binding : ActivityMainBinding</code>），让他直接获取到binder中的方法，这样你就可以在Act中的任意位置获取到binder对象，并调用他其中的方法。</p><pre><code class="language-kotlin">class MainActivity : BaseActivity() {    lateinit var binding : ActivityMainBinding    lateinit var playerBinder: PlayerService.PlayerBinder    private  val connection = object : ServiceConnection{        override fun onServiceConnected(name: ComponentName?, service: IBinder) {            playerBinder = service as PlayerService.PlayerBinder            Log.e("jszszzy",playerBinder.toString())            playerBinder.initPlayer()        }        override fun onServiceDisconnected(name: ComponentName?) {        }    }}</code></pre><p>你可能注意到了里面其实还有一个onServiceDisconnected方法，它只有在Service创建进程崩溃或者被杀掉的时候才会调用，这个方法不太常用，所以空着不写。</p><p>当然到这里还没有进行绑定呢，绑定的方式也很简单，我们来举个例子：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {     val intent = Intent(this, PlayerService::class.java)     bindService(intent, connection, Context.BIND_AUTO_CREATE)}</code></pre><p>我们直接在onCreate回调中执行绑定的代码，先构造要绑定的Service意图，这和前边的intent差不多，这里就不再赘述，再通过context的<code>bindService</code>方法，传入<code>intent</code>，和刚才构造的<code>ServiceConnection</code>对象，还有一个标志位<code>Context.BIND_AUTO_CREATE</code>，其代表的意思是，在Act和Service绑定的时候自动创建一个Service对象，<strong>其实就是调用OnCreate方法，但是这个过程中，onStartCommand()方法并不会执行。</strong></p><p>解除绑定的方法也很简单，使用unbindService方法即可解除绑定，同<strong>时Service也会执行onDestroy方法来销毁Service。</strong></p><p>我们为界面一个名为stop按钮添加一个解绑的回调函数：</p><pre><code class="language-kotlin">binding.stop.setOnClickListener {    playerBinder.stopPlayer()    unbindService(connection)}</code></pre><h3><span id="注意">注意</span></h3><p>Service这个功能是一个极其特殊的功能功能，他在绑定的时候部分代码过程并不是在主线程完成的，虽然我们知道Service只是一个长久运行的模块，他不创建进程，也不创建线程，他需要运行的时候是直接在主线程中运行的，但是初始化的时候是通过Android AMS来帮助创建的，这就会导致一个问题，即我在某个阶段直接去调用它的初始化函数可能导致，变量没有被正确赋值，因为在其他AMS还没有执行到对应的赋值代码。举个例子：</p><p>如果我们绑定调用完就立马执行binder里面的方法就会报错：</p><p>我们不再在OnCreate方法里面绑定我们在一个按钮的会带函数里面绑定并且调用绑定的方法：</p><pre><code class="language-kotlin">binding.play.setOnClickListener {    val intent = Intent(this, PlayerService::class.java)    bindService(intent, connection, Context.BIND_AUTO_CREATE)    playerBinder.startPlayer()}</code></pre><p>我们点击按钮就会产生报错：</p><pre><code class="language-powershell">E/AndroidRuntime: FATAL EXCEPTION: main    Process: com.example.audiotest, PID: 709    kotlin.UninitializedPropertyAccessException: lateinit property playerBinder has not been initialized        at com.example.audiotest.MainActivity.getPlayerBinder(MainActivity.kt:17)        at com.example.audiotest.MainActivity.onCreate$lambda-0(MainActivity.kt:49)        at com.example.audiotest.MainActivity.$r8$lambda$NLfemTBvJsTkHif14Uhm1FqFVaI(Unknown Source:0)        at com.example.audiotest.MainActivity$$ExternalSyntheticLambda1.onClick(Unknown Source:2)        at android.view.View.performClick(View.java:7603)        at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1119)        at android.view.View.performClickInternal(View.java:7577)        at android.view.View.access$3800(View.java:865)        at android.view.View$PerformClick.run(View.java:29375)        at android.os.Handler.handleCallback(Handler.java:955)        at android.os.Handler.dispatchMessage(Handler.java:102)        at android.os.Looper.loopOnce(Looper.java:206)        at android.os.Looper.loop(Looper.java:296)        at android.app.ActivityThread.main(ActivityThread.java:8899)        at java.lang.reflect.Method.invoke(Native Method)        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:569)        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:976)</code></pre><p>实际上就是我们的binder对象没有初始化完成，就在主线程里调用了binder的方法。所以绑定和调用需要分开在两个不同的阶段，以保证绑定的时候binder对象被正确的赋值。</p><h4><span id="service生命周期">Service生命周期</span></h4><p>我们在每一个回调函数里面加入Log来提示对应的生命周期，具体的代码如下：</p><pre><code class="language-kotlin">class PlayerService : Service() {    override fun onBind(intent: Intent?): IBinder? {        TODO("Not yet implemented")    }    override fun onCreate() {        super.onCreate()        Log.d("Service","This is onCreate Service")    }    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {        Log.d("Service","This is onStartCommand Service")        return super.onStartCommand(intent, flags, startId)    }    override fun onDestroy() {        Log.d("Service","This is onDestroy Service")        super.onDestroy()    }}</code></pre><p>我们在主函数中向一个button中添加按钮事件，按下按钮的时候开启Service,在另一个按钮按下的时候关闭Service。</p><p>当我们按下开启的按钮的时候，对应回调执行如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/26/c0a3d0922b8d7fde.png" alt="service-1"></p><p>当我们按下结束的时候：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/26/9f10bc948c9cc030.png" alt="service-2"></p><p>下面来说一下，onCreate，onStartCommand存在什么区别，onStartCommand在每次Service启动的时候都会去调用这个方法，而onCreate方法只有在第一次Service被调用创建的时候才会使用，Service启动了之后，会一直保持启动状态，直到stopService或者stopSelf方法被调用的时候Service才会停止。</p><p>这都是很常规的情况，如果一个Service被startService()和bindService()同时调用，那么在这种情况下就需要调用stopService和unbindService方法，这样OnDestory才会执行。</p><p>代码留档：</p><pre><code class="language-kotlin">package com.example.audiotestimport android.content.Intentimport android.media.MediaPlayerimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.os.Handlerimport android.os.Looperimport android.os.Messageimport com.example.audiotest.databinding.ActivityMainBindingimport kotlin.concurrent.threadclass MainActivity : AppCompatActivity() {    lateinit var binding : ActivityMainBinding    private val mediaPlayer = MediaPlayer()    val SongisPause = 1    val handler = object : Handler(Looper.getMainLooper()) {        override fun handleMessage(msg: Message) {            super.handleMessage(msg)            when (msg.what){                SongisPause -&gt; binding.textView.text ="Song is Pause"            }        }    }    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding= ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        initMediaPlayer()        binding.play.setOnClickListener {            val intent = Intent(this,PlayerService::class.java)            startService(intent)            if (!mediaPlayer.isPlaying)            {                mediaPlayer.start()            }        }        binding.stop.setOnClickListener {            thread {                if (mediaPlayer.isPlaying){                    val intent = Intent(this,PlayerService::class.java)                    stopService(intent)                    val msg = Message()                    msg.what = SongisPause                    handler.sendMessage(msg)                    mediaPlayer.reset()                    initMediaPlayer()                }            }        }        binding.pause.setOnClickListener {            if (mediaPlayer.isPlaying)                mediaPlayer.pause()        }    }    private fun initMediaPlayer()    {        val assetManager = assets        val fd = assetManager.openFd("music.mp3")        mediaPlayer.setDataSource(fd.fileDescriptor,fd.startOffset,fd.length)        mediaPlayer.prepare()    }    override fun onDestroy() {        super.onDestroy()        mediaPlayer.stop()        mediaPlayer.release()    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android_Service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（从入门ACT到Fragment放肆2）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BB%8E%E5%85%A5%E9%97%A8ACT%E5%88%B0Fragment%E6%94%BE%E8%82%86%EF%BC%89/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BB%8E%E5%85%A5%E9%97%A8ACT%E5%88%B0Fragment%E6%94%BE%E8%82%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门从入门act到fragment放肆2">Android开发笔记——快速入门（从入门ACT到Fragment放肆2）</span></h1><img src="https://s2.loli.net/2024/10/04/jlUq1gXsIM6Wt8G.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727981351201" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#fragment%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E5%9B%9E%E8%B0%83">Fragment的状态和回调</a><ul><li><a href="#fragment%E7%9A%84%E7%8A%B6%E6%80%81">Fragment的状态</a><ul><li><a href="#1-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81">1、运行状态</a></li><li><a href="#2-%E6%9A%82%E5%81%9C%E7%8A%B6%E6%80%81">2、暂停状态</a></li><li><a href="#3-%E5%81%9C%E6%AD%A2%E7%8A%B6%E6%80%81">3、停止状态</a></li><li><a href="#4-%E9%94%80%E6%AF%81%E7%8A%B6%E6%80%81">4、销毁状态</a></li></ul></li><li><a href="#fragment%E7%9A%84%E5%9B%9E%E8%B0%83">Fragment的回调</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><h2><span id="fragment的状态和回调">Fragment的状态和回调</span></h2><h3><span id="fragment的状态">Fragment的状态</span></h3><p>类似于Activity的生命周期，Fragment的生命周期也可能会经历几种状态，只不过在一些细小的地方会有部分区别。</p><h4><span id="1-运行状态">1、运行状态</span></h4><p>当一个Fragment所关联的Activity正处于运行状态的时，该Fragment也处于运行状态。</p><h4><span id="2-暂停状态">2、暂停状态</span></h4><p>当一个Activity进入暂停状态时候（由于另一个未占满屏幕的Activity被添加到了栈底）。与他关联的Fragment就会进入暂停状态。</p><h4><span id="3-停止状态">3、停止状态</span></h4><p>在这个状态下Fragment本身是不可见的，这个状态可以由FragmentTransaction的remove() 、replace()方法将Fragment从Activity中移除。但在事务提交前调用了addToBackStack()方法他也会进入停止状态。</p><h4><span id="4-销毁状态">4、销毁状态</span></h4><p>Fragment总是依附于Activity存在，因此当此Activity被销毁时，与它关联的Fragment就会进入销毁状态，或这个状态可以由FragmentTransaction的remove() 、replace()方法将Fragment从Activity中移除。但在事务提交前<strong>没有</strong>调用addToBackStack()方法他也会进入停止状态</p><p>这里放一张官方的图，看起来可能很难理解，不过没事，我们实验一下就会有很深的印象：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/6303547cce78e01a.png" alt="1"></p><h3><span id="fragment的回调">Fragment的回调</span></h3><p>我们可以通过新建一个基础类来方便我们观察Fragment的回调周期。</p><p>基础类实现如下：</p><pre><code class="language-kotlin">open class BasicFragment: Fragment() {     val TAG = javaClass.name.toString();    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(TAG,"This is onCreate")    }    override fun onAttach(context: Context) {        super.onAttach(context)        Log.d(TAG,"This is onAttach Attach  Activity is ${context.toString()}")    }    override fun onResume() {        super.onResume()        Log.d(TAG,"This is onResume")    }    override fun onPause() {        super.onPause()        Log.d(TAG,"This is onPause")    }    override fun onStop() {        super.onStop()        Log.d(TAG,"This is onStop")    }    override fun onDestroyView() {        super.onDestroyView()        Log.d(TAG,"This is onDestroyView")    }    override fun onDestroy() {        super.onDestroy()        Log.d(TAG,"This is onDestroy")    }    override fun onDetach() {        super.onDetach()        Log.d(TAG,"This is onDetach")    }}</code></pre><p>直接选择让他继承Fragment类，再让Fragment继承这个类即可。需要注意的是因为onCreateView方法需要返回对应的View这里需要到对应的Fragment中编写。</p><p>本次使用的Fragment是上一篇文章中的LeftFragment，就是单纯的一个Fragment没有什么特殊的通过继承BasicFragment来实现生命周期的输出，代码如下：</p><pre><code class="language-kotlin">class Left_fragment : BasicFragment() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)    }    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View? {        //onCreateView输出对应的内容         Log.d(TAG,"This is onCreateView")         return layoutInflater.inflate(R.layout.left_fragment,container,false)            }}</code></pre><p>我们启动看一看有什么结果：</p><p>可以看到绑定完成后直接调用到onCreate和onCreateView方法，随着onStart和onResume方法的调用Fragment也被显示出来。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/bbae2e7c9a12b8c5.png" alt="2"></p><p>显示结果：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/86b2e78bb782594c.png" alt="5"></p><p>当我i们按下返回键退出的时候，会调用：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/13746867e9521d7d.png" alt="3"></p><p>这时候在主界面已经不可见。</p><p>当我们尝试在后台切换回来的时候,又重新调用了</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/506ecff72f9c9f3c.png" alt="4"></p><p>下面我们再来考虑一种情况，就<strong>是当一个Fragment被另一个Fragment覆盖的时候</strong>，Fragment的回调都会调用什么？</p><p>我们在Activity中创建一个FrameLayout布局作为容器轮流将多个Fragment放入进去，当第二个Fragment显示的时候，会将第一个Fragment、完全覆盖。</p><p>如何实现将Fragment替换呢？我们先创建一个方法用来实现替换：</p><p>思路很简单，就是通过Activity的<code>supportFragmentManager</code>来对Activity中的Fragment进行管理，其中的<code>transaction</code>就是可以用来创建一个事务的，通过创建事务实现针对Fragment的操作，具体代码如下：</p><pre><code class="language-kotlin">private  fun replaceFragment( fragment: Fragment){    val fragmentManager = supportFragmentManager    val transaction = fragmentManager.beginTransaction()        transaction.replace(R.id.Framelayout_another,fragment)    transaction.addToBackStack(null)    transaction.commit()}</code></pre><p>replace方法传入两个参数一个是容器的ID用来找到容器，另一个是要加载的Fragment。</p><p>可以看到在替换之后我们将其装入了返回栈，具体有什么效果接着看。</p><p>在Activity中我们为左边按键绑定了一个回调函数，用来触发更换Fragmenmt，具体代码如下：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?){    super.onCreate(savedInstanceState)    binding = ActivityMainBinding.inflate(layoutInflater)    setContentView(binding.root)    val left_fragment: View =findViewById(R.id.leftFragment)    leftbinding =LeftFragmentBinding.bind(left_fragment)    //绑定替换函数：    leftbinding.button.setOnClickListener     {        replaceFragment(Another_Fragment())    }    replaceFragment( Right_fragment())}</code></pre><p>​    先将<code>Framelayout</code>填充一个<code>Right_fragment</code>最后使用button来替换新的<code>Another_Fragment</code>，<code>Another_Fragment</code>的布局和类完全和、<code>Right_fragment</code>代码相同，只是背景颜色不一样。</p><p>打开APP效果如下：</p><p>因为我开起了夜间模式，所以所有APP的背景颜色会随着背景进行修改将白色替换成黑色。</p><p>可以看到左边是我们的<code>Left_fragment</code>右边是我们的<code>Framelayout</code>承载的<code>Right_fragment</code>。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/119146dbcb55e739.png" alt="7"></p><p>这时候<code>Right_fragment</code>的回调函数进行如下：和上文的一个Fragment启动过程完全一致。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/eb5b1745c78c9ba0.png" alt="6"></p><p>我们点击button触发替换函数，此时他被覆盖结果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/ec74e43eee959791.png" alt="9"></p><p>这时候<code>Right_fragment</code>的回调函数进行如下：</p><p>和上文Fragment和Act一同退至后台不显示的时候不太一样，这里追加调用了一个<code>DestroyView</code>用于销毁对应的View对象。因为这个view实际上不会再显示了，注意这里将Fragment添加到了返回栈里面。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/4430bde6cf485ed3.png" alt="image-20220621182351631"></p><p>我们用返回键出栈查看结果：</p><p>按下返回键，果然返回到了初始界面：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/fe59410af2dfb4de.png" alt="11"></p><p>他的回调过程进行如下：</p><p>可以看到再调用<code>onCreateView</code>方法重新创建了view来进行显示。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/1d6f733ba2ed88d8.png" alt="10"></p><p>实际上目前栈顶是最早的<code>RightFragment</code>对象我们甚至可以将栈清空看一看有什么效果：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/ac4ceb4d36438de8.png" alt="12"></p><p>回调函数执行如下：</p><p>也就是说在执行完全退栈的时候会调用<code>onDestory</code>和<code>onDetach</code>方法。最终实现Fragment的销毁。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/945584c8a55166fb.png" alt="13"></p><p>如果我们不使用返回栈来保存呢？</p><p>当我们再次返回到<code>Right_fragment</code>会怎么样呢？</p><p>我们尝试一下：</p><p>结果很明显，我们点击替换按钮以后Fragment直接就执行销毁了，我们替换后再去执行返回就会直接退出程序，返回到主界面。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/1a910c017f6bee88.png" alt="14"></p><p>最后再放一次目前实验后得到的生命周期图：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/27/232788410f6601cf.png" alt="15"></p><p>总的归结来说，只存在两种情况和一种特殊情况：</p><ul><li><strong>用户点击返回键</strong>和<strong>fragment没有被添加到返回栈而被替换移除</strong>算是同一种 <strong>当前的Fragment</strong>都会从左边的路径。</li><li><strong>而添加了返回栈被替换移除</strong> <strong>当前的Fragment</strong> 都会从右边的路径上去。</li><li>特殊情况就是点击了返回键直接返回到了主界面效果如上图所示。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Fragment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（优雅的开发Activity）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Activity2%EF%BC%89%20/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88Activity2%EF%BC%89%20/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门优雅的开发activity">Android开发笔记——快速入门（优雅的开发Activity）</span></h1><img src="https://s2.loli.net/2024/09/29/fDGVwPp6OMtaZ5E.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727616671844" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h2><span id="软件环境">软件环境：</span></h2><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p>[TOC]</p><!-- toc --><ul><li><a href="#%E4%BD%BF%E7%94%A8android%E6%89%8B%E6%9C%BA%E5%9C%A8as%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91">使用Android手机在AS直接进行开发</a></li><li><a href="#activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F">Activity的启动模式</a><ul><li><a href="#standard">standard</a></li><li><a href="#sigletop">sigleTop</a></li><li><a href="#sigletask">sigleTask</a></li><li><a href="#singleinstance">singleInstance</a></li></ul></li><li><a href="#%E5%85%85%E5%88%86%E7%AE%A1%E7%90%86%E5%92%8C%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84act">充分管理和了解你的ACT</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E7%9F%A5%E6%99%93%E5%BD%93%E5%89%8Dact%E7%9A%84%E5%90%8D%E5%AD%97">如何知晓当前ACT的名字？</a></li><li><a href="#%E9%9A%8F%E6%97%B6%E9%80%80%E5%87%BA%E7%A8%8B%E5%BA%8F">随时退出程序</a></li><li><a href="#%E5%90%AF%E5%8A%A8act%E7%9A%84%E6%9C%80%E4%BD%B3%E5%86%99%E6%B3%95">启动ACT的最佳写法</a></li></ul></li><li><a href="#activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Activity的生命周期</a><ul><li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D">基本匹配</a></li><li><a href="#%E9%99%90%E5%AE%9A%E7%AC%A6">限定符</a></li><li><a href="#%E9%92%88%E5%AF%B9%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6">针对多个字符的运算符</a></li><li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a></li><li><a href="#%E8%BD%AC%E7%A0%81%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">转码特殊字符</a></li></ul></li></ul></li><li><a href="#%E9%94%9A%E7%82%B9">锚点</a><br>- <a href="#%E5%8F%B7">^号</a><br>- <a href="#%E5%8F%B7"><code>$</code> 号</a><ul><li><a href="#%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86">简写字符集</a></li><li><a href="#%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%83%B0%E6%80%A7%E5%8C%B9%E9%85%8D-greedy-vs-lazy-matching">贪婪匹配与惰性匹配 (Greedy vs lazy matching)</a></li></ul></li></ul><!-- tocstop --><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><h2><span id="使用android手机在as直接进行开发">使用Android手机在AS直接进行开发</span></h2><p>参考过的文章链接：</p><p><a href="https://baijiahao.baidu.com/s?id=1717480652313244278&amp;wfr=spider&amp;for=pc">如何在Android12开启开发者模式</a></p><p><a href="https://blog.csdn.net/qq_42851946/article/details/121332064">荣耀 打开USB调试 Android开发</a></p><p>首先安装google的驱动：打开SDK管理器：</p><p><img src="https://s2.loli.net/2024/09/29/LXJgQSdiZCvPOIE.png" alt="23"></p><p>找到：Google USB Driver下载：</p><p><img src="https://s2.loli.net/2024/09/29/XnRos5Embja3Qpx.png" alt="1"></p><p>然后开启设备管理器：</p><p><img src="https://s2.loli.net/2024/09/29/Rq27KFcE9xPmjnN.png" alt="24"></p><p>为设备安装驱动：</p><p><img src="https://s2.loli.net/2024/09/29/L4JXsKcUrfyxtj1.png" alt="25"></p><p>在本地找到刚下载的驱动，路径如下，需要参考你的具体路径：</p><p><img src="https://s2.loli.net/2024/09/29/92UsVMwN8GjelEf.png" alt="26"></p><p>等待安装完成</p><p><img src="https://s2.loli.net/2024/09/29/rNuAqF7DBMtvEle.png" alt="3"></p><p>打开开发者模式：</p><p>连续点击<strong>内部版本号</strong>：直到提示打开开发者模式：</p><img src="https://s2.loli.net/2024/09/29/47nQZH5fvT9qArx.jpg" alt="16" style="zoom:50%;"><p>打开如下选项就可以看到开发者选项：</p><p><img src="https://s2.loli.net/2024/09/29/Gpe6YnmbuTHX7Aw.png" alt="17"></p><p>打开开发者选项：</p><p><img src="https://s2.loli.net/2024/09/29/pcLrnjf6GV4Sbmu.png" alt="19"></p><p><img src="https://s2.loli.net/2024/09/29/wS89kgBdJ5aVNLW.png" alt="18"></p><p>往下拉找到USB配置选项：</p><p><img src="https://s2.loli.net/2024/09/29/24C8vLnRpSPlZac.png" alt="20"></p><p>如果不是RNDIS选择改成RNDIS,不知道为什么即使开启<strong>仅充电模式下开启ADB</strong>调试选项，也不无法在仅充电模式下调试，所以手动开启RNDIS稳妥一点。</p><p><strong>如果选择此模式还是没有反应，就在其它模式和本模式切换一下</strong>。</p><p><img src="https://s2.loli.net/2024/09/29/ZJEDhVyHjOTcqtu.png" alt="21"></p><p>可以看到AS中出现了设备：</p><p><img src="https://s2.loli.net/2024/09/29/Mors4Tiq6fHkpdP.png" alt="22"></p><h2><span id="activity的启动模式">Activity的启动模式</span></h2><p>Android的Activity的启动模式一共有四种。</p><p><strong>standard、sigleTop、sigleTask、singleInstace</strong>。</p><h3><span id="standard">standard</span></h3><p>standard模式是Activity的默认启动模式，在不显式指定的情况下，所有Activity都会使用这种模式。</p><p>举个例子：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    //此处注意    Log.d("FirstActivity","Task id is $taskId")   val  binding = ActivityFirstBinding.inflate(layoutInflater)    setContentView(binding.root)    binding.button1.setOnClickListener()    {        val intent = Intent(this,FirstActivity::class.java)        startActivity(intent)    }}</code></pre><p>我们给一个Act设定一个操作当点击按钮的时候再次创建一个一摸一样的Act出来。</p><p><img src="https://s2.loli.net/2024/09/29/4KpASe7gfj5a89t.png" alt="4"></p><p>实际上两个ACT的实例句柄并不相同，也就是说ACT中有两个相同的ACT实例。</p><p>具体实现模式如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/XU9teNOwGMDQsnF.png" alt="11"></p><h3><span id="sigletop">sigleTop</span></h3><p>对于标准启动模式你会觉得奇怪，明明我的ACT已经在栈顶了为什么还要启动一个重复的呢？</p><p>在sigleTop模式下就能解决你这个疑问，在本模式下，当ACT的启动模式指定为sigleTop，再启动之前就会查询栈顶元素，如果发现返回栈顶已经是该ACT，则认为可以直接使用它，不会在创建新的实例。</p><p>我们这里使用一个ACT来测试，在第一个ACT中在来创建一个相同ACT，看是否会创建。</p><p><img src="https://s2.loli.net/2024/09/29/AP3oEg7iwv2krSM.png" alt="6"></p><p>果然点击多次并没有新的ACT产生。</p><p>模式图如下：</p><p><img src="https://s2.loli.net/2024/09/29/PkvMnN92j3CDZrY.png" alt="12"></p><h3><span id="sigletask">sigleTask</span></h3><p>在SigleTop模式下你会有一个疑问，如果有两个ACT相互调用怎么办呢？如果我们使用sigleTop模式，在第二个ACT2中调用第一个ACT（此时栈顶是ACT2）仍会导致创建一个和第一个ACT相同的ACT导致资源的浪费，sigleTask就是能完美解决重复创建栈顶ACT的问题。</p><p>每次启动ACT的时候就会检查ACT是否存在该ACT的实例，如果发现已经存在则直接使用这个ACT，并将本ACT之上的所有ACT统统出栈，如果发现没有则创建一个新的ACT实例在栈顶。</p><p>我们这里创建两种测试，首先创建两个ACT，一个ACT中调用第二个ACT，在第二个ACT中调用第一个ACT，此时应该会把第一个ACT重新唤醒。</p><p><img src="https://s2.loli.net/2024/09/29/1PRjmeLucSxDndt.png" alt="7"></p><p>可以看到ACT1被重新唤醒了。</p><p>模式图如下：</p><p><img src="https://s2.loli.net/2024/09/29/P9hYJliIbgjoqSX.png" alt="14"></p><h3><span id="singleinstance">singleInstance</span></h3><p>不同于以上三种模式，singleInstance模式会启用一个新的返回栈来管理新的ACT，那么这样做有什么意义呢？</p><p>假设我们的程序中有一个ACT是允许其他程序调用的，如果想实现其他程序和我们的程序可以共享找个ACT的实例，应该如何实现呢？</p><p>前三种方式肯定是不正确的，因为他们都是在自己的返回栈的基础上进行操作，每一个应用程序都有自己的返回栈，同一个ACT在不同的返回栈中入栈的时候都必然创建新的实例。而在本模式下，不管是哪个应用程序来访问这个ACT，都会共用一个返回栈，就解决了ACT实例的问题。</p><p>我们这里使用三个ACT来实现操作：</p><p>将第一个第三个设置为stander启动模式，再将第二个设置成singleInstance启动模式。</p><p>我们让第一个调用第二个ACT，第二个调用第三个ACT.</p><p>可以通过输出的信息看到：</p><p><img src="https://s2.loli.net/2024/09/29/YnSj1cxkMK9HfGA.png" alt="9"></p><p>我们先启动了第一个ACT他的返回栈ID是106，在启动了第二个ACT他的返回栈ID是107，最后启动了第三个ACT他的返回栈是106和第一个返回栈id相同，因为他们三个都是standard模式。</p><p>我们在第三个ACT按下返回键，最后我们看到在提示信息里面有ACT1的restart方法的调用，我们在第三个ACT返回却直接返回的是ACT1，这里很好理解因为ACT1和ACT3在同一个返回栈里面。</p><p>singleInstance的返回模式图如下：</p><p><img src="https://s2.loli.net/2024/09/29/9MWjTyOgXfYKaqF.png" alt="13"></p><h2><span id="充分管理和了解你的act">充分管理和了解你的ACT</span></h2><p>在阅读之一部分前请先阅读：<a href="https://www.zhihu.com/question/24304289/answer/38218810">关于JAVA的反射与Class</a>。</p><h3><span id="如何知晓当前act的名字">如何知晓当前ACT的名字？</span></h3><p>创建一个<code>BaseActivity类</code>，注意是Kotlin的类，并不是创建一个ACT，让他继承<code>AppCompatActivity类</code>，并重写<code>onCreate方法</code>：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    Log.d("BaseActivity",javaClass.simpleName)}</code></pre><p>使用Log来输出当前的类名，值得注意的是，这里使用的是类似于java的反射机制，你可以注意到当前的类就是<code>BaseActivity</code>为什么还要通过<code>javaClass.simpleName</code>来输出类名呢？</p><p>实际上并不是这样的，我们先看一个结果：</p><p>运行一个FirstActivity以后：</p><p><img src="https://s2.loli.net/2024/09/29/ApDtHvN2JnKYQh3.png" alt="image-20220504101007423"></p><p>在Koltin中javaclass表示获取当前实例的Class对象，相当于在Java中调用getClass方法。</p><p>具体什么是Class类和对象请参考上文链接，简单的来说就是JVM中用来管理每个类的一个专门的管理类，通过这个类可以获取具体的信息包括对应类的存储位置，类的方法，类名等。</p><p>我们在重写父类的onCreate方法同时调用了父类的<code>super.onCreate(savedInstanceState)</code>方法，这样就相当于在本类中使用了<code>Log.d("BaseActivity",javaClass.simpleName)</code>方法，通过class来获取当前的实例名。</p><p>只要我们让<code>BaseActivity</code>成为所有ACT的父类就能输出类的信息。</p><p>当然你也可以这样写：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    Log.d("BaseActivity",this.toString())}</code></pre><p>这样输出内容在创建相同实例的时候更准确：</p><p><img src="https://s2.loli.net/2024/09/29/VUTAtxGlkSifBPw.png" alt="10"></p><h3><span id="随时退出程序">随时退出程序</span></h3><p>如果你目前栈内已经有了三个ACT，而现在你想检测退出程序对应ACT阶段回调函数的运行效果怎么样，总不能连续按下三次返回按键吧，那如果有很多的ACT，就连续按下多次？当然不现实了。</p><p>解决思路很简单，这里创建一个专门的类针对所有类进行管理。</p><p>先看个例子，创建了一个<code>ActitvityCollector</code>类：</p><pre><code class="language-kotlin">object ActitvityCollector{    private val activities = ArrayList&lt;Activity&gt;()    fun addActivity(activity: Activity)    {        activities.add(activity)    }    fun removeActivity(activity: Activity)    {        activities.remove(activity)    }    fun finishALL()    {        for (activity in activities)        {            if(!activity.isFinishing)            {                activity.finish()            }        }        activities.clear()    }}</code></pre><p>这里ActitvityCollector是一个单例类，因为全局实际上只需要一个ActitvityCollector来管理所有ACT就可以了。</p><p>我们创建了一个ArrayList来存放当前所有Activity，又声明了三个方法：</p><ul><li><code>addActivity</code> 用于向集合添加现有的ACT。</li><li><code>removeActivity</code> 用于移除某个ACT</li><li><code>finishALL</code> 用于将所有ACT销毁，销毁的时候需要注意当前ACT是否正在被销毁。</li></ul><p>接下来我们使用这个三个方法来管理自己的ACT</p><p>首先我们要配合<code>BaseActivity</code>来管理，首先是<code>addActivity</code>我们不需要自己手动每次调用的时候都添加这到集合中，我们配合BaseActivity的<code>onCreate</code>就可以在创建的时候自动调用了，修改后的<code>onCreate</code>如下：</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    Log.d("BaseActivity",javaClass.simpleName)    ActitvityCollector.addActivity(this)}</code></pre><p>接下来修改BaseActivity的<code>onDestroy</code>方法，让他在退出或者销毁的的时候直接把自己从队列里面移除。</p><pre><code class="language-kotlin">override fun onDestroy() {    super.onDestroy()    ActitvityCollector.removeActivity(this)}</code></pre><p>实现一键退出也很简单，我们在任何需要退出的地方调用：</p><pre><code class="language-kotlin">ActitvityCollector.finishALL()</code></pre><h3><span id="启动act的最佳写法">启动ACT的最佳写法</span></h3><p>在一个ACT中启动到另一个ACT的方法很简单，首先通过intent来构造<strong>意图</strong>，指明需要启动的ACT：</p><pre><code class="language-kotlin">val intent = Intent(this,SecondActivity::class.java)</code></pre><p>其中this为上下文对象，<code>SecondActivity::class.java</code>也是获取对应类的Class对象，为启动传输class参数。</p><p>然后通过<code>startActivity(intent)</code>或者<code>startActivityForResult()</code>将ACT启动起来，如果有数据可以使用Intent来传输，这里就不再赘述。</p><p>但是如果在另一个ACT需要启动这个ACT我们该如何传输参数呢？这时候就得跑去阅读代码了或者去问写这个ACT的人，但实际上我们应该把每一个ACT的启动都规整化把它封装一下，这样和别人一起协作的时候你写完的ACT很容易就能让别人利用起来。</p><p>在这里我们利用了companion object来实现因为这样方便在调用的时候不需要自己创建一个对象再去调用它的方法，我们本着高内聚低耦合的想法，就把启动方法声明在伴生对象里面。</p><pre><code class="language-kotlin">companion object {    fun actionStart(context: Context, data1: String, data2: String) {        val intent = Intent(context, SecondActivity::class.java).apply {            putExtra("param1", data1)            putExtra("param2", data2)        }        context.startActivity(intent)    }}</code></pre><p>我们通过这个方法把上下文传递进来然后传入要传递的参数最后构造intent实现数据传递和ACT启动。</p><h2><span id="activity的生命周期">Activity的生命周期</span></h2><p>《第一行代码》虽然是新的但其中关于Act的生命周期的部分已经发生了很大的改变，我推荐还是具体实验来真正手动去实践一下，实践才是检验真理的唯一标准。</p><p>我们在原来BasicActivity的基础上来进行修改，在每个回调之中输出对应的回调函数：</p><pre><code class="language-kotlin">open class BaseActivity : AppCompatActivity() {    val tag :String = javaClass.simpleName    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(tag,"onCreate")        ActitvityCollector.addActivity(this)    }    override fun onDestroy() {        Log.d(tag,"onDestroy")        super.onDestroy()        ActitvityCollector.removeActivity(this)    }    override fun onStart() {        super.onStart()        Log.d(tag, "onStart")    }    override fun onResume() {        super.onResume()        Log.d(tag, "onResume")    }    override fun onPause() {        super.onPause()        Log.d(tag, "onPause")    }    override fun onStop() {        super.onStop()        Log.d(tag, "onStop")    }    override fun onRestart() {        super.onRestart()        Log.d(tag, "onRestart")    }}</code></pre><p>输出的方式很简答，我们通过Log来输出tag是一个成员获取当前类的实例名称，为了让获取Log的结果更加准确，我们要使用正则表达式来过滤掉不必要的信息。所以插入学习一下正则表达式来看看具体结果。</p><h3><span id="正则表达式">正则表达式</span></h3><p>在开始之前我们先来学习一下什么是正则表达式，这个在以后调试的时候非常有用。</p><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p><p>在线测试网站：<a href="https://regexr.com/%E3%80%82">https://regexr.com/。</a></p><p>教程地址：<a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">Regex</a></p><h4><span id="基本匹配">基本匹配</span></h4><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。 例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p><p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p><h4><span id="限定符">限定符</span></h4><ul><li><strong>runoo+b</strong>，可以匹配 <strong>runoob、runooob、runoooooob</strong> 等，<strong>+</strong> 号代表前面的一个字符必须至少出现一次（1次或多次）。</li><li><strong>colou?r</strong> 可以匹配 <strong>color</strong> 或者 <strong>colour</strong>，<strong>?</strong> 问号代表前面的字符最多只可以出现一次（0次或1次），简单来说？代表的就是前一个字符是可有可无的。这里的例子就是u是可有可无的。</li><li><strong>runo*b</strong>，可以匹配 <strong>rund</strong>、<strong>runob、runoob、runoooooob</strong> 等，***** 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</li><li><strong>ab{2,}c</strong>，表示字符b至少需要出现两次，本质上是**+**的增强版。<strong>ab{2,6}c</strong> 表示b出现次数区间在【2.6】大于6的也不能算匹配。</li></ul><p>以上字符都只能作用于一个字符，这是需要注意的。</p><h4><span id="针对多个字符的运算符">针对多个字符的运算符</span></h4><p><strong>（ab)+</strong>,是()和+的结合，这里将ab看为一个整体来做+运算。</p><h4><span id="逻辑运算符">逻辑运算符</span></h4><p><strong>a(cat|dog)</strong>，表示匹配到a的情况下，后边是cat或者dog都是可以的。</p><p>需要注意的是，这里如果这样写：<strong>acat|dog</strong> 匹配结果就变成了：<strong>acat</strong>或者<strong>dog</strong></p><p>如果输入是acatdog,则匹配结果包含两个匹配项。</p><p><img src="https://s2.loli.net/2024/09/29/SmxuADRf6Z8X5HJ.png" alt="12"></p><h4><span id="字符集">字符集</span></h4><p><strong>[ ]</strong>,代表的是字符集，[abc]表示我们要匹配的是含有字符abc的单词，是abc中任意一个字母哦。</p><p>特殊用法：</p><p>[a-z]表示含有任意一个小写字母即可。</p><p>[a-z0-9]表示含有小写字母和数字即可。</p><p>[^ 0-9]表示所有不含有数字的单词，包含换行符。</p><h4><span id="转码特殊字符">转码特殊字符</span></h4><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p><p>举个例子：</p><p><code>(com\.)</code>匹配效果：</p><p><img src="https://s2.loli.net/2024/09/29/eYJruWMF12y7qHO.png" alt="11"></p><h2><span id="锚点">锚点</span></h2><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p><h5><span id="号">^号</span></h5><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p><p><code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串</p><p>匹配结果：</p><p><img src="https://s2.loli.net/2024/09/29/wFtMEofDlqU8pmW.png" alt="13"></p><p><strong>注意这里是这个字符串的开头，不是单词的开头。</strong></p><p>在上边基础类得基础上，我们为每一个周期的回调函数添加一个状态输出代码如下：</p><h5><span id="号"><code>$</code> 号</span></h5><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p><p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p><p><img src="https://s2.loli.net/2024/09/29/ug62VsdMfGbXZDI.png" alt="14"></p><h3><span id="简写字符集">简写字符集</span></h3><table><thead><tr><th>.</th><th>除换行符外的所有字符</th></tr></thead><tbody><tr><td>\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td>\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td>\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td>\s</td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p{Z}]</code></td></tr><tr><td>\S</td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符</td></tr><tr><td>\p</td><td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><h3><span id="贪婪匹配与惰性匹配-greedy-vs-lazy-matching">贪婪匹配与惰性匹配 (Greedy vs lazy matching)</span></h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><p>贪婪匹配，指的是每次匹配都选择匹配最多的内容：</p><p><img src="https://s2.loli.net/2024/09/29/hf1XMRBEyPUw8cj.png" alt="15"></p><p>如果需要在第一个地方就筛选出来（尽量短的匹配），就要配合？来实现：</p><p><img src="https://s2.loli.net/2024/09/29/Od8MelFQc3bZDon.png" alt="16"></p><p>学会了以后我们看看在AS中如何使用正则表达式来进行调试信息的输出：</p><p>选择下拉栏的Logcat模块：</p><p><img src="https://s2.loli.net/2024/09/29/RmrhSsLvABxTX8H.png" alt="18"></p><p>选择自定义效果：</p><p><img src="https://s2.loli.net/2024/09/29/yGfPcQYErJdsIeV.png" alt="19"></p><p>在Tag中定义自己需要的Tag：</p><p><img src="https://s2.loli.net/2024/09/29/Qxns8yGIacq7z5A.png" alt="17"></p><p>这样就可以自定义看到想要看到的结果啦。</p><p>这里我让他显示了FirtAct和SecondAct的所有信息。</p><p>我们在FirstAct中调用SecondAct然后在一步一步通过返回按键返回到主界面（退出程序）。</p><p>开启程序主Act完成：</p><p>界面如下：</p><p><img src="https://s2.loli.net/2024/09/29/adZutNsRQcbqwf4.png" alt="22"></p><p>此时Log中的输出为：</p><p><img src="https://s2.loli.net/2024/09/29/V9fYIqNGaBbv4Ud.png" alt="20"></p><p>点击button打开第二个界面：</p><p><img src="https://s2.loli.net/2024/09/29/ZDbP8Oujm3MV6l1.png" alt="21"></p><p>此时输出为：</p><p><img src="https://s2.loli.net/2024/09/29/1ceQqrZHlKOuENy.png" alt="24"></p><p>可以看到FirstAct实际上在SecondAct完全就绪的时候才会调用onStop方法。</p><p>我们使用返回键返回到第一个Act，结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/WXaLnYKo7wvizVE.png" alt="25"></p><p>这时候在SecondAct返回时先调用了onPause方法，直到完全被覆盖才调用onStop和onDestory。</p><p>我们再次按下返回键这时候就要返回到主界面了，结果会是什么呢？</p><p><img src="https://s2.loli.net/2024/09/29/buTEKCoqjAt5fxH.png" alt="26"></p><p>在返回主界面以后会有会连续调用<strong>onPause</strong>和<strong>onStop</strong>，但是没有调用<strong>onDestory</strong>！</p><p>这是和原来完全不一样的，也就是说，退出程序并不会去调用<strong>onDestory。</strong></p><p>还有一个细节就是，onPause是在退出前调用的，onStop是在被完全销毁退出后调用的。</p><p>最后放一张完全的图流程图：</p><p><img src="https://s2.loli.net/2024/09/29/T4BpjRCSZYP8A7O.png" alt="27"></p><p>总结Act的生命周期只有三点需要详细记忆。</p><ul><li><strong>前台生命周期：指的是在onResume到onPause之间的过程，在这个过程之间Act是正在运行的，可以交互和操作。</strong></li><li><strong>可见生命周期：指的是onStrart到onStop方法之间的过程，在onStop之前都是可见的，在不可见之后会执行onStop()。</strong></li><li><strong>OnDestory方法：他的情况在新版之后有些特殊，只有在返回栈退栈的时候才会调用方法，退出程序也不会执行。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Activity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（从入门SQLlite到Room放肆）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BB%8E%E5%85%A5%E9%97%A8SQLlite%E5%88%B0Room%E6%94%BE%E8%82%86%EF%BC%89/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BB%8E%E5%85%A5%E9%97%A8SQLlite%E5%88%B0Room%E6%94%BE%E8%82%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门从入门sqllite到room放肆">Android开发笔记——快速入门（从入门SQLlite到Room放肆）</span></h1><img src="https://s2.loli.net/2024/10/04/TI4CoLbPNzysXFH.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727981633751" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#android%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85">Android的数据持久</a></li><li><a href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8">文件存储</a><ul><li><a href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%88%B0%E6%96%87%E4%BB%B6%E5%BD%93%E4%B8%AD">将数据存储到文件当中</a></li><li><a href="#java%E6%B5%81%E5%9B%9E%E9%A1%BE">Java流回顾</a><ul><li><a href="#java%E7%9A%84%E5%AD%97%E8%8A%82%E6%B5%81">Java的字节流</a></li></ul><ul><li><a href="#android%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8">Android的文件存储</a><ul><li><a href="#%E6%9E%84%E9%80%A0%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E7%9A%84%E6%96%B9%E5%BC%8F">构造文件打开的方式</a></li><li><a href="#%E6%9E%84%E9%80%A0%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E6%B5%81">构造缓冲输入流</a></li></ul></li></ul></li><li><a href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE">从文件中读取数据</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><h2><span id="android的数据持久">Android的数据持久</span></h2><p>Android的数据持久化技术有三种，文件存储、SharedPreferences、数据库存储。</p><p>下面先来一 一介绍一下。</p><h2><span id="文件存储">文件存储</span></h2><p>文件存储是最基本的存储方式，他不对存储的内容进行任何格式化处理，所有数据都是原封不动的保存在文件当中的，因此他非常适合<strong>存储一些简单的文本数据或者二进制数据</strong>。</p><p>如果想你想通过文件存储的方式来保存一些较为复杂的结构化数据，就需要定义一套属于自己的格式规范。</p><h3><span id="将数据存储到文件当中">将数据存储到文件当中</span></h3><p>Context类当中提供了一个<code>openFileOutput()</code>方法，可以用于将指定数据存储到指定的文件中。</p><p>这个方法接收两个参数：第一个参数是文件名，在文件创建的时候使用，注意这里的第一个参数是文件名，在文件创建的时候使用，此文件名不包含路径，因此所有的文件都默认存储到/data/data/&lt; package name &gt;/files/目录下；第二个参数是文件的操作模式，主要有 ：</p><ul><li>MODE_PRIVATE:当输入的文件名相同的时候，所写的内容会覆盖原文件的内容。</li><li>MODE_APPEND:若该文件已存在，就往里面追加内容，若不存在就创建新文件。</li></ul><p><code>openFileOutput()</code>方法返回的是一个<code>FileOutputStream</code>对象，通过这个对象就可以使用Java流的方式写入文件中了。</p><h3><span id="java流回顾">Java流回顾</span></h3><p>流比喻数据的均匀连续性。流这个比喻的本质就是为了让某个对象可以均匀持续地吐出无间隔的数据，或者你可以向这个对象毫无压力地持续不断塞进数据。</p><p>我们在这里叙述的流主要是I/O流中的节点流，指的是可以从特定的io设备中读写数据的流。他只能连接数据源进行数据的读写操作。</p><p>举个例子：</p><h5><span id="java的字节流">Java的字节流</span></h5><p>在计算机当中，无论是文本还是图片或者是音频，都是以二进制，字节的形式存在的，IO流针对这种</p><p>形式提供了一系列的流，统称为字节流。</p><p>所有的字节流<strong>输入</strong>都继承于Inputstream。所有的字节流<strong>输出</strong>都继承于Outputstream。由于这两个类都是抽象的所以它没办法实例化。</p><p>这里就介绍一种来举例：FileInputStream，它可以通过字节流来实现对数据的读入。</p><p>结果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/c5800227c341e509.png" alt="1"></p><p>需要注意的是路径斜杠与反斜杠都是可以的。</p><h4><span id="android的文件存储">Android的文件存储</span></h4><p>首先来讲解存储的实现，存储的步骤分为三步，分别是构造打开文件的方式、构造缓冲输出流，关闭文件。</p><h5><span id="构造文件打开的方式">构造文件打开的方式</span></h5><p>上文提到过存在两种打开方式：</p><ul><li>MODE_PRIVATE:当输入的文件名相同的时候，所写的内容会覆盖原文件的内容。</li><li>MODE_APPEND:若该文件已存在，就往里面追加内容，若不存在就创建新文件。</li></ul><p>因为本次是在没有创建文件的前提下，所以优先使用<strong>MODE_APPEND</strong>。</p><p>使用API <code> val output = openFileOutput("data",Context.MODE_PRIVATE)</code></p><p>其中 openFileOutput返回两个参数：</p><p>分别是：文件的名字，文件的打开模式。</p><pre><code class="language-kotlin">public FileOutputStream openFileOutput(String name, int mode)</code></pre><p>最终返回一个FileOutputStream对象，实际上就是一个java的字节流对象。你可能会疑问我的文件创建在哪里呢？实际上这里的默认路径在app路径下单独创建一个File文件夹来存储没有指定路径的内容。</p><h5><span id="构造缓冲输入流">构造缓冲输入流</span></h5><p>这个和Java几乎一模一样，都是先构造输出流然后通过输出流构造成包含缓冲区的输出流，代码如下：</p><pre><code class="language-kotlin">val write = BufferedWriter(OutputStreamWriter(output))</code></pre><p>OutputStreamWriter()输入一个构造好的<code>FileOutputStream</code>对象用来将节流输出转化成字符流输出，方便直接写入字符。如果你对字符流还不太清楚，你会想为什么我不能用字节流来存储呢？可看到上文Java从一个UTF-8编码的文件中读取出来的其实是整数，并不是对应的字符。字符流可以参考一下以下文章：</p><p><a href="https://www.zhihu.com/question/39262026">字节流体系分析</a>。这里就不再赘述。</p><p>最后我们使用构造好的write，来写入对应的字符。</p><p>我们在这里可以使用kotlin的扩展函数函数来操作，kotlin提供了一个扩展函数方便我们对流进行操作，</p><pre><code class="language-kotlin">write.use {    it.write(inputText)}</code></pre><p>直接使用构造好的对象来调用use，他会在内部lambda表达式完成的时候自动调用close来关闭流，十分方便。最后完整的代码如下,我们将其封装成一个完整的函数来调用：</p><pre><code class="language-kotlin">fun save (inputText :String){    try {        val output = openFileOutput("data",Context.MODE_PRIVATE)        val write = BufferedWriter(OutputStreamWriter(output))        write.use {            it.write(inputText)        }    }catch (e:IOException)    {        e.printStackTrace()    }}</code></pre><p>结合我在Activity那篇文章的生命周期的分析，其实在Act的生命周期中onStop是保存数据的最佳时刻，此时是这个Act不可见后的操作，不影响第二个Act的展现。</p><p>所以我们在此法中保存对应的数据。</p><p>代码如下：</p><pre><code class="language-kotlin">override fun onStop() {    super.onStop()    save(binding.datasave.text.toString())}</code></pre><p>实现效果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/bf294551e954d75b.png" alt="29"></p><p>我们按下返回键，退出程序到主界面，我们从文件浏览器中观察到存储的数据如下：</p><p>浏览器中的路径：</p><p>data/data/com.example.dataset/files/data</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/922107f6d4854483.png" alt="28"></p><h3><span id="从文件中读取数据">从文件中读取数据</span></h3><p>从文件中读取数据几乎和写入数据没有什么太大区别，只是读入的时候我，我们可以使用kotlin系统内置的函数来读取对应的内容，具体代码如下：</p><pre><code class="language-kotlin">fun load():String?{    val content = StringBuilder();    try {        val input = openFileInput("data")        val reader= BufferedReader(InputStreamReader(input))        reader.use {            reader.forEachLine {                Log.e(javaClass.simpleName.toString(),reader.toString())                content.append(it)            }        }    }catch (e : IOException)    {        e.printStackTrace()    }    return content.toString();}</code></pre><p>可以看到使用方法也很简单，我们使用openFileInput、InputStreamReader来分别构造对象然后使用BufferedReader最终实现一个带缓冲区的读入流。</p><p>openFileInput是通过context返回的一个读入流（FileInputStream），后边就是字节流转换为字符流等一系列常规操作，没有什么好说，我需要特别说明的是，<code>forEachLine</code>这个系统的扩展函数，这个函数非常有意思，大多数博主的使用都多多少少存在一些问题，比如本文上边的这种写法，下面就来说一说为什么这种写法是错误的，我们跳转到<code>forEachLine</code>函数的实现，来看一看：</p><pre><code class="language-kotlin">/** * Iterates through each line of this reader, calls [action] for each line read * and closes the [Reader] when it's completed. * * @param action function to process file lines. */public fun Reader.forEachLine(action: (String) -&gt; Unit): Unit = useLines { it.forEach(action) }</code></pre><p>可以看到上边的注释，实际上这个函数的操作就是遍历文档的每一行，并将操作映射到每一行上。</p><p>函数的参数很有意思，使用的lambda表达式作为参数，这个lambda表达式名字叫<code>action</code>接收一个String类型的参数没有返回值，然后它使用了<code>useLines</code>，<code>forEach</code>函数来配合这个lambda来处理这个函数，我们再看看<code>forEach</code>的实现：</p><pre><code class="language-kotlin">/** * Performs the given [action] on each element. * * The operation is _terminal_. */public inline fun &lt;T&gt; Sequence&lt;T&gt;.forEach(action: (T) -&gt; Unit): Unit {    for (element in this) action(element)}</code></pre><p>他的实现也很简单，就是传入一个λ表达式并将调用他的对象中的内容都遍历一遍。那么是谁来调用它呢？</p><p><code>useLines { it.forEach(action) }</code>这个就是调用他的东西，这个it是什么呢？</p><p>当Lambda的参数只有一个的时候就可以用it来调用对象，我们来看一下实现：</p><pre><code class="language-kotlin">/** * Calls the [block] callback giving it a sequence of all the lines in this file and closes the reader once * the processing is complete. * @return the value returned by [block]. */@RequireKotlin("1.2", versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = "Requires newer compiler version to be inlined correctly.")public inline fun &lt;T&gt; Reader.useLines(block: (Sequence&lt;String&gt;) -&gt; T): T =    buffered().use { block(it.lineSequence()) }</code></pre><p>实际上就是将上边的<code>forEach</code>迭代<code>传入的lambda表达式</code>作为一个<code>迭代lambda表达</code>式传入到<code>useLines</code>的参数中，最后调用<code>lineSequence</code>方法，这个方法的实现很长，简答来说就是将文档中的每一行加入到一个Sequence里面然后使用<code>迭代lambda表达</code>将每一行处理，这是它的功能的实现，那为什么说大家都用错了?</p><p>注意看实际上还有两个函数：</p><p><code>buffered(),use()</code>,use是老朋友了，这里就不再详细说明了，你到这里会意识到个问题，我在这里用了use了，为什么外层还要用呢？</p><p>所以对于外层来说，正确的用法是：</p><pre><code class="language-kotlin">fun load():String?{    val content = StringBuilder();    try {        val input = openFileInput("data")        val reader= BufferedReader(InputStreamReader(input))            reader.forEachLine {                content.append(it)        }    }catch (e : IOException)    {        e.printStackTrace()    }    return content.toString();}</code></pre><p>你会感到不安，我怎么知道这个流是否关闭了呢？关于如何监测流的关闭，我们晚点再说，继续说</p><p><code>buffered()</code>函数，这个函数的实现也很简单：</p><pre><code class="language-kotlin">Returns a buffered reader wrapping this Reader, or this Reader itself if it is already buffered.@kotlin.internal.InlineOnlypublic inline fun Reader.buffered(bufferSize: Int = DEFAULT_BUFFER_SIZE): BufferedReader =    if (this is BufferedReader) this else BufferedReader(this, bufferSize)</code></pre><p>注释写的很清楚，这个函数就是用来检测是否是缓冲流的，不是的话自动给你加上包装，所以在外层我们根本不需要手动去构造缓冲流，修改后代码如下：</p><pre><code class="language-kotlin">fun load():String?{    val content = StringBuilder();    try {        val input = openFileInput("data")        val reader= InputStreamReader(input)            reader.forEachLine {                content.append(it)        }    }catch (e : IOException)    {        e.printStackTrace()    }    return content.toString();}</code></pre><p>这才是正确的使用方法。</p><p>接下来讨论如何检测流是否关闭的问题，方法也很简单，我们构造一个内部类来实现检测，这类继承于</p><p><code>InputStreamReader</code>，每次关闭的时候肯定要调用 close()方法，我们的思路就是，每次调用这个方法的时候使用Log输出一下表示流关闭了，这样就能直观的看到流关闭。</p><pre><code class="language-kotlin">inner class AddTestStream( input:FileInputStream):InputStreamReader(input){    override fun close() {        Log.d(javaClass.simpleName.toString(),"File is closed load succeed")        super.close()    }}</code></pre><p>最后使用上文的内部类替代一下，load函数结果如下：</p><pre><code class="language-kotlin">fun load():String?{    val content = StringBuilder();    try {        val input = openFileInput("data")        val reader= AddTestStream(input)            reader.forEachLine {                content.append(it)        }    }catch (e : IOException)    {        e.printStackTrace()    }    return content.toString();}</code></pre><p>我们打开软件，可以看到在onCreate执行后加载文件内容，并加载完毕后调用了close关闭了流。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/23/a2a2a8f9e513deb0.png" alt="1-1"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> SQLlite </tag>
            
            <tag> Room </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（优雅的使用ViewBinding开发）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8ViewBinding%E5%BC%80%E5%8F%91%EF%BC%89/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8ViewBinding%E5%BC%80%E5%8F%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门优雅的使用viewbinding开发">Android开发笔记——快速入门（优雅的使用ViewBinding开发）</span></h1><img src="https://s2.loli.net/2024/10/04/BfMY6Trva4pPHWh.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727982152154" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#%E4%B8%A2%E6%8E%89findviewbyid">丢掉findViewById()</a><ul><li><a href="#%E4%B8%8E-findviewbyid-%E7%9A%84%E5%8C%BA%E5%88%AB">与 findViewById 的区别</a></li><li><a href="#%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AF%B9%E6%AF%94">与数据绑定的对比</a></li><li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">如何使用：</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><h2><span id="丢掉findviewbyid">丢掉findViewById()</span></h2><p>在简单的情况下获取Act中的某个控件是很简单的，只需要通过findViewById()就可以获取控件，但是当一个页面有10多个控件的话，事情就变得麻烦了，总不能一直使用findViewById()来调用吧，一点也不优雅。</p><p>我们来使用一个新的方案，并不是kotlin-extensions的插件的自动引用，这个插件在新版的AS中已经被淘汰掉了，这里介绍如何使用ViewBinding。</p><p>通过视图绑定功能，您可以更轻松地编写可与视图交互的代码。在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个<strong>绑定类</strong>。绑定类的实例包含对在相应布局中具有 ID 的所有视图的直接引用。</p><h3><span id="与-findviewbyid-的区别">与 findViewById 的区别</span></h3><p>与使用 <code>findViewById</code> 相比，视图绑定具有一些很显著的优点：</p><ul><li><strong>Null 安全</strong>：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用 <code>@Nullable</code> 标记。</li><li><strong>类型安全</strong>：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。</li></ul><p>这些差异意味着布局和代码之间的不兼容将会导致构建在编译时（而非运行时）失败。</p><h3><span id="与数据绑定的对比">与数据绑定的对比</span></h3><p>视图绑定和<a href="https://developer.android.google.cn/topic/libraries/data-binding?hl=zh-cn">数据绑定</a>均会生成可用于直接引用视图的绑定类。但是，视图绑定旨在处理更简单的用例，与数据绑定相比，具有以下优势：</p><ul><li><strong>更快的编译速度</strong>：视图绑定不需要处理注释，因此编译时间更短。</li><li><strong>易于使用</strong>：视图绑定不需要特别标记的 XML 布局文件，因此在应用中采用速度更快。在模块中启用视图绑定后，它会自动应用于该模块的所有布局。</li></ul><p>反过来，与数据绑定相比，视图绑定也具有以下限制：</p><ul><li>视图绑定不支持<a href="https://developer.android.google.cn/topic/libraries/data-binding/expressions?hl=zh-cn">布局变量或布局表达式</a>，因此不能用于直接在 XML 布局文件中声明动态界面内容。</li><li>视图绑定不支持<a href="https://developer.android.google.cn/topic/libraries/data-binding/two-way?hl=zh-cn">双向数据绑定</a>。</li></ul><p>考虑到这些因素，在某些情况下，最好在项目中同时使用视图绑定和数据绑定。您可以在需要高级功能的布局中使用数据绑定，而在不需要高级功能的布局中使用视图绑定。</p><h3><span id="如何使用">如何使用：</span></h3><p>视图绑定功能可按模块启用。要在某个模块中启用视图绑定，请将 <code>viewBinding</code> 元素添加到其 <code>build.gradle</code> 文件中，如下例所示：</p><p><img src="https://s2.loli.net/2024/10/04/2783sTxLDlOPhHd.png" alt="屏幕截图 2022-05-02 105711"></p><p>添加完成以后记得将配置信息同步。</p><p>为某个模块启用视图绑定功能后，系统会为该模块中包含的每个 XML 布局文件生成一个绑定类。每个绑定类均包含对根视图以及具有 ID 的所有视图的引用。系统会通过以下方式生成绑定类的名称：将 XML 文件的名称转换为驼峰式大小写，并在末尾添加“Binding”一词。</p><p>举个例子我有一个<strong>FirstActivity</strong>和他的布局文件<strong>activity_first.xml</strong>，那么对应生成的绑定类就是：<strong>ActivityFirstBinding</strong></p><p>如何使用呢？</p><p>先来看一下Firstactivity布局中都有什么？</p><p><img src="https://s2.loli.net/2024/10/04/eVPq7nBbMyKO68Y.png" alt="image-20220502110141198"></p><p>很简单就只有一个<strong>button。</strong></p><p><strong>ActivityFirstBinding</strong>类目前只有个字段：名为 <code>button</code> 的 <code>Button</code>。我们先创建这个类的实例，最好创建在<strong>FirstActivity</strong>的成员中，类似如下：</p><pre><code class="language-kotlin">class FirstActivity : BaseActivity() {    private lateinit  var  binding :ActivityFirstBinding    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d("FirstActivity","Task id is $taskId")        binding =ActivityFirstBinding.inflate(layoutInflater)       //此处注意        setContentView(R.layout.activity_first)    }}</code></pre><p>先创建实例：</p><p>调用生成的绑定类中包含的静态 <code>inflate()</code> 方法。此操作会创建该绑定类的实例以供 Activity 使用。</p><p><code>ActivityFirstBinding.inflate(layoutInflater)</code></p><p>这样就完成了调用，接下来就可以愉快的使用binding了。</p><p>具体使用也很简单，比如这里我想针对button控件注册一个回调函数怎么办呢？</p><pre><code class="language-kotlin">binding.button1.setOnClickListener{}</code></pre><p>直接使用<code>binding.引用控件的ID</code>，这样就变得优雅了许多。</p><p>但是使用的时候还需要注意下 一个问题：</p><p>在上一个代码中实际上存在一个问题，就是<code>setContentView(R.layout.activity_first)</code>实际上还是用的通过资源文件的引用将其设定为活动的试图，这样确实能将目前活动的view设定为当前的view，但是你要意识到你的button1的回调函数实际上是在<code>binding.button1.setOnClickListener{}</code>也就是说它是通过binding的实例来实现的，你如果直接使用<code>R.layout.activity_first</code>view视图是不会把回调注册进去的，怎么解决这个问题呢？</p><p>通过调用 <code>getRoot()</code> 方法或使用 <a href="https://kotlinlang.org/docs/reference/properties.html#declaring-properties">Kotlin 属性语法</a>获取对根视图的引用。再将根视图传递到 <a href="https://developer.android.google.cn/reference/kotlin/android/app/Activity?hl=zh-cn#setcontentview_1"><code>setContentView()</code></a>，使其成为屏幕上的活动视图。</p><p>完整代码如下：</p><pre><code class="language-kotlin">class FirstActivity : BaseActivity() {    //不可以在此处直接初始化，会造成空指针问题。    private lateinit  var  binding :ActivityFirstBinding        override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d("FirstActivity","Task id is $taskId")        binding =ActivityFirstBinding.inflate(layoutInflater)        //注册回调        binding.button1.setOnClickListener{            SecondActivity.actionStart(this, "data1", "data2")        }        //设置视图        setContentView(binding.root)    }}</code></pre><p>还有一个问题就是不可以在类开始直接初始化：</p><pre><code class="language-kotlin">class FirstActivity : BaseActivity() {    //此处初始化报错，空指针问题   private var  binding=ActivityFirstBinding.inflate(layoutInflater)    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        //此处注意        Log.d("FirstActivity","Task id is $taskId")        //binding =ActivityFirstBinding.inflate(layoutInflater)        setContentView(binding.root)        binding.button1.setOnClickListener{        }    }}</code></pre><p>运行结果如下图：</p><p><img src="https://s2.loli.net/2024/10/04/vaVP3SMnXIxQLbk.png" alt="image-20220502113924324"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> SQLlite </tag>
            
            <tag> Room </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（从入门SQLlite到Room放肆）2</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BB%8E%E5%85%A5%E9%97%A8SQLlite%E5%88%B0Room%E6%94%BE%E8%82%86%EF%BC%892%20/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BB%8E%E5%85%A5%E9%97%A8SQLlite%E5%88%B0Room%E6%94%BE%E8%82%86%EF%BC%892%20/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门从入门sqllite到room放肆2">Android开发笔记——快速入门（从入门SQLlite到Room放肆）2</span></h1><img src="https://s2.loli.net/2024/10/04/WtmHlaEYCXrT5ev.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727981759445" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h2><span id="软件环境">软件环境：</span></h2><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#android%E7%9A%84sharepreferences">Android的SharePreferences</a><ul><li><a href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8sharepreferences%E5%BD%93%E4%B8%AD">将数据存储在SharePreferences当中</a><ul><li><a href="#1-%E9%80%9A%E8%BF%87context%E7%B1%BB%E7%9A%84getsharedpreference%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1">1、通过<code>context</code>类的<code>getSharedPreference</code>来获取对象</a></li><li><a href="#2-%E9%80%9A%E8%BF%87activity%E7%B1%BB%E7%9A%84getpreferences%E6%9D%A5%E8%8E%B7%E5%8F%96">2、通过<code>Activity</code>类的<code>getPreferences</code>来获取</a></li></ul></li><li><a href="#%E5%90%91sharepreferences%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE">向SharePreferences存储数据</a><ul><li><a href="#%E4%BB%8Esharepreferences%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE">从SharePreferences读取数据</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E6%9D%A5%E4%BC%98%E5%8C%96">使用高级函数来优化</a></li></ul></li><li><a href="#sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8">SQLite数据库入门</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1">创建数据库管理对象</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">创建数据库</a></li></ul></li><li><a href="#%E5%8D%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93">升级数据库</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">数据库的增删改查</a><ul><li><a href="#%E5%90%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE">向数据库添加数据</a></li><li><a href="#%E4%BF%AE%E6%94%B9%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE">修改对应的数据</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE">删除对应的数据</a></li><li><a href="#%E6%9F%A5%E8%AF%A2%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE">查询对应的数据</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><h2><span id="android的sharepreferences">Android的SharePreferences</span></h2><p><strong>此部分配套代码名称:DataTest2</strong></p><p>将数据存储在SharePreferences中是一个针对多种数据类型的办法，使用文件存储很不方便，不方便的点在于很难对于具有数据类型的结构化数据进行存储，一个double存储进去就变成了文本，这样很不方便，所以我们来介绍如何使用具有数据类型支持的存储方案。</p><h3><span id="将数据存储在sharepreferences当中">将数据存储在SharePreferences当中</span></h3><p>将数据存储到SharePreferences当中就需要先获取到SharePreferences对象，获取的办法有两种：</p><h4><span id="1-通过context类的getsharedpreference来获取对象">1、通过<code>context</code>类的<code>getSharedPreference</code>来获取对象</span></h4><pre><code class="language-kotlin">@Overridepublic SharedPreferences getSharedPreferences(String name, int mode) {    return mBase.getSharedPreferences(name, mode);}</code></pre><p>此方法接收两个参数，第一个参数用于指定SharePreferences文件的名称，如果指定的文件不存在则会创建一个，一般存储在：包路径下的/share_prefs/目录下，第二个参数用于指定操作模式，目前只有默认的<strong>MODE_PRIVATE</strong>这一种模式可以选，他表达的意思是只有当前的应用程序才可以针对他进行读写，其他程序一律不可以。</p><h4><span id="2-通过activity类的getpreferences来获取">2、通过<code>Activity</code>类的<code>getPreferences</code>来获取</span></h4><pre><code class="language-kotlin">public SharedPreferences getPreferences(@Context.PreferencesMode int mode) {    return getSharedPreferences(getLocalClassName(), mode);}</code></pre><p>此方法只需要接受一个模式参数即可获取到对象，与上文方法不同的是，这个方法创建的文件名与调用它的Actity类名字一模一样。可以看到此方法实际上是对上文方法的再封装。</p><h3><span id="向sharepreferences存储数据">向SharePreferences存储数据</span></h3><p>存储的过程分为三步：</p><ul><li>通过SharePreferences实例对象的edit()方法,可以获取到一个<code>SharePreferences.Editor</code>对象。</li><li>向<code>SharePreferences.Editor</code>添加数据，针对每一种类型都有其对应的方法可以添加数据，比如添加一个字符串就可以用<code>putString()</code>方法。</li><li>调用apply方法将数据提交，从而完成数据存储操作。</li></ul><p>下面举个例子：</p><pre><code class="language-kotlin">fun load_p(){    val editor = getSharedPreferences("data",Context.MODE_PRIVATE).edit()    editor.putString("data","Jszszzy_Preference")    editor.apply()}</code></pre><p>这里使用了context的getSharedPreference来获取editor对象，然后调用putSrtring来存入一个字符串，他的key值是data当你要获取的时候就要调用”data“了，最后使用apply方法将数据存储进去。</p><p>怎么用验证我们存储的数据呢？</p><p>我可以直接到对应目录下去查看，当然你也可以使用读取再把数据读取出来。</p><h4><span id="从sharepreferences读取数据">从SharePreferences读取数据</span></h4><p>你已经体验到了，我们只需要三行代码就可以将数据存储起来，并且不需要考虑太多的性能细节问题。有一个更好的消息是，读取其实更简单。</p><p>读取只有一个步骤：</p><p>通过SharePreferences实例对象的get方法分别传入键值和数据类型，就可以得到对应的数据，这里我们使用一个Textview来获取对应的数据，然后在程序启动的时候，再将读取到的对应的数据再显示出来。</p><p>onCreate读取数据代码如下：</p><p>需要注意的是这里是在前文已经实现了存储的基础上，程序已经创建好了对应的文件，然后实现的读取。</p><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(savedInstanceState)    binding = ActivityMainBinding.inflate(layoutInflater)    setContentView(binding.root)    load_p()?.let {        binding.datasave.setText(it)    }    Toast.makeText(this,"Reload data succeed",Toast.LENGTH_SHORT).show()}</code></pre><p>load的代码如下：</p><pre><code class="language-kotlin">fun load_p():String? {    val loader = getSharedPreferences("data",Context.MODE_PRIVATE)    return loader.getString("data","Cant get data")}</code></pre><p>存储的代码也很简单，我们只需要在Activity完全消失的时候，调用存储把数据存储起来，在Activity的回调函数中来保存数据：</p><pre><code class="language-kotlin">override fun onStop() {    save_p()    super.onStop()}</code></pre><p>因为要保存显示的数据，所以保存的函数也要修改：</p><pre><code class="language-kotlin">fun save_p(){    val editor = getSharedPreferences("data",Context.MODE_PRIVATE).edit()    editor.putString("data",binding.datasave.text.toString())    editor.apply()}</code></pre><p>效果如下，开启应用程序读取到数据如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/5334439cc5794979.png" alt="1-1"></p><p>修改后保存，读取到的数据如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/f59c772af7876008.png" alt="1-2"></p><h3><span id="使用高级函数来优化">使用高级函数来优化</span></h3><p>尽管使用SharePreferences已经足够简单了，但实际上还是有一些重复的书写，我们这里就使用高阶函数来优化一下。</p><p>直接举一个例子：</p><pre><code class="language-kotlin">fun SharedPreferences.open(block:SharedPreferences.Editor.()-&gt;Unit){    val editor = edit()    editor.block()//因为这个扩展函数实际上提供的是SharedPreferences上下文，二传入的参数提供的是SharedPreferences.Editor的上下文，需要加入前缀    editor.apply()}</code></pre><p>以上一段代码看起来可能有点复杂，实际上没有那么复杂，我们实际上是通过扩展函数为SharedPreferences类添加了一个open函数，这个open函数接受一个以SharedPreferences.Editor为上下文的函数参数他的名为block。</p><p>我们为什么要创建这样一个函数呢？</p><p>实际上有两个目的，一个是省略重复的获取对象和提交数据的时候调用apply函数，二是将函数作为参数可以自定义要实现的数据存储操作，并且能提供对应的上下文。</p><p>如何使用这个函数呢？</p><p>我们可以直接调用getSharedPreferences方法获取到这个对象，然后调用open函数传入需要进行的操作即可：</p><p>完整的代码如下</p><pre><code class="language-kotlin">getSharedPreferences("data",Context.MODE_PRIVATE).open {    putString("data",binding.datasave.text.toString())}</code></pre><p>和上文实现相同的操作相比：</p><pre><code class="language-kotlin">val editor = getSharedPreferences("data",Context.MODE_PRIVATE).edit()editor.putString("data",binding.datasave.text.toString())editor.apply()</code></pre><p>省略了不少，尤其当需要添加的数据增多的时候比较方便。</p><p>当然为了避免因为kotlin的匿名类产生的开销，我们使用inline关键字来增强一下避免因为匿名类产生的开销。</p><h2><span id="sqlite数据库入门">SQLite数据库入门</span></h2><p><strong>此部分配套代码名称:DataTest3</strong></p><p>前边两种方式存储的实际上都是一些简单的数据，当我们的数据关系复杂起来的时候，通过前两种办法就变的捉襟见肘了。</p><p>SQLite是一个轻量级的关系数据库，还遵循了数据库的ACID事务，所以只要你以前使用过其他关系型数据库，就可以很快的上手SQLite，同时他不仅在大小上有很大的优化，使用起来也是更加的方便和快捷。</p><h3><span id="创建数据库管理对象">创建数据库管理对象</span></h3><p>Android为了方便管数据库，专门提供了一个抽象类来供你使用，创建数据库的时候只需要单独写一个类然后继承对应的<code>SQLiteOpenHelper</code>类即可，其中包含了两个抽象方法需要你自己去实现，一个是创建的时候调用的<code>override fun onCreate(db: SQLiteDatabase?)</code> 他传递进来一个参数指明当前调用的具体哪个数据库，如果还没有数据库的表就可以通过SQLiteDatabase的方法执行SQL语句来创建表。</p><p>同时还需要重写的方法还有onUpgrade，他是当数据库需要升级的时候来调用的，具体等到数据库升级再详细讨论。</p><p>一般使用SQLiteOpenHelper的时候都会使用它较少参数的构造方法，这个构造方法如下：</p><pre><code class="language-kotlin">public SQLiteOpenHelper(@Nullable Context context, @Nullable String name,        @Nullable CursorFactory factory, int version) {    this(context, name, factory, version, null);}</code></pre><p>第一个参数context用来定位数据库的存储位置，包名等等…，没什么好说的，很多函数都需要提供上下文参数，来实现一些信息获取或者Context的内置方法获取。</p><p>第二个参数是数据库的名称。</p><p>第三个参数是允许我们在查询数据的时候返回一个自定义的Cursor，至于这是什么我们晚点再来讨论。</p><p>第四个参数是显示当前数据的版本号，可用于对数据库进行升级操作。</p><h4><span id="创建数据库">创建数据库</span></h4><p>需要注意的是上边只是创建了一个数据库助手对象，并没有将数据库本身创建出来，当我们第一次去调用getWritableDatabase方法的时候才是真正的将数据库创建了出来，我们可以通过阅读源码来知道这一关键点。</p><pre><code class="language-kotlin">Create and/or open a database that will be used for reading and writing. The first time this is called, the database will be opened and onCreate, onUpgrade and/or onOpen will be called.Once opened successfully, the database is cached, so you can call this method every time you need to write to the database. (Make sure to call close when you no longer need the database.) Errors such as bad permissions or a full disk may cause this method to fail, but future attempts may succeed if the problem is fixed.Database upgrade may take a long time, you should not call this method from the application main thread, including from ContentProvider.onCreate().Returns:a read/write database object valid until close is calledThrows:SQLiteException – if the database cannot be opened for writingpublic SQLiteDatabase getWritableDatabase() {      synchronized (this) {       return getDatabaseLocked(true);   }}</code></pre><p>源码的注释说的很清楚，我只阐述以下几个要点，让你对这个方法有更深的了解。</p><p>当第一次这个方法被调用的时候，会触发以下生命周期函数：</p><ul><li>onCreate</li><li>onUpgrade and onOpen</li></ul><p>这个方法的实现不仅包含了在第一次调用的时候创建数据库，同时也包含了在不同生命周期去调用onCreate、onDowngrade（非抽象）、onUpgrade方法、onOpen方法（非抽象），这也是为什么只有第一次调用这个方法的时候，数据库内的表和数据才会被创建。</p><p>数据库的升级过程是个很慢的过程，所以你不应该在某个组件Act或者Fragment的onCreate方法去调用getWritableDatabase或者getReadableDatabase。</p><p>接下来我们直观的体验一下如何创建一个数据库。</p><p>这里我们要创建一个BookStore.db数据库并且在数据库中建立一张表，上文说了，只有数据库第一次</p><p>被创建的时候会调用onCreate方法，所以我们初始化数据应该放在onCreate里面。</p><p>创建一个自己的SQLiteOpenHelper类，并重写初始化方法：</p><pre><code class="language-kotlin">class MyDatabaseHelper(val context:Context,name:String,version: Int)    :SQLiteOpenHelper(context,name,null,version) {            private val createBook = "create table Book ("+            "id integer primary key autoincrement,"+            "price real,"+            "pages integer,"+            "name text)"            override fun onCreate(db: SQLiteDatabase?) {        db?.execSQL(createBook)        Toast.makeText(context,"Create succeed",Toast.LENGTH_SHORT).show()    }    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {    }}</code></pre><p>在类里面我们声明了一个成员字符串变量，在字符串中写下SQL的语句，SQLite所包含的数据类并不多，具体如下：</p><ul><li>integer 整型</li><li>real 浮点类型</li><li>text 文本类型</li><li>blob 二进制类型</li></ul><p>其中语句中的关键字primary key 、autoincrement分别代表，设置为主键、内容自动增长。</p><p>最后调用onCreate方法中的数据库对象，执行SQL语句，完成建表。</p><p>那么如何查看建立好的数据库的内容呢？我们可以借助数据库查看器，<a href="https://sqlitebrowser.org/blog/version-3-12-2-released/">下载查看器</a>。</p><p>从手机中把数据库的内容保存到本地来。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/ca17b99867404014.png" alt="1-5"></p><p>数据库存储位置如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/db8170e5bac63ff8.png" alt="1-6"></p><p>在程序的包中：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/39054830e573804d.png" alt="1-7"></p><p>右键另存为，将数据库保存到PC本地，你可以使用插件打开：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/509bbcd04cb47b58.png" alt="1-8"></p><p>效果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/4d0213ff21d660ed.png" alt="1-9"></p><p>或者使用刚下载的浏览器打开:</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/07fdb3dd03f477c6.png" alt="1-10"></p><h3><span id="升级数据库">升级数据库</span></h3><p>在SQLiteOpenHelper中实际上还包含着一个onUpdate方法，他就是刚才说的针对数据库升级的方法。</p><p>目前的数据库应将创建完成了，但是我们想增加一个Category表用于存放书的各种分类信息怎么办呢？</p><p>建立表的语句很简单：</p><pre><code class="language-sql">create table Category(id interger primary autoincrement , category_name text , category_code integer)</code></pre><p>接下来我们将这条建表语句添加到MyDatabaseHelper中，代码如下所示：</p><pre><code class="language-kotlin">private var tablename:String=""private val front_test= "drop table if exists ${tablename}"private val createBook = "create table Book ("+        "id integer primary key autoincrement,"+        "price real,"+        "pages integer,"+        "name text)"private val createCategory = "create table Category(id integer primary key autoincrement , category_name text , category_code integer)"override fun onCreate(db: SQLiteDatabase?) {    db?.execSQL(createBook)    db?.execSQL(createCategory)    Toast.makeText(context,"Create succeed",Toast.LENGTH_SHORT).show()}</code></pre><p>我们在oncreate方法中调用了db来执行创建表的语句，最后提示表创建成功。</p><p>可是这里就存在一个问题，onCreate方法实际上只会在数据库创建的时候执行，也就是说，目前想去更新数据库的内容是无法通过Oncreate方法来执行的，这该怎么办呢？这就需要调用OnUpdate方法来使用了，在改变版本号的情况下，数据库会在创建的时候执行OnUpdate方法，我们只需要在创建管理类的时候传入一个比当前数据库版本更大的数字就可以了，代码如下：</p><pre><code class="language-kotlin">val dbHelper = MyDatabaseHelper(this,"BookStore.db",2)</code></pre><p>为了让其满足一定的鲁棒性，也就是说不管数据库存在不存在，是否需要升级，我们保留在Oncreate方法中创建数据库的操作，我们可以在OnUpdate方法中调用OnCreate。</p><p>最后方法实现结果如下：</p><pre><code class="language-kotlin">    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {        tablename="Book"        db?.execSQL(front_test)        tablename="Category"        db?.execSQL(front_test)        onCreate(db)    }</code></pre><p>重新启动应用程序，效果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/66cbb88631bc124a.png" alt="image-20220616100553867"></p><p>需要注意的是，你在使用Android的真机调试的时候，实际上每次系统都会给你重新安装程序，也就是说，它会自动执行OncCreate方法重新创建一个数据库。</p><h3><span id="数据库的增删改查">数据库的增删改查</span></h3><p>有时候你可能还没学习过数据库的一些基础内容，不过没关系，Android帮我们实现了一套不需要SQL语句就能操作数据库的API，我们对于数据库的操作也就是SQL实际上功能就分为四种：CRUD。</p><p>在前面我们使用getWritableDatabase方法来创建和修改数据库，实际上这个方法返回的是一个SQLiteDatabase对象，我们借助这个对象就是可实现CRUD操作了。</p><h4><span id="向数据库添加数据">向数据库添加数据</span></h4><p>SQLiteDatabase对象下文简称：SQL对象，包含一个insert方法：</p><pre><code class="language-kotlin">public long insert(String table, String nullColumnHack, ContentValues values) </code></pre><p>第一个参数用来指定是哪一个table，第二个是用于在未指定添加数据的情况下给某些可以为空的列自动赋值为NULL，这里不需要，所以我们把它设置为NULL。第三个参数很直白，就是传入一个需要插入的值。需要注意的是，这里使用的是ContentValues对象。这个对象提供了一系列的方法来将需要的数据添加进去，使用方法如下：</p><p>我们通过来获取对应的SQL对象：</p><pre><code class="language-kotlin"> val sql = dbHelper.writableDatabase</code></pre><p>通过这个SQL对象来实现添加数据，再添加数据之前，我们先要把对应的数据嵌入到ContentValues对象当中，通过ContentValues对象指定将数据插入到哪一列当中，当然数据的插入要符合对应的数据类型否则会报错。</p><p>最终插入的代码如下所示：</p><pre><code class="language-kotlin">binding.button.setOnClickListener {   val sql = dbHelper.writableDatabase   val values = ContentValues().apply {        put("name","The Da Vinci Code")        put("pages",188)        put("price",16.96)    }   sql.insert("Book",null,values)}</code></pre><p>可以看到我们把对应的插入函数绑定到了按钮上，只要按下按钮就会执行对应的插入程序。</p><p>插入的结果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/d4da2ab096527caa.png" alt="image-20220616201956921"></p><p>这里有一个需要特殊注意的地方是，我们在本地浏览数据库内容的时候，需要将设备的信息同步刷新下载以后再使用SQLite浏览器打开，并且先关闭原来正在浏览的数据库后删除本地原来存在的数据库内容，防止因为正在访问而导致的本低内容更新失败，我并不推荐使用插件因为bug确实存在。</p><h4><span id="修改对应的数据">修改对应的数据</span></h4><p>对应有insert方法也有update方法，这个方法接收四个参数，第1个参数同样也是制定了操作的表名，指定更新哪张表的数据。第二个参数是ContentValues，就是需要更新的数据，当然也是通过ContentValues来构造对应的数据，并包装起来，第三个、第四个参数用于约束某一行或者某几行中的数据进行更新，没有约束的话默认更新所有数据。</p><p>举个例子：</p><p>对于参数的使用直接说起来，还是很抽象，我们不妨结合例子来说：</p><pre><code class="language-kotlin">binding.update.setOnClickListener {    //Data_update_method    val sql = dbHelper.writableDatabase    val values = ContentValues()    values.put("price",10.99)    sql.update("Book",values,"name=?", arrayOf("The Da Vinci Code"))}</code></pre><p>第一第二个参数就不再重复了，我们直接来说第三个参数，第三个参数实际上就是where字句，在这里传入的字符串自动和where拼接起来，实现筛选指定行的目的，比如这里就相当于：</p><pre><code class="language-sql">where name=?</code></pre><p>而这里的？就是一个占位符号，当你使用第四个参数的时候可以将一个字符数组的全部内容传递过来放到where单中，所以我在第四个数据当中使用了 arrayof来创建一个数组，当然为什么要用数组呢？实际上呢一个表达式里面可以包含多个占位符，所以这里使用数组来满足多个？的情况。</p><pre><code class="language-kotlin">arrayOf("The Da Vinci Code")</code></pre><p>操作结果如下：</p><p>可以看到所有的价格都改为了10.99</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/e485a1bb70c828a3.png" alt="image-20220616224216557"></p><h4><span id="删除对应的数据">删除对应的数据</span></h4><p>删除对应的数据更简单，参数和上边基本一样：</p><pre><code class="language-kotlin">binding.delete.setOnClickListener {    //Data_update_delete    val sql = dbHelper.writableDatabase    sql.delete("Book","name = ?", arrayOf("The Da Vinci Code"))}</code></pre><p>最后删除完成以后效果如下：</p><p>可以看到所有内容都被删除了。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/2f4407fdd5027e09.png" alt="image-20220616225453207"></p><h4><span id="查询对应的数据">查询对应的数据</span></h4><p>SQL实际上是一种结构化的查询语言，他的大部分功能体现在“查”这个字上，具体的SQL操作，可以参考我的数据库专栏。</p><p>query相对来说很复杂，一共有七个参数，参数的含义分别如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/f687645e791a0edb.png" alt="image-20220616230920144"></p><p>如果你不理解，没关系，请先参考我的数据库专栏，里面有详细介绍SQL的内容。</p><p>我在这里就很简单的举个例子：</p><pre><code class="language-kotlin">binding.query.setOnClickListener {    //Data_update_query    val sql = dbHelper.writableDatabase    val result =sql.query("Book", null,null,null,null,null,null)    binding.datasave.setText( result.columnCount.toString())    result.close()}</code></pre><p>我们新增一个查询按钮，这句查询语句的意思实际上就是获取当前表中有多少行，是不是很好理解？</p><p>其等价于SQL为</p><pre><code class="language-sql">select * from Book</code></pre><p>最后通过columnCount成员获取到对应的行数。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> SQLlite </tag>
            
            <tag> Room </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（布局与RecycleView组件）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%89/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门布局与recycleview组件">Android开发笔记——快速入门（布局与RecycleView组件）</span></h1><img src="https://s2.loli.net/2024/10/04/ESkpsrWfO9q6PNz.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727982825836" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h2><span id="软件环境">软件环境：</span></h2><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80">线性布局</a></li><li><a href="#%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80">约束布局</a></li><li><a href="#constraintlayout%E7%A4%BA%E4%BE%8B">ConstraintLayout示例</a><ul><li><a href="#%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D">相对定位</a></li></ul></li><li><a href="#recycleview%E7%BB%84%E4%BB%B6">RecycleView组件</a><ul><li><a href="#%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96">添加依赖</a></li><li><a href="#%E5%9C%A8%E5%B8%83%E5%B1%80%E4%B8%AD%E6%B7%BB%E5%8A%A0recycleview%E7%BB%84%E4%BB%B6">在布局中添加RecycleView组件</a></li><li><a href="#%E8%AE%A9recycleview%E7%BB%84%E4%BB%B6%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9">让RecycleView组件显示内容</a><ul><li><a href="#recycleview%E7%9A%84%E5%B8%83%E5%B1%80%E4%B8%8E%E6%98%BE%E7%A4%BA">RecycleView的布局与显示</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><p><strong>大部分内容参考了郭霖先生的《第一行代码》，在书的基础上针对目前的实际情况进行实践记录。</strong></p><h2><span id="线性布局">线性布局</span></h2><p>创建一个ACT，并将xml布局文件修改如下：</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"android:orientation="vertical"android:layout_width="match_parent"android:layout_height="match_parent"&gt;    &lt;Button        android:id="@+id/button1"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:text="@string/button_1" /&gt;    &lt;Button        android:id="@+id/button"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:text="Button2" /&gt;    &lt;Button        android:id="@+id/button4"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:text="Button3" /&gt;&lt;/LinearLayout&gt;</code></pre><p>我们在里面添加了三个button，每个的长宽都是：</p><pre><code class="language-xml">android:layout_width="wrap_content"android:layout_height="wrap_content"</code></pre><p>并指定了排列方向是：</p><pre><code class="language-xml">android:orientation="vertical"</code></pre><p>实现效果如下：</p><p><img src="https://s2.loli.net/2024/10/04/mo3LsKahclgFu9V.png" alt="2"></p><h2><span id="约束布局">约束布局</span></h2><p>此部分参考了：</p><p>作者：四会歌神陈子豪链接：<a href="https://www.jianshu.com/p/17ec9bd6ca8a">https://www.jianshu.com/p/17ec9bd6ca8a</a></p><p><strong>约束布局ConstraintLayout</strong> 是一个ViewGroup，可以在Api9以上的Android系统使用它，它的出现主要是为了解决布局嵌套过多的问题，以灵活的方式定位和调整小部件。从 <strong>Android Studio 2.3</strong> 起，官方的模板默认使用 <strong>ConstraintLayout</strong>。</p><p>RelativeLayout是相对布局，它可以根据各个子组件的相对位置来实现布局，打个比方A、B两个组件，想要使用RelativeLayout来针对B布局，你可以指定B组件在A的右侧，这样就根据相对布局完成了一个组件布局。ConstraintLayout同样也能实现这样的功能，ConstraintLayout使用起来比RelativeLayout更灵活，性能更出色！还有一点就是ConstraintLayout可以按照比例约束控件位置和尺寸，能够更好地适配屏幕大小不同的机型。</p><h2><span id="constraintlayout示例">ConstraintLayout示例</span></h2><h3><span id="相对定位">相对定位</span></h3><p>可以看到我们创建了一个布局，其父组件的宽度大小是固定的，长度随文本大小变化而变化：</p><p>其中包含了两个组件一个是imageview 还有一个 Textview。</p><p><img src="https://s2.loli.net/2024/10/04/IsnK3X5qQcTmYiS.png" alt="7"></p><p>我们要通过相对定位来实现二者中心位置对齐：</p><p>首先文本框一定是在图片下头的，所以就要把这个属性设置为这样：</p><pre><code class="language-xml">app:layout_constraintTop_toBottomOf="@+id/imageView"</code></pre><p>constraintTop_toBottomOf这个属性很好理解，第一个constraintTop指的就是这个组建的头位置，toBottomOf就把这个头位置设定到谁的底部。</p><p><img src="https://s2.loli.net/2024/10/04/3a7SBKrAVFnh59q.png" alt="8"></p><p>补一张图方便理解，具体还有什么就不再赘述了，详细了解请参考链接，链接写的非常好！。</p><p><img src="https://s2.loli.net/2024/10/04/CJatVOdw1jzKXgu.png" alt="9"></p><p>需要注意的是，ConstraintLayout设计出来压根就不是来代替经典如LinearLayout、FrameLayout、GridLayout 等布局，你可以把他看作是RelativeLayout的超级加强版，所以切记不要在典型的线性布局需求中使用ConstraintLayout。经典线性布局的需求意味着子控件之间不需要存在任意依赖关系，任何一个控件拿掉了对整体布局没有任何影响。而你拿着ConstraintLayout对每一个子控件进行依赖，说好比国家拎着一个女人强行让你配对一样。</p><p>所以接下来使用组件的时候这两个配合着来用。</p><h2><span id="recycleview组件">RecycleView组件</span></h2><p>RecycleView同样也是ListView的增强版，他的设计和使用更加符合逻辑，不再需要更多的优化操作，所以建议抛弃掉ListView，使用RecycleView。</p><h3><span id="添加依赖">添加依赖</span></h3><pre><code class="language-groovy">implementation 'androidx.recyclerview:recyclerview:1.2.1'</code></pre><p><img src="https://s2.loli.net/2024/10/04/kYb1hIGxqfOMup4.png" alt="a-2"></p><h3><span id="在布局中添加recycleview组件">在布局中添加RecycleView组件</span></h3><p>由于不是系统内置的组件，需要把完整的包名写下来。</p><pre><code class="language-xml">    &lt;androidx.recyclerview.widget.RecyclerView        android:id="@+id/recycleView"        android:layout_width="match_parent"        android:layout_height="match_parent"        /&gt;</code></pre><h3><span id="让recycleview组件显示内容">让RecycleView组件显示内容</span></h3><p>我们需要创建一个布局文件，来规定RecycleView的里面的内容，这里就直接采用上边演示的布局文件，内容很简单，就是一个图片加下边一段文字，接下来我们研究如何将这个布局作为RecycleView的子组件导入到RecycleView之中。</p><p>我们首先需要创建一个Adapter类来将数据先转化为<strong>子布局的内容</strong>再将<strong>子布局</strong>导入到RecycleView之中。标准写法如下：</p><pre><code class="language-kotlin">class FruitAdapter_Recycle(val  fruitList :List&lt;Fruit&gt;):    RecyclerView.Adapter&lt;FruitAdapter_Recycle.ViewHolder&gt;(){    inner class ViewHolder (view:View):RecyclerView.ViewHolder(view)    {        val fruitImage : ImageView = view.findViewById(R.id.imageView)        val fruitName : TextView = view.findViewById(R.id.textView)    }    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {        val view = LayoutInflater.from(parent.context)            .inflate(R.layout.fruit_item,parent,false)        return ViewHolder(view)    }    override fun onBindViewHolder(holder: ViewHolder, position: Int) {        val fruit = fruitList[position]        holder.fruitImage.setImageResource(fruit.imageId)        holder.fruitName.text=fruit.name    }    override fun getItemCount(): Int = fruitList.size}</code></pre><p>继承了RecyclerView包中的Adapter类，可以看到将泛型指定为FruitAdapter_Recycle.ViewHolder，说明其本就是基于ViewHolder的。这为我们优化省去了不少事情。</p><pre><code class="language-kotlin">inner class ViewHolder (view:View):RecyclerView.ViewHolder(view){    val fruitImage : ImageView = view.findViewById(R.id.imageView)    val fruitName : TextView = view.findViewById(R.id.textView)}</code></pre><p>内部类ViewHolder使用最RecyclerView的最外层View来作为构造方法的参数，通过导入布局的View会把对应的子项的内容创建好，方便构造对应的ViewHolder。</p><p>同时这个类还内置好了其他的方法，我们只需将对应方法重写完成就可以正常使用了。</p><p>onCreateViewHolder方法用于创建对应的ViewHolder实例，我们在这个方法中将对应的子布局（fruit_itm）加载进来把构造好的子布局传入到ViewHolder的构造函数当中作为ViewHolder实例返回。</p><pre><code class="language-kotlin"> override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {    val view = LayoutInflater.from(parent.context)    .inflate(R.layout.fruit_item,parent,false)    return ViewHolder(view) }</code></pre><p>onBindViewHolder方法用于对RecycleView中每一个子项进行赋值，在每一个子项进入到屏幕的时候此方法会执行，将对应的数据缓存进来，指定数据的方法很简单通过Position来获取当前的位置然后将数据缓存进去。</p><pre><code class="language-kotlin">  override fun onBindViewHolder(holder: ViewHolder, position: Int) {        val fruit = fruitList[position]        holder.fruitImage.setImageResource(fruit.imageId)        holder.fruitName.text=fruit.name    }</code></pre><p>最后getItemCount方法返回Recycle有多少子项。</p><pre><code class="language-kotlin">override fun getItemCount(): Int = fruitList.size</code></pre><p>使用Adapter_Recycle载入数据：</p><p>载入数据的方法很简单，FruitAdapter_Recycle类的构造函数只需要传入一个List即可，Lsit的数据包含textview要显示的文本和imagebiew现实的图片资源地址：</p><pre><code class="language-kotlin">val fruitList = mutableListOf&lt;Fruit&gt;()fruitList.add(Fruit("Apple", R.drawable.apple_pic))</code></pre><p>每次一个子项滚入到屏幕的时候就会通过onBindViewHolder将数据加载到viewholder里面，然后再显示。</p><h4><span id="recycleview的布局与显示">RecycleView的布局与显示</span></h4><p>我们在完成数据加载以后，可以意识到一个问就是，没有指定子类的布局，在子项之间应该怎么排序？</p><p>RecycleView之中专门有一个成员来管理子类的布局，我们在这就使用线性布局来做演示：</p><p>首先创建一个布局管理类：LinearLayoutManager是系统内置的类，可以让需要的组件实现线性布局。</p><pre><code class="language-kotlin">val layoutManager =LinearLayoutManager(this)</code></pre><p>当然实现也要实现一点不一样的，Listview是无法实现横向滚动的，咱们就来实现一下，实现方法也很简单，只要把线性布局的方向改为水平即可：</p><pre><code class="language-kotlin">layoutManager.orientation=LinearLayoutManager.HORIZONTAL</code></pre><p>最后我们把这个layoutManager传递给recycleview：</p><pre><code class="language-kotlin">binding.recycleView.layoutManager =layoutManager</code></pre><p>然后将数据导入：</p><pre><code class="language-kotlin">val adapter = FruitAdapter_Recycle(fruitViewModel.fruitList)binding.recycleView.adapter=adapter</code></pre><p>实现效果：</p><p>其中名字较长的是为展现一下约束布局的具体效果而加长的。</p><p><img src="https://s2.loli.net/2024/10/04/bwIV3E7CQAeftDU.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RecycleView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（系统架构和Android Studio安装）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%89/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门系统架构和android-studio安装">Android开发笔记——快速入门（系统架构和Android Studio安装）</span></h1><img src="https://s2.loli.net/2024/10/04/uIcZWBhgfYLxHrX.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727982662332" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#android%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84">Android的系统架构</a><ul><li><a href="#linux-%E5%86%85%E6%A0%B8">Linux 内核</a></li><li><a href="#%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82-hal">硬件抽象层 (HAL)</a></li><li><a href="#android-runtime">Android Runtime</a></li><li><a href="#%E5%8E%9F%E7%94%9F-cc-%E5%BA%93">原生 C/C++ 库</a></li><li><a href="#java-api-%E6%A1%86%E6%9E%B6">Java API 框架</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8">系统应用</a></li></ul></li><li><a href="#android%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%92%8Csqlite%E6%95%B0%E6%8D%AE%E5%BA%93">Android的四大组件和SQLite数据库</a><ul><li><a href="#%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6">四大组件</a></li><li><a href="#sqlite%E6%95%B0%E6%8D%AE%E5%BA%93">SQLite数据库</a></li></ul></li><li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA">开发环境的搭建：</a></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="android的系统架构">Android的系统架构</span></h2><p>书上往往介绍为4层实际上谷歌官方将其分为如下：</p><img src="https://s2.loli.net/2024/10/04/PeXupSm1EVNTIci.png" alt="android-stack_2x" style="zoom:80%;"><h3><span id="linux-内核">Linux 内核</span></h3><p>Android 平台的基础是 Linux 内核。例如，<a href="https://developer.android.com/guide/platform#art">Android Runtime (ART)</a> 依靠 Linux 内核来执行底层功能，例如线程和低层内存管理。使用 Linux 内核可让 Android 利用<a href="https://source.android.com/security/overview/kernel-security.html">主要安全功能</a>，并且允许设备制造商为著名的内核开发硬件驱动程序。</p><h3><span id="硬件抽象层-hal">硬件抽象层 (HAL)</span></h3><p><a href="https://source.android.com/devices/architecture/hal-types">硬件抽象层 (HAL)</a> 提供标准界面，向更高级别的 <a href="https://developer.android.com/guide/platform#api-framework">Java API 框架</a>显示设备硬件功能。HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如<a href="https://source.android.com/devices/camera/index.html">相机</a>或<a href="https://source.android.com/devices/bluetooth.html">蓝牙</a>模块。当框架 API 要求访问设备硬件时，Android 系统将为该硬件组件加载库模块。</p><h3><span id="android-runtime">Android Runtime</span></h3><p>对于运行 Android 5.0（API 级别 21）或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的 <a href="https://source.android.com/devices/tech/dalvik/index.html">Android Runtime (ART)</a> 实例。ART 编写为通过执行 DEX 文件在低内存设备上运行多个虚拟机，DEX 文件是一种专为 Android 设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如 <a href="https://source.android.com/source/jack.html">Jack</a>）将 Java 源代码编译为 DEX 字节码，使其可在 Android 平台上运行。</p><h3><span id="原生-cc-库">原生 C/C++ 库</span></h3><p>许多核心 Android 系统组件和服务（例如 ART 和 HAL）构建自原生代码，需要以 C 和 C++ 编写的原生库。Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能。例如，您可以通过 Android 框架的 <a href="https://developer.android.com/reference/android/opengl/package-summary">Java OpenGL API</a> 访问 <a href="https://developer.android.com/guide/topics/graphics/opengl">OpenGL ES</a>，以支持在应用中绘制和操作 2D 和 3D 图形。如果开发的是需要 C 或 C++ 代码的应用，可以使用 <a href="https://developer.android.com/ndk">Android NDK</a> 直接从原生代码访问某些<a href="https://developer.android.com/ndk/guides/stable_apis">原生平台库</a>。</p><h3><span id="java-api-框架">Java API 框架</span></h3><p>您可通过以 Java 语言编写的 API 使用 Android OS 的整个功能集。这些 API 形成创建 Android 应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务：</p><ul><li>丰富、可扩展的<a href="https://developer.android.com/guide/topics/ui/overview">视图系统</a>，可用以构建应用的 UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器</li><li><a href="https://developer.android.com/guide/topics/resources/overview">资源管理器</a>，用于访问非代码资源，例如本地化的字符串、图形和布局文件</li><li><a href="https://developer.android.com/guide/topics/ui/notifiers/notifications">通知管理器</a>，可让所有应用在状态栏中显示自定义提醒</li><li><a href="https://developer.android.com/guide/components/activities">Activity 管理器</a>，用于管理应用的生命周期，提供常见的<a href="https://developer.android.com/guide/components/tasks-and-back-stack">导航返回栈</a></li><li><a href="https://developer.android.com/guide/topics/providers/content-providers">内容提供程序</a>，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据</li></ul><p>开发者可以完全访问 Android 系统应用使用的<a href="https://developer.android.com/reference/packages">框架 API</a>。</p><h3><span id="系统应用">系统应用</span></h3><p>Android 随附一套用于电子邮件、短信、日历、互联网浏览和联系人等的核心应用。平台随附的应用与用户可以选择安装的应用一样，没有特殊状态。因此第三方应用可成为用户的默认网络浏览器、短信 Messenger 甚至默认键盘（有一些例外，例如系统的“设置”应用）。</p><h2><span id="android的四大组件和sqlite数据库">Android的四大组件和SQLite数据库</span></h2><h4><span id="四大组件">四大组件</span></h4><p>四大组件分别是<strong>Activity</strong>、<strong>Service</strong>、<strong>BroadcastReciver</strong>、<strong>ContentProvider</strong>。</p><p><strong>Activity</strong>是应用程序的门面，就是外观设计的必需品，凡是在应用中你看得到的东西都是在<strong>Activity</strong>中实现的。</p><p><strong>Service</strong>是应用在后台的运行，即使退出了应用其也可以在继续运行。</p><p><strong>BroadcastReciver</strong>允许接受和发送广播消息，这里指的是电话短信等通信。</p><p><strong>ContentProvider</strong>是用来向不同的应用程序提供数据共享的组件，通过<strong>ContentProvider</strong>你就可以获取通讯录等。</p><h4><span id="sqlite数据库">SQLite数据库</span></h4><p>系统自带了轻量级的、运算速度极快的嵌入式关系型数据库。支持标准的SQL语法，还可以通过封装好的API进行操作。读取和存储数据变得非常方便。</p><h2><span id="开发环境的搭建">开发环境的搭建：</span></h2><p>需要以下软件：</p><ul><li><p><strong>Jetbrains Toolbox</strong></p></li><li><p><strong>JDK</strong></p></li><li><p><strong>Android SDK 由谷歌提供的开发工具包，在开发应用程序时，我们需要引入该工具来使用相关API。</strong></p></li><li><p><strong>Android Studio</strong></p></li></ul><p>强烈推荐使用<strong>Jetbrains Toolbox</strong>为安装，迁移等提供了极大的方便，特别方便管理<strong>IDEA</strong>等IDE。</p><p><a href="https://www.jetbrains.com/toolbox-app/">Jetbrains Toolbox下载地址</a></p><p>安装也十分简单直接默认安装即可。安装后在windos状态栏左下角可以看见图标，单击打开。</p><p>这里我已经安装了所以在上边显示，直接在可用里面找到点击安装即可。</p><p><img src="https://s2.loli.net/2024/10/04/cf86kF7bMd5zZ4H.png" alt="1"></p><p>如果需要配置一些信息可以打开上图的三个点进行配置：</p><p><img src="https://s2.loli.net/2024/10/04/uANSjiX9kCEcfdR.png" alt="2"></p><p>选择Do not即可。</p><p><img src="https://s2.loli.net/2024/10/04/Sg2Ip9nPRVtiDWl.png" alt="3"></p><p>点击ok以后会显示没有SDK安装的界面，这里选择Cancel。</p><p><img src="https://s2.loli.net/2024/10/04/TN8cLFEw5yRQxBA.png" alt="4"></p><p>开启安装向导：</p><p><img src="https://s2.loli.net/2024/10/04/PdlqRfatXsUJTK3.png" alt="5"></p><p>这里选择Custom安装因为这样可以指定安装位置，节省c盘空间。</p><p><img src="https://s2.loli.net/2024/10/04/BQe9EcvIdAbPzi1.png" alt="6"></p><p>选择已安装的JDK的位置（这里提示一下，如果你是通过IDEA安装的JDK可能不显示因为没有添加到环境变量里面，可以打开cmd测试一下）。</p><p><img src="https://s2.loli.net/2024/10/04/HEDCuKyhi5U2G3n.png" alt="7"></p><p>打开cmd测试一下JDK：</p><p>输入</p><pre><code class="language-shell">java -version</code></pre><p><img src="https://s2.loli.net/2024/10/04/s5MJ4EUC6OYq8Wk.png" alt="25"></p><p>指定好JDK后选择SDK安装位置：</p><p><img src="https://s2.loli.net/2024/10/04/6amWvjGDR1dThC4.png" alt="8"></p><p>这里需要验证一下设置是否正确（和你指定的位置是否一样）。</p><p><img src="https://s2.loli.net/2024/10/04/7Mb9w8aAyoFqERO.png" alt="9"></p><p>这里时需要同意每一项的License要求点击Accept即可。</p><p><img src="https://s2.loli.net/2024/10/04/fqWKVbiNLgkjazM.png" alt="10"></p><p>这里需要等待下载SDK，如果下载失败，你就需要一个魔法来辅助你下载。</p><p><img src="https://s2.loli.net/2024/10/04/zh8K6ytu1aPOXNR.png" alt="11"></p><p>下载完成后看到这个界面就可以退出。</p><p><img src="https://s2.loli.net/2024/10/04/jJEIea3G8WZ7fzH.png" alt="12"></p><p>点击创建一个新的Project。这里选择一个空的Activity。一路默认next下去即可。</p><p><img src="https://s2.loli.net/2024/10/04/LY8Zx1u6JfOhylF.png" alt="13"></p><p>等待初始化完成，右下角显示下载进度。</p><p><img src="https://s2.loli.net/2024/10/04/7isWdvbyLmNUoYp.png" alt="14"></p><p>完成以后首先点击设备管理器，然后选择创建一个设备，这里就选择Pixel 5来进行模拟。</p><p><img src="https://s2.loli.net/2024/10/04/ENVBKL8zbMc1RXH.png" alt="15"></p><p>next后让你选择API等级，此处的API等级应该指的是Java API 框架 的等级包括了<strong>Activity</strong>等。</p><p><img src="https://s2.loli.net/2024/10/04/cBE21uHnMYiylb6.png" alt="16"></p><p>此处显示了不同等级的API兼容性。</p><p><img src="https://s2.loli.net/2024/10/04/6Ly7pTiO8W1NqGs.png" alt="17"></p><p>点击Download会进入API下载器开始下载。</p><p><img src="https://s2.loli.net/2024/10/04/pZCfj7OcNGeuqgz.png" alt="18"></p><p>当然需要一些魔法来实现下载，完成后后点击finish。</p><p><img src="https://s2.loli.net/2024/10/04/DrqV4cxHheGXNw6.png" alt="19"></p><p>下载完成后会进入虚拟配置阶段，此处使用的时刚才选择的pixel5作为虚拟化设备，这里推荐使用硬件解码来实现，如红框部分，选择完成后点击finish。</p><p><img src="https://s2.loli.net/2024/10/04/CLXEMW1ratOkgNn.png" alt="20"></p><p>会看见虚拟机启动的界面。</p><p><img src="https://s2.loli.net/2024/10/04/mywoYSA1MXCIakK.png" alt="21"></p><p>点击右上角运行项目等待完成编译，手机自动运行项目启动。</p><p><img src="https://s2.loli.net/2024/10/04/7luwvmc2VtdxyYE.png" alt="22"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发笔记——快速入门（全局大喇叭）</title>
      <link href="/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
      <url>/2024/10/22/Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="android开发笔记快速入门全局大喇叭">Android开发笔记——快速入门（全局大喇叭）</span></h1><img src="https://s2.loli.net/2024/10/04/86NrLPCpqydHk2W.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727982374567" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h4><span id="软件环境">软件环境：</span></h4><ul><li><strong>Jetbrains Toolbox</strong></li><li><strong>Android Sudio 2021.1.1 Bumblebee</strong></li><li><strong>JDK 17.0.2</strong></li></ul><!-- toc --><ul><li><a href="#%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B">广播机制简介</a><ul><li><a href="#%E5%B9%BF%E6%92%AD%E7%9A%84%E7%B1%BB%E5%9E%8B">广播的类型</a></li></ul></li><li><a href="#%E4%BB%8E%E6%8E%A5%E6%94%B6%E7%B3%BB%E7%BB%9F%E5%B9%BF%E6%92%AD%E5%BC%80%E5%A7%8B">从接收系统广播开始</a><ul><li><a href="#%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC%E6%97%B6%E9%97%B4%E5%8F%98%E5%8C%96">动态注册监听时间变化</a><ul><li><a href="#%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cbroadcastreceiver">动态注册BroadcastReceiver</a></li><li><a href="#%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C%E6%B3%A8%E5%86%8Cbroadcastreceiver">静态注册注册BroadcastReceiver</a></li></ul></li></ul></li><li><a href="#%E5%8F%91%E9%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B9%BF%E6%92%AD">发送自定义广播</a><ul><li><a href="#%E5%8F%91%E9%80%81%E6%A0%87%E5%87%86%E5%B9%BF%E6%92%AD">发送标准广播</a></li><li><a href="#%E5%8F%91%E9%80%81%E6%9C%89%E5%BA%8F%E5%B9%BF%E6%92%AD">发送有序广播</a></li><li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E7%8E%B0%E5%BC%BA%E5%88%B6%E4%B8%8B%E7%BA%BF%E5%8A%9F%E8%83%BD">最佳实现——强制下线功能</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><p>请先参考前一篇文章复习一下Kotlin的一些语法。</p><h2><span id="广播机制简介">广播机制简介</span></h2><p>Android的每一个应用程序可以选择自己需要的广播来接收，可以是来自于系统的广播内容，也可以是来自某个应用程序的广播内容，下面介绍一下Android的广播的类型：</p><h3><span id="广播的类型">广播的类型</span></h3><p>BroadcastReceiver是Android应用程序接收的主要实现类，他是每一个应用程序的广播接收者。</p><ul><li>标准广播：</li></ul><p>是一种完全异步的执行的广播，在广播发出以后，所有的BroadcastReceiver几乎会在同一个时刻收到这条广播，因此，这种广播没有任何顺序可言。效率较高，但无法截断。</p><p>广播流程示意图：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/fe7b20e9672b0a13.png" alt="image-20220621191208528"></p><ul><li>有序广播：</li></ul><p>是一种完全同步执行的广播，在广播发出以后，同一个时刻，只会有一个BroadcastReceiver能够接收到这条广播信息，当这个BroadcastReceiver中的逻辑执行完毕以后，广播才会向下一个继续传递，所以这个广播是有前后顺序的，并且前边的BroadcastReceiver可以把广播截断这样后边的BroadcastReceiver就无法接收到消息了。</p><p>流程示意图如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/c44404ed56d0f89d.png" alt="image-20220621191221501"></p><h2><span id="从接收系统广播开始">从接收系统广播开始</span></h2><p>Android系统内置了很多广播，开机的时候就会自动发送一条广播，电池电量发生变化的时候会再发出来一条广播，系统时间发生变化的时候也会发出对应的广播，如果要接收这些广播，就需要使用BroadcastReceiver。</p><h3><span id="动态注册监听时间变化">动态注册监听时间变化</span></h3><p>在使用BroadcastReceiver前需要注册ManiFest，注册的方法有两种；</p><ul><li><p>在代码中注册。</p></li><li><p>在ManiFest中注册。</p></li></ul><p>我们先来讲解如何在代码中注册。</p><h4><span id="动态注册broadcastreceiver">动态注册BroadcastReceiver</span></h4><p>我们新建一个项目，包含一个空的Act并将项目的名字设置为BroadcastReceiver。</p><p>如何创建一个BroadcastReceiver？只需要新建立一个类让他继承BroadcastReceiver就可以了，重写BroadcastReceiver的onReceiver方法，当有广播来的时候就会调用此方法进行处理。</p><p>修改MainActivity的代码如下：</p><pre><code class="language-kotlin">class MainActivity : BaseActivity() {    lateinit var  timeChangeReceiver : TimeChangeReceiver    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        val intentFilter = IntentFilter()        intentFilter.addAction("android.intent.action.TIME_TICK")         timeChangeReceiver = TimeChangeReceiver()        registerReceiver(timeChangeReceiver,intentFilter)    }    override fun onDestroy() {        super.onDestroy()        unregisterReceiver(timeChangeReceiver)    }    inner class TimeChangeReceiver : BroadcastReceiver()    {        override fun onReceive(context: Context?, intent: Intent?) {            Toast.makeText(context,"Time is changed",Toast.LENGTH_SHORT).show()        }    }}</code></pre><p>这段代码看起来很复杂实际上思路很清晰，我们先从下边的TimeChangeReceiver类说起</p><pre><code class="language-kotlin">inner class TimeChangeReceiver : BroadcastReceiver(){    override fun onReceive(context: Context?, intent: Intent?) {        Toast.makeText(context,"Time is changed",Toast.LENGTH_SHORT).show()    }}</code></pre><p>就像上文说的我们继承于BroadcastReceiver()类，并且重写了对应的onReceive方法，让他在收到系统的广播之后显示一个Toast表示时间变化了。</p><pre><code class="language-kotlin"> override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        val intentFilter = IntentFilter()        intentFilter.addAction("android.intent.action.TIME_TICK")         timeChangeReceiver = TimeChangeReceiver()        registerReceiver(timeChangeReceiver,intentFilter)    }</code></pre><p>在onCreate方法之中我们通过这个 IntentFilter()方法构造了一个intent-Filter如果你不太清楚intent-Filter可以先去看看。</p><p>我们通过过滤器设置来设置接受的广播信息，其中<strong>android.intent.action.TIME_TICK</strong>就是Android发出的时间变化广播。</p><p>再将刚才声明的TimeChangeReceiver实例化，通过Context的函数registerReceiver来将这个过滤器和这个Act绑定到一起。最终实现在这个Act中时间变化广播的接收。</p><p>最后我们在onDestory方法中取消这个Receiver的注册：</p><p>这里调用的同样也是onContext里的方法。</p><pre><code class="language-kotlin">    override fun onDestroy() {        super.onDestroy()        unregisterReceiver(timeChangeReceiver)    }</code></pre><h4><span id="静态注册注册broadcastreceiver">静态注册注册BroadcastReceiver</span></h4><p>动态注册可以自由地注册与控制BoardcastReceiver，但是缺点也很明显，就是无法在不启动应用的情况下相应广播，要想实现这个功能就要使用静态注册的方式。</p><p>理论上来说，系统的广播不论在动态的BroadcastReceiver或者静态的BroadcastReceiver都应该能接收到对应的信息，但是在Android 8.0以后为了防止应用通过静态注册频繁自启动，就将静态注册获取到隐式广播的功能砍掉了，而大多数系统广播实际上是隐式广播，不过还好还留下了部分系统广播作为非隐式广播。</p><p>接下来我们演示如何通过静态广播实现应用自启动。</p><p>我们首先通过AS的引导来创建一个BroadcastReceiver：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/25dc693645eadcbb.png" alt="4"></p><p>其中，Exported代表是否允许这个BroadcastReceiver接收本程序以外的广播，Enabled代表是否启用这个BroadcastReceiver，修改名字为<code>BootCompleteReceiver</code>后完成创建。</p><p>修改类的代码如下：</p><pre><code class="language-kotlin">class BootCompleteReceiver : BroadcastReceiver() {    override fun onReceive(context: Context, intent: Intent) {        // This method is called when the BroadcastReceiver is receiving an Intent broadcast.        Toast.makeText(context,"Boot Complete",Toast.LENGTH_SHORT).show()  }}</code></pre><p>内容很简单就是在接收到广播的时候发出一条toast提示启动。</p><p>需要注意的是静态的BroadcastReceiver需要注册在Manifest的文件里面才可以使用，不过我们是通过引导的方式创建的，所以AS已经自动帮我们注册好了，是不是很方便？</p><p>我打开看一下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/55eb477a9fd642bd.png" alt="5"></p><p>出现了一个新的标签receiver，所有的BroadcastReceiver都是在这里注册的，他的注册方法和&lt; Fragment&gt;其实很相似，也是通过<code>android:name=".BootCompleteReceiver"</code>来指定绑定的是哪一个BroadcastReceiver。</p><p>不过需要注意的是我们没有指定这个BroadcastReceiver具体接收哪一个广播所以还是通过intent-filter来指定接受的广播。</p><p>修改后如下：</p><pre><code class="language-xml">&lt;receiver    android:name=".BootCompleteReceiver"    android:enabled="true"    android:exported="true" &gt;    &lt;intent-filter&gt;    &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt;&lt;/intent-filter&gt;    &lt;/receiver&gt;</code></pre><p>与其他广播不同的是有些系统广播是有很严格的权限要求的，这里不再详细赘述，只知道要在Manifest中添加一个权限声明获取即可：</p><pre><code class="language-xml">&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt;</code></pre><p>实测在荣耀magic40 最新版本下，Android12是无法获取到对应的广播的，但是在模拟器的原生google就可以：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/82c17426a25cbe5b.png" alt="6"></p><h2><span id="发送自定义广播">发送自定义广播</span></h2><p>在使用BroadcastReceiver接收广播以后，我们再来尝试使用如何发送广播。</p><h3><span id="发送标准广播">发送标准广播</span></h3><p>为了测试接收到的广播我们再来准备一个BroadcastReceiver作为接受对象，我们新建立一个类叫MyBroadcastReceiver，并在Mainfest里面添加这个BroadcastReceiver。</p><p>创建类代码入下：</p><pre><code class="language-kotlin">class MyReceiver : BroadcastReceiver() {    override fun onReceive(context: Context, intent: Intent) {        // This method is called when the BroadcastReceiver is receiving an Intent broadcast.        Toast.makeText(context,"Received the message",Toast.LENGTH_SHORT).show()            }</code></pre><p>对应的Mainfest添加代码如下：</p><pre><code class="language-kotlin">&lt;receiver    android:name=".MyReceiver"    android:enabled="true"    android:exported="true"&gt;    &lt;intent-filter&gt;        &lt;action android:name="android.intent.action.MY_BOARDCAST" /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre><p>这里设置让其接收一个<code>android.intent.action.MY_BOARDCAST</code>广播，等下就要发送这样一条广播。</p><p>在布局中再添加一个button如下：</p><pre><code class="language-xml">&lt;Button    android:id="@+id/button"    android:layout_width="0dp"    android:layout_height="wrap_content"    android:text="Send a boardcast"    app:layout_constraintBottom_toBottomOf="parent"    app:layout_constraintEnd_toEndOf="parent"    app:layout_constraintStart_toStartOf="parent"    app:layout_constraintTop_toTopOf="parent" /&gt;</code></pre><p>效果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/8c215ddb78bac494.png" alt="7"></p><p>然后在MainActivity中调用viewbinding来获取到对应button的实例。</p><pre><code class="language-kotlin">class MainActivity : BaseActivity() {    lateinit var  timeChangeReceiver : TimeChangeReceiver    lateinit var binding: ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        val intentFilter = IntentFilter()        intentFilter.addAction("android.intent.action.TIME_TICK")         timeChangeReceiver = TimeChangeReceiver()        registerReceiver(timeChangeReceiver,intentFilter)        /*Send a boardcast*/        binding=ActivityMainBinding.inflate(layoutInflater)        binding.button.setOnClickListener {            val intent = Intent("android.intent.action.MY_BOARDCAST")            intent.setPackage(packageName)            sendBroadcast(intent)        }        setContentView(binding.root)    }    .......}</code></pre><p>在这一段中我们给button添加了一个点击回调函数：</p><pre><code class="language-kotlin">/*Send a boardcast*/binding=ActivityMainBinding.inflate(layoutInflater)binding.button.setOnClickListener {    val intent = Intent("android.intent.action.MY_BOARDCAST")    intent.setPackage(packageName)    sendBroadcast(intent)}setContentView(binding.root)</code></pre><p>首先我们创建了一个Intent指明了发送广播的<strong>意图</strong>，这里用的就是上文注册的广播，然后通过setPackage方法指定发送的应用名称，通过<strong>packageName</strong>来获取到本应用的包名。最后调用**sendBroadcast(intent)**方法发送广播，这里需要注意的是，在默认情况下，如果你不用setPackage指明是哪一个应用，那么他就无法发送，因为上文提到过，没有指明包名的话它默认的是一个匿名的广播，而目前的系统是禁止发送匿名广播的。</p><p>最后实现效果，点击button:</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/61d96c6c035525a8.png" alt="8"></p><h3><span id="发送有序广播">发送有序广播</span></h3><p>发送有序广播的方法很简单，和标准广播几乎类似，为了验证标准广播是可以被截断的，我们再创建一个和上一小节一样的BroadcastReceiver来接收消息。</p><p>代码如下所示：</p><pre><code class="language-kotlin">package com.example.boardcastreceiverimport android.content.BroadcastReceiverimport android.content.Contextimport android.content.Intentimport android.widget.Toastclass MyReceiver2 : BroadcastReceiver() {    override fun onReceive(context: Context, intent: Intent) {        // This method is called when the BroadcastReceiver is receiving an Intent broadcast.        Toast.makeText(context,"Received the message 2", Toast.LENGTH_SHORT).show()    }}</code></pre><p>创建完成以后记得修改mainfest</p><pre><code class="language-xml">&lt;receiver    android:name=".MyReceiver2"    android:enabled="true"    android:exported="true"&gt;    &lt;intent-filter&gt;        &lt;action android:name="android.intent.action.MY_BOARDCAST" /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre><p>到这一步发送的还是标准广播。两个Receiver依次把内容显示出来。</p><p>想要改成有序广播很简单，直接修改发送的函数即可。</p><p>代码如下：</p><pre><code class="language-kotlin">/*Send a boardcast*/binding=ActivityMainBinding.inflate(layoutInflater)binding.button.setOnClickListener {    val intent = Intent("android.intent.action.MY_BOARDCAST")    intent.setPackage(packageName)    sendOrderedBroadcast(intent,null)}setContentView(binding.root)</code></pre><p><code>sendOrderedBroadcast(intent,null)</code>就能发送对应的有序广播，第二个参数是一个与权限相关的字符串，这里先不讨论。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/ae628ffda166e49c.png" alt="9"></p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/3ec4b0ef2f071c94.png" alt="10"></p><p>我先说如何变成有序：</p><p>修改mainfest的代码曾加第一个receiver的优先级：</p><pre><code class="language-xml">&lt;receiver    android:name=".MyReceiver"    android:enabled="true"    android:exported="true"&gt;    &lt;intent-filter android:priority="100"&gt;        &lt;action android:name="android.intent.action.MY_BOARDCAST" /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre><p>这时候谁的优先级大谁就能优先接收到对应的消息。</p><p>那么如何截断消息呢？</p><p>也很简单直接在对应的BroadcastReceiver类中修改onReceive方法即可：</p><pre><code class="language-kotlin">class MyReceiver : BroadcastReceiver() {    override fun onReceive(context: Context, intent: Intent) {        // This method is called when the BroadcastReceiver is receiving an Intent broadcast.        Toast.makeText(context,"Received the message",Toast.LENGTH_SHORT).show()        abortBroadcast()    }}</code></pre><p>这时候就能截断消息了，方法还算很简单。</p><p>我们在来测试一下，发现只能接收一个消息了而且还只能是第一个Receiver。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/6c6bfb6008248a5f.png" alt="11"></p><h3><span id="最佳实现强制下线功能">最佳实现——强制下线功能</span></h3><p>强制下线的功能是一个很常见的功能，在某些时刻你的账号的异地登陆了，就需要将目前在线的内容强制下线，从技术层面上来讲，强制下线就是弹出一个对话窗，不管用户选择哪一个选项，都将退出当前的Activity，返回至登录界面。</p><p>下面我们来实现一下这个功能：</p><p>首先要实现的功能是在任意的Activity中都能退出程序，这个功能的实现方式已经在Activity讲过了，这里就不再详细了。</p><p>我们先来实现一个登陆界面：</p><pre><code class="language-xml">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    android:orientation="vertical"    tools:context=".MainActivity"&gt;    &lt;LinearLayout        android:orientation="horizontal"        android:layout_width="match_parent"        android:layout_height="60dp"&gt;        &lt;TextView            android:layout_width="90dp"            android:layout_height="wrap_content"            android:layout_gravity="center_vertical"            android:textSize="18sp"            android:text="Account:" /&gt;        &lt;EditText            android:id="@+id/accountEdit"            android:layout_width="0dp"            android:layout_height="wrap_content"            android:layout_weight="1"            android:layout_gravity="center_vertical" /&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:orientation="horizontal"        android:layout_width="match_parent"        android:layout_height="60dp"&gt;        &lt;TextView            android:layout_width="90dp"            android:layout_height="wrap_content"            android:layout_gravity="center_vertical"            android:textSize="18sp"            android:text="Password:" /&gt;        &lt;EditText            android:id="@+id/passwordEdit"            android:layout_width="0dp"            android:layout_height="wrap_content"            android:layout_weight="1"            android:layout_gravity="center_vertical"            android:inputType="textPassword" /&gt;    &lt;/LinearLayout&gt;    &lt;Button        android:id="@+id/login"        android:layout_width="200dp"        android:layout_height="60dp"        android:layout_gravity="center_horizontal"        android:text="Login" /&gt;&lt;/LinearLayout&gt;</code></pre><p>效果如下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/cd232613da09a051.png" alt="12"></p><p>我们在登陆按钮添加如下逻辑：</p><pre><code class="language-kotlin">/*login*/binding=ActivityMainBinding.inflate(layoutInflater)binding.login.setOnClickListener {    val account = binding.accountEdit.text.toString()    val password = binding.passwordEdit.text.toString()        if(account == "admin" &amp;&amp; password =="123") {        val intent = Intent(this,OfflineActivity::class.java)        startActivity(intent)        finish()    }else{        Toast.makeText(this,"account or password is invalid",Toast.LENGTH_SHORT).show()    }}</code></pre><p>实现的内容很简单，就是读取账户和密码来校验一下，登陆成功后开启另一个OffilineActivity，并将这个Activity关闭。</p><p>我们再来看一下登陆后的Activity中有什么内容：</p><p>首先布局很简单：</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".OfflineActivity"&gt;    &lt;Button        android:id="@+id/button"        android:layout_width="0dp"        android:layout_height="wrap_content"        android:text="OFFLINE"        app:layout_constraintBottom_toBottomOf="parent"        app:layout_constraintEnd_toEndOf="parent"        app:layout_constraintStart_toStartOf="parent"        app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p>只包含一个用于下线的按钮。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/295ab209e6055946.png" alt="13"></p><p>为按钮添加一个回调，当点击的时候就会发出一个广播让对应的BroadcastReceiver来处理当前的事件。</p><p>代码如下：</p><pre><code class="language-kotlin">class OfflineActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        lateinit var binding: ActivityOfflineBinding        super.onCreate(savedInstanceState)        setContentView(binding.root)        binding.button.setOnClickListener {            val intent = Intent("android.intent.action.MY_BOARDCAST")            sendBroadcast(intent)        }    }}</code></pre><p>终于到了实现强制下线功能的核心阶段了，我们需要考虑的有两个方面，首先是</p><p>我怎么样才能弹出对应的对话框呢？单纯的一个静态的BroadcastReceiver是无法弹出任何一个UI组件的，因为不管哪个UI都需要在一定的context来构建，而在一个单独的静态的Receiver里面的context实际上是他自身，不信输出一下看看：</p><pre><code class="language-kotlin">override fun onReceive(context: Context, intent: Intent) {    // This method is called when the BroadcastReceiver is receiving an Intent broadcast.    Toast.makeText(context,context.toString(),Toast.LENGTH_SHORT).show()}</code></pre><p>可以看到对应的context实际上是不对的，无法为UI提供支持：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/b1807016dbf90b92.png" alt="14"></p><p>那么应该怎么办呢？也很简单我们在BaseActivity中动态注册一个receiver这样所有的Act中都包含了一个receiver。</p><p>动态注册的办法在前面已经讲得很详细了，这里就不在多讨论了直接看代码。</p><pre><code class="language-kotlin">open class BaseActivity : AppCompatActivity() {    val tag :String = javaClass.simpleName    lateinit var receiver:OfflineReceiver    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Log.d(tag,"onCreate")        ActivityCollector.addActivity(this)    }    ........    override fun onResume() {        super.onResume()        val intentFilter = IntentFilter()        intentFilter.addAction("android.intent.action.MY_BOARDCAST")        receiver = OfflineReceiver()        registerReceiver(receiver,intentFilter)        Log.d(tag, "onResume")    }    override fun onPause() {        super.onPause()        unregisterReceiver(receiver)        Log.d(tag, "onPause")    }    ............    inner  class OfflineReceiver:BroadcastReceiver() {        override fun onReceive(context: Context, intent: Intent?) {            AlertDialog.Builder(context).apply {                setTitle("WARNING")                setMessage("FORCE TO OFFLINE")                setCancelable(false)                setPositiveButton("OK") { _, _                    -&gt;                    ActivityCollector.finishALL()                    val i = Intent(context, MainActivity::class.java)                    context.startActivity(i)                }                show()            }        }    }}</code></pre><p>在这里我们实现了在onReceive方法里面为当前界面注册了一个AlertDialog，其中这里的context实际上是：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/22/7f99a0a37156d6ed.png" alt="image-20220622095300526"></p><p>基于Activity的，这样就能生成一个DIALOG了。</p><p>但是具体是为什么，静态和动态的具体差距还不清楚，有时间再研究一下。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> BroadcastReceiver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala基础笔记</title>
      <link href="/2024/10/22/Scala%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/10/22/Scala%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1><span id="scala基础笔记">Scala基础笔记</span></h1><img src="https://s2.loli.net/2024/09/29/fsQuzXhY4FKioqV.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727611612601" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><!-- toc --><ul><li><a href="#scala%E7%9A%84%E5%8E%86%E5%8F%B2">Scala的历史</a></li></ul><ul><li><a href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">环境搭建</a><ul><li><a href="#1-sbt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%92%8Crepl">1、SBT构建工具和REPL</a></li><li><a href="#2-%E4%BD%BF%E7%94%A8ide">2、使用IDE：</a></li></ul></li><li><a href="#scala-%E5%85%A5%E9%97%A8">Scala 入门</a><ul><li><a href="#%E4%B8%80%E7%82%B9%E7%82%B9%E8%A1%A5%E5%85%85">一点点补充</a></li><li><a href="#scala%E7%9A%84%E8%84%9A%E6%9C%AC">Scala的脚本</a></li></ul><ul><li><a href="#%E5%A3%B0%E6%98%8E%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F">声明值和变量</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型：</a></li><li><a href="#scala%E8%BF%90%E7%AE%97%E7%AC%A6">Scala运算符</a></li><li><a href="#scala%E7%9A%84%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">Scala的控制语句</a><ul><li><a href="#range">Range:</a></li><li><a href="#for%E5%BE%AA%E7%8E%AF">for循环</a></li></ul></li><li><a href="#scala%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">Scala的数据结构</a></li><li><a href="#%E5%85%83%E7%BB%84%E5%92%8Czip%E6%93%8D%E4%BD%9C">元组和zip操作</a><ul><li><a href="#zip%E6%93%8D%E4%BD%9C">Zip操作</a></li></ul></li><li><a href="#%E9%9B%86%E5%90%88">集合</a></li><li><a href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89">类的定义</a><ul><li><a href="#%E8%BE%85%E5%8A%A9%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">辅助构造方法</a></li><li><a href="#%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E4%B8%8Emain">单例对象与main</a></li><li><a href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1">伴生对象</a></li></ul></li><li><a href="#%E6%96%B9%E6%B3%95%E4%B8%8E%E5%87%BD%E6%95%B0">方法与函数</a><ul><li><a href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89">方法的定义</a></li><li><a href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%9A%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8">方法的多参数列表</a></li><li><a href="#%E5%87%BD%E6%95%B0%E7%AE%80%E5%86%99%E8%A7%84%E5%88%99">函数简写规则</a></li></ul></li><li><a href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">类的继承：</a><ul><li><a href="#scala-trait%E7%89%B9%E5%BE%81">Scala Trait(特征)</a></li></ul></li><li><a href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模式匹配</a><ul><li><a href="#%E6%A0%B7%E4%BE%8B%E7%B1%BB">样例类</a></li></ul></li></ul></li></ul><!-- tocstop --><h3><span id="scala的历史">Scala的历史</span></h3><p>Scala于2001年由洛桑联邦理工学院（EPFL） 的编程方法实验室研发，它由Martin Odersky（马 丁•奥德斯基）创建。目前，许多公司依靠Java进行 的关键性业务应用转向或正在转向Scala，以提高其开发效率、应用程序的可扩展性和整体的可靠性。</p><p>Scala是Scalable Language的简称，它是一门多范式的编程语言， 其设计初衷是实现可伸缩的语言、并集成面向对象编程和函数式编程的 各种特性。</p><p>可伸缩性，简单来说，是以更大的规模来做你现在所做的事。伸展一个 Web 应用的规模在于让更多的人使用你的程序。如果你没法找出方法在伸展规模的同时提高性能，没关系。而且只要你可以伸展规模来处理更大数量的用户，那么有几个单点故障（single point of failure）也没关系。</p><p>Scala语言可以运行在Windows、Linux、Mac OS等系统上。由于Scala是运行在JVM平台上的， 所以安装Scala之前必须配置好JDK环境。具体的环境配置可以见下文。</p><h2><span id="环境搭建">环境搭建</span></h2><h3><span id="1-sbt构建工具和repl">1、SBT构建工具和REPL</span></h3><p><a href="http://www.scala-sbt.org">SBT构建工具官网</a> 安装 SBT，它是业内公认的构建工具。安装完成后，便可以在 Linux、OS X 终端、Windows 命令窗口中运行 sbt 命令。</p><p>打开 shell 或命令行窗口，进入示例代码解压后的目录，敲入命令 <strong>sbt test</strong>，该命令会 下载所有的依赖项，包括 Scala 编译器及第三方库。下载完毕后，sbt 会编译代码并运行单元测试。该命令最后会输出 success 信息。再次运行 sbt test 命令，由于该命令不需要执行任何事情，你会发现命令很快就结束了，当你启动 sbt 命令时，假如不指定任何任务，SBT 将启动一个交互式 REPL（REPL 是 Read、Eval、Print、Loop 的简写，代表了“读取 - 求值 - 打印 - 循环”）。</p><p>提示：如果报错JAVA version 0 请安装JDK，教程地址：<a href="https://www.cnblogs.com/xch-yang/p/7629351.html">JDK 安装</a>。</p><p>JDK，SBT ，安装完成后可以看到：</p><p>执行：</p><pre><code class="language-shell">sbt test</code></pre><p>有一个警告：</p><p><strong>No sbt.version set in project/build.properties, base directory: D:\Scalar\SBT\test</strong></p><p><img src="https://s2.loli.net/2024/09/29/XEPScdRgH64ezVB.png" alt="baocuo"></p><p>找到解决办法：</p><pre><code>sbt sbtVersion</code></pre><img src="https://s2.loli.net/2024/09/29/n7QJw8bpGAquY9U.png" alt="image-20240929192333080" style="zoom: 50%;"><pre><code class="language-shell">D:\Scalar\SBT\test&gt;sbt sbtVersion[info] Updated file D:\Scalar\SBT\test\project\build.properties: set sbt.version to 1.6.2[info] welcome to sbt 1.6.2 (Oracle Corporation Java 17.0.2)[info] loading project definition from D:\Scalar\SBT\test\project[info] set current project to test (in build file:/D:/Scalar/SBT/test/)[info] 1.6.2</code></pre><p>最后通过<strong>console</strong>进入<strong>REPL</strong></p><pre><code class="language-shell">&gt;sbt console[info] welcome to sbt 1.6.2 (Oracle Corporation Java 17.0.2)[info] loading project definition from D:\Scalar\SBT\test\project[info] set current project to test (in build file:/D:/Scalar/SBT/test/)[info] Non-compiled module 'compiler-bridge_2.12' for Scala 2.12.15. Compiling...[info]   Compilation completed in 8.133s.[info] Starting scala interpreter...Welcome to Scala 2.12.15 (OpenJDK 64-Bit Server VM, Java 17.0.2).Type in expressions for evaluation. Or try :help.</code></pre><p>执行 <strong>scala</strong> 命令时，如果未指定主程序或脚本文件，那么 **scala **将进入 <strong>REPL</strong> 模式，这与在 <strong>sbt</strong> 中运行 <strong>console</strong> 命令类似。（不过，运行 <strong>scala</strong> 时的 <strong>classpath</strong> 与执 行 <strong>console</strong> 任务的 <strong>classpath</strong> 不同。）（如 果你未独立安装 Scala，在 sbt 中执行 console 任务也能进入 Scala REPL 环境）。此时， <strong>REPL</strong> 提示符是 <strong>scala&gt;</strong>。REPL 支持 tab 补全。</p><h3><span id="2-使用ide">2、使用IDE：</span></h3><p><strong>强烈建议使用IDEA，来进行scala开发，省去很多麻烦！</strong></p><p>Idea 社区版 2021.3.2 自带 Scala 插件，无需另行安装，但需要下载 Scala 库。在 Idea 中选择“文件”-&gt;“新建”-&gt;“项目”菜单，在打开的“新建项目”窗口 的左侧列表中选择“Scala”项目类型，在右侧的列表中选择“Idea”子类型， 然后单击“下一步”按钮，如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/Nftb2WoMBvZ3IVl.png" alt="idea"></p><p>在打开的窗口中输入项目名称、软件包前缀信息并选择项目使用的 Scala 库。如果是使用 Idea 第一次创建 Scala 项目，需要点击“创建”按钮，下 载并创建 Scala 库，Scala 库的版本选择 2.13.8，如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/pehr5bsZ9gSqW4A.png" alt="%AI_EC$AVRG0@RD@CNRM9F"></p><p>库下载 完成以后，点击“新建项目”窗口中的“完成”按钮，完成 Scala 项目的创建，如 果创建成功，说明 Scala 开发环境配置成功。</p><p><strong>IDEA</strong> 有另一种执行 <strong>REPL</strong> 的方式。特别是当你使用 <strong>Eclipse</strong>、<strong>IntelliJ</strong> IDEA 或 <strong>NetBeans</strong> 时，这种方式会更加实用。<strong>Eclipse</strong> 和 <strong>IDEA</strong> 支持 <strong>worksheet</strong> 功能，当你编辑 <strong>Scala</strong> 代码时，感觉不到它与正常地编辑编译代码或脚本代码有什么区别。不过一旦将该文件保 存，代码便会立刻被执行。因此，假如你需要修改并重新运行重要的代码片段，使用这种 开发方式比使用 <strong>REPL</strong> 更为方便。</p><p>具体使用见：</p><p><a href="https://blog.csdn.net/weixin_43913245/article/details/120055975">worksheet指南</a></p><h2><span id="scala-入门">Scala 入门</span></h2><h4><span id="一点点补充">一点点补充</span></h4><h4><span id="scala的脚本">Scala的脚本</span></h4><p>有时我们会使用 scalac 来运行 Scala“脚本”文件，而 java 命令行却没有提供类似的功能。脚本文件的扩展名为 .sc，而编译后的文 件的扩展名为 .scala。通常，脚本文件往往也使用 .scala 扩展 名。不过如果使用 SBT 构建项目，SBT 会尝试编译这些以 scala 命名的文件，而这些脚本 文件却无法编译。脚本设计的初衷是为了简化代码，无须将声明（变量和 函数）封装在对象中便是一种简化。而将 Java 和 Scala 代码编译后，声明必须封装在对象 中（这是 JVM 字节码的需求）。scala 命令通过一个聪明的技巧解决了冲突：将脚本封装 在一个你看不到的匿名对象中。如果非要编译可以使用特殊命令：</p><p>在 scalac 命 令中传入 -Xscript  参数， 表示你所选中的 main 类，它是生成的 Java 应用程序的入口点。</p><p>关于匿名类将会在后边有机会再讨论。</p><h3><span id="声明值和变量">声明值和变量</span></h3><p>Scala 有两种类型的变量，一种是使用关键字 <strong>var</strong> 声明的变量，值是可变的，另一种是关键字 <strong>val</strong> 声明的变量，也叫常量值在初始化后不可变。</p><pre><code class="language-scala">var myVar : String ="Hello"</code></pre><pre><code class="language-scala">val myVal : String = "World"</code></pre><p>提示 ：Scala 遵循 Java、C#、C 等语言的注释规则，// comment 只能作用到本行行尾， 而 /* comment */ 则可以跨行。</p><p>Scala 的标识符，如方法名和变量名，中允许出现尖括号，例如定义“小于” 方法时，该方法常被命名为 &lt;，这在 Scala 语言中是允许的，而 Java 则不允 许标识符中出现这样的字符。因此，为了避免出现歧义，Scala 使用方括号 而不是尖括号表示参数化类型，并且不允许在标识符中使用方括号，这一点等我们到了泛型的时候再来讨论。</p><h3><span id="数据类型">数据类型：</span></h3><p>Scala中的所有值都有一个类型，包括数值和函数，但其数据类型都是对象，也就是说scala没有java中的原生类型。在scala是可以对数字等基础类型调用方法的。Scala 尽力使其面向对象特性更加一致，因此这些类型在 Scala 中是包含有方法的对象，就像引用类型一样。然而，Scala 编译时将这些类型尽可能地转为原生类型，使你可以得到原生类型的运行效率。</p><table><thead><tr><th>Byte</th><th>8位有符号补码整数。数值区间为 -128 到 127</th></tr></thead><tbody><tr><td>Short</td><td>16位有符号补码整数。数值区间为 -32768 到 32767</td></tr><tr><td>Int</td><td>32位有符号补码整数。数值区间为 -2147483648 到 2147483647</td></tr><tr><td>Long</td><td>64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807</td></tr><tr><td>Float</td><td>32 位, IEEE 754 标准的单精度浮点数</td></tr><tr><td>Double</td><td>64 位 IEEE 754 标准的双精度浮点数</td></tr><tr><td>Char</td><td>16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF</td></tr><tr><td>String</td><td>字符序列</td></tr><tr><td>Boolean</td><td>true或false</td></tr><tr><td>Unit</td><td>表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。</td></tr><tr><td>Null</td><td>null 或空引用</td></tr><tr><td>Nothing</td><td>Nothing类型在Scala的类层级的最底端；它是任何其他类型的子类型。</td></tr><tr><td>Any</td><td>Any是所有其他类的超类</td></tr><tr><td>AnyRef</td><td>AnyRef类是Scala里所有引用类(reference class)的基类</td></tr></tbody></table><img src="https://s2.loli.net/2024/09/29/lVv4NK9oaZqpbPE.png" alt="image-20240929192445337" style="zoom:80%;"><h3><span id="scala运算符">Scala运算符</span></h3><p>Scala中算术操作符（+、-、 * 、/、%）的作用和 Java是一样的，位操作符（&amp;、|、&gt;&gt;、&lt;&lt;）也是一样 的。特别强调的是，Scala的这些操作符其实是方法。例 如，a+b其实是a.+(b)的简写。</p><h3><span id="scala的控制语句">Scala的控制语句</span></h3><p>Scala 也为 for 循环这一常见的控制结构提供了非常多的特性，这些 for 循环的特性被称为 for 推导式（for comprehension）或 for 表达式（for expression）。 事实上，推导式一词起源于函数式编程。它表达了这样一个理念：我们遍历一个或多个集合，对集合中的元素进行“推导”，并从中计算出新的事物，新推导出的事物往往是另一个集合。</p><h4><span id="range">Range:</span></h4><p>有时我们需要一个数字序列，从某个起点到某个终点。而 Range 能满足这个需要。以下 实例将展示如何创建 Range，支持 Range 的类型包括 Int、Long、Float、Double、Char、 BigInt、和 BigDecimal</p><p>你创建的 Range 可以包含区间上限，也可以不包含区间上限；步长默认为 1，也可以指定 一个非 1 的步长：</p><pre><code class="language-scala">import scala.math.BigDecimal.double2bigDecimal//range 演示for (i&lt;- 1 to 10){  println(i)}output:12345678910//不含右边界for (i &lt;- 1 until  10){  println(i)}output:123456789//步长为3for (i &lt;- 1 to  10 by 3){  println(i)}output:14710//非整数步长for (j &lt;- 1.1 to 10.3 by 3.1 )//需要头文件支持{  println(j)}output:1.14.27.3</code></pre><h4><span id="for循环">for循环</span></h4><p>基础结构如下：</p><pre><code class="language-scala">for(变量&lt;-表达式/数组/集合){    循环语句; }</code></pre><p>像 <strong>变量&lt;-表达式</strong> 这样的表达式也被称为<strong>生成器表达式（generator expression）</strong>，生成器表达式之所以叫这个名字，是因为该表达式会基于集合生成单独的数值。左箭头操作符 (&lt;-) 用于对像列表这样的集合进行遍历。</p><p>当然可以用生成器表达式对数字区间进行访问,以这种方式编写的for更加自然。</p><pre><code class="language-scala">for (i &lt;- 1 to 10)  println(i)output：12345678910</code></pre><h3><span id="scala的数据结构">Scala的数据结构</span></h3><p>Scala中包含两种数组，定长数组和变长数组，定义定长数组，需要使用new关键字，而 定义变长数组时，则需要导包import scala.collection.mutable.ArrayBuffer。</p><p>这里的定长数组指的是，数组的长度不会随着变化。。</p><pre><code class="language-scala">举个例子：&gt;&gt;&gt;&gt; var ab= new Array[Int](3)ab: Array[Int] = Array(0, 0, 0)</code></pre><p>这个数组的长度就是3，但是存在一个问题就是如果我们使用追加函数。</p><p>如下所示：</p><pre><code class="language-scala">scala&gt; ab ++= Array(1,3,4,5)scala&gt; abres1: Array[Int] = Array(0, 0, 0, 1, 3, 4, 5)</code></pre><p>就离谱！它的长度还是变了。将我们追加的元素放了进去。不知道是怎么想的。</p><p>你还会好奇是不是因为var或者val的问题？</p><p>我们再来试一下：</p><p>使用上文定义的数组，我来实现一个操作：</p><pre><code class="language-scala">scala&gt; ab(1)=1scala&gt; abres3: Array[Int] = Array(0, 1, 0, 1, 3, 4, 5)</code></pre><p>果然内容被修改了。</p><p>我们再来定义一个val的数组来试一试。</p><pre><code class="language-scala">scala&gt; val ab2= new Array[Int](3)ab2: Array[Int] = Array(0, 0, 0)</code></pre><p>里面的内容能不能修改呢？</p><pre><code class="language-scala">scala&gt; ab2(2)=1scala&gt; ab2res10: Array[Int] = Array(0, 0, 1)</code></pre><p>也是可以的！那么val到底是什么呢？</p><pre><code class="language-scala">scala&gt; ab2++=Array(1,2,3,4)&lt;console&gt;:13: error: value ++= is not a member of Array[Int]  Expression does not convert to assignment because receiver is not assignable. ab2++=Array(1,2,3,4)</code></pre><p>竟然报错啦！不过你可以意识到一个事情，实际上对于引用类型来说，val，var的实际区别在于其引用对象是否发生了修改，引用的对象的内容发生修改也是完全没有问题的！所以上文实际上是新的一个Array对象，并不是原来的长度发生了变化。</p><h3><span id="元组和zip操作">元组和zip操作</span></h3><p>元组的定义很简单，Scala的元组是对多个不同类型对象的一种简单封装，它将不同 的值用小括号括起来，并用逗号作分隔，即表示元组。</p><pre><code class="language-scala">val tuple=(元素,元素...)</code></pre><p>举个例子：</p><pre><code class="language-scala">scala&gt; val tuple_names=("jszszzy","jszslxl")tuple_names: (String, String) = (jszszzy,jszslxl)</code></pre><p>需要注意的是访问成员的时候需要如下表达式：</p><pre><code class="language-scala">scala&gt; tuple_names._1res15: String = jszszzy</code></pre><h4><span id="zip操作">Zip操作</span></h4><p>zip操作实际上是把多个集合中的元素关联起来，将其合并成一个个元组，再放到集合中。</p><p>举个例子：</p><pre><code class="language-scala">scala&gt; val names=Array("jszszzy","jszslxl")names: Array[String] = Array(jszszzy, jszslxl)scala&gt; val scores=Array(1,2)scores: Array[Int] = Array(1, 2)scala&gt; names.zip(scores)res12: Array[(String, Int)] = Array((jszszzy,1), (jszslxl,2))</code></pre><p>实际上每个Array中的元素变成了一个元组。</p><p>当然这个方法不能对两个元组使用，否则会报错。</p><pre><code class="language-scala">scala&gt; tuple_scores.zip(tuple_names)&lt;console&gt;:14: error: value zip is not a member of (Int, Int)       tuple_scores.zip(tuple_names)</code></pre><h3><span id="集合">集合</span></h3><p>在Scala中，集合有三大类： List、Set以及Map，所有的集合都扩展自Iterable特质 。 Scala 集合分为可变的（mutable）和不可变（immutable）的 集合：</p><p>➢ 可变集合可以在适当的地方被更新或扩展，意味着可以对 集合进行修改、添加、移除元素</p><p>➢ 不可变集合类，初始化后就永远不会改变。</p><p>举个例子：</p><pre><code class="language-Scala">// 字符串val fruit: List[String] =List("apples","oranges","pears")// 整型val nums: List[Int] = List(1, 2, 3, 4)// 空val empty: List[Nothing] = List()// 二维列表val dim: List[List[Int]] =List(List(1, 0, 0),List(0, 1, 0),List(0, 0, 1))</code></pre><p>在Scala中，Set是没有重复对象的集合，所有元素都是唯一 的。默认情况下，Scala 使用不可变Set集合，若想使用可变的 Set集合，则需要引入 scala.collection.mutable.Set 包。</p><p>举个例子：</p><pre><code class="language-scala">val set: Set[Int] = Set(1,2,3,4,5)</code></pre><p>map</p><p>在Scala中，Map是一种可迭代的键值对（key/value）结构， 并且键是唯一的，值不一定是唯一的，所有的值都是通过键来获取 的。Map中所有元素的键与值都存在一种对应关系，这种关系即为 映射。Map有两种类型，可变集合与不可变集合，默认是不可变 Map 。 若 需 要 使 用 可 变 的 Map 集 合 ， 则 需 要 引 入 import scala.collection.mutable.Map 类。</p><p>举个例子：</p><pre><code class="language-scala">var A:Map[Char,Int] = Map(键 -&gt; 值,键 -&gt; 值...)</code></pre><h3><span id="类的定义">类的定义</span></h3><p>无论是在Scala中还是Java中，类都是对象的抽象，而对象都是类的具体实例；类不占用内存，而对象占用存储空间。由于面向对象的核心是对 象，若想要在应用程序中使用对象，就必须得先创建一个类。类是用于描 述一组对象的共同特征和行为。</p><p>在 Scala 中定义类时需要输入 class 关键字，整个类定义体包含在最外层的一对大括号中 （{…}）。事实上，这个类定义体同样也是这个类的主构造函数。假如需要将参数传递给这个构造函数，就要在类名之后输入参数列表。</p><pre><code class="language-scala">class 类名 (参数列表)</code></pre><p>Scala类的定义主体就是类的构造器，称为主构造器，在类名之后用圆括号列出主构造 器的参数列表 . 主构造器的参数前可以使用val或var关键字，Scala内部将自动为这些参数创建私有字段， 并提供对应的访问方法:</p><p>举个例子：</p><pre><code class="language-scala">scala&gt; class Person(val name:String)defined class Personscala&gt; val jszszzy = new Person("Jszszzy")jszszzy: Person = Person@55f4f59a//访问对应的成员属性，虽然是私有的但是默认提供了对应的访问方法。scala&gt; jszszzy.nameres14: String = Jszszzyscala&gt; jszszzy.name="Jszslxl"&lt;console&gt;:12: error: reassignment to val       jszszzy.name="Jszslxl"</code></pre><h4><span id="辅助构造方法">辅助构造方法</span></h4><p>辅助构造方法使用this来作为方法名，this的返回类型为Unit，其定义格式如下：</p><pre><code class="language-scala">class 类名{def this(参数){this(主构造器参数)this.属性 = 参数;}}</code></pre><p>每个辅助构造器的第一个表达式必须是调用一个此前已经定义的辅助构造器或主构造器， 调用的形式为“this(参数列表)”</p><h4><span id="单例对象与main">单例对象与main</span></h4><p>与Java不同的是，Scala中提供了object这个关键字用来实现单例模式，使用关键字object创 建的对象为单例对象。你如果在类的文件中直接定义一个mian方法是不能直接运行的，在IDEA中会报错：</p><pre><code class="language-scala">package priv.jszszzy.testclass HelloWorld{  var myVar : String ="Hello"  val myVal : String = "World"  def main(strings: Array[String]): Unit =  {    println(myVar + myVal)  }}ERROR: main 方法不是类 priv.jszszzy.test.HelloWorld 中的static, 请将 main 方法定义为: public static void main(String[] args)</code></pre><p>但是scala没有static，这个其使用java虚拟机运行有很大关系，你需要这样定义：</p><pre><code class="language-scala">package priv.jszszzy.testobject HelloWorld{  var myVar : String ="Hello"  val myVal : String = "World"  def main(strings: Array[String]): Unit =  {    println(myVar + myVal)  }}</code></pre><p>由此可以看出，其想要main的入口方法需要一个object的单例类，scala 将单例模式视为本语言的第一等级成员。尽管我们声明了一个类，不过 Scala 运行时只会创建 HelloWorld的一个实例。也就是说，你无法 通过 new 创建 HelloWorld 对象。就好像 Java 使用静态类型一样，其他语言使用类成员（class-level member），Scala 则使用对象进行处理。由于 HelloWorld 中并不包含状态信息，所以我们此 处的确不需要多个实例，使用单例便能满足需求。</p><h4><span id="伴生对象">伴生对象</span></h4><p>在一个源文件中有一个类和一个单例对象，若单例对象名与类名相同，则把 这个单例对象称作伴生对象（companion object），这个类则被称为是单例对象的伴生类（companion class）。类和伴生对象之间可以相互访问私有的方法和字段。</p><ul><li><strong>class 中要访问 object 中的私有属性，直接以 object 名来 “点” 相应的变量或方法即可，可以参考下面例子</strong>；</li><li><strong>object 中要访问 class 中的私有属性，必须要通过 class 的对象引用来 “点” 相应变量或方法，可以参考下面例子</strong>。</li></ul><pre><code class="language-scala">package priv.jszszzy.testclass HelloWorld{  private var myName : String ="companion class"  def test():Unit =  {    println(HelloWorld.myVal)    //调用伴生对象的成员  }}object HelloWorld{  private var myVar : String ="Hello"  private val myVal : String = "World"  private var c_ClassName : HelloWorld =new HelloWorld();  def test():Unit =  {    println(HelloWorld.myVar)  }  def main(strings: Array[String]): Unit =  {    println(myVar + myVal)    //伴生对象的成员    println(c_ClassName.myName)    //伴生对象的方法    HelloWorld.test()    // 伴生类的方法    c_ClassName.test()  }}output:HelloWorldcompanion classHelloWorld</code></pre><h3><span id="方法与函数">方法与函数</span></h3><p>对于大多数的面向对象编程语言而言，方法指的是类或对象中定义的函数。当调用方 法时，方法中的 this 引用会隐性地指向某一对象。当然，在大多数的 OOP 语言中， 方法调用的语法通常是 :</p><pre><code class="language-scala">this.method_name(other_args)</code></pre><p>本文中的“方法”也满足这一 常用规范。我们提到的“函数”尽管不是方法，但在某些时候通常会将方法也归入函 数。当前上下文能够认清它们的区别。</p><h4><span id="方法的定义">方法的定义</span></h4><pre><code class="language-scala">def functionName ([参数列表]):[return type]={    function body    return [expr]}</code></pre><p>函数定义：</p><pre><code class="language-scala">val functionName ([参数列表]):[return type]={    function body    return [expr]}</code></pre><h4><span id="方法的多参数列表">方法的多参数列表</span></h4><p>这里的 draw 方法有两个参数列表，每个参数列表都有一个参数，而不是拥有一个 具有两个参数的参数列表。</p><pre><code class="language-scala">package priv.jszszzy.testobject HelloWorld{  private var myVar : String ="Hello"  private val myVal : String = "World"  def MultiArgs(a : Int)(b :Int):Unit =  {    println(a)    println(b)  }  def main(strings: Array[String]): Unit =  {      /*那么，为什么要允许多个参数列表呢?      当最后一个参数列表只包含一个表示函数的参数时，多个参数列表的形式拥有整齐的块结构语法。      以下是我们调用新的 draw 方法的表达 方式：*/    MultiArgs(1){2}  }}</code></pre><h4><span id="函数简写规则">函数简写规则</span></h4><ul><li>（1）return可以省略，Scala会使用方法体的最后一行代码作为返回值</li><li>（2）返回值类型如果能够推断出来，那么可以省略</li><li>（3）如果方法体只有一行代码，可以省略花括号</li><li>（4）如果方法无参，则可以省略小括号。若定义方法时省略小括号，则调用该方法时，也需省略小括号；若定时方法时未省略，则调用时，可省可不省。</li><li>（5）如果方法明确声明Unit，那么即使方法体中使用return关键字也不起作用</li><li>（6）Scala如果想要自动推断无返回值，可以省略等号</li><li>（7）如果方法明确使用return关键字，那么方法返回就不能使用自行推断了，需要声明返回值类型</li></ul><h3><span id="类的继承">类的继承：</span></h3><ul><li><p>Scala和Java类似，只允许继承一个父类</p></li><li><p>Java只能继承父类中非私有的属性和方法，而Scala可以继承父类中 的所有属性和方法。</p><pre><code class="language-scala"> //父类class HelloWorld{  private var myName : String ="companion class"  def test():Unit =  {    println(HelloWorld.myVal)    //调用伴生对象的成员  }}//子类class HelloWorld_son extends HelloWorld{  var myName :String = "HelloWorld_Son"  override def test(): Unit =//需要加入override关键字，来重写非抽象方法  {    println(myName);  }}//主类用来运行函数object HelloWorld{  private var myVar : String ="Hello"  private val myVal : String = "World"      //类的继承演示代码  def extendsTest(): Unit =  {    var son :HelloWorld_son= new HelloWorld_son()    son.test();  }  def main(strings: Array[String]): Unit =  {     //调用继承的方法    extendsTest()  }}output：HelloWorld_Son</code></pre><h4><span id="scala-trait特征">Scala Trait(特征)</span></h4><p>​在Scala中，Trait（特质）的功能类似于Java中的接口，但Trait的 功能却比Java中的接口强大。例如，Trait可以对定义的字段和方法进行实现，而接口却不能。Scala中的Trait可以被类和对象使用关键字extends来继承。</p><p>定义方法：</p><pre><code class="language-scala">//特质演示trait HelloWorld_trait{  val trait_member = "trait"//特质成员  def traitTest ()= println(trait_member)//特质方法  def traitAbstratTest() :Unit//特质抽象方法}</code></pre><p>部分代码演示：</p><pre><code class="language-scala">package priv.jszszzy.test//父类class HelloWorld{  private var myName : String ="companion class"  def test():Unit =  {    println(HelloWorld.myVal)    //调用伴生对象的成员  }}object HelloWorld extends HelloWorld_trait{  private var myVar : String ="Hello"  private val myVal : String = "World"  def main(strings: Array[String]): Unit =  {     //调用重写后的抽象方法    HelloWorld.traitAbstratTest()  }  //重写特质的抽象方法  def traitAbstratTest(): Unit =  {    HelloWorld.traitTest()  }}//特质演示trait HelloWorld_trait{  val trait_member = "trait"  def traitTest ()= println(trait_member)  def traitAbstratTest() :Unit}</code></pre></li></ul><h3><span id="模式匹配">模式匹配</span></h3><p>每一个模式匹配都包含了一系列选项，每个都开始于<strong>case</strong>关键字，每个模式和表达式通过**=&gt;**来分开。值得一说的是，case在执行完语句后就不会再去执行其他case。</p><pre><code class="language-scala">object Test {   def main(args: Array[String]) {      println(matchTest("two"))      println(matchTest("test"))      println(matchTest(1))      println(matchTest(6))   }   def matchTest(x: Any): Any = x match    {        //对应整型数值 1      case 1 =&gt; "one"        //对应字符串值 two      case "two" =&gt; 2        //case 对应类型模式，用于判断传入的值是否为整型      case y: Int =&gt; "scala.Int"        //表示默认的全匹配备选项      case _ =&gt; "many"   }}</code></pre><h4><span id="样例类">样例类</span></h4><p>使用了case关键字的类定义就是样例类(case classes)，样例类是种特殊的类，经过优化以用于模式匹配。</p><p>使用后会有如下自动生成。</p><ul><li>构造器的每个参数都成为val，除非显式被声明为var，但是并不推荐这么做；</li><li>在伴生对象中提供了apply方法，所以可以不使用new关键字就可构建对象；</li><li>提供unapply方法使模式匹配可以工作；</li><li>生成toString、equals、hashCode和copy方法，除非显示给出这些方法的定义。</li></ul><pre><code class="language-scala">object HelloWorld extends HelloWorld_trait{  def case_test(test : case_test): Unit =  {    test match    {      case x:case_test =&gt;println("This is case")      case case_test("jszszzy") =&gt; println("This is zzy")    }  }      def main(strings: Array[String]): Unit =  {    //调用模板类测试方法    case_test(new case_test("jszszzy"));  }}//模式匹配演示case class case_test( name :String)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark的WSL环境安装与Hadoop环境配置（贰）</title>
      <link href="/2024/10/22/Spark(2)/"/>
      <url>/2024/10/22/Spark(2)/</url>
      
        <content type="html"><![CDATA[<h1><span id="spark快速大数据分析spark的wsl环境安装与hadoop环境配置贰">Spark快速大数据分析——Spark的WSL环境安装与Hadoop环境配置（贰）</span></h1><img src="https://s2.loli.net/2024/09/29/AGdij6z9ftuKrh1.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727611823050" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h3><span id="软件环境">软件环境：</span></h3><ul><li><strong>Hadoop-3.2</strong></li><li><strong>Spark-3.1.3</strong></li><li><strong>JDK 8</strong></li><li><strong>WSL2</strong> <strong>Ubuntu20.04</strong></li><li><strong>Windos10 20H2</strong></li></ul><!-- toc --><ul><li><a href="#spark%E7%9A%84wsl%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">Spark的WSL环境搭建：</a><ul><li><a href="#%E7%AC%94%E8%AE%B0%E6%9C%ACwindos%E5%A6%82%E4%BD%95%E6%9C%80%E5%BF%AB%E9%80%9F%E7%9C%81%E4%BA%8B%E5%8D%87%E7%BA%A7%E4%B8%93%E4%B8%9A%E7%89%88">笔记本Windos如何最快速省事升级专业版？</a></li><li><a href="#wsl%E7%9A%84%E5%AE%89%E8%A3%85">WSL的安装</a></li><li><a href="#%E5%8D%87%E7%BA%A7wsl%E8%87%B3wsl2">升级WSL至WSL2</a></li><li><a href="#wsl2%E6%8D%A2%E4%B8%8B%E8%BD%BD%E6%BA%90">WSL2换下载源</a></li><li><a href="#hadoop%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">Hadoop环境配置</a><ul><li><a href="#%E5%88%9B%E5%BB%BAhadoop%E7%94%A8%E6%88%B7">创建hadoop用户</a></li></ul></li><li><a href="#%E6%9B%B4%E6%96%B0apt">更新apt</a></li><li><a href="#%E5%AE%89%E8%A3%85vim">安装Vim</a></li><li><a href="#%E5%AE%89%E8%A3%85ssh-%E9%85%8D%E7%BD%AEssh%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E9%99%86">安装SSH、配置SSH无密码登陆</a></li><li><a href="#java%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">Java环境配置</a></li><li><a href="#hadoop%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-1">Hadoop环境配置</a></li><li><a href="#%E6%8F%90%E7%A4%BA">提示：</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="spark的wsl环境搭建">Spark的WSL环境搭建：</span></h2><p>Hadoop还不算折腾人的，当年caffe环境才是最恶心的，装过caffe以后装什么都很有自信。</p><p>俗话说的好windos是最好的linux发行版，WSL2是证明这个观点的强有力的证据。开个玩笑。</p><p><strong>先来说如何安装WSL2，注意这里说的是WSL2并不是WSL！</strong></p><p>如果你的电脑是Windos专业版，可以直接跳到WSL2安装部分，如果你的电脑是家庭中文版就先往下看。</p><h3><span id="笔记本windos如何最快速省事升级专业版">笔记本Windos如何最快速省事升级专业版？</span></h3><p>找到你的<strong>windos激活界面</strong>先查看自己windos版本，如果是家庭版就需要升级来获取高级的系统组件，点击<strong>更改产品密钥</strong>：</p><img src="https://s2.loli.net/2024/09/29/FaPKcwdSZJRQM7D.png" alt="1" style="zoom:80%;"><p>点击更改密钥：</p><p><img src="https://s2.loli.net/2024/09/29/d3OyMjPQxv2uoJL.png" alt="2"></p><p>会让你输入密钥来升级，密钥的获取当然是万能的TB了，直接搜索windos激活码然后先问店家买一个升级码再买一个激活码即可。（注意是两个码！）</p><p><img src="https://s2.loli.net/2024/09/29/w42bfKL1o8EFaXi.png" alt="3"></p><p>先输入升级码进行升级，重启后再使用激活码进行激活，一共<strong>7块钱</strong>就可以搞点，虽然有很多升级办法，但是这个还是最省事的，升级过程最好插上电，防止没电。升级过程因为没办法截图就没有截图，过程都是自动的，不需要太多操作这里就不详细赘述了。</p><p>升级完成后在系统激活中输入激活码直接激活即可：</p><p><img src="https://s2.loli.net/2024/09/29/AVLYUlQJRrGpZ48.png" alt="4"></p><p>激活完成界面：</p><p><img src="https://s2.loli.net/2024/09/29/i2uFdL68HORWSZX.png" alt="5"></p><p>这样一来你就升级到了专业版。</p><h3><span id="wsl的安装">WSL的安装</span></h3><p>然后进行WSL的安装：</p><p>首先添加系统组件：</p><p><img src="https://s2.loli.net/2024/09/29/72G95lHR1Qe4kbO.png" alt="6"></p><p><img src="https://s2.loli.net/2024/09/29/9hdCx1Wy8pTnSMz.png" alt="7"></p><p>确定后等待完成：</p><p><img src="https://s2.loli.net/2024/09/29/uDfm85SXjI6cOh4.png" alt="8"></p><p>在windos商店中查找Ubuntu：</p><p><img src="https://s2.loli.net/2024/09/29/LvqAomlGQXgPhE7.png" alt="9"></p><p>直接点击下载然后等待安装即可，安装完成以后打开，设置一下用户名和密码：</p><img src="https://s2.loli.net/2024/09/29/GVAw8S2c1FY9LmQ.png" alt="10" style="zoom:80%;"><p>先关闭界面，因为这里可能安装的是WSL1，不过没关系，我们可以升级一下直接用就行，先检测一下版本：</p><p>打开windos cmd或者powershell（以管理员身份打开）：</p><p>输入命令：<code>wsl -l -v</code></p><img src="https://s2.loli.net/2024/09/29/Jtds9mUN3BFObHu.png" alt="11" style="zoom:80%;"><p>如果如图，那么你就安装的是WSL2，可以直接跳到<strong>hadoop安装</strong>，如果你输出的是1请往下看升级步骤：</p><p>升级之前先要注意一个问题就是windos的版本：</p><p>若要更新到 WSL 2：</p><ul><li>对于 x64 系统：<strong>版本 1903</strong> 或更高版本，采用<strong>内部版本 18362</strong> 或更高版本。</li><li>我的是20H2所以没问题，你如果版本不够请先升级windos。</li></ul><p><img src="https://s2.loli.net/2024/09/29/DSg9J1oIBzh7jnN.png" alt="13"></p><h3><span id="升级wsl至wsl2">升级WSL至WSL2</span></h3><p>首先下载Linux内核更新包：<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">点击下载</a>。</p><p>下载完成后直接安装即可：</p><p><img src="https://s2.loli.net/2024/09/29/L2TbWX7HBjFkJ8m.png" alt="12"></p><p>如果你没有安装内核更新包直接打开WSL就有可能遇到以下错误：</p><pre><code class="language-SSH">WslRegisterDistribution failed with error: 0x800701bcError: 0x800701bc WSL 2 ?????????????????? https://aka.ms/wsl2kernelPress any key to continue.. .</code></pre><p><img src="https://s2.loli.net/2024/09/29/yDq8HI9sRXYvCZ1.png" alt="14"></p><p>安装内核包以后就没有问题了。</p><p>这时候我们再设置一下WSL的默认版本：</p><p>打开cmd使用命令：</p><pre><code class="language-ssh">wsl --set-version Ubuntu-20.04 2</code></pre><p>使用完成后再打开WSL就可以看见：</p><p><img src="https://s2.loli.net/2024/09/29/8CRTyZvqBEXHVNP.png" alt="15"></p><p>等一段时间然后按一下回车就可以看见：</p><p>可以看到WSL已经更新到了WSL2。</p><p><img src="https://s2.loli.net/2024/09/29/BeFguHc83LM74wX.png" alt="16"></p><p>如果你没有这个界面或者更新失败，问题不大，不要慌，卸载然后返回到安装步骤再来一遍即可：</p><p><img src="https://s2.loli.net/2024/09/29/xGML4oR71kYh5fH.png" alt="17"></p><h3><span id="wsl2换下载源">WSL2换下载源</span></h3><p>首先输入命令备份当前源目录：</p><pre><code class="language-ssh">cd /etc/apt  #进入配置文件所在目录cp sources.list sources.list.bak  #备份配置文件</code></pre><p>使用vim编辑源文件：</p><pre><code class="language-ssh">vim sources.list  #编辑配置文件</code></pre><p>打开后将里面内容全部删除并替换成以下内容：</p><p>删除内容方法：</p><ul><li>按一下ESC键，确保退出编辑模式</li><li>按两次键盘上面的g键，让光标移动到文本的首行</li><li>然后按键盘上面的d和G键。其中d键是小写，G键要切换成大写的。</li></ul><p>然后切换到编辑模式（输入i）复制进去即可：</p><pre><code class="language-ssh">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</code></pre><p>注意换行问题，web可能显示换行实际上每一行都是没有换行的！可以先复制到记事本再copy过去。</p><p>复制以后样子如下：</p><p><img src="https://s2.loli.net/2024/09/29/fVmbMJBXYTw1ytg.png" alt="1-1"></p><p>退出编辑并保存：esc+wq</p><p>使用命令更新源：</p><pre><code class="language-ssh">sudo apt-get update  #更新源  </code></pre><p><img src="https://s2.loli.net/2024/09/29/bcB48ROESynTuH1.png" alt="1-3"></p><p>更新软件：</p><pre><code>sudo apt-get upgrade  #更新软件</code></pre><p><img src="https://s2.loli.net/2024/09/29/7SzMs1EZw8Ax2aU.png" alt="1-4"></p><h3><span id="hadoop环境配置">Hadoop环境配置</span></h3><p>首先介绍一下，WSL下一些常用的功能：</p><p>在WSL下打开windos的文件浏览器来访问linux下的文件。</p><p>输入命令：</p><p><code>explorer.exe .</code></p><p><strong>注意exe后边还有一个空格。</strong></p><h4><span id="创建hadoop用户">创建hadoop用户</span></h4><p>如果你安装 Ubuntu 的时候不是用的 “hadoop” 用户，那么需要增加一个名为 hadoop 的用户。</p><pre><code class="language-ssh">$ sudo useradd -m hadoop -s /bin/bash</code></pre><p>这条命令创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为 shell。（在Ubuntu终端窗口中，复制粘贴的快捷键需要加上 shift，即粘贴是 ctrl+shift+v。）</p><pre><code class="language-ssh">$ sudo passwd hadoop</code></pre><p>为hadoop用户增加管理员权限：</p><pre><code class="language-ssh">$ sudo adduser hadoop sudo</code></pre><p>最后输入：</p><pre><code class="language-ssh">$ su hadoop</code></pre><p>切换到hadoop用户。</p><h3><span id="更新apt">更新apt</span></h3><p>用 hadoop 用户登录后，我们先更新一下 apt，后续我们使用 apt 安装软件，如果没更新可能有一些软件安装不了。 按 ctrl+alt+t 打开终端窗口，执行如下命令：</p><pre><code class="language-ssh">$ sudo apt-get update</code></pre><p>若出现如下 “Hash校验和不符” 的提示，可通过更改软件源来解决。若没有该问题，则不需要更改。从软件源下载某 些软件的过程中，可能由于网络方面的原因出现没法下载的情况，那么建议更改软件源。</p><h3><span id="安装vim">安装Vim</span></h3><pre><code>$ sudo apt-get install vim</code></pre><p>vim的常用模式有分为命令模式，插入模式，可视模式，正常模式。本教程中，只需要用到正常模式和插入模式。二 者间的切换即可以帮助你完成本指南的学习。</p><ol><li>正常模式 正常模式主要用来浏览文本内容。一开始打开vim都是正常模式。在任何模式下按下Esc键就可以返回正常模式</li><li>插入编辑模式 插入编辑模式则用来向文本中添加内容的。在正常模式下，输入i键即可进入插入编辑模式</li><li>退出vim 如果有利用vim修改任何的文本，一定要记得保存。Esc键退回到正常模式中，然后输入:wq即可保存文本并退出 vim。</li></ol><h3><span id="安装ssh-配置ssh无密码登陆">安装SSH、配置SSH无密码登陆</span></h3><p>集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令）， Ubuntu 默认已安装了 SSH client，此外还需要安装 SSH server：</p><pre><code class="language-ssh">$ sudo apt-get install openssh-server</code></pre><p>安装后，需要重新启动一下：</p><pre><code class="language-ssh">$ sudo service ssh restart</code></pre><p>输入命令后发现报错：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sudo service ssh restartsshd: no hostkeys available -- exiting.</code></pre><p>使用exit切换到root用户：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ exitexitjszszzy@LAPTOP-74GAR8S9:~$</code></pre><p>检查ssh是否生成密钥，发现没有：</p><pre><code class="language-ssh">jszszzy@LAPTOP-74GAR8S9:~$ cd ~/.ssh/-bash: cd: /home/jszszzy/.ssh/: No such file or directory</code></pre><p>再切换到hadoop用户尝试连接一下本地ssh：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sudo ssh localhost[sudo] password for hadoop:ssh: connect to host localhost port 22: Connection refused</code></pre><p>发现报错：</p><p><strong>ssh: connect to host localhost port 22: Connection refused</strong></p><p>这报错可使用下边的命令解决，或者卸载ssh再重新安装一遍也可能会解决。</p><p>使用管理权限开始ssh服务：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sudo service ssh start * Starting OpenBSD Secure Shell server sshd                                             sshd: no hostkeys available -- exiting.</code></pre><p>**sshd: no hostkeys available – exiting.**仍报错</p><p>没办法手动生成一下hostkey，两种加密方式：</p><pre><code class="language-ssh">sudo ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key</code></pre><pre><code class="language-ssh">sudo ssh-keygen -t dsa -f /etc/ssh/ssh_host_rsa_key</code></pre><pre><code class="language-ssh">sudo ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_keyGenerating public/private dsa key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /etc/ssh/ssh_host_dsa_keyYour public key has been saved in /etc/ssh/ssh_host_dsa_key.pubThe key fingerprint is:SHA256:Oizwqo5xcIIVUTAetxHLW8StQ2+oRT/FMAWei/EoKIA root@LAPTOP-74GAR8S9The key's randomart image is:+---[DSA 1024]----+|  *+=o..+=.      ||.. * =+..oo      ||E o +oo=o.       ||o. . o===.       ||= + ooooS.       || = o.o .         ||. . o +          ||.o . . .         ||+o.              |+----[SHA256]-----+</code></pre><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sudo ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_keyGenerating public/private rsa key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /etc/ssh/ssh_host_rsa_keyYour public key has been saved in /etc/ssh/ssh_host_rsa_key.pubThe key fingerprint is:SHA256:2iivZii9bXWn7GXnkK3oVoEbjuVkfKuVnjocVyABTcM root@LAPTOP-74GAR8S9The key's randomart image is:+---[RSA 3072]----+|      .=+.       ||        E..      ||       . o .     ||        B o .    ||       BS+ =     ||      o+* Bo     || . ...o+.X=.o    ||. o.+o  B+o=     || ..=o..+=o. .    |+----[SHA256]-----+</code></pre><p>如果还没解决，就卸载ssh后安装：</p><pre><code class="language-ssh">sudo apt-get purge openssh-server</code></pre><pre><code class="language-ssh">sudo apt-get update</code></pre><pre><code>sudo apt-get install openssh-server</code></pre><p>最后启动一下：</p><pre><code>sudo service ssh restart</code></pre><p>如果还不成功尝试以下命令：</p><pre><code>sudo ssh-keygen -Asudo chmod 600 /etc/ssh/ssh_host_rsa_keysudo chmod 600 /etc/ssh/ssh_host_dsa_key</code></pre><p>再次打开ssh，发现成功：</p><pre><code class="language-ssh">sudo service ssh restart * Restarting OpenBSD Secure Shell server sshd</code></pre><p>然后查找进程是否存在：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sps -e | grep ssh12765 ?        00:00:00 sshd</code></pre><p>生成本低公钥添加至免密中：</p><pre><code>hadoop@LAPTOP-74GAR8S9:~/.ssh$ ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/home/hadoop/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/hadoop/.ssh/id_rsaYour public key has been saved in /home/hadoop/.ssh/id_rsa.pubThe key fingerprint is:SHA256:kMkQ2+migmrgDhEKXw4k7pBs8k88Eawq6aqqhFnz2iw hadoop@LAPTOP-74GAR8S9The key's randomart image is:+---[RSA 3072]----+|. ..+.           ||o+  .* +         ||*+..+ B          ||B+.= o .         ||o+= * . S        ||B+ * o           ||@.. o            |+----[SHA256]-----+</code></pre><p>添加至免密：</p><p>注意当前所在位置：~/.ssh</p><pre><code>hadoop@LAPTOP-74GAR8S9:~/.ssh$ sudo cat ./id_rsa.pub &gt;&gt; ./authorized_keys</code></pre><p>测试一下ssh，发现能连接：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:~/windos_pubkey$ ssh localhostWelcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.10.16.3-microsoft-standard-WSL2 x86_64) * Documentation:  https://help.ubuntu.com * Management:     https://landscape.canonical.com * Support:        https://ubuntu.com/advantage  System information as of Tue Apr 12 22:00:21 CST 2022  System load:  0.0                Processes:             13  Usage of /:   0.8% of 250.98GB   Users logged in:       0  Memory usage: 1%                 IPv4 address for eth0: 172.20.4.176  Swap usage:   0%19 updates can be applied immediately.12 of these updates are standard security updates.To see these additional updates run: apt list --upgradableLast login: Tue Apr 12 21:38:02 2022 from 127.0.0.1</code></pre><h3><span id="java环境配置">Java环境配置</span></h3><p>推荐使用openjdk。</p><p>输入命令直接安装：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:~/windos_pubkey$ sudo apt-get install openjdk-8-jdk</code></pre><p>安装完成后测试一下：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:~/windos_pubkey$ java -versionopenjdk version "1.8.0_312"OpenJDK Runtime Environment (build 1.8.0_312-8u312-b07-0ubuntu1~20.04-b07)OpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode)</code></pre><p>JAVAHOME环境变量设置：</p><p>打开环境变量设置：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:~$ vim ~/.bashrc</code></pre><p>在最下边输入一下内容：</p><pre><code class="language-ssh">export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH</code></pre><h3><span id="hadoop环境配置">Hadoop环境配置</span></h3><p>下载hadoop 3.2：<a href="https://archive.apache.org/dist/hadoop/common/hadoop-3.2.2/hadoop-3.2.2.tar.gz">hadoop3.2下载</a>。</p><p>使用windos的文件浏览器将下载好的hadoop直接拖拽到root目录对应位置即可：</p><p>这里再介绍一种方法打开文件浏览器：</p><p>在浏览器上栏输入：</p><pre><code class="language-ssh">\\wsl$</code></pre><p>效果如下：</p><p><img src="https://s2.loli.net/2024/09/29/rYECV8fSRhKolOQ.png" alt=""></p><p>我拷贝到了这个目录下：</p><p><img src="https://s2.loli.net/2024/09/29/mahEoYtvlAxBVcI.png" alt="19"></p><p>然后使用命令解压到<code>/usr/local</code>目录下：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:~$ sudo tar -zxf /home/jszszzy/hadoop/hadoop-3.2.2.tar.gz -C /usr/local</code></pre><p>然后转移到文件夹下，进行一系列操作：</p><pre><code class="language-ssh">$ cd /usr/local/$ sudo mv ./hadoop-3.1.3/ ./hadoop # 将文件夹名改为hadoop$ sudo chown -R hadoop ./hadoop # 修改文件权限</code></pre><p>最后运行一下：</p><pre><code class="language-ssh">$ cd /usr/local/hadoop$ ./bin/hadoop version</code></pre><h3><span id="提示">提示：</span></h3><p>相对路径与绝对路径 请务必注意命令中的相对路径与绝对路径，本文后续出现的 ./bin/… ， ./etc/… 等包含 ./ 的路径，均 为相对路径，以 /usr/local/hadoop 为当前目录。例如在 /usr/local/hadoop 目录中执行 ./bin/hadoop version 等同于执行 /usr/local/hadoop/bin/hadoop version 。可以将相对路径改成绝对路径来执行，但 如果你是在主文件夹 ~ 中执行 ./bin/hadoop version ，执行的会是 /home/hadoop/bin/hadoop version ， 就不是我们所想要的了。</p><p>下一篇将会介绍Hadoop单机配置、Hadoop伪分布式配置。</p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
          <category> Hadoop </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> Hadoop </tag>
            
            <tag> Scala </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark快速大数据分析——Spark的Hadoop配置（叁）</title>
      <link href="/2024/10/22/Spark(3)/"/>
      <url>/2024/10/22/Spark(3)/</url>
      
        <content type="html"><![CDATA[<h1><span id="spark快速大数据分析spark的hadoop配置叁">Spark快速大数据分析——Spark的Hadoop配置（叁）</span></h1><img src="https://s2.loli.net/2024/09/29/JGuU5PY7BSrQzAX.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727612092601" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h2><span id="软件环境">软件环境：</span></h2><ul><li><strong>Hadoop-3.2</strong></li><li><strong>Spark-3.1.3</strong></li><li><strong>JDK 8</strong></li><li><strong>WSL2</strong> <strong>Ubuntu20.04</strong></li><li><strong>Windos10 20H2</strong></li></ul><!-- toc --><ul><li><a href="#hadoop%E5%8D%95%E6%9C%BA%E9%85%8D%E7%BD%AE%E9%9D%9E%E5%88%86%E5%B8%83%E5%BC%8F">Hadoop单机配置(非分布式)</a><ul><li><a href="#%E6%B3%A8%E6%84%8F">注意！</a></li></ul></li><li><a href="#hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE">Hadoop伪分布式配置</a><ul><li><a href="#hadoop%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E">Hadoop配置文件说明</a></li><li><a href="#%E6%B3%A8%E6%84%8F-1">注意！</a></li><li><a href="#%E6%B3%A8%E6%84%8F-2">注意！</a></li><li><a href="#hadoop%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">Hadoop无法正常启动的解决方法</a></li></ul></li><li><a href="#%E8%BF%90%E8%A1%8Chadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E4%BE%8B">运行Hadoop伪分布式实例</a><ul><li><a href="#%E6%B3%A8%E6%84%8F-3">注意！</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="hadoop单机配置非分布式">Hadoop单机配置(非分布式)</span></h2><p>Hadoop 默认模式为非分布式模式（本地模式），无需进行其他配置即可运行。非分布式即单 Java 进程，方便进行 调试。</p><p>现在我们可以执行例子来测试一下Hadoop 的运行是否正常。</p><p>Hadoop 附带了丰富的例子（运行 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar 可以看到所有例子），包括 wordcount、 terasort、join、grep 等。</p><p>在此我们选择运行grep例子，我们将input文件夹的所有文件作为输入，筛选当中符合正则表达式 dfs[a-z.]+ 的单 词并统计出现的次数，最后输出结果到 output 文件夹中。</p><p>首先切换到hadoop用户下：</p><pre><code class="language-ssh">jszszzy@LAPTOP-74GAR8S9:~$ su hadoop</code></pre><p>切换对应文件夹下：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ cd /usr/local/hadoop</code></pre><p>创建一个input文件夹，把配置文件拷贝过来，将配置文件作为输入文件：</p><pre><code>hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ mkdir ./inputhadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ cp ./etc/hadoop/*.xml ./input</code></pre><p>最后调用运行，注意不要换行！（显示的可能有换行），注意版本和你本机安装的版本相对应：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./bin/hadoop jar./share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.2.jar grep input output 'dfs[a-z.]+'</code></pre><p>如果在这个地方产生报错：</p><pre><code class="language-shell">Error: Could not find or load main class jar..share.hadoop.mapreduce.hadoop</code></pre><p>请删除hadoop重新解压一下，删除命令如下，解压命令参考第三篇：</p><pre><code class="language-shell">cd /usr/local</code></pre><pre><code class="language-shell">sudo rm -r hadoop</code></pre><p>等待运行完成后查看结果：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ cat ./output/*1       dfsadmin</code></pre><p>完成后结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/xeak7WG54hVpm2o.png" alt="1"></p><p>显示符合正则的单词 dfsadmin 出现了1次。</p><h3><span id="注意">注意！</span></h3><p>注意，Hadoop 默认不会覆盖结果文件，因此再次运行上面实例会提示出错，需要先将 ./output 删除。</p><p>删除命令：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ rm -r ./output</code></pre><h2><span id="hadoop伪分布式配置">Hadoop伪分布式配置</span></h2><p>Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。</p><p>Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/ 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfssite.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。</p><p>修改配置文件 core-site.xml： vim ./etc/hadoop/core-site.xml ，将当中的</p><pre><code class="language-ssh">&lt;configuration&gt;&lt;/configuration&gt;</code></pre><p>修改为下面配置：</p><pre><code class="language-ssh">&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt;</code></pre><p>同样的，修改配置文件 hdfs-site.xml：</p><pre><code class="language-ssh">&lt;configuration&gt;&lt;property&gt;&lt;name&gt;dfs.replication&lt;/name&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;&lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;&lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><h3><span id="hadoop配置文件说明">Hadoop配置文件说明</span></h3><p>Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模 式切换回非分布式模式，需要删除 core-site.xml 中的配置项。</p><p>此外，伪分布式虽然只需要配置 fs.defaultFS 和 dfs.replication 就可以运行（官方教程如此），不过若没有 配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系 统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。</p><p>我们继续回到配置：</p><p>配置完成后，执行 NameNode 的格式化，注意这里路径是什么:</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./bin/hdfs namenode -format</code></pre><p>成功的话，会看到 “successfully formatted” 的提示，具体返回信息类似如下：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./bin/hdfs namenode -formatWARNING: /usr/local/hadoop/logs does not exist. Creating.2022-04-14 13:20:01,596 INFO namenode.NameNode: STARTUP_MSG:/************************************************************STARTUP_MSG: Starting NameNodeSTARTUP_MSG:   host = LAPTOP-74GAR8S9.localdomain/127.0.1.1STARTUP_MSG:   args = [-format]STARTUP_MSG:   version = 3.2.2STARTUP_MSG:   classpath = /usr/local/hadoop/etc/hadoop:/usr/local/hadoop/share/hadoop/common/lib/netty-3.10.6.Final.</code></pre><p><img src="https://s2.loli.net/2024/09/29/y4HaB7jmtohMGkJ.png" alt="2"></p><h3><span id="注意">注意！</span></h3><p>如果在这一步报错：</p><p><strong>Error: JAVA_HOME is not set and could not be found.</strong></p><p>则说明之前设置 JAVA_HOME 环境变量那边就没设置好，请按教程先设置好 JAVA_HOME 变量，否则后面的过程都是进行不下去 。</p><p>如果已经按照前面教程在.bashrc文件中设置了JAVA_HOME。还是出现 Error: JAVA_HOME is not set and could not be found. 的错误。</p><p>那么，请到hadoop的安装目录修改配置文件/usr/local/hadoop/etc/hadoop/hadoop-env.sh”，在里面找到“export JAVA_HOME=${JAVA_HOME}”这行，然后，把它修改成JAVA安装路径的具体地址，比 如，“export JAVA_HOME=/usr/lib/jvm/default-java”，然后，再次启动Hadoop。</p><p>设置后仍报错：</p><p><img src="https://s2.loli.net/2024/09/29/7lAQHfOWvVSZ28b.png" alt="3"></p><p>打开环境配置文件：</p><p>添加：<code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</code></p><p><img src="https://s2.loli.net/2024/09/29/cnD3CpoeQkMh8NT.png" alt="4"></p><p>接着开启NameNode和DataNode守护进程:</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ cd /usr/local/hadoophadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./sbin/start-dfs.sh</code></pre><p>输入命令以后开始运行：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ cd /usr/local/hadoophadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./sbin/start-dfs.sh</code></pre><p>如果有报错如下：</p><pre><code class="language-shell">hadoop@LAPTOP-HO0AHQKI:/usr/local/hadoop$ sudo ./sbin/start-dfs.shWARNING: HADOOP_SECURE_DN_USER has been replaced by HDFS_DATANODE_SECURE_USER. Using value of HADOOP_SECURE_DN_USER.Starting namenodes on [localhost]localhost: root@localhost: Permission denied (publickey).Starting datanodeslocalhost: root@localhost: Permission denied (publickey).Starting secondary namenodes [LAPTOP-HO0AHQKI]LAPTOP-HO0AHQKI: root@laptop-ho0ahqki: Permission denied (publickey).</code></pre><p>请使用：</p><pre><code class="language-ssh">exit</code></pre><p><strong>退出ssh！</strong></p><h3><span id="注意">注意！</span></h3><p>若出现如下SSH提示，输入yes即可：</p><p><img src="https://s2.loli.net/2024/09/29/n71om5iAyrFUMkN.png" alt="5"></p><p>启动时可能会出现如下 WARN 提示：WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable WARN 提示可以忽略，并不会影响正常使用。</p><p>启动 Hadoop 时提示 Could not resolve hostname 如果启动 Hadoop 时遇到输出非常多“ssh: Could not resolve hostname xxx”的异常情况，如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/SmkjwXlIM2osNAY.png" alt="6"></p><p>这个并不是 ssh 的问题，可通过设置 Hadoop 环境变量来解决。首先按键盘的 ctrl + c 中断启动，然后在 ~/.bashrc 中，增加如下两行内容（设置过程与 JAVA_HOME 变量一样，其中 HADOOP_HOME 为 Hadoop 的安装目录）：</p><pre><code>export HADOOP_HOME=/usr/local/hadoopexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native</code></pre><p>保存后，务必执行 source ~/.bashrc 使变量设置生效，然后再次执行 ./sbin/start-dfs.sh 启动 Hadoop。</p><p>启动完成后，可以通过命令 jps 来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode” 和 “SecondaryNameNode”（如果 SecondaryNameNode 没有启动，请运行 sbin/stop-dfs.sh 关闭进程，然后再次尝 试启动尝试）。如果没有 NameNode 或 DataNode ，那就是配置不成功，请仔细检查之前步骤，或通过查看启动日志排查原因。</p><p>使用后：</p><p><img src="https://s2.loli.net/2024/09/29/gJ8zF6boCySwmda.png" alt="7"></p><h3><span id="hadoop无法正常启动的解决方法">Hadoop无法正常启动的解决方法</span></h3><ul><li>一般可以查看启动日志来排查原因，注意几点： 启动时会提示形如 “DBLab-XMU: starting namenode, logging to /usr/local/hadoop/logs/hadoop-hadoopnamenode-DBLab-XMU.out”，其中 DBLab-XMU 对应你的机器名，但其实启动日志信息是记录在 /usr/local/hadoop/logs/hadoop-hadoop-namenode-DBLab-XMU.log 中，所以应该查看这个后缀为 .log 的 文件；</li><li>每一次的启动日志都是追加在日志文件之后，所以得拉到最后面看，对比下记录的时间就知道了。</li><li>一般出错的提示在最后面，通常是写着 Fatal、Error、Warning 或者 Java Exception 的地方。</li><li>可以在网上搜索一下出错信息，看能否找到一些相关的解决方法</li></ul><p>此外，若是 DataNode 没有启动，可尝试如下的方法（注意这会删除 HDFS 中原有的所有数据，如果原有的 数据很重要请不要这样做）：</p><pre><code class="language-ssh">$ # 针对 DataNode 没法启动的解决方法$ cd /usr/local/hadoop$ ./sbin/stop-dfs.sh # 关闭$ rm -r ./tmp # 删除 tmp 文件，注意这会删除 HDFS 中原有的所有数据$ ./bin/hdfs namenode -format # 重新格式化 NameNode$ ./sbin/start-dfs.sh # 重启</code></pre><h2><span id="运行hadoop伪分布式实例">运行Hadoop伪分布式实例</span></h2><p>上面的单机模式，grep 例子读取的是本地数据，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要在 HDFS 中创建用户目录：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./bin/hdfs dfs -mkdir -p /user/hadoop</code></pre><p>接着将 ./etc/hadoop 中的 xml 文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制 到分布式文件系统中的 /user/hadoop/input 中。我们使用的是 hadoop 用户，并且已创建相应的用户目录 /user/hadoop ，因此在命令中就可以使用相对路径如 input，其对应的绝对路径就是 /user/hadoop/input:</p><pre><code>hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./bin/hdfs dfs -mkdir  -p /user/hadoop/inputhadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./bin/hdfs dfs -put ./etc/hadoop/*.xml input</code></pre><p>可以使用ls查看一下文件信息：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./bin/hdfs dfs -ls inputFound 9 items-rw-r--r--   1 hadoop supergroup       9213 2022-04-14 13:37 input/capacity-scheduler.xml-rw-r--r--   1 hadoop supergroup       1033 2022-04-14 13:37 input/core-site.xml-rw-r--r--   1 hadoop supergroup      11392 2022-04-14 13:37 input/hadoop-policy.xml-rw-r--r--   1 hadoop supergroup       1079 2022-04-14 13:37 input/hdfs-site.xml-rw-r--r--   1 hadoop supergroup        620 2022-04-14 13:37 input/httpfs-site.xml-rw-r--r--   1 hadoop supergroup       3518 2022-04-14 13:37 input/kms-acls.xml-rw-r--r--   1 hadoop supergroup        682 2022-04-14 13:37 input/kms-site.xml-rw-r--r--   1 hadoop supergroup        758 2022-04-14 13:37 input/mapred-site.xml-rw-r--r--   1 hadoop supergroup        690 2022-04-14 13:37 input/yarn-site.xml</code></pre><p>伪分布式运行 MapReduce 作业的方式跟单机模式相同，区别在于伪分布式读取的是HDFS中的文件（可以将单机步 骤中创建的本地 input 文件夹，输出结果 output 文件夹都删掉来验证这一点）。</p><p>注意：命令没有换行：</p><pre><code class="language-ssh"> hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.2.jar grep input output 'dfs[a-z.]+'</code></pre><p><img src="https://s2.loli.net/2024/09/29/IsaTWyZhPClrBKt.png" alt="8"></p><p>查看运行结果的命令（查看的是位于 HDFS 中的输出结果）：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./bin/hdfs dfs -cat output/*1       dfsadmin1       dfs.replication1       dfs.namenode.name.dir1       dfs.datanode.data.dir</code></pre><p>Hadoop 运行程序时，输出目录不能存在，否则会提示错误 <strong>“org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:9000/user/hadoop/output already exists”</strong></p><p>因此若要再次执行，需要执行如下命令删除 output 文件夹:</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./bin/hdfs dfs -rm -r outputDeleted output</code></pre><h3><span id="注意">注意！</span></h3><p>运行程序时，输出目录不能存在 运行 Hadoop 程序时，为了防止覆盖结果，程序指定的输出目录（如 output）不能存在，否则会提示错误， 因此运行前需要先删除输出目录。在实际开发应用程序时，可考虑在程序中加上如下代码，能在每次运行时 自动删除输出目录，避免繁琐的命令行操作：</p><pre><code class="language-java">Configuration conf = new Configuration();Job job = new Job(conf);/* 删除输出目录 */Path outputPath = new Path(args[1]);outputPath.getFileSystem(conf).delete(outputPath, true);</code></pre><p>若要关闭 Hadoop，则运行：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$  ./sbin/stop-dfs.shStopping namenodes on [localhost]Stopping datanodesStopping secondary namenodes [LAPTOP-74GAR8S9]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
          <category> Hadoop </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> Hadoop </tag>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark快速大数据分析——Spark的结构化数据API（伍）</title>
      <link href="/2024/10/22/Spark(5)/"/>
      <url>/2024/10/22/Spark(5)/</url>
      
        <content type="html"><![CDATA[<h1><span id="spark快速大数据分析spark的结构化数据api伍">Spark快速大数据分析——Spark的结构化数据API（伍）</span></h1><img src="https://s2.loli.net/2024/09/29/2FrYNJepTGxCiEs.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727612573373" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><!-- toc --><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83">软件环境</a></li><li><a href="#spark%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AEapi">Spark的结构化数据API</a><ul><li><a href="#rddresilient-distributed-datasets%E5%BC%B9%E6%80%A7%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%9B%86">RDD(Resilient Distributed Datasets)弹性分布式数据集</a><ul><li><a href="#rdd%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">RDD存在的问题</a></li><li><a href="#spark%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE">Spark的结构化数据</a></li><li><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9%E4%B8%8E%E5%A5%BD%E5%A4%84">结构化的关键点与好处</a></li><li><a href="#dataframe-api">DataFrame API</a></li><li><a href="#spark%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">Spark的基本数据类型</a></li><li><a href="#spark%E7%9A%84%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">Spark的复杂数据类型</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="软件环境">软件环境</span></h2><p><strong>强烈提示：<br>请按照对应配套版本来进行环境配置！</strong></p><ul><li><strong>Hadoop-3.2</strong></li><li><strong>IDEA 2021.3.2</strong></li><li><strong>Spark-3.1.3 搭配  scala版本：2.12  构建方式：IDEA导入本地JAR，Spark库</strong></li><li><strong>Spark-3.2.1 搭配  scala版本 ：2.13.8 构建方式 ：SBT自动导入依赖</strong></li><li><strong>JDK 8</strong></li></ul><h2><span id="spark的结构化数据api">Spark的结构化数据API</span></h2><p>Spark在1.x版本中首次引入了Spark SQL，Spark SQL 引入了表达能力更强的高层操作函数模仿类似于SQL的语法，接着Dataframe作为SchemaRDD的继任者由Spark1.3引入，为后续版本中更多的结构化支持打下了基础，并为Spark查询计算中的高性能操作做铺垫。</p><h3><span id="rddresilient-distributed-datasets弹性分布式数据集">RDD(Resilient Distributed Datasets)弹性分布式数据集</span></h3><p>在结构化数据API诞生之前，Spark都是使用RDD来完成操作的，首先来讨论一下什么是RDD？</p><p>RDD是Spark最基本的抽象。存在三个至关重要的属性：</p><ul><li>依赖关系</li><li>分区</li><li>计算函数：Partition =&gt; Iterator[T]</li></ul><p>这三大属性对于简单的RDD编程API模型来说都是不可或缺的，其他的更高层的功能也给予这三种属性构建。</p><p>依赖关系就是上一节所说的血缘，通过依赖关系列表会告诉Spark如何通过输入来构建RDD，同时需要重算的时候Spark可以根据这些依赖关系重新执行操作，重建出RDD。这一属性赋予了RDD容错的弹性。</p><p>分区指的是Spark工作的时候以分区为单位，分配到多个执行器上并行运算，再某些情况下如使用HDFS读取信息,Spark会使用分区信息来判断位置远近，这样一来，需要跨网络传输的带宽就少了很多。</p><p>最后每一个RDD都需要一个计算函数compute，可用于生成RDD所表示数据的Iterator[T]对象，实际上就是计算完成后的结果。</p><h4><span id="rdd存在的问题">RDD存在的问题</span></h4><p>RDD传输的计算函数对于Spark来说是不透明的，也就是说Spark不知道你在计算函数里面要干什么。无论是要做连接、过滤、还是聚合，Spark是没有办法具体了解你的传输的lambda表达式具体的操作，实际上让Spark推断的话是很困难的一件事。</p><p>这就无法实现前文针对执行计划来做出优化的方式，因为Spark根本不知道你在做什么。无法针对你的具体执行操作来实现优化。</p><p>其次是Iterator[T]对象对于Spark来说也是什么都不知道，拿Python的RDD来说，Spark只知道这是一个python的对象，这样就造成了另一个问题。</p><p>Spark无法针对数据类型来对数据进行压缩等操作，只能将其不透明的对象转化成字节码传输。</p><h4><span id="spark的结构化数据">Spark的结构化数据</span></h4><p>针对Spark存在的问题，Spark在2.x版本引入了用于支持结构化数据的方案。其中之一就是为了解决数据操作不透明的问题而诞生的顶层API。</p><p>通过引入数据分析常用的模式来表达计算。这些模式使用过滤、选择、计数、聚合、平均和分组等高层操作来进行表示。这样一来，计算的表达更加清晰、简洁了。</p><p>通过在DSL（领域特定语言）中使用通用的算子，可以进一步减少计算表达的特异性。Spark所支持的语言都提供了这样一组算子，这些算子让你能够告诉Spark希望计算出来什么数据。这样一来，Spark能够以此为依据为实际执行构建出高效的查询计划，并最终执行。</p><h4><span id="结构化的关键点与好处">结构化的关键点与好处</span></h4><p>我们首要讨论的就是：</p><p>结构化的优点：<strong>表达能力强、简洁、易组合、风格一致。</strong></p><p>举个例子：</p><p>以下是配套书的代码并未尝试运行，如有错误请以书为准。</p><pre><code class="language-python">#Python代码#创建二元组(nare，age)构成的RDDdataRDD = sc.parallelize([("Brooke"，20)，("Denny"，31)，(" Jules"，30),("TD"，35)，( "Brooke"，25)])#调用转化操作rap和reduceByKey，借助lanbda表达式来聚合并计算平均值agesRDD = (dataRDD.map(lambda x: (×[0],(×[1]，1))).reduceByKey( lambda x, y: (×[0] +y[0],x[1] + y[1])).map( lambda x: (×[0],x[1][0]/x[1][1])))</code></pre><p>可以看到实际操作都是使用map等底层数据api通过传入lambda表达式来实现的具体操作，不仅表达能力、可读性差而且跨语言实现起来相同的操作会因为不同语言的语法而导致存在很大的差异，比如使用Scala来实现就完全不相同。</p><p>如果使用DataFrame（结构化）呢？</p><pre><code class="language-python">#Python代码fron pyspark.sql inport SparkSessionfron pyspark.sql.functions import avg#用SparkSession创建DataFramespark = (SparkSession.builder.appNane( "AuthorsAges").getOrCreate())#创建DataFramedata_df = spark.createDataFrane([("Brooke" ,20)，( "Denny"，31)，(" Jules"，30),("TD"，35)，( "Brooke"，25)]，[ "name" , "age"])#按名字分组,聚合同名人的年龄,计算平均值avg_df = data_df.groupBy( "name" ).agg(avg( "age" ))avg_df.show()#展示执行的最终结果</code></pre><p>跟上一个版本比相比，你应该在没学过的情况下也能大概推断出这一部分代码是干什么的，实际上我们已经通过这些API明确告诉了Spark该去做什么，所以Spark能针对你写的代码进行优化或者重排整体操作被API组合成了一条链式调用。</p><p>高度封装API会导致开发者的应用受限不自由，这是经常发生的事情，你在初学Spark的时候就有可能会遇到（使用的不自在），但是目前咱先把这个问题放一放，因为Spark同时支持你使用上边的底层API和高层API混写。</p><h4><span id="dataframe-api">DataFrame API</span></h4><p>Spark的DataFrame API可以说就是将Pandas库抄过来的，同样是结构化，有格式的，且支持一些特定的操作，就像分布式内存中的表那样，每一列都有名字，每张表都需要通过表的定义来设置数据类型，整型，字符串或者实数等，就单纯来说Dataframe对于人来说就是张表，表头就是表的定义。</p><p><img src="https://s2.loli.net/2024/09/29/4nPdrDg7yLiB5sX.png" alt="1"></p><h4><span id="spark的基本数据类型">Spark的基本数据类型</span></h4><p>Spark的基本数据类型都与对应的内部数据类型，**这些数据类型既可以通过Spark应用来定义，也可以在Spark的表结构来定义。**使用Scala编写代码的时候可以直接将某列的定义声明为String，Byte，Long等。</p><p>举个例子：</p><p><img src="https://s2.loli.net/2024/09/29/ABjtRIokcvFwmOJ.png" alt="2"></p><p>可以看到使用了一个 类型是StringType的变量</p><p>注意的是这里使用的实际上是他的构造方法创建的对象，并不是Scala的类型定义的方式<strong>所以是=号</strong>，而这里实际上是将变量绑定到对应spark中StringType的一个叫type的成员类型，并不是真正的字符串。</p><p><img src="https://s2.loli.net/2024/09/29/Os5aRAhIBxgi3qF.png" alt="3"></p><h4><span id="spark的复杂数据类型">Spark的复杂数据类型</span></h4><p>复杂的数据分析不会只有简单的数据类型。有些时候需要格式化，标准化数据类型来作辅助，原数据可能是随意记载的，比如日期，每个人记录格式不统一就需要使用一种标准化的数据类型来将读入数据统一一下。当然还有些数据结构用来构建Dataframe，比如：映射表、数组、结构体。</p><p>下表展示了Spark支持的结构化数据类型:</p><p><img src="https://s2.loli.net/2024/09/29/1dkGiLEaB6CH83h.png" alt="4"></p><p>如果你对Seq或者Map不太熟悉请查看关于scala数据结构的内容。</p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
          <category> Hadoop </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> Hadoop </tag>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark快速大数据分析——Hive的部署与使用（陆）</title>
      <link href="/2024/10/22/Spark(6)/"/>
      <url>/2024/10/22/Spark(6)/</url>
      
        <content type="html"><![CDATA[<h1><span id="spark快速大数据分析hive的部署与使用陆">Spark快速大数据分析——Hive的部署与使用（陆）</span></h1><img src="https://s2.loli.net/2024/09/29/9cbeUOHyknhTrLY.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727612918890" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><!-- toc --><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83">软件环境：</a></li><li><a href="#%E4%B8%80-%E5%AE%89%E8%A3%85hive">一、安装Hive</a></li><li><a href="#%E4%BA%8C-%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmysql">二、安装并配置Mysql</a></li><li><a href="#hive%E7%9A%84mysql%E9%85%8D%E7%BD%AE%E9%83%A8%E5%88%86">Hive的mysql配置部分</a></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="软件环境">软件环境：</span></h2><p><strong>强烈提示：<br>请按照对应配套版本来进行环境配置！</strong></p><ul><li><strong>Hadoop-3.2</strong></li><li><strong>IDEA 2021.3.2</strong></li><li><strong>Spark-3.1.3 搭配  scala版本：2.12  构建方式：IDEA导入本地JAR，Spark库</strong></li><li><strong>JDK 8</strong></li><li><strong>Hive 3.1.3</strong></li><li><strong>MYSQL 8.0.2</strong></li><li><strong>WSL 2 Ubuntu20.04</strong></li></ul><p><strong>备注：在安装Hive3.1.2之前，请首先安装Hadoop3.2。</strong></p><h2><span id="一-安装hive">一、安装Hive</span></h2><p><strong>温馨提示：</strong></p><pre><code class="language-ssh">jszszzy@LAPTOP-74GAR8S9:~$</code></pre><p>此此前缀代表的是当前用户和目录，并不是命令的一部分。</p><p>首先需要下载Hive安装包文件， <a href="http://www.apache.org/dyn/closer.cgi/hive/">Hive官网下载地址</a>。</p><p>开启文件浏览器，将下载的压缩包放入进去，可以先放到root用户目录下：</p><pre><code class="language-ssh">jszszzy@LAPTOP-74GAR8S9:~$ explorer.exe .</code></pre><p><img src="https://s2.loli.net/2024/09/29/1ZQRP9H72qwaKzj.png" alt="3"></p><p>最好先下载好hive的配置文件一起放入进去：</p><p>地址，下载压缩包解压即可。</p><p>注意是：<strong>hive-site.xml</strong></p><p><img src="https://s2.loli.net/2024/09/29/K1bVlXgxoNkeqth.png" alt="4"></p><p>将对应文件解压过去：</p><p>此处我事先创建了一个hive文件夹，用来存放内容，可自行通过文件浏览器创建。</p><pre><code class="language-ssh">jszszzy@LAPTOP-74GAR8S9:~$ cd hivejszszzy@LAPTOP-74GAR8S9:~/hive$ sudo tar -zxvf ./apache-hive-3.1.3-bin.tar.gz -C /usr/local</code></pre><p>随后前往对应文件夹来进行修改：</p><pre><code class="language-ssh">jszszzy@LAPTOP-74GAR8S9:~/hive$ cd /usr/local/jszszzy@LAPTOP-74GAR8S9:/usr/local$ sudo mv apache-hive-3.1.3-bin hive</code></pre><p>修改完名字后再修改权限：</p><pre><code class="language-ssh">jszszzy@LAPTOP-74GAR8S9:/usr/local$ sudo chown -R jszszzy:jszszzy hive</code></pre><p>添加环境变量方便运行：</p><pre><code class="language-ssh">jszszzy@LAPTOP-74GAR8S9:/usr/local$ vim ~ /.bashrc</code></pre><p>在最后添加的内容如下：</p><pre><code>export HIVE_HOME=/usr/local/hiveexport PATH=$PATH:$HIVE_HOME/binexport HADOOP_HOME=/usr/local/hadoop</code></pre><p>生效修改：</p><pre><code class="language-ssh">jszszzy@LAPTOP-74GAR8S9:/usr/local$ source ~/.bashrc</code></pre><p>别忘了hadoop用户相应的权限。</p><p>先切换到hadoop用户：</p><pre><code>su hadoop</code></pre><p>转移到对应文件夹：</p><pre><code>hadoop@LAPTOP-74GAR8S9:/usr/local$ cd /usr/local/hadoop@LAPTOP-74GAR8S9:/usr/local$ sudo chown -R hadoop:hadoop hive</code></pre><p>记得添加环境变量这里就不再赘述：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local$  vim ~/.bashrchadoop@LAPTOP-74GAR8S9:/usr/local$ source ~/.bashrc</code></pre><p>添加的内容相同。</p><p>修改hive的配置文件：</p><pre><code>hadoop@LAPTOP-74GAR8S9:/usr/local$ cd /usr/local/hive/conf</code></pre><p>修改hive的配置文件的名字：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hive/conf$ mv hive-default.xml.template hive-default.xml</code></pre><p>打开配置文件：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/usr/local/hive/conf$ vim hive-site.xml</code></pre><p>在hive-site.xml中添加如下配置信息：</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;&lt;configuration&gt;  &lt;property&gt;    &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;    &lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;    &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;  &lt;/property&gt;    &lt;property&gt;    &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;    &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;    &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;  &lt;/property&gt;    &lt;property&gt;    &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;    &lt;value&gt;hive&lt;/value&gt;    &lt;description&gt;username to use against metastore database&lt;/description&gt;  &lt;/property&gt;    &lt;property&gt;    &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;    &lt;value&gt;hive&lt;/value&gt;    &lt;description&gt;password to use against metastore database&lt;/description&gt;  &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>你可能注意到复制过程可能会导致过程混乱，所以推荐你下载我写好的，直接通过文件浏览器复制过去就行了，当然对于这个目录是直接无法访问的，所以推荐先拷贝在root用户下，然后复制过去。</p><p>拷贝到root用户下使用命令，然后拖拽过去：</p><pre><code>jszszzy@LAPTOP-74GAR8S9:~$ explorer.exe .</code></pre><p>修改配置文件为新的配置文件：</p><pre><code>hadoop@LAPTOP-74GAR8S9:/usr/local/hive/conf$ rm hive-site.xmlhadoop@LAPTOP-74GAR8S9:/usr/local/hive/conf$ cp /home/jszszzy/hive-site.xml /usr/local/hive/conf</code></pre><h2><span id="二-安装并配置mysql">二、安装并配置Mysql</span></h2><p>这一部分是最折腾的部分，每个人的情况都可能不太一样，所以版本的内容要尽量和我的一模一样再来开始。</p><p>版本的信息内容我已放到最开头部分，请仔细查看。</p><p>目前发文时期最新的APT安装的MYSQL是可以使用的，但是过程有些小麻烦，详见如下：</p><p>网上的安装人云亦云，什么在Mysql的辅助版本下安装等方法层出不穷，我基本都做了尝试，你如果使用的是WSL2最好和我的方法保持一致。</p><p>避免浪费时间。</p><p><strong>如下这种方法，完全不行，始终无法检测到mysql的状态，不推荐使用：</strong></p><p><img src="https://s2.loli.net/2024/09/29/5IB3gMEm7TxGOoj.png" alt="14"></p><p>我们直接使用APT来安装：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sudo apt-get updatehadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sudo apt-get install mysql-server -y</code></pre><p>安装过程稍微有些长，如果你没有换源请看我前几篇是如何更换下载源的。</p><p>下载过程：</p><pre><code>eading package lists... DoneBuilding dependency treeReading state information... DoneThe following additional packages will be installed:  libcgi-fast-perl libcgi-pm-perl libencode-locale-perl libevent-core-2.1-7 libevent-pthreads-2.1-7 libfcgi-perl  libhtml-parser-perl libhtml-tagset-perl libhtml-template-perl libhttp-date-perl libhttp-message-perl libio-html-perl  liblwp-mediatypes-perl libmecab2 libtimedate-perl liburi-perl mecab-ipadic mecab-ipadic-utf8 mecab-utils  mysql-client-8.0 mysql-client-core-8.0 mysql-common mysql-server-8.0 mysql-server-core-8.0Suggested packages:  libdata-dump-perl libipc-sharedcache-perl libwww-perl mailx tinycaThe following NEW packages will be installed:  libcgi-fast-perl libcgi-pm-perl libencode-locale-perl libevent-core-2.1-7 libevent-pthreads-2.1-7 libfcgi-perl...............................................省略部分信息.................................................关键地方需要看一眼：done!update-alternatives: using /var/lib/mecab/dic/ipadic-utf8 to provide /var/lib/mecab/dic/debian (mecab-dictionary) in auto modeSetting up libhtml-parser-perl (3.72-5) ...Setting up libhttp-message-perl (6.22-1) ...Setting up mysql-server-8.0 (8.0.29-0ubuntu0.20.04.3) ...invoke-rc.d: could not determine current runlevel * Stopping MySQL database server mysqld                                                                         [ OK ]update-alternatives: using /etc/mysql/mysql.cnf to provide /etc/mysql/my.cnf (my.cnf) in auto modeRenaming removed key_buffer and myisam-recover options (if present)mysqld will log errors to /var/log/mysql/error.logmysqld is running as pid 782Created symlink /etc/systemd/system/multi-user.target.wants/mysql.service → /lib/systemd/system/mysql.service.invoke-rc.d: could not determine current runlevelSetting up libcgi-pm-perl (4.46-1) ...Setting up libhtml-template-perl (2.97-1) ...Setting up mysql-server (8.0.29-0ubuntu0.20.04.3) ...Setting up libcgi-fast-perl (1:2.15-1) ...Processing triggers for systemd (245.4-4ubuntu3.16) ...Processing triggers for man-db (2.9.1-1) ...Processing triggers for libc-bin (2.31-0ubuntu9.7) .../sbin/ldconfig.real: /usr/lib/wsl/lib/libcuda.so.1 is not a symbolic link</code></pre><p>在最后安装完成的时候会提示：</p><pre><code class="language-ssh"> * Stopping MySQL database server mysqld                                           [ OK ]</code></pre><p>不知道为什么自动关闭了，不过问题不大我们手动打开：</p><pre><code class="language-ssh">sudo service mysql restart</code></pre><p>这里推荐使用sudo，不知道为什么这里输入hadoop的密码后还是会报错导致无法开启。</p><p><img src="https://s2.loli.net/2024/09/29/C7gZ3dAB456WyPz.png" alt="20"></p><p>使用sudo：</p><p><img src="https://s2.loli.net/2024/09/29/dVzHSY3bE2O4Fic.png" alt="N2YC41{K(SWNKQ)DPL%ZB$F"></p><p>打开后我们再来检测一下状态，发现仍是STOP？？？？这就是一个很离谱的bug，说明他启动没有成功。</p><p>中间还有可能出现一个小问题：</p><p>问题如下：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/etc/mysql/mysql.conf.d$ sudo service mysql start * Starting MySQL database server mysqld                                                 su: warning: cannot change directory to /nonexistent: No such file or directory [ OK ]</code></pre><p>解决办法是：</p><pre><code class="language-ssh"># Ubuntusudo service mysql stopsudo usermod -d /var/lib/mysql/ mysqlsudo service mysql start</code></pre><p>不过这里我们先放放无法启动的问题，你如果检测的状态如下：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/var/lib/mysql$ sudo service mysql statusmysql: unrecognized service</code></pre><p>这说明没有安装成功推荐安装办法如下：</p><p>记得先卸载原来安装的！</p><p>卸载SQL：</p><pre><code>hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sudo apt purge mysql-*hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sudo rm -rf /etc/mysql/ /var/lib/mysqlhadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sudo apt autoremovehadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sudo apt autoclean</code></pre><p>如果你的检测状态如下，恭喜你一遍就安装成功了，很幸运。请直接跳到Hive的mysql配置部分。</p><pre><code>* /usr/bin/mysqladmin  Ver 8.0.29-0ubuntu0.20.04.3 for Linux on x86_64 ((Ubuntu))Copyright (c) 2000, 2022, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Server version          8.0.29-0ubuntu0.20.04.3Protocol version        10Connection              Localhost via UNIX socketUNIX socket             /var/run/mysqld/mysqld.sockUptime:                 8 secThreads: 2  Questions: 8  Slow queries: 0  Opens: 436  Flush tables: 3  Open tables: 27  Queries per second avg: 1.000</code></pre><p>如果你的状态是上图那个，请你继续往下看：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/etc/mysql/mysql.conf.d$ service mysql status * MySQL is stopped.</code></pre><p>我们再来看一下默认的3306端口有东西吗？</p><pre><code>hadoop@LAPTOP-74GAR8S9:/etc/mysql/mysql.conf.d$ netstat -an|grep 3306</code></pre><p>如果你没有输出，就继续往下看。</p><p>我们先尝试登陆一下MySQL看看具体情况如何：</p><p>你到这里会意识到一个问题，我的MYSQL密码是什么？初始化的时候并没有设置，所以这里应该是有一个随机密码的，我们先找到随机密码：</p><p>使用如下命令：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/etc/mysql/mysql.conf.d$ sudo cat /etc/mysql/debian.cnf# Automatically generated for Debian scripts. DO NOT TOUCH![client]host     = localhostuser     = debian-sys-maintpassword = dC6kQukIgXCUqqtosocket   = /var/run/mysqld/mysqld.sock[mysql_upgrade]host     = localhostuser     = debian-sys-maintpassword = dC6kQukIgXCUqqtosocket   = /var/run/mysqld/mysqld.sock</code></pre><p>其中包含了一个默认的用户名（<strong>debian-sys-maint</strong>）和随机密码（<strong>dC6kQukIgXCUqqto</strong>）。</p><p>我们就用这个登录：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/etc/mysql/mysql.conf.d$ mysql -udebian-sys-maint -pEnter password:</code></pre><p>注意输入密码的时候是看不见所以要分清大小写一个一个登录。</p><p>如果你在这里报错：</p><pre><code class="language-ssh">ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (13)</code></pre><p>那就有点麻烦了，注意你报错的如果是这个，那可能是你的密码不正确，再多尝试几次：</p><pre><code>ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)</code></pre><p>登陆成功你可以跳转到MYSQL配置HIVE的部分，如果还是报错，请往下看。</p><p>MYSQL有两种登陆方式，一个是通过ssh一个是通过TCP链接，我们尝试通过TCP链接一下：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/etc/mysql/mysql.conf.d$ mysql -u debian-sys-maint -h 127.0.0.1 -pEnter password:</code></pre><p>果然通过TCP就可以了，说明我们的<strong>socket</strong>出了问题，一般是再MYSQL服务启动的时候会制动生成<strong>mysqld.sock</strong>，这里说是不行我就觉得很离谱。</p><p>不过没关系我也找到了解决办法：</p><p>首先可以尝试如下操作：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/etc/mysql$ cd /var/run/mysqld/bash: cd: /var/run/mysqld/: Permission denied</code></pre><p>竟然被拒绝，先给对应的文件加上权限，可访问可运行：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/etc/mysql$ sudo chmod 777 /var/run/mysqld/</code></pre><p>加上权限后再次检测状态，应该可以检测到了，如果还不能！</p><p>不慌！我们还有办法：</p><p>在安装的时候有个重要信息：</p><pre><code class="language-ssh">update-alternatives: using /etc/mysql/mysql.cnf to provide /etc/mysql/my.cnf (my.cnf) in auto mode</code></pre><p>意思是：在自动模式下使用**/etc/mysql/my.cnf (my.cnf)<strong>的配置文件去替代</strong>/etc/mysql/mysql.cnf** 的配置文件，这就意味着我们可以使用他来替代这个文件，不知道为什么这个配置文件会有这样的BUG，我在SO上找到了解决办法：</p><p>注意！请先使用cp备份一下。</p><pre><code>hadoop@LAPTOP-74GAR8S9:/etc/mysql$ sudo cp my.cnf my.cnf.buckup</code></pre><p>删除对应配置文件，实际上应该是一个软连接到了mysql.cnf上，所以问题不大。</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/var/lib/mysql$ sudo rm -rf /etc/mysql/my.cnf</code></pre><p>重启一下:</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/etc/mysql$ sudo service mysql restart</code></pre><p>再次检测状态：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/etc/mysql$ sudo service mysql status</code></pre><p>问题解决：</p><pre><code class="language-ssh">adoop@LAPTOP-74GAR8S9:/etc/mysql$ sudo service mysql status * /usr/bin/mysqladmin  Ver 8.0.29-0ubuntu0.20.04.3 for Linux on x86_64 ((Ubuntu))Copyright (c) 2000, 2022, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Server version          8.0.29-0ubuntu0.20.04.3Protocol version        10Connection              Localhost via UNIX socketUNIX socket             /var/run/mysqld/mysqld.sockUptime:                 8 secThreads: 2  Questions: 8  Slow queries: 0  Opens: 436  Flush tables: 3  Open tables: 27  Queries per second avg: 1.000</code></pre><p>还有个小bug：</p><pre><code>hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ sudo service mysql restart * Stopping MySQL database server mysqld                                          [ OK ] * /etc/init.d/mysql: WARNING: /etc/mysql/my.cnf cannot be read. See README.Debian.gz * Starting MySQL database server mysqld[ OK ]</code></pre><p>我们删除后会导致有警告，问题不大：</p><p>我们将备份还原即可：</p><p>注意所在路径。</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/etc/mysql$ sudo mv my.cnf.buckup my.cnf</code></pre><p>登录MYSQL配置HIVE所需环境，你刚才是用来TCP登陆了，不过这里就是使用socket登录，密码还是前文随机的密码。</p><pre><code>mysql -u debian-sys-maint -p</code></pre><p>登陆结果如下：</p><pre><code class="language-ssh">Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 12Server version: 8.0.29-0ubuntu0.20.04.3 (Ubuntu)Copyright (c) 2000, 2022, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</code></pre><p>修改初始密码：</p><p>选择数据库，<code>use mysql</code></p><pre><code>mysql&gt; use mysqlReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -A</code></pre><p>先修改密码：<code>alter user 'root'@'localhost' identified by '123456';</code></p><pre><code>mysql&gt; alter user 'root'@'localhost' identified by '123456';Query OK, 0 rows affected (0.00 sec)mysql&gt; select user,plugin from user;+------------------+-----------------------+| user             | plugin                |+------------------+-----------------------+| debian-sys-maint | caching_sha2_password || mysql.infoschema | caching_sha2_password || mysql.session    | caching_sha2_password || mysql.sys        | caching_sha2_password || root             | auth_socket           |+------------------+-----------------------+5 rows in set (0.00 sec)</code></pre><p>修改其密码格式<br><code>update user set plugin='mysql_native_password' where user='root';</code></p><p>查询其用户<code>select user,plugin from user;</code></p><pre><code class="language-ssh">mysql&gt; update user set plugin='mysql_native_password' where user='root';Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select user,plugin from user;+------------------+-----------------------+| user             | plugin                |+------------------+-----------------------+| debian-sys-maint | caching_sha2_password || mysql.infoschema | caching_sha2_password || mysql.session    | caching_sha2_password || mysql.sys        | caching_sha2_password || root             | mysql_native_password |+------------------+-----------------------+5 rows in set (0.00 sec)</code></pre><p>保存权限修改：</p><pre><code class="language-ssh">mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec)</code></pre><p>最后退出：</p><pre><code class="language-ssh">mysql&gt; quitBye</code></pre><p>尝试登陆：</p><pre><code class="language-ssh">hadoop@LAPTOP-74GAR8S9:/etc/mysql/mysql.conf.d$ mysql -u root -pEnter password:</code></pre><p>登陆成功。</p><p><img src="https://s2.loli.net/2024/09/29/PBhkb6jfCXrNGxU.png" alt="18"></p><h2><span id="hive的mysql配置部分">Hive的mysql配置部分</span></h2><p>剩下的请参考厦门大学林子雨老师的博客：<a href="http://dblab.xmu.edu.cn/blog/2440-2/">大数据实验室</a>。直接到配置完成MYSQL,这部分有时间再写！</p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
          <category> Hadoop </category>
          
          <category> Scala </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> Hadoop </tag>
            
            <tag> Scala </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark快速大数据分析——Spark的结构化数据API（伍—分支1）</title>
      <link href="/2024/10/22/Spark(5_1)/"/>
      <url>/2024/10/22/Spark(5_1)/</url>
      
        <content type="html"><![CDATA[<h1><span id="spark快速大数据分析spark的结构化数据api伍分支1">Spark快速大数据分析——Spark的结构化数据API（伍—分支1）</span></h1><img src="https://s2.loli.net/2024/09/29/ZRGWD1Vcf9L7T8a.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727612689935" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><!-- toc --><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83">软件环境：</a></li><li><a href="#spark%E8%AF%BB%E5%8F%96avro%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%94%99">Spark读取AVRO数据报错</a></li><li><a href="#%E5%9C%A8%E4%BD%BF%E7%94%A8idea%E7%9A%84%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5avro%E5%8C%85%E6%9D%A5%E5%AE%9E%E7%8E%B0avro%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%85%A5%E5%91%A2">在使用IDEA的构建模式下，我该如何导入AVRO包来实现AVRO的数据读入呢？</a></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="软件环境">软件环境：</span></h2><p><strong>强烈提示：<br>请按照对应配套版本来进行环境配置！</strong></p><ul><li><strong>Hadoop-3.2</strong></li><li><strong>IDEA 2021.3.2</strong></li><li><strong>Spark-3.1.3 搭配  scala版本：2.12  构建方式：IDEA导入本地JAR，Spark库</strong></li><li><strong>JDK 8</strong></li></ul><h2><span id="spark读取avro数据报错">Spark读取AVRO数据报错</span></h2><p><img src="https://s2.loli.net/2024/09/29/ULCFPWeB1vMRVwq.png" alt="4"></p><pre><code class="language-shell">22/85/83—18:28:84 INFD BlockWanager: Initialized BlockWanager: BlockHlanagerId(driver，DESKTOP-S-1UNV8，58320，None)22/85/8318:28:05 TIFO ShanedState: Setting hive.metastore .warehouse.dir ('null' ) to the value of spank.sq1.wavehouse.dir( 'file:/C:/Users/86136/SparkProject/DataFrame01/spark-warehouse').22/05/83 18:28:05 INFD ShanedState: Warehouse path is 'file:/C:/Users/86136/SparkProject/DataFrame1/spark-warehouse .Etneptio in thrcadt"rsin" ng .apacne .span.go..nlysisExceaptin Cestetorghmit. laild tn find dota Lcauow av. Akn is built-in but extenal data sounce moduvle sine8Spark 2.4.Please deploy the application as per the deployment section o "Apache Avro Data Source Guide".at org.apache .spark.sql.execution.datasources.DataSource$.lookupDataSoUrce(Uata8Ource.scala.6797)at org.apache .spark.sql.execution.datasoucces.DataSource$.lookupDataSourceV2(DataSounce.scala:746)at org.apache.spark.sql.DataFrameReader.load(DataFrameReader.scala:265)at org.apache.spark.sql.DataFrameReader.load(DataFrameReader.scala:239)at test$.main(test.scala:33)at test.main(test.scala)22/05/03 18:28:06 INF0 SparkContext: Invoking stop() from shutdown hook</code></pre><h2><span id="在使用idea的构建模式下我该如何导入avro包来实现avro的数据读入呢">在使用IDEA的构建模式下，我该如何导入AVRO包来实现AVRO的数据读入呢？</span></h2><p>首先，在windos下打开CMD或者Powershell</p><p>输入以下命令：</p><pre><code class="language-powershell">spark-shell —packages org. apache.spark:spark-avro_2.12:3.1.3 ...</code></pre><p>首先要确认你安装了Sparkshell，并能正确运行和我上边的配置版本基本相同，因为不同版本的这个包是不通用的。</p><p>运行以后结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/h2AaGMnE4YJL7K9.png" alt="1"></p><p>等着出现Sparkshell的标志既可。</p><p>需要注意的是不要急着关闭，要记录一个关键信息：</p><p><img src="https://s2.loli.net/2024/09/29/GMSIubYvNBhmV8K.png" alt="2"></p><p>下载的jar包的存储位置。</p><p>我们找到找个jar包的位置并把它复制到IDEA导入的Spark的jar路径。</p><p>名字其实不太需要修改，我这边使用的没有问题。</p><p><img src="https://s2.loli.net/2024/09/29/9Y3yrNpIbZFek7T.png" alt="3"></p><p>最好在文件再导入一下依赖：</p><pre><code class="language-scala">import org.apache.spark.sql.avro.functions._</code></pre><p>但是我这边测试的时候只要加入到spark的jars包里面就可以了，看具体情况吧。</p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
          <category> Hadoop </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> Hadoop </tag>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark快速大数据分析——Spark的部署与使用（柒）</title>
      <link href="/2024/10/22/Spark(7)/"/>
      <url>/2024/10/22/Spark(7)/</url>
      
        <content type="html"><![CDATA[<h1><span id="spark快速大数据分析spark的部署与使用柒">Spark快速大数据分析——Spark的部署与使用（柒）</span></h1><img src="https://s2.loli.net/2024/09/29/I861KJRCQPwropA.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727613037515" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h2><span id="软件环境">软件环境</span></h2><p><strong>强烈提示：<br>请按照对应配套版本来进行环境配置！</strong></p><ul><li><strong>Hadoop-3.2</strong></li><li><strong>IDEA 2021.3.2</strong></li><li><strong>Spark-3.1.3 搭配  scala版本：2.12  构建方式：IDEA导入本地JAR，Spark库</strong></li><li><strong>JDK 8</strong></li><li><strong>Hive 3.1.3</strong></li><li><strong>MYSQL 8.0.2</strong></li><li><strong>WSL 2 Ubuntu20.04</strong></li></ul><p><strong>备注：在安装Spark-3.1.3 之前，请首先安装Hadoop3.2。</strong></p><h2><span id="spark在wsl2中的部署">Spark在WSL2中的部署</span></h2><p>windos下的压缩包和Linux下安装的压缩包完全一致，我们将压缩包送入root用户的目录下：</p><p><img src="https://s2.loli.net/2024/09/29/JbSr6AdRtLPMVsw.png" alt="0-9"></p><p>打开命令行，切换到hadoop用户：</p><p><code>su hadoop</code></p><p>切换以后再使用解压命令：</p><pre><code class="language-shell">hadoop@LAPTOP-74GAR8S9:/usr/local$ sudo tar -zvxf /home/jszszzy/spark/spark-3.1.3-bin-hadoop3.2.tgz  -C /usr/local/</code></pre><p>切换目录到解压目录下：</p><pre><code class="language-shell">hadoop@LAPTOP-74GAR8S9:/usr/local$ cd /usr/local</code></pre><p>修改对应目录的名字：</p><pre><code class="language-shell">hadoop@LAPTOP-74GAR8S9:/usr/local$ sudo mv ./spark-3.1.3-bin-hadoop3.2/ ./spark</code></pre><p>增加用户组权限：</p><pre><code class="language-shell">hadoop@LAPTOP-74GAR8S9:/usr/local$ sudo chown -R hadoop:hadoop ./spark</code></pre><p>进入目录修改配置文件：</p><pre><code class="language-shell">hadoop@LAPTOP-74GAR8S9:/usr/local$ cd spark/hadoop@LAPTOP-74GAR8S9:/usr/local/spark$ cp ./conf/spark-env.sh.template ./conf/spark-env.sh</code></pre><p>使用vim修改配置文件，添加以下内容：</p><pre><code class="language-shell">hadoop@LAPTOP-74GAR8S9:/usr/local/spark$ vim ./conf/spark-env.sh</code></pre><p>添加hadoop支持：</p><pre><code class="language-shell">export SPARK_DIST_CLASSPATH=$(/usr/local/hadoop/bin/hadoop classpath)</code></pre><p>有了上面的配置信息以后，Spark就可以把数据存储到Hadoop分布式文件系统HDFS中，也可以从HDFS中读取数据。如果没有配置上面信息，Spark就只能读写本地数据，无法读写HDFS数据。配置完成后就可以直接使用，不需要像Hadoop运行启动命令。</p><p>在测试前请先打开ssh和hadoop还有hive：</p><p>打开ssh：</p><pre><code>hadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ sudo service ssh restart[sudo] password for hadoop: * Restarting OpenBSD Secure Shell server sshd                                     [ OK ]</code></pre><p>打开hadoop：</p><pre><code class="language-shell">hadoop@LAPTOP-74GAR8S9:/home/jszszzy$ cd /usr/local/hadoophadoop@LAPTOP-74GAR8S9:/usr/local/hadoop$ ./sbin/start-dfs.shStarting namenodes on [localhost]</code></pre><p>如果有需要还需要打开Mysql和hive，具体可参考hive安装篇。</p><p>通过运行Spark自带的示例，验证Spark是否安装成功。</p><pre><code class="language-shell">cd /usr/local/sparkbin/run-example SparkPi 2&gt;&amp;1 | grep "Pi is"</code></pre><p>得到pi=31.4即可。</p><p><img src="https://s2.loli.net/2024/09/29/S9T7PGYWFn6gwV8.png" alt="0"></p><h2><span id="使用idea连接wsl2运行spark代码">使用IDEA连接WSL2运行Spark代码</span></h2><p>打开IDEA创建一个sbt项目，如果你不会创建，请参考专栏对应文章。</p><p>找到编辑编译配置项目，具体如下图：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/17/ffa1807c64c247bd.png" alt></p><p>打开以后找到如下选项：</p><p><img src="https://s2.loli.net/2024/09/29/cDXWGsx2K6wrjhL.png" alt="0-11"></p><p>打开Run on选项选择新建运行环境，并选择WSL，选择会会让你配置wsl的运行环境：</p><p>他自动检测到了WSL的JDK，实际上安装了两个JDK，应该使用Spark所要的jdk。</p><p><img src="https://s2.loli.net/2024/09/29/lDn59uyh2ZbHAKX.png" alt="0-13"></p><p>我们点击next，手动配置一下。</p><p><img src="https://s2.loli.net/2024/09/29/jzn9kJQPtxWbm7R.png" alt="0-14"></p><p>具体怎么填写，可以参考我的。</p><p><img src="https://s2.loli.net/2024/09/29/Hdrjf7SOoIcWkgq.png" alt="0-16"></p><p>打开Run on选项将Local machine替换为WSL2：</p><p><img src="https://s2.loli.net/2024/09/29/yI9i8wa6VtgJWlD.png" alt="0-12"></p><p>此时应该就可以愉快的运行了。</p><p>需要注意的是你需要先将hadoop和ssh服务都开启才能正常运行，如何打开服务，请参考hadoop配置篇。</p><p>以下提供一个参考代码用于检测运行;</p><pre><code class="language-scala">package com.jszszzy.testimport org.apache.spark.sql.SparkSessionimport org.apache.spark.sql.functions._import org.apache.spark.sql.types.IntegerTypeobject Test {  def main(args: Array[String]): Unit = {    val spark = SparkSession      .builder()      .appName("test")      .enableHiveSupport()      .getOrCreate()      }}</code></pre><p>对应的配置项如下，具体的信息需要你那个修改：</p><pre><code class="language-scala">ThisBuild / version := "0.1.0-SNAPSHOT"ThisBuild / scalaVersion := "2.12.10"libraryDependencies ++= Seq(  "org.apache.spark" %% "spark-hive" % "3.1.3","org.apache.spark" %% "spark-core" % "3.1.3",  "org.apache.spark" %% "spark-sql" % "3.1.3")lazy val root = (project in file("."))  .settings(    name := "test",    idePackagePrefix := Some("com.jszszzy.test") )</code></pre><p>当然你如果测试的时候出现以下错误，请按我的修改：</p><h4><span id="错误一">错误一</span></h4><p><img src="D:%5C%E6%96%87%E7%AB%A0%5CSpark%5CSpark(7).assets%5C0-17.png" alt="0-17"></p><pre><code class="language-shell">Exception in thread "main" java.lang.IllegalArgumentException: System memory 462422016 must be at least 471859200. Please increase heap size using the --driver-memory option or spark.driver.memory in Spark configuration.at org.apache.spark.memory.UnifiedMemoryManager$.getMaxMemory(UnifiedMemoryManager.scala:221)at org.apache.spark.memory.UnifiedMemoryManager$.apply(UnifiedMemoryManager.scala:201)at org.apache.spark.SparkEnv$.create(SparkEnv.scala:340)at org.apache.spark.SparkEnv$.createDriverEnv(SparkEnv.scala:189)at org.apache.spark.SparkContext.createSparkEnv(SparkContext.scala:277)at org.apache.spark.SparkContext.&lt;init&gt;(SparkContext.scala:458)</code></pre><h4><span id="错误二">错误二</span></h4><pre><code class="language-shell">org.apache.spark.SparkException: A master URL must be set in your configurationat org.apache.spark.SparkContext.&lt;init&gt;(SparkContext.scala:394)at org.apache.spark.SparkContext$.getOrCreate(SparkContext.scala:2672)at org.apache.spark.sql.SparkSession$Builder.$anonfun$getOrCreate$2(SparkSession.scala:945)at scala.Option.getOrElse(Option.scala:189)</code></pre><p>这是因为JVM分配默认的内存有点小，并且我们没有设置运行的主节点，我们为其添加以下指令：</p><pre><code class="language-java">-Dspark.master=local[*] -Xmx3g</code></pre><p>添加的位置如下：</p><p><img src="https://s2.loli.net/2024/09/29/mcn6YB3JRH4Labh.png" alt="0-18"></p><p><img src="https://s2.loli.net/2024/09/29/VeK6njlJRdQL7c1.png" alt="0-19"></p><h4><span id="错误三">错误三</span></h4><p>Hive支持失败。</p><pre><code class="language-shell">ERROR ApplicationMaster:94 - User class threw exception: java.lang.IllegalArgumentException: Unable to instantiate SparkSession with Hive support because Hive classes are not found.java.lang.IllegalArgumentException: Unable to instantiate SparkSession with Hive support because Hive classes are not found</code></pre><p>问题不大请将sbt的依赖按照上文修改一摸一样即可，不要添加”provided“选项。</p><h4><span id="错误四">错误四</span></h4><pre><code class="language-shell">Command line is too long. In order to reduce its length classpath file can be used. Would you like to enable classpath file mode for all run configurations of your project? Enable</code></pre><p>在stackoverflow上找到了解决办法：</p><p><img src="https://s2.loli.net/2024/09/29/zBQZi5YSJ1muTId.png" alt="0-20"></p><p><img src="https://s2.loli.net/2024/09/29/8CN56yOHUdajFfP.png" alt="0-21"></p><p>原回答链接：<a href="https://stackoverflow.com/questions/6381213/idea-10-5-command-line-is-too-long%E3%80%82">https://stackoverflow.com/questions/6381213/idea-10-5-command-line-is-too-long。</a></p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
          <category> Hadoop </category>
          
          <category> Scala </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> Hadoop </tag>
            
            <tag> Scala </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark快速大数据分析——Spark基础（肆）</title>
      <link href="/2024/10/22/Spark(4)/"/>
      <url>/2024/10/22/Spark(4)/</url>
      
        <content type="html"><![CDATA[<h1><span id="spark快速大数据分析spark基础肆">Spark快速大数据分析——Spark基础（肆）</span></h1><img src="https://s2.loli.net/2024/09/29/NbsHdGrJ1IkZFVY.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727612362790" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h2><span id="软件环境">软件环境</span></h2><p><strong>强烈提示：<br>请按照对应配套版本来进行环境配置！</strong></p><ul><li><strong>Hadoop-3.2</strong></li><li><strong>IDEA 2021.3.2</strong></li><li><strong>Spark-3.1.3 搭配  scala版本：2.12  构建方式：IDEA导入本地JAR，Spark库</strong></li><li><strong>Spark-3.2.1 搭配  scala版本 ：2.13.8 构建方式 ：SBT自动导入依赖</strong></li><li><strong>JDK 8</strong></li></ul><!-- toc --><ul><li><a href="#spark%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%A7%E8%A1%8C">Spark的分布式执行</a><ul><li><a href="#spark%E9%A9%B1%E5%8A%A8%E5%99%A8">Spark驱动器</a></li><li><a href="#sparksession">SparkSession</a></li><li><a href="#%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%99%A8">集群管理器</a></li><li><a href="#spark%E6%89%A7%E8%A1%8C%E5%99%A8">Spark执行器</a></li><li><a href="#%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F">部署模式</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%88%86%E5%8C%BA">分布式数据与分区</a></li></ul></li><li><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3spark%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">深入理解Spark的基础概念</a><ul><li><a href="#%E5%BA%94%E7%94%A8">应用</a></li><li><a href="#sparksession-1">SparkSession</a></li><li><a href="#%E4%BD%9C%E4%B8%9A">作业</a></li><li><a href="#%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5">执行阶段</a></li><li><a href="#%E4%BB%BB%E5%8A%A1">任务</a></li><li><a href="#spark%E7%9A%84%E6%93%8D%E4%BD%9C">Spark的操作</a><ul><li><a href="#%E8%BD%AC%E5%8C%96%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC">转化操作与惰性求值</a></li><li><a href="#%E8%A1%8C%E5%8A%A8%E6%93%8D%E4%BD%9C">行动操作</a></li></ul></li><li><a href="#spark%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92">Spark的查询计划</a></li><li><a href="#%E7%AA%84%E8%BD%AC%E5%8C%96%E4%B8%8E%E5%AE%BD%E8%BD%AC%E5%8C%96">窄转化与宽转化</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="spark的分布式执行">Spark的分布式执行</span></h2><p>为了方便理解概念，我将完整的交互关系图画了出来，可以一边看文章配合着这张图来理解：</p><p><img src="https://s2.loli.net/2024/09/29/FLwSZTncIHJm3ez.jpg" alt="1_37e"></p><h3><span id="spark驱动器">Spark驱动器</span></h3><p>作为Spark应用中负责初始化的SparkSession的部分，Spark驱动器扮演着多个角色：</p><ul><li><strong>与集群管理器打交道</strong>，<strong>向集群管理器申请Spark执行器（JVM）所需要的资源</strong>；</li><li><strong>将Spark操作转换为DAG运算，并负责调度，还要将计算分成任务分发到Spark执行器上</strong>。</li></ul><h3><span id="sparksession">SparkSession</span></h3><p>在Spark2.0之中，SparkSession是所有Spark操作和数据的统一入口。它不仅封装了Spark程序之前的各种入口，还让Spark变得更加简单。</p><p>2.x和1.x版本的区别在哪里呢？</p><p>在1.x版本你需要创建多个上下文对象（分别对数据进行处理，sql查询等），这会让代码显得很繁琐。但在Spark2.x中你只需要为每个JVM创建一个Sparksession即可，就可以通过Sparksession调用全部对象。</p><p>在Spark2.x版本中虽然Sparksession已经包含了其中操作的各种对象例如使用SparkContext和SQLContext产生的对象，你也可以直接旧版的1.x的代码来使用这些类和对象，也就是说2.x兼容1.x版本的代码。</p><p>通过Sparksession入口，可以创建JVM运行时的参数、定义DataFrame或Dataset、从数据源读取数据、访问数据库的元数据，并发起SQL查询。SparkSession为所有的Spark功能提供了统一的入口。</p><h3><span id="集群管理器">集群管理器</span></h3><p>集群管理器负责管理和分配各个节点的资源，以用来Spark应用的执行。</p><p>目前Spark支持4种集群管理器：</p><ul><li>Spark自带的独立集群管理器</li><li>Apache Hadoop YARN</li><li>Apache Mesos</li><li>Kubernetes</li></ul><h3><span id="spark执行器">Spark执行器</span></h3><p>Spark执行器在各个节点上进行工作，<strong>执行器与驱动器程序通信</strong>，<strong>并负责在工作节点上执行任务</strong>。<strong>在大多数部署模式，每个节点上的只有一个执行器。</strong></p><h3><span id="部署模式">部署模式</span></h3><p>目前spark支持的部署模式如下：</p><img src="https://s2.loli.net/2024/09/29/tdMcbAOW8VigraU.png" alt="9" style="zoom:67%;"><p>常用的就是本地模式和独立模式。</p><h3><span id="分布式数据与分区">分布式数据与分区</span></h3><p>实际上物理数据是以分区的形式分布在<strong>HDFS</strong>或者云储存上的，数据分区遍布整个物理集群，而Spark将每个分区在逻辑上抽象为内存中的一个Dataframe（和结构化数据结构不相同），根据本地要求在分配任务的时候根据要求的数据分区与各Spark执行器上在网络上的远近，将数据分配到最近的Spark执行器上，将数据分区的分布式结构可以让Spark执行器只处理靠近自己的数据，从而最小化网络带宽的使用率。也就是说，执行器的每个核心都能分到自己要处理数据的分区。</p><p>如下图展示了Spark的分区数据结构：</p><p><img src="https://s2.loli.net/2024/09/29/Ahf81IDBSlu2gHn.png" alt="10"></p><h2><span id="深入理解spark的基础概念">深入理解Spark的基础概念</span></h2><h3><span id="应用">应用</span></h3><p>使用Spark的API构建基于Spark的用户程序。</p><p>一般由一个驱动器和集群内多个执行器组成。</p><h3><span id="sparksession">SparkSession</span></h3><p>SparkSession对象提供与下层Spark功能交互的入口。它允许用户用Spark API编写Spark程序。在交互式Spark shell种，Spark驱动器已经初始化了一个SparkSession对象，但在Spark应用中，你需要自行创建SparkSession对象。</p><p>所有Spark应用的核心都是Spark驱动器程序，他要负责创建Spark Session对象当使用Spark shell的时候驱动器是shell的一部分，SparkSeesion对象已经自动创建好了，在启动Spark-shell的时候可以看见：</p><p><img src="https://s2.loli.net/2024/09/29/PZF4zJnpf1RxH8s.png" alt="1"></p><p>在前边windos下Spark的启动都是以本地模式启动的 Spark shell，因此所有操作都会在本地的单个JVM中执行。如果要在集群中启动Spark shell来并行分析数据，其实和本地模式差不多，使用spark-shell --help来展示如何连接：</p><p><img src="https://s2.loli.net/2024/09/29/hfXPEbrjAyNdags.png" alt="2"></p><p>下图展示了Spark分布式集群管理器是如何通过驱动器实现各节点连接的</p><p><img src="https://s2.loli.net/2024/09/29/ZUqNKnly37dmktb.png" alt="3"></p><h3><span id="作业">作业</span></h3><p>在Spark-shell进行交互式会话中，<strong>驱动器会将Spark应用转为一个或者多个Spark作业</strong>，如图所示：</p><p><img src="https://s2.loli.net/2024/09/29/D86SsfQrUl7OFME.png" alt="4"></p><p>驱动器会自动将每个作业转化为一个DAG（<strong>有向无环图</strong>），这个DAG本质上就是Spark运行的执行计划，每一个节点都有可能是一个或者多个Spark执行阶段，具体什么是执行阶段接着往下看.</p><h3><span id="执行阶段">执行阶段</span></h3><p>Spark执行阶段可以作为任务计划的一个节点，也就是DAG图中的一个节点，Spark会根据操作能否并行执行或者必须串行执行来创建执行阶段。<strong>不是所有的Spark操作只对应一个阶段，某些操作可能是多个阶段的。</strong></p><p><strong>执行阶段之间可能会触发Spark执行器间的数据传输。</strong></p><p>下图展示了一个作业如何被分解成一个DAG内多个执行阶段的。</p><p><img src="https://s2.loli.net/2024/09/29/dTackD8lmRW9NMO.png" alt="5"></p><h3><span id="任务">任务</span></h3><p>执行阶段是由Spark任务组成的，这些任务由Spark的各个执行器一起执行。每个任务对应一个<strong>处理器核心</strong>（cpu 物理上的核心或者超线程），并处理一个<strong>数据分区</strong>，从而使Spark的任务执行高度并行化，更重要的是不需要用户自己具体考虑如何具体并行化。</p><p>下图展示了Spark执行阶段创建的多个任务：</p><p><img src="https://s2.loli.net/2024/09/29/swEJA18OlvkgWjb.png" alt="6"></p><h3><span id="spark的操作">Spark的操作</span></h3><p>Spark对分布式数据的操作可以分为两种类型:<strong>转化操作和行动操作</strong>。</p><h4><span id="转化操作与惰性求值">转化操作与惰性求值</span></h4><p>顾名思义，转化操作就是将Spark DataFrame转化为新的DataFrame，而不改变原有的数据，这赋予了DataFrame不可变的属性，并不改变原有的数据，这样就赋予了Dataframe不可变的属性。换句话说，像select()[选择数据]或者filter()[过滤数据]这种操作并不会修改原有的数据，这些操作会将数据返回成一个新的DataFrame。</p><p>所有转化操作都是惰性求值的，也就是说，具体结果不会立即计算出来，Spark只是将具体的转化关系作为血缘(lineage）记录下来，记录下来的血缘允许Spark在后续生成执行计划时重新安排要做的转化操作，比如合并多个转化操作，或者优化为不同的执行阶段来提高执行效率。惰性求值是Spark的策略，目的是直到调用行动操作或“碰”到数据（从硬盘上读取或向硬盘写入)时才真正执行行动操作会触发所记录下来的所有转化操作的实际求值。</p><h4><span id="行动操作">行动操作</span></h4><p>行动操作会触发记录下来的所有转化操作的实际求值。也就是说转化操作会被行动操作所触发。</p><p><img src="https://s2.loli.net/2024/09/29/nqUu3i69ycXILNG.png" alt="7"></p><p>如上图，在调用A操作前，所有转化操作T都只是被记录下来了。每个操作T都会生成一个新的DataFrame</p><p><strong>惰性求值允许Spark通过综合分析整个转化操作链来优化查询。</strong></p><p><strong>血缘（lineage）和数据不可变性则让Spark拥有容错性。只需要通过Spark记录下来的血缘就可以重新构建出DataFrame，这样Spark便能够在失败的时候依然有机会恢复！</strong></p><p>常用的转化与行动操作：</p><img src="https://s2.loli.net/2024/09/29/ag1k8B2hNLuv3rG.png" alt="8" style="zoom: 67%;"><h3><span id="spark的查询计划">Spark的查询计划</span></h3><p>行动操作和转化操作生成了Spark的查询计划，以后会对此进行介绍。调用行动操作之前Spark并不会执行查询计划。只有行动操作会触发查询计划的执行，此时查询计划中包含的的所有记录下来的转化操作才会真正执行。</p><h3><span id="窄转化与宽转化">窄转化与宽转化</span></h3><p>如前文所述，转化操作是Spark特有的惰性求值操作。惰性求值方案的最大优势是，Spark可以分析整个计算查询，然后针对计算查询过程进行分析优化，到后边我们会举例Spark是如何优化的。这里的优化包括将一些操作连起来放在一个执行阶段中进行管道化执行，或者根据是否需要集群节点进行数据交换或者混洗，将操作分为多个阶段来执行。</p><p>根据依赖关系属于窄依赖还是宽依赖可以将转化操作分为两类。如果输出的单个数据分区是由单个输入分区计算得来的，那么这样的转化操作就成为窄转化。比如filter()和contains()就属于窄转化，因为这些操作在每个数据分区是独立的，生成的输出数据分区时不需要跨分区进行操作。</p><p>然而，groupby()和orderby（）会产生宽转化操作。对于统计每个分区存在单词“spark”的出现次数，需要从每个执行器上将来自于各个分区的数据进行混洗。具体是如何实现的留到后面再说。</p><p><img src="https://s2.loli.net/2024/09/29/zOsunEPx7Jpy2wh.png" alt="18"></p><p>以上就是Spark的一些基础概念，下节将介绍Spark代码具体的应用。</p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
          <category> Hadoop </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> Hadoop </tag>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOS管 —— 快速复苏应用笔记[参数与应用篇]</title>
      <link href="/2024/10/21/MOS%E7%AE%A1%20%E2%80%94%E2%80%94%20%E5%BF%AB%E9%80%9F%E5%A4%8D%E8%8B%8F%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0%5B%E5%8E%9F%E7%90%86%E7%AF%87%5D/"/>
      <url>/2024/10/21/MOS%E7%AE%A1%20%E2%80%94%E2%80%94%20%E5%BF%AB%E9%80%9F%E5%A4%8D%E8%8B%8F%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0%5B%E5%8E%9F%E7%90%86%E7%AF%87%5D/</url>
      
        <content type="html"><![CDATA[<h1><span id="mos管-快速复苏应用笔记原理篇">MOS管 —— 快速复苏应用笔记[原理篇]</span></h1><p>此篇内容为MOS管的开篇内容，助你从结构上理解和使用MOS管。</p><img src="https://s2.loli.net/2024/09/29/nZBpl8GWmNS3dEr.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727598698710" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><!-- toc --><ul><li><a href="#%E5%9C%BA%E6%95%88%E5%BA%94%E6%99%B6%E4%BD%93%E7%AE%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">场效应晶体管的工作原理</a><ul><li><a href="#%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E5%92%8C%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BC%98%E5%8A%BF">场效应管和双极型晶体管的区别和优势</a></li><li><a href="#%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%8E%9F%E7%90%86%E5%9B%BE%E5%AE%9A%E4%B9%89">场效应管的分类和原理图定义</a></li><li><a href="#%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%BB%93%E6%9E%84">场效应管的原理和结构</a><ul><li><a href="#nmos%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84">NMOS的内部结构</a></li><li><a href="#%E9%87%91%E5%B1%9E%E6%B0%A7%E5%8C%96%E7%89%A9%E6%95%88%E5%BA%94%E7%9A%84%E5%8E%9F%E7%90%86">金属氧化物效应的原理</a><ul><li><a href="#%E7%B4%AF%E7%A7%AF%E9%98%B6%E6%AE%B5">累积阶段</a></li><li><a href="#%E8%80%97%E5%B0%BD%E9%98%B6%E6%AE%B5">耗尽阶段</a></li><li><a href="#%E5%8F%8D%E5%9E%8B%E9%98%B6%E6%AE%B5">反型阶段</a></li></ul></li><li><a href="#%E9%87%91%E6%B0%A7%E6%95%88%E5%BA%94%E4%B8%8Emos%E7%BB%93%E6%9E%84%E7%9A%84%E9%85%8D%E5%90%88%E5%B7%A5%E4%BD%9C">金氧效应与MOS结构的配合工作</a><ul><li><a href="#mos%E7%9A%84%E7%9C%9F%E5%AE%9E%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%84%E7%94%9F%E4%BA%8C%E6%9E%81%E7%AE%A1">MOS的真实结构与寄生二极管</a></li><li><a href="#mos%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">MOS的工作模式</a></li><li><a href="#%E6%88%AA%E6%AD%A2%E5%8C%BA%E4%BA%9A%E9%98%88%E5%80%BC%E5%8C%BA%E6%88%96%E5%BC%B1%E5%8F%8D%E8%BD%AC%E5%8C%BAcutoff-subthreshold-or-weak-inversion-mode">截止区（亚阈值区或弱反转区）（cutoff, subthreshold or weak-inversion mode）</a></li><li><a href="#%E7%BA%BF%E6%80%A7%E5%8C%BA%E4%B8%89%E6%9E%81%E5%8C%BA%E6%88%96%E6%AC%A7%E5%A7%86%E5%8C%BAlinear-region-triode-mode-or-ohmic-mode">线性区（三极区或欧姆区）（linear region, triode mode or ohmic mode）</a></li><li><a href="#%E9%A5%B1%E5%92%8C%E5%8C%BA%E6%94%BE%E5%A4%A7%E5%8C%BAsaturation-or-active-mode">饱和区（放大区）（saturation or active mode）</a></li></ul></li><li><a href="#mos%E7%AE%A1%E7%9A%84%E7%AC%A6%E5%8F%B7">MOS管的符号</a></li><li><a href="#pmos">PMOS</a></li><li><a href="#nmos">NMOS</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="场效应晶体管的工作原理">场效应晶体管的工作原理</span></h2><p>场效应管（Field Effect Transistor —— FET）是单极型晶体管，与双极型晶体管BJT都属于晶体管(Transistor)。在双极型晶体管中，载流子包含电子运动也包含空穴运动，像双重合力一般流向两个极；而在场效应管中，只有一种载流子运动，或者电子或者空穴，流向一个极，因此叫单极型晶体管。</p><h3><span id="场效应管和双极型晶体管的区别和优势">场效应管和双极型晶体管的区别和优势</span></h3><p>单极型虽然诞生比较晚，但是通过其本是固有的一些优点，比如低噪声、高阻低功耗、热稳定性好等，同时二者都能实现放大功能和开关功能，因此直接就碾压了BJT，其无敌的低功耗为数字芯片领域所青睐，随着时代变化，MOSFET基本完全替代了BJT，只有在部分模拟器中比如：运算放大器、数模转换器、电源模块、超高频、电流放大、低成本应用领域等BJT还占有一定的比例。</p><h3><span id="场效应管的分类和原理图定义">场效应管的分类和原理图定义</span></h3><p>场效应管大致可以分为以下两种：</p><pre class="mermaid">graph LR A(场效应管) --&gt; B("结型场效应管(Junction FET)") A --&gt; C("金属氧化物效应管(Metal-Oxide-Semiconductor Field Effect Transistor-MOSFET)")</pre><p>结型场效应工作电流很小，适合于模拟信号放大，它分为N沟道和P沟道两种。像双极性晶体管中的NPN和PNP一样，M沟道和P沟道仅仅是工作电流的方向相反。结型场效应管由于应用场合有限，数量较少。这里不详细介绍，仅作了解。</p><p>MOSFET的分类和BJT就不近相同了，MOSEFT作为最常见的FET首先分为两种类型增强型和耗尽型，在两种类型之下又因为掺杂工艺不同又分为N沟道和P沟道。</p><pre class="mermaid">graph TBA("金属氧化物效应管(Metal-Oxide-Semiconductor Field Effect Transistor-MOSFET)") --&gt; B("增强型(enhancement mode)")A --&gt; C("耗尽型(depletion mode)")B --&gt; D(P沟道)B --&gt; E(N沟道)C --&gt; F(N沟道)</pre><p>当然也有一些区分办法是依据工作电压和电流来区分，一般分为小信号管和功率管两种。</p><h3><span id="场效应管的原理和结构">场效应管的原理和结构</span></h3><p>想要真正了解MOS是如何工作的就必须要知道其物理结构是怎样的，大多数书上的内容这一块都讲的不明不白，今天来根据我所了解的来总结一下。以下内容全部是关于增强型的，因为耗尽型型号比较少，关于两者的区别将在下文中顺便说明。</p><h4><span id="nmos的内部结构">NMOS的内部结构</span></h4><p>下图是一个N型MOS的剖面图，我们来通过剖面图详细解说一下。</p><p><img src="https://s2.loli.net/2024/09/29/lXQh2MAf19nUzpb.png" alt="MOSFET-Cross"></p><p>可以看到他是用一块掺杂浓度比较低的P型硅片作为衬底，利用扩散工艺在衬底上扩散两个高掺杂浓度的N型区域。</p><p>NMOS的源极与漏极上标示的“N+”代表着两个意义：</p><p>（1）N代表掺杂（doped）在源极与漏极区域的杂质极性为N；</p><p>（2）“+”代表这个区域为高掺杂浓度区域（heavily doped region），也就是此区的电子或空穴浓度远高于其他区域。在源极与漏极之间被一个极性相反的区域隔开，也就是所谓的基极（或称基体）区域。如果是NMOS，那么其基体区的掺杂就是p-type。反之对PMOS而言，基体应该是n-type，而源极与漏极(上图的Drain)则为p-type（而且是高掺杂的P+）。基体的掺杂浓度不需要如源极或漏极那么高，故在左图中没有“+”，作为沟道用。</p><p>可以看到在N型区域引出的两个欧姆电极，分别称为源极(Source)和漏极(Drain),为了简化符号书写我们常常使用S和D来分别代表以上的电极。</p><p>你可以注意到引出的电极的上层并不是完全空的，而是有一层氧化薄膜，对应上图中就是场氧化层(Filed Oxide),氧化层的材料多半是<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E6%B0%A7%E5%8C%96%E7%9F%BD">二氧化硅</a>，其下是作为基极的<a href="https://zh.wikipedia.org/wiki/%E7%9F%BD">硅</a>，而其上则是作为栅极的<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%99%B6%E7%A1%85">多晶硅</a>，当然早期的时候这里的多晶硅被替换为铝电极，并将其引出这就是栅极(Gate)。当上层覆盖的氧化层在早期是金属铝的时候，人们通常把这种结构叫金属氧化物效应管，这也是MOS名称的由来。</p><h4><span id="金属氧化物效应的原理">金属氧化物效应的原理</span></h4><p>MOS管在结构上以一个<strong>金属—氧化物层—半导体(基极)<strong>的</strong>电容</strong>为核心，氧化层的材料多半是<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E6%B0%A7%E5%8C%96%E7%9F%BD">二氧化硅</a>，其下是作为基极的硅，而其上则是作为栅极的多晶硅（早期是金属）。这样的结构正好等于一个<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AE%B9%E5%99%A8">电容器</a>。氧化层为电容器中<a href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E9%9B%BB%E8%B3%AA">介电质</a>，而电容值由氧化层的厚度与二氧化硅的<strong>介电系数</strong>来决定。栅极多晶硅与基极的<strong>硅</strong>则成为MOS电容的两个端点。完整的结构如下所示：</p><img src="https://s2.loli.net/2024/09/29/OGFsvSI9BlYrRVC.png" alt="Mos_capacitance" style="zoom:67%;"><h5><span id="累积阶段">累积阶段</span></h5><p>当一个电压施加在MOS电容的两端时，半导体的电荷分布也会跟着改变。如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/p1gaJT3DV4FNOfK.gif" alt="Illustration_of_C-V_measurement"></p><p>在这张图片中，显示了具有不同氧化层厚度的块状p型衬底MOS-CAP的C-V曲线。显示的蓝色曲线是指高频C-V曲线，而红色曲线是指低频C-V曲线。在积累和耗尽阶段，MOS电容与所有频率无关。这是因为在这里，总电荷是由多数载流子控制的。在反转区，电荷由少数载流子支配，形成反转层。由于少数载流子产生的时间有限，在较高的频率下，总电荷不能跟随栅极偏置，这可能导致C-V曲线的差异。这里还值得注意的是阈值电压随不同的氧化层厚度的变化。</p><p>电容公式高速我们电容只和介电常数以及厚度和面积相关，所以和电压无关。不过MOS结构的电容会随着电压的变化而变化，所以我们通过C-V曲线来进行分析，由于衬底是P，而积累的也是P-type，所以下电极只是导电特性变好，所有的栅极电压全部加在G上，所以此时电容最大。</p><h5><span id="耗尽阶段">耗尽阶段</span></h5><p>相反，当一个正的电压<em>VGD</em>施加在栅极与基极端（如图）时，空穴的浓度会减少（称为耗尽，如C-V曲线中间所示），<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90">电子</a>的浓度会增加。</p><h5><span id="反型阶段">反型阶段</span></h5><p>当<em>VGB</em>够强时，接近栅极端的电子浓度会超过空穴。这个在p-type半导体中，电子浓度（带负电荷）超过空穴（带正电荷）浓度的区域，便是所谓的<strong>反转层</strong>（inversion layer）。</p><p>在反型区，也就是Vg大于开启电压时，此时耗尽区宽度达到最大值，所以进入强反型，这个时候的电容达到最小值。当然还有个不容忽略的问题是我们的测试电压的频率，当频率较低时，载流子的速度可以跟的上电压频率的变化，所以此时的反型区是被充电的最终还是达到GOX的厚度。而如果是高频，载流子速度根本赶不上反型区充电速度，所以只能保持在低电容状态。而实际上这个反型区宽度与衬底浓度是有很大关系的(这个可能用Vt与衬底浓度的关系来理解，所以完全可以通过反型区高频电容特性来判断衬底浓度的变化。</p><p>MOS电容的特性决定了金氧半场效晶体管的工作特性，但是一个完整的金氧半场效晶体管结构还需要一个提供<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%95%B8%E8%BC%89%E5%AD%90">多数载流子</a>（majority carrier）的源极以及接受这些多数载流子的漏极。</p><h4><span id="金氧效应与mos结构的配合工作">金氧效应与MOS结构的配合工作</span></h4><h5><span id="mos的真实结构与寄生二极管">MOS的真实结构与寄生二极管</span></h5><p>理论情况下，一个MOS的封装应该会有四个脚,源极（S）、漏极（D）、栅极（G）外，尚有一<strong>基极</strong>（Bulk或是Body），例如如下所示：</p><img src="https://s2.loli.net/2024/09/29/uwkQO3a6iLtJWs7.png" alt="image-20220723103920689" style="zoom:67%;"><p>但实际上市面上销售的MOS结构都不是这样的，应该是如下：</p><img src="https://s2.loli.net/2024/09/29/OaRsiWClxLnGZe3.png" alt="image-20220723104549822" style="zoom:50%;"><p>这是因为通常把基极和源极接在一起，如上图符号所示，故分布式金氧场效晶体管通常为三端器件。而在集成电路中的金氧半场效晶体管通常因为使用同一个基极（common bulk），所以不标示出基极的极性，而在PMOS的栅极端多加一个圆圈以示区别。</p><p><strong>将衬底也就是B和S连接在一起会导致什么事情呢？</strong></p><p>请看下图：</p><p><img src="https://s2.loli.net/2024/09/29/Vso7Ed6WiHbI5mF.png" alt="image-20220723105235303"></p><p>这是一个NMOS，当衬底和S连接的时候就会像上边一样，此时S到D的通路就会形成一个神奇的东西：<strong>PN结</strong>，如下所示：</p><p><img src="https://s2.loli.net/2024/09/29/gqZmsD3OpuYrUeV.png" alt="image-20220723105538593"></p><p><strong>也就是说，当我们直接对NMOS得S和D极加上一个电压的时候，他就会因为PN结直接导通。<strong>而我们将这个形成的二极管称为</strong>寄生二极管</strong>。这是由MOS结构决定的，是不可避免的。</p><p>你可能不相信，我们通过仿真来测试一下,电路结构如下：</p><p><img src="https://s2.loli.net/2024/09/29/yikERIVJWhQSPum.png" alt="image-20220723112854801"></p><p>仿真结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/7OhIBnj9xzgks2E.png" alt="image-20220723113005451"></p><p>我们更改一下电路结构，看看DS是否还是导通的？更改后结构如下：</p><p><img src="https://s2.loli.net/2024/09/29/qeGLWndrgQTVoXj.png" alt="image-20220723113432002"></p><p>结果如下，果然不导通。</p><p><img src="https://s2.loli.net/2024/09/29/9V15y2H6exhoCUu.png" alt="image-20220723113414469"></p><p>在这里我们需要说明一下：<strong>场效应管(JEFT不是MOS)中，源极和漏极是对称的，可以互换。但是在MOSFET 中，由于衬底和源极在内部已经连同，甚至很多MOSFET内部还在D、S之间并联了一个二极管，注意这里的是真的添加了一个二极管不是体二极管，因此D和S不能互换。</strong></p><h5><span id="mos的工作模式">MOS的工作模式</span></h5><p>依照在MOS管的栅极、源极，与漏极等三个端点施加的<a href="https://zh.wikipedia.org/wiki/%E5%81%8F%E7%BD%AE">偏置</a>（bias）不同，MOS管将有下列三种工作模式。</p><h5><span id="截止区亚阈值区或弱反转区cutoff-subthreshold-or-weak-inversion-mode">截止区（亚阈值区或弱反转区）（cutoff, subthreshold or weak-inversion mode）</span></h5><p>当 $|V_{GS}| &lt; |V_{th}|$ 时：</p><p>$|V_{GS}|$ 代表栅极到源极的偏置差(电压差)，$|Vth|$ 为材料的<a href="https://zh.wikipedia.org/wiki/%E9%98%88%E5%80%BC%E7%94%B5%E5%8E%8B">临界电压</a>,也就是上文金氧效应的达到反型时的电压。这个金氧半场效晶体管是处在<a href="https://zh.wikipedia.org/w/index.php?title=%E6%88%AA%E6%AD%A2&amp;action=edit&amp;redlink=1">截止</a>（cut-off）的状态，沟道仍保持P断开状态，并没有足够的多数载流子，电流无法流过这个MOS管，也就是这个MOS管不导通。</p><p>此时MOS的状态如下：</p><p><img src="https://s2.loli.net/2024/09/29/qCg6KDokyGr3zJS.png" alt="image-20220723170543989"></p><p>可以看到指定区域并没有形成可通过区域，而是由基底和掺杂区域形成的耗尽区(depletion region)，此时没有电流可以通过。</p><h5><span id="线性区三极区或欧姆区linear-region-triode-mode-or-ohmic-mode">线性区（三极区或欧姆区）（linear region, triode mode or ohmic mode）</span></h5><p>当 $V_{GS} &gt; V_{th}$ 且 $V_{GD} &gt; V_{th}$ 时：</p><p>此处$V_{DS}$为NMOS漏极至源极的电压，则这颗NMOS为导通的状况，在氧化层下方的沟道也已形成。此时这颗NMOS的行为类似一个压控电阻（voltage-controlled resistor），而由漏极向源极流出的电流大小为：<br>$$<br>I_{D}=\mu_{n} C_{o x} \frac{W}{L}\left(V_{G S}-V_{t h}-\frac{V_{D S}}{2}\right) V_{D S}<br>$$<br>μn是载流子迁移率（carrier mobility）、W是金氧半场效晶体管的栅极宽度、L是金氧半场效晶体管的栅极长度，而<em><strong>Cox</strong></em>则是栅极氧化层的单位电容大小。在这个区域内，MOS管的<strong>电流—电压</strong>关系有一个线性方程式，因而称为线性区。</p><p>当工作在线性区域的时候MOS的解面图如下：</p><p><img src="https://s2.loli.net/2024/09/29/BLX2GFi5xvdzhkK.png" alt="image-20220723173426565"></p><p>可以看到对应区域出现了<strong>反转层</strong>，这时候S和D之间出现了Channel。</p><p>下图展示了NMOS的漏极电流$I_{DS}$与漏极电压之间在不同$V_{GS}-V_{th}$的关系：</p><p><img src="https://s2.loli.net/2024/09/29/dekOVY7QGhT5qcz.png" alt="1"></p><p>可以看到随着$V_{GS}-V_{th}$的变化能通过的电流大小也持续增加，直到某个电压值可通过的电流大小不再变化，这个电压值就是下边要说的<strong>饱和区（放大区）</strong>。</p><h5><span id="饱和区放大区saturation-or-active-mode">饱和区（放大区）（saturation or active mode）</span></h5><p>当 $V_{GS} &gt; V_{th}$ 时$V_GS保持一定$ 且 $V_{GD} &lt; V_{th}$ 时：</p><p>这Mos管为导通的状况，也形成了沟道让电流通过。<strong>但是随着漏极电压(D)增加，超过栅极电压时，会使得接近漏极区的反转层电荷为零</strong>，此处的沟道几乎消失（如下图），这种状况称之为<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%BE%E6%AD%A2&amp;action=edit&amp;redlink=1">夹断</a>（pinch-off）。</p><p><img src="https://s2.loli.net/2024/09/29/pU4ZKYRNrSMsxOP.png" alt="image-20220723181244898"></p><p>这里注意靠近D极的沟道已经消失。下面一张图显示的更加清楚。</p><p><img src="https://s2.loli.net/2024/09/29/XIAEMYyQvZzmhw7.png" alt="image-20220723181410592"></p><p>注意上图的表达式$V_{DS} &gt; V_{GS}- V_{th}$</p><p>同时此时的电压差也可以写为：$V_{DS _ \mathrm{dv}}=V_{\mathrm{GS}}-V_{\mathrm{GSTH}}$</p><p>在这种状况下，由源极出发的载流子（电子）经由沟道到达夹断点时，会被注入漏极周围的空间电荷区（space charge region），再被电场扫入漏极。此时通过金氧半场效晶体管的电流与其漏极—源极间的电压<em>VDS</em>无关，只与栅极电压有关，主要原因在于靠近漏极区的栅极电压已经不足以让沟道反转，而造成所能提供的载流子有限，限制住了沟道的电流大小，关系式如下：<br>$$<br>I_{D}=\frac{\mu_{n} C_{o x}}{2} \frac{W}{L}\left(V_{G S}-V_{t h}\right)^{2}<br>$$<br>上述的公式也是理想状况下，金氧半场效晶体管在饱和区工作的电流与电压关系式。事实上在饱和区的MOS管漏极电流会因为<a href="https://zh.wikipedia.org/w/index.php?title=%E9%80%9A%E9%81%93%E9%95%B7%E5%BA%A6%E8%AA%BF%E8%AE%8A%E6%95%88%E6%87%89&amp;action=edit&amp;redlink=1">沟道长度调制效应</a>而改变，并非与<em>VDS</em>全然无关。考虑沟道长度调制效应之后的饱和区电流—电压关系式如下：<br>$$<br>I_{D}=\frac{\mu_{n} C_{o x}}{2} \frac{W}{L}\left(V_{G S}-V_{t h}\right)^{2}\left(1+\lambda V_{D S}\right)<br>$$<br>我们在这里不考虑MOS的放大作用，优先考虑开关作用，具体等到讲解放大电路的时候再详细考虑。</p><p>下图显示了某个N沟道MOS管的转移特性和输出特性图。</p><img src="https://s2.loli.net/2024/09/29/g43OsM5orQUv2ZK.png" alt="image-20220723220252670" style="zoom:80%;"><p>所谓转移特性指的是在恒定$V_{DS}$的条件下不同$V_{GS}$的电压条件可输出的电流电大小，即对应了上文饱和区的饱和电流，需要强调的是饱和区的时候通道并没有完全夹断，只是因为限制而导致电流大小无法再上升，也就是上图对应的红色部分和左图。</p><p>输出特性图就是右侧的图形，MOS管做开关等应用的时候就是工作在饱和区，通过控制GS在某个数值和0V之间进行切换来让其在导通和不导通之间切换。</p><p>为了方便理解在不同区域的切换，我找到下图：</p><p><img src="https://s2.loli.net/2024/09/29/lghS3NH7f2WwkR1.png" alt="image-20220723224658911"></p><p>其中$V_{\mathrm{DS \underline{}} \mathrm{dv}}=V_{\mathrm{GS}}-V_{\mathrm{GSTH}} $,本质上是上图中红色和右侧图曲线相交的部分。</p><h4><span id="mos管的符号">MOS管的符号</span></h4><p>下图显示了常见的增强型mos的符号。</p><p><img src="https://s2.loli.net/2024/09/29/xQowWtcNJ7lp3zS.png" alt="image-20220723210344580"></p><p>一般我们不讨论耗尽型，下文只讨论增强型。</p><h4><span id="pmos">PMOS</span></h4><img src="https://i-blog.csdnimg.cn/blog_migrate/1fcd69084fe88caf9c1dc2815e506eda.png" alt="image-20220723213430794" style="zoom: 50%;"><p>这个为P沟道的MOS管符号图，根据上文我们知道P沟道的MOS的基极是N型半导体，上图中箭头实际上标明的是体二极管导通的时候，电流的流向，这里就是从D到S。同时GS电压与对应的体二极管导通方向相反，也就是说GS电压小于0的时候才能正常导通。$V_{GS} &lt; 0 $。</p><p>当然有些厂商给的图也很直接，如下图：</p><p><img src="https://s2.loli.net/2024/09/29/XcPO4eCwrUyD1vq.png" alt="image-20220723212941261"></p><p>这种直接表明了对应的二极管，但是这种一般是真的封装了一个二极管进去，并不是体二极管，这里需要注意。</p><h4><span id="nmos">NMOS</span></h4><p>这个为N沟道的MOS管符号图，根据上文我们知道N沟道的MOS的基极是P型半导体,上图中的箭头实际上标明的也是体二极管导通的方向，这里说明就是直接加电压在SD之间就能到导通，当然GS电压满足如下的时候才能实现导通：$V_{GS} &gt; 0 $。</p><img src="https://s2.loli.net/2024/09/29/8hySgmcXkx9LRQT.png" alt="image-20220723213356954" style="zoom:50%;"><p>当然有些厂商给的图也很直接，如下图：</p><p><img src="https://s2.loli.net/2024/09/29/MtxAKz9DSBfEui8.png" alt="image-20220723213304229"></p><p>参考文章：</p><p><a href="http://blog.zy-xcx.cn/?id=101">如何巧用C-V曲线来查Case</a>。</p><p><a href="https://zh.wikipedia.org/wiki/%E9%87%91%E5%B1%AC%E6%B0%A7%E5%8C%96%E7%89%A9%E5%8D%8A%E5%B0%8E%E9%AB%94%E5%A0%B4%E6%95%88%E9%9B%BB%E6%99%B6%E9%AB%94">WIKI百科</a>。</p>]]></content>
      
      
      <categories>
          
          <category> MOSFET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MOSFET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOS管 —— 快速复苏应用笔记[参数与应用篇]</title>
      <link href="/2024/10/21/MOS%E7%AE%A1%20%E2%80%94%E2%80%94%20%E5%BF%AB%E9%80%9F%E5%A4%8D%E8%8B%8F%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0%5B%E5%8F%82%E6%95%B0%E4%B8%8E%E5%BA%94%E7%94%A8%E7%AF%87%5D/"/>
      <url>/2024/10/21/MOS%E7%AE%A1%20%E2%80%94%E2%80%94%20%E5%BF%AB%E9%80%9F%E5%A4%8D%E8%8B%8F%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0%5B%E5%8F%82%E6%95%B0%E4%B8%8E%E5%BA%94%E7%94%A8%E7%AF%87%5D/</url>
      
        <content type="html"><![CDATA[<h1><span id="mos管-快速复苏应用笔记参数与应用篇">MOS管 —— 快速复苏应用笔记[参数与应用篇]</span></h1><img src="https://s2.loli.net/2024/09/29/9rvl76uE4hTnHYO.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727592837206" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><p>此篇内容为MOS管第二篇内容，助你从参数和应用上理解和使用MOS管，此篇内容会随着项目持续更新。</p><!-- toc --><ul><li><a href="#mos%E5%8F%82%E6%95%B0">MOS参数</a><ul><li><a href="#%E6%9C%80%E5%A4%A7%E6%BC%8F%E6%BA%90%E7%94%B5%E5%8E%8B">最大漏源电压</a></li><li><a href="#%E6%9C%80%E5%A4%A7%E6%A0%85%E6%BA%90%E7%94%B5%E5%8E%8B">最大栅源电压</a></li><li><a href="#%E5%AF%BC%E9%80%9A%E7%94%B5%E9%98%BB">导通电阻</a></li><li><a href="#%E8%BF%9E%E7%BB%AD%E6%BC%8F%E6%9E%81%E7%94%B5%E6%B5%81">连续漏极电流</a></li><li><a href="#%E9%97%A8%E6%A7%9B%E7%94%B5%E5%8E%8B">门槛电压</a></li><li><a href="#%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1%E6%9C%80%E5%A4%A7%E9%80%9A%E8%BF%87%E7%94%B5%E6%B5%81">体二极管最大通过电流</a></li></ul></li><li><a href="#nmos">NMOS</a><ul><li><a href="#%E4%BD%8E%E7%AB%AF%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6">低端负载控制</a><ul><li><a href="#%E4%B8%80%E4%B8%AA%E9%9C%80%E8%A6%81%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F%E7%9A%84%E6%9D%A1%E4%BB%B6">一个需要特别注意的条件</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88nmos%E4%B8%8D%E8%83%BD%E5%81%9A%E9%AB%98%E7%AB%AF%E6%8E%A7%E5%88%B6">为什么NMOS不能做高端控制？</a></li><li><a href="#multisim%E7%9A%84%E9%82%AA%E9%97%A8%E4%BB%BF%E7%9C%9F">Multisim的邪门仿真</a></li></ul></li></ul></li><li><a href="#pmos">PMOS</a><ul><li><a href="#%E9%AB%98%E7%AB%AF%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6">高端负载控制</a></li><li><a href="#%E9%98%B2%E5%8F%8D%E6%8E%A5%E7%94%B5%E8%B7%AF">防反接电路</a></li><li><a href="#usb%E4%BE%9B%E7%94%B5%E5%92%8C%E7%94%B5%E6%B1%A0%E5%88%87%E6%8D%A2">USB供电和电池切换</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="mos参数">MOS参数</span></h2><h3><span id="最大漏源电压">最大漏源电压</span></h3><p>$V_{DS}$(最大漏源电压),指的是在栅极和源极之间加上一定的电压，在漏源发生雪崩击穿之前所能施加的最大电压。根据温度不同，实际雪崩电压可能低于额定电压VDSS，所以要留存一定的余量。</p><h3><span id="最大栅源电压">最大栅源电压</span></h3><p>$V_{GS_{(max)}}$(最大栅源电压)，指的是栅极和源极之间可以施加的最大电压。设定该额定电压的主要目的是防止电压过高而导致的栅极氧化层损伤。</p><h3><span id="导通电阻">导通电阻</span></h3><p>$R_{DS_{(on)}}$，指在特定漏极电流下，通常为$I_D$的一半、栅源电压等于门槛电压的时候所测得的导通电阻，这是造成输出电压压降的主要原因。</p><h3><span id="连续漏极电流">连续漏极电流</span></h3><p>$I_D$    其定义是芯片在最大额定结温下TJ（max），管表面温度在25度或者更高温度下可允许流过的最大制流电流，当然这个参数也和$V_{GS}$的大小存在一定的关系，一般Datasheet会明确给出。</p><h3><span id="门槛电压">门槛电压</span></h3><p>$V_{GS_{(th)}}$门槛电压，是指加的栅源电压能使漏极开始有电流，或关断MOSFET时电流消失时的电压，测试的条件（漏极电流，漏源电压，结温）也是有规格的。正常情况下，所有的MOS栅极器件的阙值电压都会有所不同。因此，VGS(th)的变化范围是规定好的。VGS(th)是负温度系数，当温度上升时，MOSFET将会在比较低的栅源电压下开启。</p><h3><span id="体二极管最大通过电流">体二极管最大通过电流</span></h3><p><code>I_s</code>，一般Datasheet中给出的是体二极管最大通过电流，在你需要使用体二极管的时候就需要看一下这个参数的大小，不过一般使用的时候不推荐使用体二极管，因为发热严重。</p><p><img src="https://s2.loli.net/2024/09/29/o1uUCR7DyGIjwLz.png" alt="image-20240929141035794"></p><p>如图此MOS的体二极管就可以通过25A的电流，相对应的$I_D$   大小为：</p><p><img src="https://s2.loli.net/2024/09/29/hETDQNXiIgewCnv.png" alt="image-20240929141603592"></p><p>也是远远超过体二极管所能承受的能力。</p><h2><span id="nmos">NMOS</span></h2><p>这里我们使用AON6884来作为具体的器件，其参数如下：</p><p><img src="https://s2.loli.net/2024/09/29/WOU6munTqhVbcYA.png" alt="image-20220726232031252"></p><p>同时$V_{GS_{(max)}}$(最大栅源电压)如下：</p><p><img src="https://s2.loli.net/2024/09/29/r3dplXPzsWV9LI7.png" alt="image-20240929143944434"></p><p>性能可以说是十分优异。</p><h3><span id="低端负载控制">低端负载控制</span></h3><p>低端负载控制指的并不是负载在低端而是MOS处于负载的低电位，为什么不能处于高电位呢？这个原因我们稍后再讲，这里我们使用电阻替代负载比如直流电机等，让其流过1A的电流，来看看线路上各点的状态。</p><p>电路如下：</p><p>我们通过一个DC10V的电源供电，让后MOS管GS两端的电压是4.5V观察一下电路上各点电压和电流大小。</p><p><img src="https://s2.loli.net/2024/09/29/rVqPfuMblOJHGCN.png" alt="image-20220726231253840"></p><p>我们来测试一下各点的电位：</p><p><img src="https://s2.loli.net/2024/09/29/mBWPUM9gfjdhxzc.png" alt="image-20220726231405589"></p><p>为了方便看到$V_1$点的电位大小我把期数值单独列出来：</p><p><img src="https://s2.loli.net/2024/09/29/mn1MedhKIlzHGFA.png" alt="image-20220726231607659"></p><p>计算出来结果如下：0.013975欧姆。</p><p>这个和手册上的数据几乎完全一致。</p><h4><span id="一个需要特别注意的条件">一个需要特别注意的条件</span></h4><p>需要注意的是我们在做负载开关的时候需要满足一个条件，而不是仅仅让$V_{GS}&gt;V_{GS_{(th)}}$即可，这个条件就是：<br>$$<br>V_{DS} &gt; V_{GS}- V_{th}<br>$$<br>只有满足这个条件才能让MOS工作在横流区，这个公式的本质是这样的：</p><p>当 $V_{GS} &gt; V_{th} $ $V_{GS}保持一定的时候$  $V_{GD} &lt; V_{th}$，更本质上的原因也就是随着漏极电压(D)增加，超过栅极电压时，会使得接近漏极区的反转层电荷为零，此处的沟道几乎消失，详见MOS专栏第一篇。这是MOS工作在恒流区的必要条件。</p><h4><span id="为什么nmos不能做高端控制">为什么NMOS不能做高端控制？</span></h4><p>我们来直接尝试一下一种情况：</p><p><img src="https://s2.loli.net/2024/09/29/8NuxLodpC5DMsBV.png" alt="image-20220726234404848"></p><p>可以看到我们把AON6884，放到高端负载处，把负载电阻放到下边来，我们来看看仿真的结果是什么？</p><p><img src="https://s2.loli.net/2024/09/29/JhWt2ew148ofQD3.png" alt="image-20220726234615240"></p><p>Vin当然还是10V，V2则变成了1.8V左右，整体流过的电流I也变为181ma左右：</p><p><img src="https://s2.loli.net/2024/09/29/RlpJ4ZKuOcEfoVz.png" alt="image-20220726234712792"></p><p>并不是我们常见的说不能导通，而趋向于一种稳定状态但是不是完全导通的，虽然$V_{GS}$电压已经到达了阈值：</p><p><img src="https://s2.loli.net/2024/09/29/SIkdK4NZowU9hF1.png" alt="image-20220726234910918"></p><p>仍处于一种导通但没有完全导通的状态，DS两级之间的电压远大于GS两极之间的电压，理论上来说工作在横流区，但因为导通后s极电压发生变化，处于一种不确定的状态，无法正常工作。</p><h4><span id="multisim的邪门仿真">Multisim的邪门仿真</span></h4><p>这里我们使用BSS214N来作为具体的器件，其参数如下：</p><p><img src="https://s2.loli.net/2024/09/29/IcKeSguRCZkz8Y3.png" alt="image-20220726213039517"></p><p>同时$V_{GS_{(max)}}$(最大栅源电压)如下：</p><p><img src="https://s2.loli.net/2024/09/29/8SmnPWzdVKl9ywT.png" alt="image-20220726213413162"></p><p>电路如下：</p><p>我们通过一个DC10V的电源供电，让后MOS管GS两端的电压是4.5V观察一下电路上各点电压和电流大小。</p><p><img src="https://s2.loli.net/2024/09/29/4GXQMp6AfiTn9jx.png" alt="image-20220726225019224"></p><p>通道A为红色的波形，通道B为橙色的波形：</p><p><img src="https://s2.loli.net/2024/09/29/WrDnBUH8JyXFE45.png" alt="image-20220726223929040"></p><p>可以看到流经MOS管的电流大小是901mA：</p><p><img src="https://s2.loli.net/2024/09/29/PGt1yegw5fmanrZ.png" alt="image-20220726225048245"></p><p>我们先计算出电阻的实际电阻大小为：9.9955欧姆。</p><p>这是因为还存在一定的$R_{DS_{(on)}}$，我们看看手册这里的$R_{DS_{(on)}}$大小是多少：</p><p><img src="https://s2.loli.net/2024/09/29/xNelOI7Xc4T3tnQ.png" alt="image-20220726225822180"></p><p>太离谱了上文计算出来实际内阻1.10321欧姆。我也不知道原因是什么，我怀疑Multisim纯纯垃圾，第一次使用我也找不到原因。</p><h2><span id="pmos">PMOS</span></h2><h3><span id="高端负载控制">高端负载控制</span></h3><p>这里就不再赘述，和NMOS一样，不过他常常作为高端负载控制，而不是低端负载控制，使用时注意即可，当然也要满足MOS工作在恒流区的必要条件。</p><h3><span id="防反接电路">防反接电路</span></h3><p>这里我们使用AON7404来作为具体的器件，其参数如下：</p><p><img src="https://s2.loli.net/2024/09/29/ryK46MCtO1vSaxw.png" alt="image-20220727002308953"></p><p><img src="https://s2.loli.net/2024/09/29/1pnuJyjHG9U8MT3.png" alt="image-20220727002426534"></p><p><img src="https://s2.loli.net/2024/09/29/d5XifLZMClFIe1Q.png" alt="image-20220727002506299"></p><p>下图是采用PMOS的电源防反接的方案。</p><p>原理很简单，采用MOS管防反接的好处在于压降很小，几乎可以忽略不计。现在的工艺可以把MOS管的内阻控制在几个mΩ，假设电流是1A，那么导通压降只有几个mV。</p><p>用PMOS时，上电瞬间MOS管的寄生二极管导通，电源与负载形成回路，所以S极电位就是VBAT-0.6V，而G极电位是0V，此时PMOS管导通，把二极管短路。电源接反时：G极是高电平，PMOS管不导通。保护电路安全。</p><p><img src="https://s2.loli.net/2024/09/29/dWziqUvQTY6SZKj.png" alt="image-20220727135739359"></p><p>仿真的结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/8IWiPtE5LSRAcwG.png" alt="image-20220727140206812"></p><p>可以看到随着电源电压（Vd）增加，VDS两端电压逐渐减小（上图偏粉色的线）很小，只有几乎0.06V，大部分功率都没有消耗在MOS上。MOS的体二极管也没有什么作用。下图显示了两端的压差。</p><p><img src="https://s2.loli.net/2024/09/29/K4txCyBMSfcNVgi.png" alt="image-20220727120045230"></p><p>你可能会问，此时PMOS管导通，把二极管短路？为什么会把二极管短路呢？</p><p>我们知道二极管的本质上是PN结，PN结两端不满足欧姆定律，但是想要二极管导通，就需要有一定的正向偏置电压，所以电源电压增加，当二极管在最初导通的时候打开了MOS，此时GS电压会因为MOS的导通状态自保持，MOS导通后SD两端电压恢复到上图0.06V，此时体二极管无法导通，这里体二极管就相当于做了一个触发动作，触发动作后二极管不再工作。</p><p>下图是未导通的时候MOS的抽象模型。</p><p><img src="https://s2.loli.net/2024/09/29/yvZde2QzHAqoxf4.png" alt="image-20220727135649078"></p><p>，可以看到当R为5欧姆的时候二极管两端电压为：</p><p><img src="https://s2.loli.net/2024/09/29/17NxnJYLyBlFDte.png" alt="image-20220727140612034"></p><p>当二极管导通的时候电阻非常小，只有几毫欧，那么R2可以变化成如下：</p><p><img src="https://s2.loli.net/2024/09/29/yWQYl4jXuHeDbIz.png" alt="image-20220727140755318"></p><p>此时电压变得非常小，电流几乎为0。</p><p><img src="https://s2.loli.net/2024/09/29/to9SPKzIXBrp2Hk.png" alt="image-20220727140850223"></p><p>但是注意到在电压上升阶段还是有电流流过，推测是漏电流。</p><h3><span id="usb供电和电池切换">USB供电和电池切换</span></h3><p>下图展示了我目前做过的最稳定的包含电池充电还有USB供电切换的电路，切换电路一共需要三个MOS，分别是两个PMOS一个NMOS。完整的切换电路如下：</p><p>5V电源代表的是USB电源，4.2V代表的是电池电源。R3是模拟的负载大电流的情况。</p><p><img src="https://s2.loli.net/2024/09/29/Bkeo9LIwlHtAfhu.png" alt="image-20220727235354405"></p><p>如果V1 = 5V，NMOS M1导通，之后拉低了PMOS M3的栅极，然后M1也开始导通(体二极管作用)，此时，M2的栅极跟源极之间的电压为M3的导通压降，该电压差不多为几十mV，因此M2关闭，外部电源V2断开，POWEROUT由V1供电，Vout = 5V。此时整个电路的静态功耗I1+I2 = 10uA左右，此处静态功耗指的是电阻上的电流。</p><p>现在，V1断开了，M1截止，M2的栅极有R1的下拉，所以M2导通，M3的栅极通过R2上拉，所以M3也截止，整个电路，M1跟M3截止，POWEROUT由V2供电，Vout = 4.2V。<strong>此时上面电路I1跟I2的静态功耗不存在。</strong></p><p>一些电路的问题：主备电一直在的时候，M2体二极管是一直通的，所以备电还是在供电？</p><p>错误。因为此时压降非常小，体二极管无法导通，具体电流大小如下：</p><p><img src="https://s2.loli.net/2024/09/29/MS7Oisn3jZoEBF1.png" alt="image-20220728004451034"></p><p>如果上述V2和V1电压大小相同呢？错误。因为此时压降非常小，体二极管无法导通，具体电流大小如下：</p><p><img src="https://s2.loli.net/2024/09/29/PJuKlRU7pseEMzX.png" alt="image-20220728004353456"></p><p>参考资料：<a href="https://blog.csdn.net/karaxiaoyu/article/details/110021989">https://blog.csdn.net/karaxiaoyu/article/details/110021989</a></p>]]></content>
      
      
      <categories>
          
          <category> MOSFET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MOSFET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark快速大数据分析——Spark的安装与介绍（壹）</title>
      <link href="/2024/10/21/Spark(1)/"/>
      <url>/2024/10/21/Spark(1)/</url>
      
        <content type="html"><![CDATA[<h1><span id="spark快速大数据分析spark的安装与介绍壹">Spark快速大数据分析——Spark的安装与介绍（壹）</span></h1><img src="https://s2.loli.net/2024/09/29/TZ9xIe13HbgNAOn.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727611659085" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><h3><span id="软件环境">软件环境：</span></h3><ul><li><strong>Hadoop-3.3.2</strong></li><li><strong>Spark-3.1.3/Spark-3.2.1（sbt pull）</strong></li><li><strong>JDK 11</strong></li><li><strong>Scala 2.13.8/SCala 2.1（搭配3.1.3使用）</strong></li></ul><!-- toc --><ul><li><a href="#spark%E4%BB%8B%E7%BB%8D">Spark介绍</a></li><li><a href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">环境搭建：</a></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="spark介绍">Spark介绍</span></h2><p>来自美国加州大学伯克利分校、具有 Hadoop MapReduce 经验的研究人员接受了挑战， 并推出了 Spark 项目,2009 年，Spark 项目在 RAD 实验室诞生，后来该实验室改名为 AMPLab（现在名叫 RISELab）.</p><p>Spark 项目的中心思想是，借鉴 Hadoop MR 的思想并增强系统，加上高容错性和高并发， 支持将迭代式或交互式映射和归约计算的中间结果存储在内存中，并向用户提供支持多种 语言、简单、易组合的 API 作为编程模型，一站式支持各种使用场景.</p><p>2014 年 5 月，在 Apache 软件基金会的管理下，Databricks 与开源社区的开发人员共同 发布了 Apache Spark 1.0。</p><p>Spark 为中间计算结果提供了基于内存的存储，这让它比 Hadoop MR 快了很多，它整合 了各种上层库，比如用于机器学习的库 MLlib、提供交互式查询功能的 Spark SQL、支持 操作实时数据的流处理库 Structured Streaming，以及图计算库 GraphX，这些库都提供 了易用的 API。</p><p>Spark 的设计哲学围绕下列四大特性展开：</p><p>⚫ 快速 ⚫ 易用 ⚫ 模块化 ⚫ 可扩展</p><h2><span id="环境搭建">环境搭建：</span></h2><p>首先下载Spark：<a href="https://www.apache.org/dyn/closer.lua/spark/spark-3.2.1/spark-3.2.1-bin-hadoop3.2.tgz">Spark下载地址</a></p><p><img src="https://s2.loli.net/2024/09/29/ek2Zd5c3Caswulr.png" alt="1"></p><p>点击下载Spark，如果你网速慢也该可以通过我的gitee来下载。gitee地址：</p><p>下载后直接解压即可：</p><p>我解压位置如下</p><p><img src="https://s2.loli.net/2024/09/29/rqnCYt8WB5eRFpf.png" alt="2"></p><p>然后添加系统环境变量：</p><p><img src="https://s2.loli.net/2024/09/29/54uJ8Emza3UwxMl.png" alt="3"></p><p>spark的运行需要Hadoop的支持，所以还需要下载Hadoop来支持运行:</p><p><a href="https://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-3.2.2/hadoop-3.2.2.tar.gz">Hadoop下载地址</a></p><p>也是压缩包需要注意的是<strong>解压需要提供管理员权限</strong>。</p><p>解压完后添加环境变量和系统变量。</p><p><img src="https://s2.loli.net/2024/09/29/vTiX37cSNG8PZWU.png" alt="4"></p><p>新建一个系统变量：</p><p><img src="https://s2.loli.net/2024/09/29/ZyAdfUJjQgvICPo.png" alt="5"></p><p>到这里还没有完，如果你是win环境下开发可能会遇到报错：</p><pre><code class="language-shell">C:\spark-3.2.0-bin-hadoop3.2\bin&gt;spark-shellUsing Spark's default log4j profile: org/apache/spark/log4j-defaults.propertiesSetting default log level to "WARN".To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).21/11/11 00:14:24 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable21/11/11 00:14:26 ERROR SparkContext: Error initializing SparkContext.java.lang.reflect.InvocationTargetException        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)        at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source)        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source)        at java.lang.reflect.Constructor.newInstance(Unknown Source)        at org.apache.spark.executor.Executor.addReplClassLoaderIfNeeded(Executor.scala:909)        at org.apache.spark.executor.Executor.&lt;init&gt;(Executor.scala:160)        at org.apache.spark.scheduler.local.LocalEndpoint.&lt;init&gt;(LocalSchedulerBackend.scala:64)        at org.apache.spark.scheduler.local.LocalSchedulerBackend.start(LocalSchedulerBackend.scala:132)        at org.apache.spark.scheduler.TaskSchedulerImpl.start(TaskSchedulerImpl.scala:220)        at org.apache.spark.SparkContext.&lt;init&gt;(SparkContext.scala:581)        at org.apache.spark.SparkContext$.getOrCreate(SparkContext.scala:2690)        at org.apache.spark.sql.SparkSession$Builder.$anonfun$getOrCreate$2(SparkSession.scala:949)        at scala.Option.getOrElse(Option.scala:189)        at org.apache.spark.sql.SparkSession$Builder.getOrCreate(SparkSession.scala:943)        at org.apache.spark.repl.Main$.createSparkSession(Main.scala:106)        at $line3.$read$$iw$$iw.&lt;init&gt;(&lt;console&gt;:15)        at $line3.$read$$iw.&lt;init&gt;(&lt;console&gt;:42)        at $line3.$read.&lt;init&gt;(&lt;console&gt;:44)        at $line3.$read$.&lt;init&gt;(&lt;console&gt;:48)        at $line3.$read$.&lt;clinit&gt;(&lt;console&gt;)        at $line3.$eval$.$print$lzycompute(&lt;console&gt;:7)        at $line3.$eval$.$print(&lt;console&gt;:6)        at $line3.$eval.$print(&lt;console&gt;)        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)        at java.lang.reflect.Method.invoke(Unknown Source)</code></pre><p>但没关系，我帮你踩坑了~</p><p>只需要按照对应版本进行下载然后替换bin目录下的内容即可：</p><p><img src="https://s2.loli.net/2024/09/29/fjqKRNx1EAJolit.png" alt="6"></p><p>在任意地方打开cmd：</p><p>输入 <code>spark-shell</code>。等待一会：</p><p><img src="https://s2.loli.net/2024/09/29/rNwTsqxPOpjaQUg.png" alt="7"></p><p>引用一个库看一看：</p><p><img src="https://s2.loli.net/2024/09/29/oXjItYQMHPTg182.png" alt="8"></p><p>如果正常恭喜你完成了80%，这些都是基于命令行的，可是我们要基于IDEA要怎么开发呢？</p><p>首先idea支持的构建方式首选的是SBT，如果你没有安装sbt可以参考上一篇文章：。</p><p>打开IDEA新建一个项目：</p><p><img src="https://s2.loli.net/2024/09/29/UYdgWDZ7sPJ5vxe.png" alt="10"></p><p>系统会自动检测你的安装的SBT和SCALA</p><p><img src="https://s2.loli.net/2024/09/29/9MeCT6stk41SoKu.png" alt="11"></p><p>在创建完成后在<strong>build.sbt</strong>中添加如下代码：</p><pre><code class="language-scala">libraryDependencies += "org.apache.spark" % "spark-core_2.12" % "3.1.3"</code></pre><p><img src="https://s2.loli.net/2024/09/29/FgXOuxQjInt8E6e.png" alt="12"></p><p>如果你在MVN找到的sbt依赖添加代码是这样的：</p><pre><code class="language-scala">libraryDependencies += "org.apache.spark" %% "spark-core" % "3.1.3"</code></pre><p>或者是这样的：</p><pre><code class="language-scala">libraryDependencies += "org.apache.spark" % "spark-core" % "3.1.3"//这个是错的 %% 才能自动指定scala版本</code></pre><p>有可能会报错：</p><p><img src="https://s2.loli.net/2024/09/29/uLREd4FMxb3mSKD.png" alt="14"></p><p>没关系更改一下版本就可以：</p><pre><code class="language-Scala">libraryDependencies += "org.apache.spark" %% "spark-core" % "3.2.1"</code></pre><p><img src="https://s2.loli.net/2024/09/29/AytSj9mwcUZevbz.png" alt="16"></p><p>如果更改版本还没办法的话可以指定一下版本：</p><pre><code class="language-scala">libraryDependencies += "org.apache.spark" % "spark-core_2.12" % "3.1.3"</code></pre><p><img src="https://s2.loli.net/2024/09/29/GmFXyJCrU9clvsh.png" alt="17"></p><p>但是你如过不太清楚构建spark的scala和你本地的scala是否匹配的话建议还是用“%%”来自动匹配版本：</p><p>否则就会报错：</p><pre><code class="language-shell">Exception in thread "main" java.lang.NoSuchMethodError: 'void scala.util.matching.Regex.&lt;init&gt;(java.lang.String, scala.collection.Seq)'at scala.collection.immutable.StringLike.r(StringLike.scala:284)at scala.collection.immutable.StringLike.r$(StringLike.scala:284)at scala.collection.immutable.StringOps.r(StringOps.scala:33)at scala.collection.immutable.StringLike.r(StringLike.scala:273)at scala.collection.immutable.StringLike.r$(StringLike.scala:273)at scala.collection.immutable.StringOps.r(StringOps.scala:33)at org.apache.spark.util.Utils$.&lt;init&gt;(Utils.scala:105)at org.apache.spark.util.Utils$.&lt;clinit&gt;(Utils.scala)at org.apache.spark.SparkConf.loadFromSystemProperties(SparkConf.scala:75)at org.apache.spark.SparkConf.&lt;init&gt;(SparkConf.scala:70)at org.apache.spark.SparkConf.&lt;init&gt;(SparkConf.scala:59)at com.demo.test$.main(test.scala:8)at com.demo.test.main(test.scala)</code></pre><p>这里给一段测试代码，如果报错了你就要更换spark版本：</p><pre><code class="language-Scala">package com.demoimport org.apache.spark.{SparkConf, SparkContext}object test{  def main(args: Array[String]): Unit = {    val conf = new SparkConf().setMaster("local").setAppName("HelloWorld")    val sc = new SparkContext(conf)    val helloWorld = sc.parallelize(List("Hello,World!","Hello,Spark!","Hello,BigData!"))    helloWorld.foreach(line =&gt; println(line))  }}</code></pre><p><strong>如果没问题,环境就搭建好了！</strong></p><p>但是你会有个疑问：</p><p>为什么我都本地下载了Spark，还需要下载托管的Spark？</p><p>这是我刚开始的疑问，SBT不能同时管理本地的jar包吗？必须重新下载后才能管理本地内容吗？</p><p>通过SBT手动添加JAR包是可以的，但是有点复杂 而且需要添加多个才能使用，所以这里推荐另一个模式来构建项目：</p><p>我们来利用IDEA本身的管理来构建Scala项目，在创建栏选择IDEA：</p><p><img src="https://s2.loli.net/2024/09/29/ycEgDveXbSGrUk5.png" alt="27"></p><p>后面都是一样的，这里主要讲解一下如何导入本地Spark实现项目构建：</p><p>选择对应选项卡：</p><p><img src="https://s2.loli.net/2024/09/29/ca5CkueJMHloYKp.png" alt="19"></p><p>在<strong>Golobal Libraries</strong>用+添加<strong>Spark</strong>：</p><p><img src="https://s2.loli.net/2024/09/29/k2HflTMyoFxDPCz.png" alt="20"></p><p>选择java选项：</p><p><img src="https://s2.loli.net/2024/09/29/VNUO9b8KTygkjfZ.png" alt="21"></p><p>找到自己Spark安装的：</p><p><img src="https://s2.loli.net/2024/09/29/g1yukNYvUhw54cH.png" alt="22"></p><p>点击OK：</p><p><img src="https://s2.loli.net/2024/09/29/N9vx4PKXlnIijt6.png" alt="23"></p><p>如果出现<strong>Problems</strong>点击一下<strong>Fix</strong>，选择添加到依赖修复即可：</p><p><img src="https://s2.loli.net/2024/09/29/1M7RGnXlYAIqsmL.png" alt="26"></p><p>在外部库中可以看见<strong>jars</strong>，并且可以引用<strong>Spark</strong>：</p><p><img src="https://s2.loli.net/2024/09/29/98toWZRAE4NTKw2.png" alt="28"></p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
          <category> Hadoop </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> Hadoop </tag>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bionet_WIFI使用指南</title>
      <link href="/2024/09/29/Bionet_WiFi/"/>
      <url>/2024/09/29/Bionet_WiFi/</url>
      
        <content type="html"><![CDATA[<h1><span id="bionet_wifi使用指南">Bionet_WIFI使用指南</span></h1><img src="https://s2.loli.net/2024/09/29/yhNMvJ21PrfqVOk.jpg" alt="使用指南" style="zoom:67%;"><!-- toc --><ul><li><a href="#%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%9A%84%E7%9C%9F%E5%AE%9Emac%E5%9C%B0%E5%9D%80">获取本机的真实MAC地址</a><ul><li><a href="#pc%E8%AE%BE%E5%A4%87">PC设备：</a></li><li><a href="#android%E8%AE%BE%E5%A4%87">Android设备：</a></li><li><a href="#ios%E8%AE%BE%E5%A4%87">IOS设备：</a></li></ul></li></ul><!-- tocstop --><p>适用对象：文宣楼A406课题组成员</p><p>A406房间包含两个独立的路由器，分别有1000Mb的带宽。</p><p>其SSID（名字）如下：</p><img src="https://s2.loli.net/2024/05/12/HDXRUkAf2tINVlp.png" alt="image-20240512112431863.png" style="zoom: 67%;"><p>使用的时候，应选择排名比较靠前的WIFI使用，越靠前来说信号越好，速度越快。</p><h2><span id="获取本机的真实mac地址">获取本机的真实MAC地址</span></h2><p>路由器开启了连接管控，可以找谭然、或者我来执行绑定和连接。设备绑定依赖于本机的真实MAC地址。首先要获取设备的真实MAC地址，获取方法如下：</p><h3><span id="pc设备">PC设备：</span></h3><p>获取本机MAC地址</p><p>在设置中查找MAC：</p><img src="https://s2.loli.net/2024/05/11/1IlVejHObDtQ6oE.png" alt="image-20240511182342670.png" style="zoom: 67%;"><p>点击：</p><img src="https://s2.loli.net/2024/09/29/SAQXCqUmkYhjteF.png" alt="image-20240928171559953" style="zoom: 67%;"><p>关闭随机硬件MAC地址：</p><img src="https://s2.loli.net/2024/05/11/OFXSioyE2GUqvhW.png" alt="image-20240511182513806.png" style="zoom:67%;"><p>点击：</p><img src="https://s2.loli.net/2024/05/12/ULCXqEJRFigHPmz.png" alt="image-20240511182756107.png" style="zoom:67%;"><p>然后记录下此信息：</p><img src="https://s2.loli.net/2024/05/12/zKdChegHlj5PfuY.png" alt="image-20240511182816689.png" style="zoom:80%;"><p>以如下格式发送给我：</p><pre><code class="language-shell">设备名称：neo_phone (姓名_设备名称)MAC地址：填入MAC地址</code></pre><p>然后即可继续连接。</p><h3><span id="android设备">Android设备：</span></h3><p>以荣耀设备为例子：</p><p>打开设备设置管理界面：</p><img src="https://s2.loli.net/2024/05/11/hJEzybCkvB7SfqP.png" alt="image-20240511183320386.png" style="zoom:67%;"><p>在上方搜索栏搜索：MAC</p><p>选择：</p><img src="https://s2.loli.net/2024/05/11/3oHQGbsweR1YINL.png" alt="image-20240511183449726.png" style="zoom:50%;"><p>将此内容截图发给我：</p><img src="https://s2.loli.net/2024/05/11/WbVSzdspKXocCL9.png" alt="image-20240511183526491.png" style="zoom: 80%;"><p>等我添加信息之后，选择对应的WIFI连接：</p><p>连接时选择高级选项，将随机MAC地址修改成使用设备MAC：</p><img src="https://s2.loli.net/2024/05/11/QaoEg38j5WfxNYH.png" alt="image-20240511183602054.png" style="zoom:67%;"><img src="https://s2.loli.net/2024/05/11/92ESIyW4pxHRz1j.png" alt="image-20240511183706756.png" style="zoom: 50%;"><p>输入密码连接即可，等我添加完成设备之后就可以上网了。</p><h3><span id="ios设备">IOS设备：</span></h3><p>IOS设备需要先连接到WIFI，点击对应WIFI右侧的感叹号，查看MAC地址信息：</p><pre><code class="language-shell">设备名称：neo_ipad/iphone/MAC (姓名_设备名称)MAC地址：填入MAC地址</code></pre><img src="https://s2.loli.net/2024/05/11/YbuERIdAP4XhZOy.png" alt="image-20240511185628123.png" style="zoom:67%;"><p>连接之后会提示无法上网，问题不大，关闭自己的私有MAC地址：</p><img src="https://s2.loli.net/2024/05/11/FnKaXR76Tm2fpPu.png" alt="image-20240511184700751.png" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> Bionet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bionet </tag>
            
            <tag> A406 </tag>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAS服务器使用说明</title>
      <link href="/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1><span id="nas服务器使用说明">NAS服务器使用说明</span></h1><img src="https://s2.loli.net/2024/09/29/F4JzXvoRg5kuWin.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727547916644" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><p>Version:1.0</p><p>Date: 2024.04.23</p><p>Authors：Tr，NeoNeuxs</p><!-- toc --><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A6%81%E6%B1%82">基本的网络要求</a></li><li><a href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">目录结构</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E6%9D%A5%E4%B8%8A%E4%BC%A0%E5%86%85%E5%AE%B9">如何建立映射来上传内容</a></li><li><a href="#%E4%B8%8A%E4%BC%A0%E5%86%85%E5%AE%B9%E6%B2%A1%E6%9C%89%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E">上传内容没有及时更新该怎么办？</a></li><li><a href="#%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99">一些使用规则</a></li><li><a href="#%E4%B8%8A%E4%BC%A0%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8">上传之后如何在服务器上使用</a></li><li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</a><ul><li><a href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">一些基础知识</a></li><li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-1">最佳实践</a></li></ul></li></ul><!-- tocstop --><h2><span id="基本的网络要求">基本的网络要求</span></h2><p>网络要求需要在校园网中，在校园网外需要使用VPN来进行上传。上传文件的速度取决于你的链接速度，推荐使用网线上传。</p><p>为什么我的网速很慢？打开校园网链接信息，网线连接的用户，一般不用考虑这个问题，此处可以跳过。</p><img src="https://s2.loli.net/2024/04/23/CWBdyLkx72UXKna.png" alt="image-20240423215045985" style="zoom:67%;"><p>查看连接信息：</p><img src="https://s2.loli.net/2024/04/23/S2b6eO89k7hdFAH.png" alt="image-20240423215142791" style="zoom:80%;"><p>应连接到5HZ频段，2.4Ghz频段速度较低，较慢的情况如下：</p><img src="https://s2.loli.net/2024/04/23/8G6U7LedFmag9z4.png" alt="image-20240423215305320" style="zoom:67%;"><p>**72Mbps相当于10M左右的网速，如果上传100GB的数据那就需要100*1000/10 = 10000s，也就是2.78个小时才能完成上传。**所以使用的时候请注意。</p><p>如何从2.4Ghz切换到5Ghz？首先电脑支持5Ghz频段才能使用，2.4Ghz频段切换方法如下：</p><p><img src="https://s2.loli.net/2024/04/23/j2pdsZQyIFPi7C8.png" alt="image-20240423215639861"></p><p>点击<strong>断开连接</strong>后再次点击连接就能查看所连接的信息是否改变，没有改变的情况下，多次尝试即可。</p><h2><span id="目录结构">目录结构</span></h2><p><img src="https://s2.loli.net/2024/04/24/9Yz6UONRdgisnwT.png" alt="image-20240424234753210"></p><p>第一级目录存放了两个文件夹，分别是我个人的用户文件夹，<strong>公用的数据文件夹Dataset</strong>，一般要求如下：</p><p><img src="https://s2.loli.net/2024/04/24/T1PUYLxzKVSsNkl.png" alt="image-20240424235033899"></p><h2><span id="如何建立映射来上传内容">如何建立映射来上传内容</span></h2><p>1.打开我的电脑，并在左侧右击“此电脑”，然后点击“映射网络驱动器”。</p><p><img src="https://s2.loli.net/2024/04/23/zVMEx1q9O4QJt2m.png" alt="image-20240423202540683"></p><p>2.弹出弹窗，点击“连接到可用于存储文档和图片的网站”。</p><p><img src="https://s2.loli.net/2024/04/23/A1ihgnZuxBNJY97.png" alt="image-20240423203018882"></p><p>3.点两次下一步。</p><p><img src="https://s2.loli.net/2024/04/23/QjiskIncw7T9E4G.png" alt="image-20240423203100159"></p><p><img src="https://s2.loli.net/2024/04/23/O1yt4lv8H95XdWn.png" alt="image-20240423203212778"></p><p>4.输入Internet地址或网络地址：</p><pre><code>ftp://10.26.58.111</code></pre><p><img src="https://s2.loli.net/2024/04/23/s981hadbKNUWYJr.png" alt="image-20240423203455064"></p><p>5.一定记得<strong>取消匿名登录</strong>！！输入用户名“bionet"。</p><p><img src="https://s2.loli.net/2024/04/23/NnB3aCoSYVpLDzy.png" alt="image-20240423203635552"></p><p><img src="https://s2.loli.net/2024/04/23/heH3M2NxyAZXmUf.png" alt="image-20240423203732896"></p><p>6.给你这个网络位置起一个名字，这里自己起一个方便自己标识的名字就行，这里我起名叫做bionet-tr。</p><p><img src="https://s2.loli.net/2024/04/23/rXPga2uA43iMG8W.png" alt="image-20240423204219721"></p><p>7.输入密码之后，密码详见群内信息，完成。</p><p><img src="https://s2.loli.net/2024/04/23/GUFsW2z6jOCyVxH.png" alt="image-20240423204302462"></p><p>8.使用。此时“我的电脑”会出现以下网络连接图标，点击图标进入。此时就可以通过拖拽进行数据上传了。</p><p><img src="https://s2.loli.net/2024/04/23/1DqclYEfFA2Jpia.png" alt="image-20240423204424138"></p><p><img src="https://s2.loli.net/2024/04/23/tnK86qs74ToNxZD.png" alt="image-20240423204739094"></p><h2><span id="上传内容没有及时更新该怎么办">上传内容没有及时更新该怎么办？</span></h2><p>映射之后，我们打开：</p><p><img src="https://s2.loli.net/2024/04/23/THoBR5P9wdnQmK7.png" alt="image-20240423214856217"></p><p>点击刷新即可：</p><p><img src="https://s2.loli.net/2024/04/23/3W4yhu2RpxQgZd7.png" alt="image-20240423214906566"></p><h2><span id="一些使用规则">一些使用规则</span></h2><p>由于FTP权限管理比较薄弱，各位拥有的权限都比较高，所以请将较大的数据集放入Dataset文件夹：</p><p>再强调一遍！请将对应的数据放到Dataset文件夹，按照以下命名规则：</p><p><code>使用者姓名__数据集名__版本</code>。举个例子：</p><p><img src="https://s2.loli.net/2024/04/23/ySpLnWN9D3VewUu.png" alt="image-20240423220546039"></p><p><strong>需要强调的是，v是小写，<code>_</code>是英文下划线，一个即可。</strong></p><p><strong>创建之后没有及时显示，请刷新即可</strong>。</p><p>私人文件请放入上一层，以自己名字命名的文件夹下，请创建自己的文件夹如图所示：</p><img src="https://s2.loli.net/2024/04/23/x59UIvJ81hN7HmY.png" alt="image-20240423220213345" style="zoom:67%;"><p><strong>创建之后没有及时显示，请刷新即可</strong>。</p><h2><span id="上传之后如何在服务器上使用">上传之后如何在服务器上使用</span></h2><p>该NAS服务器映射在原来服务器的/home/Data_NAS/路径下。进入该路径即可看到所有上传的数据。</p><img src="https://s2.loli.net/2024/04/23/ZcW8fD2J1u6gib5.png" alt="image-20240423205229731" style="zoom:80%;"><img src="https://s2.loli.net/2024/04/23/BARezykG3fYimQ2.png" alt="image-20240423205433620" style="zoom:80%;"><h2><span id="最佳实践">最佳实践</span></h2><h3><span id="一些基础知识">一些基础知识</span></h3><p>下图展示了存储配置的全部架构：</p><pre class="mermaid">graph LR;    A["容器(最高权限)"]     B["服务器主机A"]    F["服务器主机B(待建设)"]    C["NAS(网络附加存储)"]    D["你的本地电脑"]    E["外部网盘"]            A--"Datasets文件夹依赖于"---&gt;C    A--"运行依赖于"---&gt;B    A--"运行依赖于"---&gt;F    B--"Datasets文件夹依赖于"---&gt;C    F--"Datasets文件夹依赖于"---&gt;C    A--"NCZone、R_Share、P_Share文件夹直接存在于"---&gt;B    D =="Bionet(Datasets)文件夹依赖于"==&gt;C    D--"连接运行"---&gt;A    E--"数据"--&gt;D</pre><p>在这里再次对主机（服务器主机）上存在的文件解释一下：</p><p>主机上的文件存储由这样的硬盘空间组成的,分为高速、中速、低速区。顾名思义，每个区域速度不同，速度不同的同时稳定性也存在一定的差异，稳定性和速度正好相反：</p><p><code>Data_NAS(Datasets) &gt; Samsung 860evo 512G  &gt; GLOWAY YCQ4TNVMe-M.2</code></p><p>其中每一条格式如下：[分区名、挂载路径、分区大小]</p><pre class="mermaid">graph TB;  subgraph HighSpeed  nvme0n1("nvme0n1:GLOWAY YCQ4TNVMe-M.2")  nvme0n1 --&gt; nvme0n1p1("nvme0n1p1,[/home],2.5T")  nvme0n1 --&gt; nvme0n1p2("nvme0n1p2,[/],1T")  nvme0n1 --&gt; nvme0n1p3("nvme0n1p3,[swap],256G")  nvme0n1 --&gt; nvme0n1p4("nvme0n1p4,[/var],128G")  nvme0n1 --&gt; nvme0n1p5("nvme0n1p5,[/opt],128G")  nvme0n1 --&gt; nvme0n1p6("nvme0n1p6,[/tmp],50G")  end  HighSpeed --&gt; MiddleSpeed  subgraph MiddleSpeed  sda("sda:Samsung 860evo 512G")  sda --&gt; sda1["sda1,[/boot/efi],500MB"]  sda --&gt; sda2["sda2,[/boot],1GB"]  sda --&gt; empty["docker lvm[/var/lib/docker] 400G"]  end  MiddleSpeed --&gt; LowSpeed  subgraph LowSpeed  NAS --&gt; NFS1(NFS,/home/Data_NAS,16T)  NAS --&gt; NFS2(NFS,/home/Datasets,16T)  end</pre><p>这其中包含了共享文件夹和用户文件夹，如图共享文件夹使用红框标注，用来传递文件</p><p><img src="https://s2.loli.net/2024/05/13/hMrBjZOIpcC5Fgv.png" alt="image-20240513230049068"></p><p>一共包含五个文件夹：</p><ul><li><p>Datasets文件夹是用来放置公用数据集的，其命名需要遵循以下方式：<code>上传者_数据集名称_上传日期</code>。</p><ul><li>此文件夹使用详见：<a href="http://10.26.58.109/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">NAS服务器使用说明</a></li></ul></li><li><p>Data_NAS是直接连接到NAS的文件夹，其目录内容与Datasets保持一致，但是二者物理通道不同（挂载在不同的IP），使用起来是一模一样的。</p></li><li><p>PastData文件夹是过去硬盘中的所有数据，在三个月后将会自动删除，各位及时使用。【现在已经删除】</p></li><li><p>NCZone文件夹是没有做任何保护的文件夹，用户随时可写可删除，使用的时候需要小心删除，并避免写冲突问题（多人对同一个文件修改），其不被多个服务器所共享，<strong>只保存在No1或者No2服务器上</strong>。</p></li><li><p>Some_scripts文件夹使用分享一个shell脚本的，用来管理系统方便的，使用需要管理员权限。</p></li><li><p>SoftWares文件夹比较特殊：</p></li></ul><p><img src="https://s2.loli.net/2024/04/01/dXxH8ARVvPUEf6r.png" alt="image-20240401205431946"></p><p>里面包含了P_Share和R_Share,分别挂载到了对应的容器用来分享文件，容器使用的时候只可读，部分情况下可以写入，如果报错则说明无法写入（处于权限和安全考虑这样设置的），需要通过桌面用户来写入文件。</p><p>P代指python容器，R代指R语言容器的存储空间。</p><h3><span id="最佳实践">最佳实践</span></h3><p>简化后的路径当中红色的路径为推荐的上传数据集的方式：</p><img src="https://s2.loli.net/2024/10/21/mZun6qNW3tvPTKB.png" alt="image-20241021232145477" style="zoom:80%;"><p>代码等数据集合比较小的可以直接上传：</p><p><img src="https://s2.loli.net/2024/10/21/y6vCgVmNFjOHD4T.png" alt="image-20241021234950722"></p><p>对于R容器，建议直接使用R_Share或者NCZone,可以考虑如下路径：</p><p><img src="https://s2.loli.net/2024/10/21/naqj2KiNpMvyzoP.png" alt="image-20241021235340468"></p><p>Matlab使用路径同其他。</p>]]></content>
      
      
      <categories>
          
          <category> Bionet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bionet </tag>
            
            <tag> NAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算放大器  ——  快速复苏笔记（参数篇）</title>
      <link href="/2024/09/28/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%20%20%E2%80%94%E2%80%94%20%20%E5%BF%AB%E9%80%9F%E5%A4%8D%E8%8B%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8F%82%E6%95%B0%E7%AF%87%EF%BC%89/"/>
      <url>/2024/09/28/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%20%20%E2%80%94%E2%80%94%20%20%E5%BF%AB%E9%80%9F%E5%A4%8D%E8%8B%8F%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8F%82%E6%95%B0%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="运算放大器-快速复苏笔记参数篇">运算放大器  ——  快速复苏笔记（参数篇）</span></h1><img src="https://s2.loli.net/2024/09/29/9ENzmw4Y8j7O1sQ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727599770846" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><!-- toc --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8">什么是运算放大器：</a></li><li><a href="#%E8%99%9A%E7%9F%AD%E4%B8%8E%E8%99%9A%E6%96%AD">虚短与虚断：</a><ul><li><a href="#%E6%80%BB%E7%BB%93">总结：</a></li></ul></li><li><a href="#%E8%BF%90%E6%94%BE%E7%9A%84%E5%8F%82%E6%95%B0">运放的参数：</a><ul><li><a href="#1-%E8%BE%93%E5%85%A5%E7%94%B5%E5%8E%8Bsupply-voltage">1、输入电压（Supply voltage）</a></li><li><a href="#2-%E8%BE%93%E5%85%A5%E5%81%8F%E7%BD%AE%E7%94%B5%E6%B5%81input-bias-current">2、输入偏置电流（Input Bias Current）</a></li><li><a href="#3-%E5%99%AA%E5%A3%B0vn">3、噪声（Vn）</a></li><li><a href="#4-%E9%9D%99%E6%80%81%E7%94%B5%E6%B5%81iq">4、静态电流（Iq）</a></li><li><a href="#5-%E8%BE%93%E5%85%A5%E5%A4%B1%E8%B0%83%E7%94%B5%E5%8E%8Bvos-input-offset-voltage">5、输入失调电压（Vos / Input  Offset Voltage）</a></li><li><a href="#6-%E5%A2%9E%E7%9B%8A%E5%B8%A6%E5%AE%BD%E7%A7%AFgbw-gbp">6、增益带宽积（GBW \GBP）</a></li><li><a href="#7-%E7%94%B5%E5%8E%8B%E8%BD%AC%E6%8D%A2%E9%80%9F%E7%8E%87-%E5%8E%8B%E6%91%86%E7%8E%87slew-rate">7、电压转换速率 /压摆率（Slew Rate）</a></li><li><a href="#8-%E8%BE%93%E5%85%A5%E7%94%B5%E5%8E%8B%E8%8C%83%E5%9B%B4-%E5%85%B1%E6%A8%A1%E8%BE%93%E5%85%A5%E7%94%B5%E5%8E%8B%E8%8C%83%E5%9B%B4input-voltage-range">8、输入电压范围 \ 共模输入电压范围（Input Voltage range）</a></li><li><a href="#9-%E8%BE%93%E5%87%BA%E7%94%B5%E5%8E%8B%E8%8C%83%E5%9B%B4onput-voltage-range">9、输出电压范围（Onput Voltage range）</a></li><li><a href="#10-%E7%9F%AD%E8%B7%AF%E7%94%B5%E6%B5%81-isc">10、短路电流 （$Isc$）</a></li><li><a href="#11-%E8%BE%93%E5%85%A5%E9%98%BB%E6%8A%97impedance-resistance">11、输入阻抗（impedance ， resistance）</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="什么是运算放大器">什么是运算放大器：</span></h2><p>运算放大器(Operational Amplifier)是一种<strong>差分放大器</strong>，具有<strong>高输入电阻</strong>、<strong>低输出电阻</strong>、<strong>高开放增益（开环增益）</strong>，并具有可放大+输入引脚与-输入引脚间的电压差的功能。每个电路由、<strong>负侧电源引脚</strong>、<strong>+输入引脚</strong>、<strong>-输入引脚</strong>、**输出引脚 **等5个引脚构成。</p><p><img src="https://s2.loli.net/2024/09/29/yL1cIY7kGOmD9wz.jpg" alt="运放原理图"></p><p><img src="https://s2.loli.net/2024/09/29/CvZ5IcdOEeyLafQ.jpg" alt="运算放大器的电源引脚名称示例"></p><h2><span id="虚短与虚断">虚短与虚断：</span></h2><p>电压放大模型：</p><p><img src="https://s2.loli.net/2024/09/29/1vsaVly5g946SQD.jpg" alt="电压控制电压源放大器模型"></p><p>上图Vo满足如下关系式：</p><p><img src="https://s2.loli.net/2024/09/29/dDxnUA4WjGb2ZqX.png" alt="公式"></p><p>信号电压 <strong>Vi</strong> 是通过电阻分压<strong>Vs</strong>由信号源电阻 <strong>Rs</strong> 和运算放大器的输入电阻 <strong>Ri</strong> 分压而得，因此衰减的信号被输入运算放大器。但是，当 <strong>Ri</strong> 远远大于 <strong>Rs</strong>( <strong>Ri</strong> = <strong>∞</strong> ) 时，公式的第1项可视作近似于1、即<strong>Vs=Vi</strong>。</p><p>关于公式的另一个分数项，放大了的输入电压<strong>AvVi</strong> 被运算放大器的输出电阻 <strong>Ro</strong> 和负载电阻 <strong>RL</strong> 分压输出。此时，当 <strong>Ro</strong> 远远小于<strong>RL(Ro=0)</strong> 时，第2项可近似于1，信号可在不衰减的状态下输出。满足以上条件的的运算放大器被称为理想运算放大器。</p><p>上式子就转化成了下式：<br>$$<br>Vo = Av * Vs<br>$$<br>举个例子：</p><p><img src="https://s2.loli.net/2024/09/29/XExbzDn4GgZVwcF.jpg" alt="电压跟随电路"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/14/80da1d53d3b964b5.png" alt="公式"></p><p>当运算放大器的开放增益$Av$足够大时，可视为左边近似于 0 、$Vs=VOUT$ 。增益较低时，公式左边不可近似于 0，这样，输出电压会发生误差。之所以希望运算放大器有高开放增益，是因为通过该增益可尽量缩小输出电压误差。高开放增益从其他角度来看，意味着应尽量减小+输入引脚和-输入引脚间的电位差。</p><p>即开环增益越大，<strong>VIN+=VIN-</strong> 的关系成立的可能性就越大。该+输入引脚和-输入引脚的电位基本相等的关系被称为<strong>虚短</strong> 或 <strong>虚拟接地</strong>。构成负反馈电路使用时，该关系成立，可利用虚拟接地的特性设计应用电路。</p><h3><span id="总结">总结：</span></h3><p><strong>对于理想放大器：</strong></p><p><strong>虚短，满足如下条件：</strong><br>$$<br>Vin _ + = Vin _ -<br>$$<br><strong>虚断：</strong><br>$$<br>Iin _ + = Iin _ - = 0<br>$$</p><h2><span id="运放的参数">运放的参数：</span></h2><h3><span id="1-输入电压supply-voltage">1、输入电压（Supply  voltage）</span></h3><p><strong>AD8605</strong>、<strong>AD8606</strong>系列：</p><img src="https://s2.loli.net/2024/09/29/nlXfwH4gAjoLs8y.png" alt="输入电压范围" style="zoom:80%;"><p>OPA228:</p><img src="https://s2.loli.net/2024/09/29/QVRaJfZxB4vpLy1.png" alt="OPA228" style="zoom:80%;"><p>双电源供电减半最高电压，选型时保持一定裕量防止烧毁。</p><h3><span id="2-输入偏置电流input-bias-current">2、输入偏置电流（Input Bias Current）</span></h3><p>在满足虚断的条件下 $I_B$ 的大小称为偏置电流：</p><p>满足如下关系：<br>$$<br>I_B = (Iin_+ + Iin_- )/2<br>$$<br>定义为<strong>两个输入端流进电流的平均值</strong>，此参数越小越好。一般用于精密电流检测及其他需要低**$I_B$ **的场合 (光电二极管检测电流)。</p><p>偏置电流的存在是因为，运放的输入一般是基于BJT（就是Bipolar Junction Transistor，简单来说就是三极管）或者FET结构的长尾式差分输入。对于BJT来说，由于三极管工作在放大区是需要提供一定的偏置电流的，因此需要提供输入电流，一般有<strong>nA到uA</strong>级别；对于FET来说，由于场效应管本身是场控器件，但还是存在一定的漏电流，但是电流非常小，一般是<strong>fA或者pA</strong>级别。有时候为了ESD，还会增加钳位二极管，从而更加增大了这个漏电流大小。</p><p>运放的两个输入端并不是绝对高阻的，本项指标主要描述输入端流进电流的数 量级。比如某个运放在接成跟随器且正输入端接地情况下，正输入端存在流进电流 1.3nA，即图 2-2 中 IB1=1.3nA，负输入端存在流进电流 0.6nA，即图 2-2 中 IB2=0.6nA，那 么该运放的输入偏置电流 IIB即为 0.95nA。</p><p><img src="https://s2.loli.net/2024/09/29/ujWd29orpeY8J51.png" alt="image-20220714181259056"></p><p>如果不考虑偏置电流的情况下，直接使用，会有什么情况呢？</p><p>第一，当用放大器接成跨阻放大测量外部微小电流时，过大的输入偏置电流会 分掉被测电流，使测量失准。</p><p>第二，当放大器输入端通过一个电阻接地时，这个电流将在 电阻上产生不期望的输入电压。</p><p>对策：为避免输入偏置电流对放大电路的影响，最主要的措施是选择 IB较小的放大 器。有很多 FET 输入运放可以实现这个要求。但是需要注意，高速运放且 IB较小的运放比 较难选择，数量极少。ADI 公司的 ADA4817-1/-2，带宽 1050MHz，IB约为 2pA，单位增 益稳定。</p><p>举例：AD8606的Datasheet上有如下内容</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/14/9ce44b3ef0223424.png" alt="iB"></p><h3><span id="3-噪声vn">3、噪声（Vn）</span></h3><p>运放的噪声固有无法消除，放大小信号时候需要选择低噪声运放。</p><p><strong>AD8605</strong>、<strong>AD8606</strong>系列：</p><img src="https://s2.loli.net/2024/10/02/dsOrBbZAaCNGDug.png" alt="Vn"><h3><span id="4-静态电流iq">4、静态电流（Iq）</span></h3><p>运放在没有负载情况下的待机电流或者建立静态工作点的电流，越小越好。在低功耗场合需要特别关注。常用于移动设备等。</p><h3><span id="5-输入失调电压vos-input-offset-voltage">5、输入失调电压（Vos / Input  Offset Voltage）</span></h3><p>在理想情况下 <strong>VIN+=VIN-</strong>，实际情况下 VIN+和VIN-之间存在一个恒定的电位差，就叫输入失调电压。</p><p>也可以被以下方法定义：在运放开环使用时，加载在两个输入端之间的直流电压使得放大器直流输出电 压为 0。也可定义为当运放接成跟随器且正输入端接地时，输出存在的非 0 电压。</p><p>满足如下关系：<br>$$<br>Vos= Vin_+ - Vin_-<br>$$<br>任何一个放大器，无论开环连接或者反馈连接，当两个输入端都接地时，理论上输出应该为0，但运放内部两输入支路无法做到完全平衡，导致输出永远不会是 0。此时保持放大器负输入端不变，而在正输入端施加一个可调的直流电压，调节它直到输出直流 电压变为 0V，此时正输入端施加的电压的负值即为输入失调电压，用 $V_{OS}$ 表示。但是，多数情况下，输入失调电压不分正负，生产厂家会以绝对值表示。</p><p>如果不考虑失调电压，使用的后果：当一个放大器被设计成AF倍闭环电压增益（同相输入放大增益，也称噪声增益）时，如果放大器的失调电压为 $V_{OS}$，则放大电路 0 输入时，输出存在一个等于 $A_F*V_{OS}$ 的直流电平，此输出被称为输出失调电压。闭环增益越大，则输出失调电压也越大。</p><p>如何消除失调电压？可通过加法器实现调零：</p><img src="https://s2.loli.net/2024/10/02/kWX83YxwSMeLBZ9.png" alt="调零" style="zoom:80%;"><p><strong>AD8605</strong>、<strong>AD8606</strong>系列：</p><p><img src="https://s2.loli.net/2024/10/02/1g3jdGrnq2YNCHV.png" alt="img"></p><h3><span id="6-增益带宽积gbw-gbp">6、增益带宽积（GBW \GBP）</span></h3><p>当运算放大器在小信号（Vpp(峰峰值) 在1V以下的信号）环境下应用时，电压反馈运算放大器的带宽和增益的乘积是一个定值，即等于增益带宽积。</p><p>满足如下条件时可正常放大：<br>$$<br>GBW = (10 \textasciitilde 100) * A_s(GAIN) * F(MHz)<br>$$</p><p><strong>-3dB</strong>带宽带宽：表示增益为1时随着信号频率增加，输出信号幅度信号下降到-3dB时的带宽。一般运放的都是用增益带宽积GBP来表征其处理交流信号的能力，是一个常数。</p><p>单位增益带宽是指在运放电路闭环增益为<strong>0db</strong>时的带宽。</p><p>具体频率和增益关系需要看开环增益图。</p><h3><span id="7-电压转换速率-压摆率slew-rate">7、电压转换速率 /压摆率（Slew Rate）</span></h3><p>其定义时在<strong>1us</strong>或者<strong>1ns</strong>等时间里电压升高的的幅度，直观上讲就是电压从波谷上升到波峰所需要的时间。实际上是闭环放大器输出电压变化的最快速率。</p><p>此值显示运放正常工作时，输出端所能提供的最大变化速率，当输出信号欲实现比这个速率还快的变化时，运放就不能提供了，导致输出波形变形——原本是正弦波就变成了三角波。</p><p>对一个正弦波来说，其最大变化速率发生在过零点处，且与输出信号幅度、频率有 关。设输出正弦波幅度为 Am，频率为 fout，过零点变化速率为 DV，则满足如下条件可正常放大：<br>$$<br>D_v =  2π𝐴_𝑚𝑓_{out}\<br>SR  \ge 2\pi f 𝐴_𝑚 \<br>其中SR就是其压摆率<br>$$</p><h3><span id="8-输入电压范围-共模输入电压范围input-voltage-range">8、输入电压范围 \ 共模输入电压范围（Input Voltage range）</span></h3><p>保证运算放大器正常工作的最大输入电压范围。也称为共模输入电压范围。</p><p>当运放最大输入电压范围与电源范围比较接近时，比如相差 0.1V 甚至相等、超过，都 可以叫“输入轨至轨”，表示为 Rail-to-rail input，或 RRI。</p><p>轨至轨演示图如下：</p><p><img src="https://s2.loli.net/2024/10/02/1RT2rO8BDP35GeH.png" alt="image-20220714185339493"></p><p>运放的两个输入端，任何一个的输入电压超过此范围，都将引起运放的失效。 注意，超出此范围并不代表运放会被烧毁，但绝对参数中出现的此值是坚决不能超过的。 之所以叫共模输入电压范围，是因为运放正常工作时，两个输入端之间的差压是很小 的，某个输入端的电压与两个输入端电压的平均值（共模）是基本相同的</p><p>对于非轨到轨放大器来说，存在一定输入限制，可参考：<a href="https://wenku.baidu.com/view/8162c04bae1ffc4ffe4733687e21af45b307fe2a.html">TI对于共模输入电压的解析。</a></p><h3><span id="9-输出电压范围onput-voltage-range">9、输出电压范围（Onput Voltage range）</span></h3><p>在给定电源电压和负载情况下，输出能够达到的最大电压范围。或者给出正向最大电压 VOH 以及负向最小电压 VOL——相对于给定的电源电压和负载；或者给出与电 源轨（rail）的差距。</p><p>优劣范围：一般运放的输出电压范围要比电源电压范围略窄 1V 到几 V。较好的运放 输出电压范围可以与电源电压范围非常接近，比如几十 mV 的差异，这被称为“输出至轨 电压”。这在低电压供电场合非常有用。当厂家觉得这个运放的输出范围已经接近于电源电 压范围时，就自称“输出轨至轨”，表示为 Rail-to-rail output，或 RRO。</p><p>在没有额外的储能元件情况下，运放的输出电压不可能超过电源电压范围，随 着负载的加重，输出最大值与电源电压的差异会越大。轨到轨受到输出电流的影响，如果负载过小，输出电流过大，则会使输出电压达不到电源轨。</p><p>输出电压范围，或者输出至轨电压有如下特点：</p><ul><li>1）正至轨电压与负至轨电压的绝对值可能不一致，但一般情况下数量级相同；</li><li>2） 至轨电压与负载密切相关，负载越重（阻抗小）至轨电压越大；</li><li>3）至轨电压与信号频率相关，频率越高，至轨电压越大，甚至会突然大幅度下降；</li></ul><p>对于<strong>AD8605</strong>、<strong>AD8606</strong>系列：</p><p>其5v输出特性已经标明：其中高低代表输出电平的高低。</p><p><img src="https://s2.loli.net/2024/10/02/kde14aM9zCSY6y8.png" alt="输出电压"></p><p>对于其他系列：</p><p>OPA354 在  $RL = 10K$   的情况下电压最大值为   $Vo = V_s -20mV $</p><p><img src="https://s2.loli.net/2024/10/02/5rlVEa7k3Iv6DTU.png" alt="输出"></p><p>详细了解可参考：<a href="https://wenku.baidu.com/view/fa1d4f138ad63186bceb19e8b8f67c1cfbd6eefe.html">TI对于输出范围解析 </a>。</p><h3><span id="10-短路电流-isc">10、短路电流 （$Isc$）</span></h3><p>标明运放输出级输入或者灌入电流的能力（表征输出驱动的能力），有特殊的驱动运放才有此参数。</p><h3><span id="11-输入阻抗impedance-resistance">11、输入阻抗（impedance ， resistance）</span></h3><p>选择运放输入阻抗时要考虑到被放大对象（信源）的内阻。运放的输入阻抗要远远大于信源内阻。例如信源内阻为10KΩ，则需要选择100K以上的输入阻抗才能达到90%的精度，要达到99%的精度则要选择1M以上的输入阻抗。</p>]]></content>
      
      
      <categories>
          
          <category> Operational Amplifier </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operational Amplifier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算放大器  ——  快速复苏笔记[贰]（应用篇）</title>
      <link href="/2024/09/28/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%20%20%E2%80%94%E2%80%94%20%20%E5%BF%AB%E9%80%9F%E5%A4%8D%E8%8B%8F%E7%AC%94%E8%AE%B0%5B%E8%B4%B0%5D%EF%BC%88%E5%BA%94%E7%94%A8%E7%AF%87%EF%BC%89/"/>
      <url>/2024/09/28/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%20%20%E2%80%94%E2%80%94%20%20%E5%BF%AB%E9%80%9F%E5%A4%8D%E8%8B%8F%E7%AC%94%E8%AE%B0%5B%E8%B4%B0%5D%EF%BC%88%E5%BA%94%E7%94%A8%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="运算放大器-快速复苏笔记贰应用篇">运算放大器  ——  快速复苏笔记[贰]（应用篇）</span></h1><img src="https://s2.loli.net/2024/09/29/oFphKzqP5k2iwmJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727599199035" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><!-- toc --><ul><li><a href="#%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96">资源获取</a></li><li><a href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">前置知识</a><ul><li><a href="#%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E5%AE%9A%E5%BE%8B">基尔霍夫定律</a></li><li><a href="#%E9%BD%90%E7%BA%B3%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%A8%B3%E5%8E%8B%E4%BA%8C%E6%9E%81%E7%AE%A1zener-diode">齐纳二极管/稳压二极管/Zener diode</a><ul><li><a href="#%E4%B8%BB%E8%A6%81%E5%8F%82%E6%95%B0">主要参数</a><ul><li><a href="#%E7%A8%B3%E5%AE%9A%E7%94%B5%E5%8E%8Buz">稳定电压(Uz)</a></li><li><a href="#%E9%A2%9D%E5%AE%9A%E7%94%B5%E6%B5%81iz">额定电流(Iz)</a></li><li><a href="#%E5%8A%A8%E6%80%81%E7%94%B5%E9%98%BBrz">动态电阻(Rz)</a></li><li><a href="#%E9%A2%9D%E5%AE%9A%E5%8A%9F%E8%80%97pz">额定功耗(Pz)</a></li><li><a href="#%E5%8F%8D%E5%90%91%E6%BC%8F%E7%94%B5%E6%B5%81ir">反向漏电流(IR)</a></li></ul></li></ul></li></ul></li><li><a href="#%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E5%BA%94%E7%94%A8">运算放大器应用</a><ul><li><a href="#%E5%BA%94%E7%94%A81">应用1</a><ul><li><a href="#%E5%8F%8D%E7%9B%B8%E6%AF%94%E4%BE%8B%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF">反相比例运算电路</a></li><li><a href="#%E5%8F%8D%E5%90%91%E6%94%BE%E5%A4%A7%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5">反向放大的特殊情况</a></li><li><a href="#%E7%94%B5%E6%B5%81%E6%94%BE%E5%A4%A7%E8%B7%A8%E9%98%BB%E6%94%BE%E5%A4%A7%E5%99%A8">电流放大\跨阻放大器</a></li><li><a href="#%E5%8F%8D%E5%90%91%E5%8A%A0%E6%B3%95%E7%94%B5%E8%B7%AF">反向加法电路</a></li></ul></li><li><a href="#%E6%80%9D%E8%80%83%E9%97%AE%E9%A2%98">思考问题</a><ul><li><a href="#%E5%B9%B3%E8%A1%A1%E7%94%B5%E9%98%BB%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B">平衡电阻大小的推导过程</a></li></ul></li><li><a href="#%E5%BA%94%E7%94%A82">应用2</a><ul><li><a href="#%E6%AD%A3%E5%90%91%E6%AF%94%E4%BE%8B%E8%BF%90%E7%AE%97">正向比例运算</a></li><li><a href="#%E7%94%B5%E5%8E%8B%E8%B7%9F%E9%9A%8F%E5%99%A8">电压跟随器</a></li><li><a href="#%E5%90%8C%E7%9B%B8%E5%8A%A0%E6%B3%95%E5%99%A8">同相加法器</a></li></ul></li><li><a href="#%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF">减法运算电路</a></li></ul></li></ul><!-- tocstop --><p>阅读前请参考专栏前一篇文章，了解一些基础知识。</p><h2><span id="资源获取">资源获取</span></h2><p>写这篇文章的原因是我经常会忘记运放是如何使用的，希望通过几个样例和分析能快速且详细的分析出来。部分电路的仿真和电路仿真软件，我已经上传到云盘，这里推荐阿里的云盘，不限速下载很快，<a href="https://www.aliyundrive.com/s/kvHgWETjj9V">下载地址</a>。提取码: 00kx。</p><h2><span id="前置知识">前置知识</span></h2><h3><span id="基尔霍夫定律">基尔霍夫定律</span></h3><p><strong>基尔霍夫电流定律</strong>也叫KCL。是说电路中任一节点上所流入的电流等于所流出的电流，也就是节点上电流的代数合为0。</p><p><img src="https://s2.loli.net/2024/09/29/tFm8oQ2zqnRYLKC.jpg" alt="jehf"></p><p><strong>节点:一个电路的分支点。在这里，可以把任意封闭曲线或曲面，看作一个广义的节点。像力学上的质量一样，可以把物体抽象成质点来分析。</strong></p><p><img src="https://s2.loli.net/2024/09/29/OYGbJivFKlMP5L4.jpg" alt="img"></p><p>简单来说你可以直接画一个圆，对于这个圆来说，这个圆就是一个节点，进入和出去这个圆的电流合为0。</p><h3><span id="齐纳二极管稳压二极管zener-diode">齐纳二极管/稳压二极管/Zener diode</span></h3><p><strong>稳压二极管的特点就是击穿后，其两端的电压基本保持不变</strong>。这个电压在手册中常说的是Nominal Zener Voltage，标称稳压值。这样，当把稳压管接入电路以后，若由于电源电压发生波动，或其它原因造成电路中各点电压变动时，负载两端的电压将基本保持不变。</p><p>其反向特性是在反向电压低于反向击穿电压时，反向电阻很大，反向漏电流极小。但是，当反向电压临近反向电压的临界值时，反向电流骤然增大，称为击穿，在这一临界击穿点上，反向电阻骤然降至很小值。尽管电流在很大的范围内变化，而二极管两端的电压却基本上稳定在击穿电压附近，从而实现了二极管的稳压功能。其原理的关键点就在于过了稳压值的时候电阻很小，即使加上不同的电压，流过的电流也不会让其两端电压变化很大，这就达到了稳压的效果。</p><p><img src="https://s2.loli.net/2024/09/29/VOeQxzG4mcghpja.png" alt="v2-5bbc8b3d2670ef1ebc2e4906359962df_720w"></p><h4><span id="主要参数">主要参数</span></h4><h5><span id="稳定电压uz">稳定电压(Uz)</span></h5><p>指稳压二极管通过额定电流时两端产生的稳定电压值。该值随工作电流和温度的不同而略有改变。由于制造工艺的差别，同一型号稳压二极管的稳压值也不完全一致。例如，2CW51型稳压二极管的Vzmin为3.0V, Vzmax则为3.6V。</p><h5><span id="额定电流iz">额定电流(Iz)</span></h5><p>指稳压二极管产生稳定电压时通过该管的电流值。低于此值时，稳压二极管虽并非不能稳压，但稳压效果会变差;高于此值时，只要不超过额定功率损耗，也是允许的，而且稳压性能会好一些，但要多消耗电能。</p><h5><span id="动态电阻rz">动态电阻(Rz)</span></h5><p>指稳压二极管两端电压变化与电流变化的比值。该比值随工作电流的不同而改变，一般是工作电流愈大，动态电阻则愈小。例如，2CW7C稳压二极管的工作电流为 5mA时，Rz为18Ω;工作电流为1OmA时，Rz为8Ω;为20mA时，Rz为2Ω ; &gt; 20mA则基本维持此数值。</p><h5><span id="额定功耗pz">额定功耗(Pz)</span></h5><p>由芯片允许温升决定，其数值为稳定电压Vz和允许最大电流Izm的乘积。例如2CW51稳压二极管的Vz为3V，Izm为20mA，则该管的Pz为60mWo。</p><h5><span id="反向漏电流ir">反向漏电流(IR)</span></h5><p>指稳压二极管在规定的反向电压下产生的漏电流。例如2CW58稳压二极管的VR=1V时，IR=O.1uA;在VR=6V时，IR=10uA。</p><h2><span id="运算放大器应用">运算放大器应用</span></h2><p>前提：</p><ul><li>虚短：</li></ul><p>$$<br>Vin_+ = Vin_-<br>$$</p><ul><li>虚断：</li></ul><p>$$<br>Iin_+ = Iin_- = 0<br>$$</p><h3><span id="应用1">应用1</span></h3><h4><span id="反相比例运算电路">反相比例运算电路</span></h4><p>这里我们先把电路放上来，在看这一篇之前请先去看参数篇，运放的基础知识。详见专栏：</p><p><img src="https://s2.loli.net/2024/09/29/WQ9SznwGj2i4Ip1.png" alt="image-20220713225253744"></p><p>V1是放大器电源输出为+5V的DC电压。</p><p>V2是虚拟地电压，用来模拟没有直接接地的情况。这里提供的是一个2V的DC电压</p><p>V3是正弦波，其参数如下：</p><p><img src="https://s2.loli.net/2024/09/29/iOPrZW4tYSasCqD.png" alt="image-20220713225458473"></p><p>反向放大推导：</p><p>虚短：<br>$$<br>V_+ = V_- = V_{GND}\<br>V_{GND}为V-和V+的值<br>$$<br>虚断：以反相输入端为节点分析。<br>$$<br>\frac{V_{in} - V_{GND}}{R_2}= \frac{V_{GND} - V_{out}}{R3}\<br>KCL方法推导电流相等、方向相反，以V_{GND}到V_{out}为正方向。<br>$$</p><p>化简得：<br>$$<br>V_{out} = V_{GND}(1+\frac{R_3}{R_2}) - V_{in}\frac{R_3}{R_2}<br>$$<br>我们试一试推导带入，上文情况下，Vout的输出结果是怎么样的：<br>$$<br>V_{out} = V_{GND}(1+\frac{R_3}{R_2}) - V_{in}\frac{R_3}{R_2}=2*(1+1.5) - V_{in}*1.5\<br>其中V_{in}=[0,2]，且为\sin{x}波形\<br>结果如下：V_{out}=[2,5]<br>$$<br>仿真的结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/6sIfbt3B4xAdM7F.png" alt="image-20220713231510637"></p><h4><span id="反向放大的特殊情况">反向放大的特殊情况</span></h4><p>可以看到下图中我们放大器的输入+接的是GND，这是一种特殊情况，对应的输入+接的是GND就是电压为0，我们再用上文的分析方法试一试：</p><img src="https://s2.loli.net/2024/09/29/5V9rc6zRoMxkYt4.png" alt="img" style="zoom:67%;"><p>同样满足如下条件：</p><p>虚短：<br>$$<br>V_+ = V_- = V_{GND} = GNDA =0\<br>V_{GND}为V-和V+的值<br>$$<br>虚断：<br>$$<br>\frac{V_{in} - V_{GND}}{R_2}= \frac{V_{GND} - V_{out}}{R3}\<br>KCL方法推导电流相等、方向相反，以V_{GND}到V_{out}为正方向。<br>$$</p><p>化简得：<br>$$<br>V_{out} = -V_{in}\frac{R_3}{R_2}<br>$$<br>我们仿真一下，修改电路如下：</p><p><img src="https://s2.loli.net/2024/09/29/Pk4uZlexUdCVaoT.png" alt="image-20220713232300943"></p><p>对比上文的仿真，少了参考电压DC2V。</p><p>输出结果会是什么呢？</p><p><img src="https://s2.loli.net/2024/09/29/o2C8qleptixshH3.png" alt="image-20220713232404566"></p><p>为什么V_out没有波形呢？这里提示一下是放大器电源的问题，因为放大器此时没有负电压，我们再来修改一下，为放大器添加一个负电源：</p><p><img src="https://s2.loli.net/2024/09/29/WoXPJbE3ySlUs9g.png" alt="image-20220714123259531"></p><p>因为AD8606的电源范围为0-6V，所以正负电源压差也不能超过6V，这里就是±3V。</p><p>仿真后效果如下：<br><img src="https://s2.loli.net/2024/09/29/jnFihtWDTMEsSIc.png" alt="image-20220714123348596"></p><p>存在三种情况：</p><ul><li>$R3 &gt; R2$ 反相放大</li><li>$R3 = R2$ 反相</li><li>$R3 &lt; R2$ 反相缩小波形</li></ul><h4><span id="电流放大跨阻放大器">电流放大\跨阻放大器</span></h4><p><strong>放大器常常还用于电流放大又叫跨阻放大器</strong>，结构更加简单，下面我先把电路举出来，然后解释一下原理：</p><p>下面是电路仿真截图:</p><p><img src="https://s2.loli.net/2024/09/29/ZCmsP8TX537fFLR.png" alt="image-20220713235705056"></p><p>我们将反向输入端换成了一个DC电流源,其提供的电流大小为$5\times10^{-6}A$.</p><p>下面我们来推导一下，它是如何放大的？</p><p>首先也是满足如下两种条件：</p><p>虚短：<br>$$<br>V_+ = V_- = V_{GND} \<br>V_{GND}为V-和V+的值<br>$$<br>虚断：<br>$$<br>I_1= \frac{V_{GND} - V_{out}}{R3}\<br>KCL方法推导电流相等、方向相反，以V_{GND}到V_{out}为正方向。<br>$$</p><p>因为$V_{GND}$是虚拟地电位为0,这里的虚拟地指的是其虚短条件，所以可以简化成如下:<br>$$<br>V_{out}=-R3 * I_1<br>$$<br>这时候我们就知道了，放大器输出的电压实际上是电流的倍数关系。需要注意的是这里的倍数关系还存在一个负值，输出的时候是一个负电压，仿真结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/t9GzcO52KCkgB1p.png" alt="image-20220714123920761"></p><p>你如果细心的话就会发现，实际上的值并不完全等于上述公式，为什么呢？我们分析的时候使用的是理想状态，实际上仿真的时候需要考虑偏置电压，详见上一篇运放参数。</p><p>完整的公式如下：<br>$$<br>I_1= \frac{V_{GND} +V_{offset}- V_{out}}{R3}\<br>$$<br>我们测量一下$V_{offset}$的值：</p><p><img src="https://s2.loli.net/2024/09/29/zyDOfgX9KIbhm4G.png" alt="image-20220714134120857"></p><p>用上边的公式计算一下：<br>$$<br>V_{out}= V_{offset}-I_1{R3} = -40.096(mv)\<br>$$<br><img src="https://s2.loli.net/2024/09/29/mdwlrQ67Xzt9KEL.png" alt="image-20220714134600871"></p><p>我们再来增加一点难度：</p><p><img src="https://s2.loli.net/2024/09/29/LplMndb1qkycJE4.png" alt="image-20220714000647944"></p><p>我们在+输入端增加一个电压，是不是很眼熟？这该如何推导呢？同样满足如下条件：</p><p>虚短：<br>$$<br>V_+ = V_- = V_{GND} \<br>V_{GND}为V-和V+的值<br>$$<br>虚断：<br>$$<br>I_1= \frac{V_{GND} - V_{out}}{R3}\<br>KCL方法推导电流相等、方向相反，以V_{GND}到V_{out}为正方向。<br>$$</p><p>此时$V_{GND}=1V$，我们再来推导一下：<br>$$<br>V_{out} = V_{GND} - I_1*R_3<br>$$<br>仿真结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/oLt2db1UQEScOen.png" alt="image-20220714001003426"></p><h4><span id="反向加法电路">反向加法电路</span></h4><p><img src="https://s2.loli.net/2024/09/29/UO5pr7AiqcWCLQI.png" alt="image-20220720182419709"></p><p>其中信号$V_3$的参数如下：</p><p><img src="https://s2.loli.net/2024/09/29/g4G2IYZ9lizmEjs.png" alt="Alt"></p><p>生成一个方波，周期位0.1s,上升下降波形较陡，持续时间为0.05s。</p><p><img src="https://s2.loli.net/2024/09/29/aZIfPS4nACBMJRV.png" alt="Alt"></p><p>信号$V_4$正弦波形如下：</p><p><img src="https://s2.loli.net/2024/09/29/5zZL1eMg3l6okR9.png" alt="image-20220720182530450"></p><p><img src="https://s2.loli.net/2024/09/29/knDIKa1Y5WCzyHM.png" alt="image-20220720182620369"></p><p>推导过程如下：</p><p>同时也满足如下条件：</p><ul><li>虚短：</li></ul><p>$$<br>Vin_+ = Vin_-<br>$$</p><ul><li>虚断：</li></ul><p>$$<br>Iin_+ = Iin_- = 0<br>$$</p><p>则有：<br>$$<br>Vin_+ = Vin_- = 0\<br>I_{3} = I_{1}+I_{2}\电流跟随电阻序号<br>$$<br>对负数输入端使用KCL则有：<br>$$<br>\frac{V_{GND} - V_{out}}{R_3} = \frac{V_3 - V_{GND}}{R_1} + \frac{V_4 - V_{GND}}{R_2}<br>$$<br>化简得：<br>$$<br>V_{out}  = - (\frac{R_3}{R_1}V_3 + \frac{R_3}{R_2}V_4 )<br>$$<br>实现了放大和相加，上图电路仿真结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/IsHzU6NpWo8nLuV.png" alt="image-20220720183510646"></p><h3><span id="思考问题">思考问题</span></h3><p>上文中正向输入端总是接一个10k的电阻的原因是什么？</p><p>其本质是平衡电阻，目的是为了减小运放输入偏置电流在电阻上形成的静态输入电压而带来误差(减少失调电压)。当运放的输入偏置电流较小，或信号较大，其影响可以忽略时，可以不用平衡电阻。某些并不需要平衡电阻。例如OPA227，其内部有校准好的电阻。</p><h4><span id="平衡电阻大小的推导过程">平衡电阻大小的推导过程</span></h4><p><a href="http://www.ejiguan.cn/2021/changjianwtjd_0525/3512.html">平衡电阻</a></p><img src="https://s2.loli.net/2024/09/29/WoXPJbE3ySlUs9g.png" alt="image-20220714123259531" style="zoom:80%;"><p>设输入电阻为$R2$，反馈电阻为$R3$，先假设同相端没有接平衡电阻，直接连接到地，设运放输入偏置电流为$IB$（同相端和反相端相同），流过$R2$和$R3$的电流分别为$I2$和$I3$，反相端电压为$V_-$，运放增益为$A$，那么在反相端运用$KCL$，有（设输入信号为0）：<br>$$<br>\frac{(0－V_-)}{R2}－\frac{(A - 1)V_-}{R3} ＝ I_B<br>$$<br>上式可得：<br>$$<br>V_- ＝ －\frac{(I_B × R2 × R3)}{R3＋(A - 1)R2}<br>$$<br>此时运放输出电压为：<br>$$<br>Vo＝A×\frac{(I_B×R2×R3)}{R3＋(A-1)R2}\<br>近似为：\<br>Vo＝I_B×((A*R2) // R3)\<br>注意这里是并联大小符号<br>$$<br>在不满足虚短的条件下，实际上$V_o$应该如何算呢？，需要注意的是这里不能直接使用虚短条件来运算，因为虚短的前提条件是忽略两端微小电压差。这里因为存在偏置电流所以不能省略。</p><p>如何计算，这里直接说结论，具体怎么来的请看专栏前文：<br>$$<br>V_o= A * V_{in}\<br>V_{in} = V_+ - V_-<br>$$<br>理论上如果是直接使用虚短条件，$V_o$大的大小应该等于零，但是经过上文分析，并不等于0，这是因为$V_{GND}$处电压不等于0，如果同相端通过一个电阻$R1$到地，且$R1＝R2//R3$，那么同相输入端电压为：<br>$$<br>V_＋＝I_B * R_1<br>$$<br>再对反相端分析（设输入信号为0）：<br>$$<br>\frac{(0－V_-)}{R_2} - \frac{( A ×(V_-)－(V_- - V_+))}{R_3}＝I_B<br>$$<br>上式子 $I_B = 0$,则此时放大器输出也等于0。</p><h3><span id="应用2">应用2</span></h3><h4><span id="正向比例运算">正向比例运算</span></h4><img src="https://s2.loli.net/2024/09/29/U6S5sYIMgDJQ1tz.png" alt="image-20220720174432642" style="zoom:80%;"><p>同时也满足如下条件：</p><ul><li>虚短：</li></ul><p>$$<br>Vin_+ = Vin_-<br>$$</p><ul><li>虚断：</li></ul><p>$$<br>Iin_+ = Iin_- = 0<br>$$</p><p>此时VGND等于下边电压源所产生的电压，即满足下式：<br>$$<br>V_{GND}= V_+ = V_- = \sin{t}<br>$$<br>针对负输入端使用KCL可得：<br>$$<br>\frac{V_- - 0}{R_2}= \frac{V_{out} - V_{GND}}{R_3}<br>$$<br>化简得：<br>$$<br>V_+ \times (1+\frac{R_3}{R_2}) = V_{out}<br>$$<br>仿真结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/QnbGSp7vKAfkPdz.png" alt="image-20220720174423802"></p><p>同相比例输入电阻大，输出电阻小。需要注意的是有些运放对正向放大倍数有一定要求，所以推荐仔细观看手册。</p><h4><span id="电压跟随器">电压跟随器</span></h4><p>主要特点：输入阻抗高，输出阻抗低，常作为阻抗变换和缓冲级，提高输出能力。</p><img src="https://s2.loli.net/2024/09/29/nsbatXoFdxL7Kyc.png" alt="image-20220720175131290" style="zoom:80%;"><p>其放大特点是不放大，没错就是输出电压和输入电压保持一致，具体推导实在过于简单，使用虚短即可。</p><p>一般的运放不能这样，只有数据手册寿命了，单位增益稳定（Unity-Gain Stable）的运放才可以:</p><img src="https://s2.loli.net/2024/09/29/tKQh7F6bYdBkovZ.png" alt="image-20220720175614619" style="zoom:80%;"><p>仿真结果：</p><p><img src="https://s2.loli.net/2024/09/29/Unu1b6SY8ygveRF.png" alt="image-20220720175116800"></p><h4><span id="同相加法器">同相加法器</span></h4><p>通向加法器是使用最多的加法器，因为某些信号可能是含有负电压的，而单片机内置的ADC是无法采集负电压的，所以我们需要通过加法器辣酱对应的电压抬升，实现负电压采集。</p><p>举个例子，有以下电路：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9iBHL4zz-1658479233051)(<a href="https://s3.bmp.ovh/imgs/2022/07/20/37ac9ad8f071b78e.png">https://s3.bmp.ovh/imgs/2022/07/20/37ac9ad8f071b78e.png</a>)]</p><p>其中信号$V_3$的参数如下：</p><img src="https://s2.loli.net/2024/09/29/5aQbxctulXmNfWk.png" alt="image-20220720184511182" style="zoom:80%;"><p>波形如下：</p><img src="https://s2.loli.net/2024/09/29/wX7UQ21PrjbpeWY.png" style="zoom:80%;"><p>V4是一个DC1V的直流信号。</p><p>同时也满足如下条件：</p><ul><li>虚短：</li></ul><p>$$<br>Vin_+ = Vin_-<br>$$</p><ul><li>虚断：</li></ul><p>$$<br>Iin_+ = Iin_- = 0<br>$$</p><p>根据上式负输入端的分析则有：<br>$$<br>\frac{V_- - 0}{R2} =\frac{ V_{out} - V_-}{R_3}<br>$$<br>实际上我们对于$V_+$应该这样分析：</p><p>使用叠加定理。为了确定每个独立源的作用，所有的其他电源的必须“关闭”（置零）：</p><ol><li>在所有其他独立<a href="https://zh.m.wikipedia.org/wiki/%E7%94%B5%E5%8E%8B%E6%BA%90">电压源</a>处用<a href="https://zh.m.wikipedia.org/wiki/%E7%9F%AD%E8%B7%AF">短路</a>（Short circuit）代替（从而消除电压，即令V = 0；理想<a href="https://zh.m.wikipedia.org/wiki/%E7%94%B5%E5%8E%8B%E6%BA%90">电压源</a>的内部阻抗为零（<a href="https://zh.m.wikipedia.org/wiki/%E7%9F%AD%E8%B7%AF">短路</a>））。</li><li>在所有其他独立<a href="https://zh.m.wikipedia.org/wiki/%E7%94%B5%E6%B5%81%E6%BA%90">电流源</a>处用<a href="https://zh.m.wikipedia.org/wiki/%E5%BC%80%E8%B7%AF">开路</a>（Open circuit）代替 （从而消除电流，即令I = 0；理想的<a href="https://zh.m.wikipedia.org/wiki/%E7%94%B5%E6%B5%81%E6%BA%90">电流源</a>的内部阻抗为无穷大（开路））。</li></ol><p>依次对每个电源进行以上步骤，然后将所得的响应相加以确定电路的真实操作。所得到的电路操作是不同电压源和电流源的叠加。</p><p>我们知道$Iin_+ = Iin_- = 0$,那么就存在下式：<br>$$<br>V_+  = \frac{V_3 - 0}{R1+R_4} *R4 + \frac{V_4 - 0}{R1+R_4} *R1<br>$$<br>再根据虚短和对负输入端的分析则有：<br>$$<br>V_{out} = (1+\frac{R_3}{R_2})(\frac{V_3 }{R1+R_4} *R4 + \frac{V_4}{R1+R_4} *R1)<br>$$<br>当R1=R4=R3=R2的时候：</p><p>就满足：<br>$$<br>V_{out} =V_3+V_4<br>$$<br>仿真结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/JzfIbgt7FSCdWVU.png" alt="image-20220720193058452"></p><p>其中V(gnd)为V+电压，V(n004)为V4信号，Vin和Vout如仿真中的标签。</p><h3><span id="减法运算电路">减法运算电路</span></h3><p>由于减法运算并不分正负所以我们把他单独列出来。</p><p>减法常常用于输出差分信号。</p><p>其电路一般如下：</p><img src="https://s2.loli.net/2024/09/29/o8QblYrAjuDImHL.png" alt="image-20220720194053859" style="zoom:80%;"><p>其中V_3为正弦波：<br><img src="https://s2.loli.net/2024/09/29/M84TyktCiAoQqX7.png" alt="image-20220720194138888"></p><p>V_4为直流电源1V。</p><p>同时也满足如下条件：</p><ul><li>虚短：</li></ul><p>$$<br>Vin_+ = Vin_- = V_{GND}<br>$$</p><ul><li>虚断：</li></ul><p>$$<br>Iin_+ = Iin_- = 0<br>$$</p><p>其中V_+的计算方法如下：<br>$$<br>V_+ = \frac{R_4}{R_1+R_4} * Vin_+<br>$$<br>其中对负输入端使用KCL分析如下：<br>$$<br>\frac{Vin_- V_{GND}}{R_2} = \frac{ V_{GND} - V_{out}}{R_3}<br>$$<br>将$Vin_+ = Vin_- = V_{GND}$带入得：<br>$$<br>V_{out} = Vin_+ \frac{R_4}{R_1+R_4}(1+\frac{R_3}{R_2}) - Vin_-(\frac{R_3}{R_2})<br>$$<br>当$R_3 = R_4且 R_1 =R_2$条件满足时</p><p>化简为：<br>$$<br>V_{out} = \frac{R_3}{R_2} ( Vin_+ -  Vin_-)<br>$$<br>满足减法电路。</p><p>最后仿真结果如下：</p><p><img src="https://s2.loli.net/2024/09/29/toi2znFSUPeArsp.png" alt="image-20220720200858123"></p><p>其中V(gnd)为V+电压，V(n001)为V3信号，Vout如仿真中的标签。</p>]]></content>
      
      
      <categories>
          
          <category> Operational Amplifier </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operational Amplifier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python类基础筑基（1）————面对对象</title>
      <link href="/2024/09/28/Python%E7%AD%91%E5%9F%BA(1)%E2%80%94%E2%80%94%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/09/28/Python%E7%AD%91%E5%9F%BA(1)%E2%80%94%E2%80%94%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1><span id="python类基础筑基1面对对象">Python类基础筑基（1）————面对对象</span></h1><img src="https://s2.loli.net/2023/11/30/9ktxJMd1G5perfh.jpg" alt="zXu5EpoCmKH8FiJ" style="zoom:67%;"><img src="https://s2.loli.net/2023/12/01/WpEDI6ayQt5zbM9.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1701391443259" style="zoom:67%;"><p>本文以Python3主要为主，穿插2.7的信息，如无特别说明默认为Python3</p><p>[TOC]</p><h2><span id="1python的命名空间与作用域">1.Python的命名空间与作用域</span></h2><h3><span id="11命名空间namespace">1.1命名空间（namespace）</span></h3><p><em>namespace</em> （命名空间）是从名称到对象的映射。现在，大多数命名空间都使用 Python 字典实现，但除非涉及到性能优化，我们一般不会关注这方面的事情，而且将来也可能会改变这种方式。命名空间的例子有：内置名称集合（包括 <a href="https://docs.python.org/zh-cn/3/library/functions.html#abs"><code>abs()</code></a> 函数以及内置异常的名称等）；一个模块的全局命名空间；一个函数调用中的局部命名空间。对象的属性集合也是命名空间的一种形式。</p><p>命名空间是在不同时刻创建的，且拥有不同的生命周期。下边列出来四种常见的命名空间的简单介绍：</p><ul><li>内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。内置名称实际上也在模块里，即 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins"><code>builtins</code></a> 。</li><li>模块的全局命名空间在读取模块定义时创建；通常，模块的命名空间也会持续到解释器退出。</li><li>从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__"><code>__main__</code></a> 模块调用的一部分，也拥有自己的全局命名空间。</li><li>函数的局部命名空间在函数被调用时被创建，并在函数返回或抛出未在函数内被处理的异常时，被删除。（实际上，用“遗忘”来描述实际发生的情况会更好一些。）当然，每次递归调用都有自己的局部命名空间。</li></ul><p>上述内容代表了常见的四种命名空间：内置命名空间、全局命名空间、main模块命名空间、函数的命名空间。实际上main也应该算作一种全局命名空间，只是他相对特殊这里单列出来。</p><p>“从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__"><code>__main__</code></a> 模块调用的一部分，也拥有自己的全局命名空间” 这句话该如何理解呢？什么是main模块自己的全局命名空间？</p><p>这里可以参考一下python官方文档的解释：</p><p>在 Python 中，特殊名称 <code>__main__</code> 用于两个重要的构造：</p><ol><li>程序的顶层环境的名称，可以使用 <code>__name__ == '__main__'</code> 表达式进行检查；</li><li>Python 包中的 <code>__main__.py</code> 文件。</li></ol><p>这两种机制都与 Python 模块有关，涉及用户如何与模块互动以及模块之间如何互动。下面详细解释了它们的作用。如果你是 Python 模块的新手，请参阅教程部分 <a href="https://docs.python.org/3/tutorial/modules.html#tut-modules">Modules</a> 以进行介绍。</p><p><code>__main__</code> 是顶层代码运行的环境名称。所谓的 “顶层代码” 是指开始运行的第一个用户指定的 Python 模块。它之所以被称为 “顶层”，是因为它导入了程序所需的所有其他模块。有时 “顶层代码” 也被称为应用程序的 <em>入口点</em>。</p><p>顶层代码环境可以是：</p><ul><li><p>交互式提示符的作用域：</p><pre><code>pythonCopy code&gt;&gt;&gt; __name__'__main__'</code></pre></li><li><p>作为文件参数传递给 Python 解释器的 Python 模块：</p><pre><code>pythonCopy code$ python helloworld.pyHello, world!</code></pre></li><li><p>使用 <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-m"><code>-m</code></a> 参数传递给 Python 解释器的 Python 模块或包：</p><pre><code>pythonCopy code$ python -m tarfileusage: tarfile.py [-h] [-v] (...)</code></pre></li><li><p>从标准输入中读取的 Python 代码：</p><pre><code>pythonCopy code$ echo "import this" | pythonThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit....</code></pre></li><li><p>使用 <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-c"><code>-c</code></a> 参数传递给 Python 解释器的 Python 代码：</p><pre><code>pythonCopy code$ python -c "import this"The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit....</code></pre></li></ul><p>在每一种情况下，顶层模块的 <code>__name__</code> 被设置为 <code>'__main__'</code>。</p><p>因此，一个模块可以通过检查自己的 <code>__name__</code> 来发现它是否在顶层环境中运行，这允许一种常见的习惯用法，用于在模块未从导入语句初始化时有条件地执行代码：</p><pre><code>pythonCopy codeif __name__ == '__main__':    # 当模块未从导入语句初始化时执行。    ...</code></pre><pre><code class="language-python">if __name__ == '__main__':    # Execute when the module is not initialized from an import statement.    ...</code></pre><p>这意味着如果脚本文件被直接运行（而不是被导入为模块），那么其中的代码将作为主程序执行，即被解释器顶层调用执行。这是Python中的一种约定，用于标识脚本的主要入口点。</p><h3><span id="12作用域scope">1.2作用域（scope）</span></h3><p>一个命名空间的 <em>作用域</em> 是 Python 代码中的一段文本区域（textual region），<strong>从这个区域可直接访问该命名空间</strong>。“可直接访问”的意思是，该文本区域内的名称在被非限定引用时，查找名称的范围，是包括该命名空间在内的。</p><p>作用域是按字面文本（textual region）确定的解释：模块内定义的函数的全局作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。另一方面，实际的名称搜索是在运行时动态完成的。但是，Python 正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！（局部变量已经是被静态确定了。）</p><p>作用域虽然是被静态确定的，但会被动态使用。执行期间的任何时刻，都会有 3 或 4 个“命名空间可直接访问”的嵌套作用域：</p><ul><li>最内层作用域，包含局部名称，并首先在其中进行搜索</li><li>那些外层闭包函数的作用域，包含“非局部、非全局”的名称，从最靠内层的那个作用域开始，逐层向外搜索。</li><li>倒数第二层作用域，包含当前模块的全局名称</li><li>最外层（最后搜索）的作用域，是内置名称的命名空间</li></ul><p>如果一个名称被声明为全局，则所有引用和赋值都将直接指向“倒数第二层作用域”，即包含模块的全局名称的作用域。</p><h3><span id="13关于作用域和命名空间的混淆点">1.3关于作用域和命名空间的混淆点</span></h3><p>命名空间：名称(name)及其所引用对象(object)的集合。python使用dictionary来表示命名空间，key对应名称(name)，value为名称所对应的对象(object)。</p><p>实际上命名空间是一种映射关系的具体实现，在python中以dictionary来实现，其存储了具体的映射关系。</p><p>而作用域是在命名空间的基础上所遵循的规则信息。其规定了我们的程序将查看哪些命名空间（中的名称）及以顺序。</p><h3><span id="114作用域的具体例子global-amp-nonlocal">1.1.4作用域的具体例子（global &amp; nonlocal）</span></h3><p>如果程序执行时去使用一个变量 hello ，那么 Python， 查找变量顺序为：</p><p><strong>局部的命名空间 -&gt; 全局命名空间 -&gt; 内置命名空间</strong></p><p>如果按照这个顺序找不到相应的变量，它将放弃查找并抛出一个 NameError 异常：</p><pre><code class="language-shell">NameError: name 'hello' is not defined。</code></pre><p>Python 有一个特殊规定。如果不存在生效的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句，则对名称的赋值总是会进入最内层作用域。赋值不会复制数据，只是将名称绑定到对象。删除也是如此：语句 <code>del x</code> 从局部作用域引用的命名空间中移除对 <code>x</code> 的绑定。所有引入新名称的操作都是使用局部作用域：尤其是 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import"><code>import</code></a> 语句和函数定义会在局部作用域中绑定模块或函数名称。</p><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句用于表明特定变量在全局作用域里，并应在全局作用域中重新绑定；<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句表明特定变量在外层作用域中，并应在外层作用域中重新绑定。</p><p>摘两段关于global和nonlocal的定义：</p><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量。 要给全局变量赋值不可能不用到 <code>global</code> 关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。</p><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句会使得所列出的名称指向之前在最近的包含作用域中绑定的<strong>除全局变量以外的变量</strong>。与 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句中列出的名称不同，<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句中列出的名称必须指向之前存在于包含作用域之中的绑定（在这个应当用来创建新绑定的作用域不能被无歧义地确定）。</p><p>要重新绑定在最内层作用域以外的变量，可以使用 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句；如果未使用 nonlocal 声明，这些变量将为只读（尝试写入这样的变量将在最内层作用域中创建一个 <em>新的</em> 局部变量，而使得同名的外部变量保持不变）。</p><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句中列出的名称不得与之前存在于局部作用域中的绑定相冲突。</p><p>这句话看起来很难理解，不过没关系，下面的例子很好的解释了这个问题：</p><pre><code class="language-python">def scope_test():    def do_nonlocal():        spam = "do_nonlocal spam"        nonlocal spam        spam = "nonlocal spam"            spam = "test spam"    do_nonlocal()    print("After nonlocal assignment:", spam)scope_test()</code></pre><p><img src="https://s2.loli.net/2023/11/28/hmzu2dqKHFP83yS.png" alt="image-20231128130324612"></p><p>可以看到<code>nonlocal</code>不能绑定已经绑定过的局部变量，这里使用‘绑定’这个词是有原因的，可以看一下下边的内容。</p><h4><span id="扩展名称和对象">扩展：名称和对象</span></h4><p>对于Python来说所有内容都是对象，对象之间相互独立，多个名称（甚至是多个作用域内的多个名称）可以绑定到同一对象。这在其他语言中通常被称为别名。Python 初学者通常不容易理解这个概念，处理数字、字符串、元组等不可变基本类型时，可以不必理会。</p><p>但是，对于涉及可变对象（如列表、字典，以及大多数其他类型）的 Python 代码的语义，别名可能会产生意料之外的效果。这样做，通常是为了让程序受益，因为别名在某些方面就像指针。例如，传递对象的代价很小，因为实现只传递一个指针。</p><p>我们通过以下的例子来综合解释一下如何使用global &amp; nonlocal：</p><pre><code class="language-python">def scope_test():    def do_local():        spam = "local spam"    def do_nonlocal():        nonlocal spam        spam = "nonlocal spam"    def do_global():        global spam        spam = "global spam"    spam = "test spam"    do_local()    print("After local assignment:", spam)    do_nonlocal()    print("After nonlocal assignment:", spam)    do_global()    print("After global assignment:", spam)scope_test()print("In global scope:", spam)</code></pre><p>示例代码的输出是：</p><pre><code class="language-shell">After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam</code></pre><p>在调用<code>scope_test</code>之后，会先创建一个在<code>scope_test</code>函数作用域之内的<code>spam</code>变量其作用域是在<code>scope_test</code>函数的局部变量里面，这时候调用<code>do_local()</code>函数其将<code>do_local()</code>函数小局部作用域中的spam通过nonlocal关键字绑定到了上一个局部作用域中，并进行了赋值，这时上一个局部作用域中的spam被赋值修改了绑定关系。所以输出结果从<code>test spam</code>变化成为了<code>nonlocal spam</code>。</p><p>需要注意的是<code>do_global()</code>函数将在全局一个不存在的spam进行了绑定，相当于在局部变量中创建了全局变量，这是比较特殊的。</p><h2><span id="2面对对象与类">2.面对对象与类</span></h2><h3><span id="21python的面对对象">2.1Python的面对对象</span></h3><p>最简单的类定义形式如下：</p><pre><code class="language-python">class ClassName:    """class help doc"""    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;</code></pre><p>当进入类定义时，将创建一个新的<strong>命名空间</strong>，并将其用作<strong>局部作用域</strong>，因此，所有对局部变量的赋值都是在这个新<strong>命名空间</strong>之内。</p><p>类的帮助信息可以通过ClassName.__ doc __查看。</p><p>特别的，函数定义会绑定到这里的新函数名称。也就是会将里面的函数定义绑定到对应的函数名称，完成函数的创建。</p><p>当 (从结尾处) 正常离开类定义时，将创建一个 <em><strong>类对象</strong></em>。 这基本上是一个围绕类定义所创建的命名空间的包装器；至于什么是包装器，包装器的作用是什么，这个以后再讨论。</p><p>原始 (在进入类定义之前有效的) 作用域将重新生效，<strong>类对象</strong>将在这里与类定义头所给出的类名称进行绑定 (在这个示例中为 <code>ClassName</code>)。</p><p>这里需要关注的是类其实也是一个对象，<strong>类对象也是对象的一种。在创建的结束将类名和类对象进行绑定</strong>。</p><h3><span id="22类对象">2.2类对象</span></h3><p>类对象支持两种操作：属性引用和实例化。</p><h4><span id="221属性引用">2.2.1属性引用</span></h4><p>使用 Python 中所有属性引用所使用的标准语法: <code>obj.name</code>。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:</p><pre><code class="language-python">class MyClass:    """A simple example class"""    i = 12345    def f(self):        return 'hello world'</code></pre><p>那么 <code>MyClass.i</code> 和 <code>MyClass.f</code> 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 <code>MyClass.i</code> 的值。 有趣的是这样的内容在java系语言中被定为静态属性，其生命周期不会随着类的实例化所变化。</p><p><code>__doc__</code> 也是一个有效的属性，将返回所属类的文档字符串: <code>"A simple example class"</code>。</p><h4><span id="222实例化">2.2.2实例化</span></h4><p>类对象的实例化功能实际上就是其他语言的创建类的实例对象，需要注意的是<strong>实例对象</strong>和<strong>类对象</strong>是两个不同的概念，后面会详细介绍二者的区别。</p><p>类的 <em>实例化</em> 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。常见的形式如下：</p><pre><code class="language-python">对象变量 = 类名()x = MyClass()</code></pre><p>创建类的新 <em>实例</em> 并将此对象分配给局部变量 <code>x</code>。</p><p>上述实例化操作 (“调用”类对象) 会创建一个空对象。 许多类都希望创建的对象实例是根据特定初始状态定制的。</p><p>因此一个类可能会定义名为 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__"><code>__init__()</code></a> 的特殊方法，就像这样:</p><pre><code class="language-python">def __init__(self):    self.data = []</code></pre><p>当一个类定义了 <code>__init__()</code>方法时，类的实例化会自动为新创建的类实例发起调用 <code>__init__()</code>。 因此在这个例子中，可以通过以下语句获得一个已初始化的新实例:</p><pre><code class="language-python">x = MyClass()</code></pre><p>Example：</p><p><img src="https://s2.loli.net/2023/11/28/W9kIqAGpDdoZjh6.png" alt="image-20231128173030208"></p><h3><span id="23实例对象">2.3实例对象</span></h3><p>实例对象所能理解的唯一操作是属性引用。 有两种有效的属性名称：数据属性和方法。</p><h4><span id="231数据属性">2.3.1数据属性</span></h4><p>数据属性就是java中的成员属性，需要注意的是pyhton是一门动态的语言， 数据属性不需要声明；就像局部变量一样，它们将在首次被赋值时产生。且在操作过程中可进行删除操作，删除一个实例对象的数据属性。这是其他静态语言所难以企及的。</p><p>下面举个例子，在上文的基础上进行修改：</p><p><img src="https://s2.loli.net/2023/11/28/c9XjiGlNACIKs42.png" alt="image-20231128174245657"></p><p>只能说python过于自由了。哈哈哈。</p><h4><span id="232方法">2.3.2方法</span></h4><p>另一类实例属性引用称为 <strong>方法</strong>。 方法是<strong>从属于</strong>对象的函数。 （在 Python 中，方法这个术语并不是类实例所特有的：其他对象也可以有方法。 例如，列表对象具有 append, insert, remove, sort 等方法。 然而，在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外显式地说明）</p><p>实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是其实例的相应方法。</p><p>因此在我们的示例中，<code>x.f</code> 是有效的方法引用，因为 <code>MyClass.f</code> 是一个函数，而 <code>x.i</code> 不是方法，因为 <code>MyClass.i</code> 不是函数。 但是 <code>x.f</code> 与 <code>MyClass.f</code> 并不是一回事 — 它是一个 <strong>方法对象</strong>，不是<strong>函数对象</strong>。</p><p>这里让人难以理解的就是什么。为什么方法也是对象，对于函数对象还是比较好理解的，就像变量对象一样，是基础的对象类型，那么什么是方法对象呢？</p><h3><span id="24方法对象">2.4方法对象</span></h3><p>这里在上文的对象中添加一个<code>f()</code>方法，代码如下：</p><pre><code class="language-python">class Complex:    def __init__(self,realpart , imagpart):        self.r = realpart        self.i = imagpart    def f(self):        return 'hello world'</code></pre><p>添加完成以后，Complex对象就有了方法对象，可以通过实例对象来进行引用，如下图所示，它不仅可以在实例对象中进行引用同时也可以将其存储起来，存储对象在xf中，xf就相当于方法的别名，可以看到二者指向的对象是相同。</p><p><img src="https://s2.loli.net/2023/11/28/JmHpSQNYbOwdLt3.png" alt="image-20231128193553688"></p><h3><span id="25方法对象amp函数对象的区别-类对象amp实例对象的区别">2.5方法对象&amp;函数对象的区别、类对象&amp;实例对象的区别</span></h3><h4><span id="251方法对象amp函数对象的区别">2.5.1方法对象&amp;函数对象的区别</span></h4><p>在官方的文档中有这样一句话：</p><p>Each value is an object, and therefore has a <em>class</em> (also called its <em>type</em>). It is stored as <code>object.__class__</code>.</p><p>对于方法对象和函数对象来说而这最大的区别就在于使用方法上，我们可以注意到：</p><p><code>f()</code> 的函数定义指定了一个参数，但上面调用 <code>x.f()</code> 时却没有带参数。 这个参数发生了什么事？ 当一个需要参数的函数在不附带任何参数的情况下被调用时 Python 肯定会引发异常 — 即使参数实际上没有被使用…</p><p>实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 <code>x.f()</code> 其实就相当于 <code>MyClass.f(x)</code>。</p><p>我们可以构建一个例子关于f的直接引用和实例对象的方法引用，如下代码所展示的</p><pre><code class="language-python">&gt;&gt;&gt;y = Complex.f&gt;&gt;&gt;y&lt;function Complex.f at 0x000002A8D1C23910&gt;</code></pre><p>可以看到直接使用类对象的f引用结果变成了一个函数对象。图像右侧可以看到</p><p><img src="https://s2.loli.net/2023/11/28/Fi3L5f7CmOhurPk.png" alt="image-20231128200522921"></p><p>那如果我们打印一个上文中<code>x.f</code>呢？</p><p><img src="https://s2.loli.net/2023/11/28/oZXjEUHLR51MO79.png" alt="image-20231128200731043"></p><p>这就是二者的核心区别，如果我们直接调用y，他就会因为缺少参数而无法运行：</p><p><img src="https://s2.loli.net/2023/11/28/zl25Kf9Cs4bxdwI.png" alt="image-20231128200824816"></p><p>当然到这里你会更迷惑了，那么一个实例的方法的调用过程是什么呢？</p><p>当对实例对象进行属性引用时，如果该属性在实例中无法找到，将搜索实例所属的类。如果被引用的属性名称表示一个有效的类属性中的函数对象，会打包两者（实例对象和查找到的函数对象）的指针到一个抽象对象，这个抽象对象就是方法对象。当用参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并用这个新参数列表调用相应的函数对象。</p><p>也就是说你本质上调用的是新参数列表的函数对象，当直接调用的时候新参数列表中没有实例对象（self实际上代之的是实例对象自己）而无法运行。</p><p>这也是类对象&amp;实例对象的区别，实际上二者底层实现不一样，功能不同。</p><p><img src="https://s2.loli.net/2023/11/28/5PotQHXh6DyxgWY.png" alt="image-20231128201202962"></p><p>可以看到Complex自己代表了一个命名空间，和x并不相同。</p><p><strong>任何一个作为类属性的函数都为该类的实例定义了一个相应方法</strong>。 <strong>注意的是这里是任何，也就是说任何符合带有self参数的引用的都只能作为方法来使用，这句话下面会解释</strong>。函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如，下面的代码实现了一个函数并将其添加到了类中：</p><pre><code class="language-python"># Function defined outside the classdef f1(self, x, y):    return min(x, x+y)class C:    f = f1    def g(self):        return 'hello world'    h = g</code></pre><p>现在 <code>f</code>、<code>g</code> 和 <code>h</code> 都 <code>C</code> 类的指向函数对象的属性，因此它们都是 <code>C</code> 实例的方法 — 其中 <code>h</code> 与 <code>g</code> 完全等价。 但请注意这种做法通常只会使程序的阅读者感到迷惑，这里只是展示其完全相同的结果。</p><p>也就是说在类空间中定义的函数对象，被转化成为了方法。实例化后以方法对象的形式调用。</p><p>那么这些函数对象能被调用吗？如何获取呢？</p><p><strong>实例方法对象也具有属性: <code>m.__self__</code> 就是带有 <code>m()</code> 方法的实例对象，而 <code>m.__func__</code> 则是该方法所对应的函数对象。</strong></p><p>举个例子可能会更好理解，在上文代码的基础上做一些简单的修改：</p><pre><code class="language-python">class SonClass(FatherClass):    def __init__(self):        super(SonClass, self).__init__()        print('This is son init')    def method(self, son_value):        # super(SonClass, self).method()        print('son_value is ' + son_value)        print("This is a son method")        print(self)        # print(self.y)        son = SonClass()m = son.methodprint(m.__self__)func = m.__func__print(func('self', son_value='func_test'))</code></pre><p>注意的是，这里修改了method方法，取消了内部所有对self的引用，至于为什么接下来会说，我们在下边调用了<code>m = son.method</code>来获取<strong>实例对象的方法对象</strong>，简称<strong>实例方法对象</strong>，输出两个属性，并通过<code>__func__</code>来获取其函数对象，最后通过<code>func('self', son_value='func_test')</code>来实现调用函数对象。</p><p>输出结果如下：</p><pre><code class="language-shell">This is son init&lt;__main__.SonClass object at 0x000001526B98FA00&gt;son_value is func_testThis is a son methodself</code></pre><p>这里再解释一下为什么要取消self的调用，很简单函数对象并没有继承关系，也不会获取self对象到底是什么，是否是实例对象，所以这里使用字符串来作为参数，输出结果就是self字符。</p><p>若果包含self参数调用，会是什么样呢？报错如下：</p><pre><code class="language-shell">Traceback (most recent call last):  File "D:\SafeZone\PythonProjects\ICS_4\main.py", line 52, in &lt;module&gt;    print(func('self', son_value='func_test'))  File "D:\SafeZone\PythonProjects\ICS_4\main.py", line 33, in method    super(SonClass, self).method()TypeError: super(type, obj): obj must be an instance or subtype of type</code></pre><h4><span id="252类对象amp实例对象的区别">2.5.2类对象&amp;实例对象的区别</span></h4><p>一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:</p><pre><code class="language-python">class Dog:    kind = 'canine'         # class variable shared by all instances    def __init__(self, name):        self.name = name    # instance variable unique to each instance&gt;&gt;&gt; d = Dog('Fido')&gt;&gt;&gt; e = Dog('Buddy')&gt;&gt;&gt; d.kind                  # shared by all dogs'canine'&gt;&gt;&gt; e.kind                  # shared by all dogs'canine'&gt;&gt;&gt; d.name                  # unique to d'Fido'&gt;&gt;&gt; e.name                  # unique to e'Buddy'</code></pre><p>正如 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-object">名称和对象</a> 中已讨论过的，共享数据可能在涉及 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-mutable">mutable</a> 对象例如列表和字典的时候导致令人惊讶的结果。 例如以下代码中的 <em>tricks</em> 列表不应该被用作类变量，因为所有的 <em>Dog</em> 实例将只共享一个单独的列表,也就是说所有可变变量不应该放到类中。正如下下面的例子中：</p><pre><code class="language-python">class Dog:    tricks = []             # mistaken use of a class variable    def __init__(self, name):        self.name = name    def add_trick(self, trick):        self.tricks.append(trick)&gt;&gt;&gt; d = Dog('Fido')&gt;&gt;&gt; e = Dog('Buddy')&gt;&gt;&gt; d.add_trick('roll over')&gt;&gt;&gt; e.add_trick('play dead')&gt;&gt;&gt; d.tricks                # unexpectedly shared by all dogs['roll over', 'play dead']</code></pre><p>这里回到本小节开头的那句话：</p><p>每个值都是一个对象，因此具有 <em>类</em> （也称为 <em>类型</em>），并存储为 <code>object.__class__</code> 。</p><p>我们上文代码中的打印所有的对象的Class：</p><p><img src="https://s2.loli.net/2023/11/28/gAqiwv28jPy4VDL.png" alt="image-20231128204036052"></p><p>有趣的是Class的类型是type，这就非常有趣了，至于为什么可以参考：</p><p><a href="https://www.zhihu.com/question/349522986">在 Python 中，为什么 type 类对象自身的类型是 type？ - 知乎 (zhihu.com)</a></p><h2><span id="3继承">3.继承</span></h2><p>终于讨论到最有趣的地方的了，Python是我接触的第一个动态语言和多继承语言，当然，如果不支持继承，语言特性就不值得称为“类”。单继承的语言类似Java系，继承很好理解，Python的多继承将会是我们讨论的重点，我们不妨先从单继承的视角来看它的继承。</p><p>子（派生）类的语法定义如下：</p><pre><code class="language-python">class DerivedClassName(BaseClassName):    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;</code></pre><p>当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。这只是针对单继承的基本查找规则，多继承相对更加复杂一点，后面会着重讨论。</p><h3><span id="31派生类的实例化">3.1派生类的实例化</span></h3><p>派生类的实例化没有任何特殊之处: <code>DerivedClassName()</code> 会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。</p><p>上边的是官方的文档，实际上什么也没说，和狗屁一样，我们不如实际一点，通过几个例子来详细说明，派生类实例化会涉及到什么，应用的时候应该注意什么。</p><p>3.1.1<code>__init__</code>会怎么调用?</p><pre><code class="language-python">class FatherClass(object):    def __init__(self):        print('This is father init')    def method(self):        print("This is a father method")class SonClass(FatherClass):    # def __init__(self):    #     #super(SonClass,self).__init__()    #     print('This is son init')    def method(self):        print("This is a son method")son = SonClass()print(son.__class__)son.method()</code></pre><p>代码的输出：</p><pre><code class="language-python">This is father init&lt;class '__main__.SonClass'&gt;This is a son method</code></pre><p>可以看到子类初始化的时候没有显式指定<code>__init__</code>，就会默认调用父类的<code>__init__</code>。</p><p>如果我们显式的指定<code>__init__</code>会有什么后果？我们将注释去掉，结果如下：</p><p>注意的是这里的super行仍有注释存在。</p><pre><code class="language-python">This is son init&lt;class '__main__.SonClass'&gt;This is a son method</code></pre><p>这里就要引出<code>super()</code>方法了，这里先不说名为什么要用super()，以及super()是如何实现的，我们就先姑且把它当作父类实例的代指函数，通过他就可以调用父类的对象。</p><p>我们把对应的super注释去掉，看看结果会如何：</p><pre><code class="language-python">This is father initThis is son init&lt;class '__main__.SonClass'&gt;This is a son method</code></pre><p>可以看到父类的<code>__init__</code>方法也被调用了。</p><p>上述的内容可以一句话总结一下：</p><p>子类没有显式指定的时候，会自动调用父类的init，子类显示指定的时候也要显式调用父类的init。</p><p>需要补充的是，在没有显式指定的时候，父类的实例变量并无法访问，之恩那个访问到对应的父类的类变量。修改上文的代码后，来验证这个内容：</p><pre><code class="language-python">class FatherClass(object):    y = 'father class variable'    def __init__(self):        self.x = 'father variable'        print('This is father init')    def method(self):        print("This is a father method")class SonClass(FatherClass):    def __init__(self):        #super(SonClass, self).__init__()        print('This is son init')    def method(self):        print("This is a son method")son = SonClass()print(son.__class__)print(son.y)print(son.x)son.method()</code></pre><p>结果如下：</p><pre><code class="language-shell">This is son init&lt;class '__main__.SonClass'&gt;father class variableTraceback (most recent call last):  File "D:\SafeZone\PythonProjects\ICS_4\main.py", line 25, in &lt;module&gt;    print(son.x)AttributeError: 'SonClass' object has no attribute 'x'</code></pre><h3><span id="32派生类方法的扩展与重载">3.2派生类方法的扩展与重载</span></h3><p>重载派生类的方法很简单，只需要直接修改参数内容即可：</p><p>如下代码所示，重载了对应的method方法：</p><pre><code class="language-python">class FatherClass(object):    y = 'father class variable'    def __init__(self):        self.x = 'father variable'        print('This is father init')    def method(self):        print("This is a father method")class SonClass(FatherClass):    def __init__(self):        super(SonClass, self).__init__()        print('This is son init')    def method(self, son_value):        print('son_value is ' + son_value)        print("This is a son method")son = SonClass()print(son.__class__)print(son.y)print(son.x)son.method('mother fucker')</code></pre><p>输出结果如下：</p><pre><code class="language-shell">This is father initThis is son init&lt;class '__main__.SonClass'&gt;father class variablefather variableson_value is mother fuckerThis is a son method</code></pre><p>扩展就更加简单，只需要通过super来调用父类，即可接着父类方法来实现续写：</p><pre><code class="language-python">    def method(self, son_value):        super(SonClass, self).method()        print('son_value is ' + son_value)        print("This is a son method")</code></pre><p>输出结果如下：</p><pre><code class="language-python">father class variablefather variableThis is a father methodson_value is mother fuckerThis is a son method</code></pre><h3><span id="33-super函数详解">3.3 super()函数详解</span></h3><p>上文中所有super的写法我都依照python2的写法来实现的，实际上python3对于super有了更简便的写法，如下所示：</p><pre><code class="language-python">super(SonClass, self).method()#python 2super().method()#python 3</code></pre><p>这两个关键的参数被省略了，这对新手来说是一个很方便的事情，但是参数的省略带来信息的丢失，总是让人很迷茫，super到底的作用是什么？同时有很多python3的代码也采用了python2的写法（python3 对这个是兼容的）</p><p>那么不禁让人提问 ：super是如何工作的？两个参数的作用是什么呢？</p><p>super的定义如下：</p><pre><code class="language-python">class super(type, object_or_type=None)返回一个代理对象，它会将方法调用委托给 type 的父类或兄弟类。 这对于访问已在类中被重载的继承方法很有用。</code></pre><p>type这里只是一个参数名称，如果你要问和type有什么关系，不要忘记了所有class的类型是type，也就是说这里要填一个类对象进去。</p><p>对于后一个参数的理解就更加简单了，填入一个<strong>实例对象</strong>或者<strong>类对象</strong>即可。</p><p>那对这两个参数填入的内容已经有大概的了解，那么这两个参数到底有什么用？</p><p>这两参数被用来实例化super类，对没错。super是一个类对象：</p><pre><code class="language-python">&gt;&gt;&gt;super.__class__&lt;class 'type'&gt;&gt;&gt;&gt;class A:pass&gt;&gt;&gt;super(A).__class__&lt;class 'super'&gt;</code></pre><p>实例化之后将会返回代理对象，代理的就是他的祖先类的对象（可按照顺序调用各种祖先类对象，具体按照什么顺序稍后会解释）。它会将方法调用委托给 <em>type</em> 的父类或兄弟类。</p><p><em>object_or_type</em> 确定要用于搜索的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-method-resolution-order">method resolution order</a>。 搜索会从 <em>type</em> 之后的类开始。</p><p><strong>MRO</strong> 指的是 type(<strong>object_or_type</strong>)的 MRO, MRO 中的那个类就是 <strong>type</strong>。注意这里使用粗体的指的是参数，前边的type为python内置函数。</p><p>也就是说，object_or_type用于确定在哪一颗祖先树上进行搜索，因为Python是多继承的(这里还没有讲多继承是如何实现的，不过没关系，可以从真实世界的族谱上理解一下)，所以其继承关系会构建出来一颗祖先树。</p><p>在早期python的经典类结构，也就是python2中MRO遵循的是从左到右，深度优先，但是在2.2版本后多继承遵循了C3算法，详细可参考：<a href="https://www.python.org/download/releases/2.3/mro/">The Python 2.3 Method Resolution Order | Python.org</a>里面详细论述了python是如何实现MRO，考虑到文章的长度，在以后会单独写一篇关于继承顺序的文章，这里可以先看一下参考文献。</p><p>举一个简单的例子：</p><p>For example, if <a href="https://docs.python.org/3/library/stdtypes.html#class.__mro__"><code>__mro__</code></a> of <em>object_or_type</em> is <code>D -&gt; B -&gt; C -&gt; A -&gt; object</code> and the value of <em>type</em> is <code>B</code>, then <a href="https://docs.python.org/3/library/functions.html#super"><code>super()</code></a> searches <code>C -&gt; A -&gt; object</code>。</p><p>想要了解某一个类的MRO情况可以通过__mro__属性来获取：</p><pre><code class="language-python">print(SonClass.__mro__)输出：(&lt;class '__main__.SonClass'&gt;, &lt;class '__main__.FatherClass'&gt;, &lt;class '__main__.UncleClass'&gt;, &lt;class 'object'&gt;)</code></pre><p>这里再介绍一下两个内置函数，这两个内置函数用来测试是否满足的super的参数条件。</p><ul><li>使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#isinstance"><code>isinstance()</code></a> 来检查一个实例的类型: <code>isinstance(obj, int)</code> 仅会在 <code>obj.__class__</code> 为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a> 或某个派生自 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a> 的类时为 <code>True</code>。简单来说作用是检测实例是否是某一个类子类的实例对象。</li><li>使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#issubclass"><code>issubclass()</code></a> 来检查类的继承关系: <code>issubclass(bool, int)</code> 为 <code>True</code>，因为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#bool"><code>bool</code></a> 是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a> 的子类。 但是，<code>issubclass(float, int)</code> 为 <code>False</code>，因为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#float"><code>float</code></a> 不是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a> 的子类。 检测class对象是否为某一个类对象的子类。</li></ul><p>实际上super的参数还有另一种情况，当object_or_type 输入类型也是type的时候，就需要满足issubclass为true的条件，这时候super的调用就成了这样：</p><pre><code class="language-python">super(type1, type2)</code></pre><p>MRO 指的是 <strong>type2</strong> 的 <strong>MRO</strong>, <strong>MRO</strong> 中的那个类就是 <strong>type1</strong> ，同时 <strong>issubclass(type2, type1) == True</strong> 。</p><p>那么， <strong>super()</strong> 实际上做了啥呢？简单来说就是：提供一个 <strong>MRO</strong> 以及一个 <strong>MRO</strong> 中的类 <strong>C</strong> ， <strong>super()</strong> 将返回一个从 <strong>MRO</strong> 中 <strong>C</strong> 之后的类中查找方法的对象。</p><p>那是不是意味着我们也可以这样写，写了之后会有什么效果呢？</p><p>这样调用会有什么结果呢？我们再举一个例子，在上文的代码中扩充添加一个TestClass类，他是最底层的类，是所有类的子类：</p><pre><code class="language-python">class FatherClass(object):    y = 'father class variable'    def __init__(self):        self.x = 'father variable'        print('This is father init')    def method(self):        print("This is a father method")    def function():        print('This is a father function')class SonClass(FatherClass):    def __init__(self):        super(SonClass, self).__init__()        print('This is son init')    def method(self, son_value):        super(SonClass, self).method()        print('son_value is ' + son_value)        print("This is a son method")class TestClass(SonClass):    def __init__(self):        super().__init__()    def metod(self):        pass</code></pre><p>然后进行调用：</p><pre><code class="language-python">son = SonClass()print(super(SonClass, TestClass).y)</code></pre><p>输出结果：</p><pre><code class="language-shell">This is father initThis is son initfather class variable</code></pre><p>可以看到他直接找到了父类作为调用对象，并输出了对应的y属性，需要注意的是这里无法针对方法对象来实现，原因很简单，并没有self参数作为载体，来进行方法的调用。记住上文说的：<strong>任何一个作为类属性的函数都为该类的实例定义了一个相应方法</strong>。不能把它作为函数对象来调用。</p><h3><span id="34私有变量">3.4私有变量</span></h3><p>那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。这也算是设计特点， 但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 <code>_spam</code>) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。</p><p>但是这样并不是很有效的操作，例如避免名称与子类所定义的名称相冲突，即使去使用 <code>_spam</code>的形式也是不合理的，子类仍能继承到，因此Python存在一个机制，叫做<strong>名称改写</strong>。</p><h3><span id="341名称改写">3.4.1名称改写</span></h3><p>形式为 <code>__spam</code> 的标识符，至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。</p><p>这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。</p><p>举个例子：如何使用私有变量进行解耦合</p><pre><code class="language-python">class FatherClass(object):    __y = 'father class variable'    def __init__(self):        self.x = 'father variable'        print('This is father init')        self.method()    def method(self):        print("This is a father method")</code></pre><p>可以看到 父类这里的init和method进行了耦合，init依赖于 method。产生了耦合</p><p>子类继承的时候无法重写method方法，如果重写了就会报错：</p><p>子类定义如下：</p><pre><code class="language-python">class SonClass(FatherClass):    def __init__(self):        super(SonClass, self).__init__()        print('This is son init')    def method(self, son_value):        super(SonClass, self).method()        print('son_value is ' + son_value)        print("This is a son method")</code></pre><p>报错信息如下：</p><pre><code class="language-shell">Traceback (most recent call last):  File "D:\SafeZone\PythonProjects\ICS_4\main.py", line 33, in &lt;module&gt;    son = SonClass()  File "D:\SafeZone\PythonProjects\ICS_4\main.py", line 16, in __init__    super(SonClass, self).__init__()  File "D:\SafeZone\PythonProjects\ICS_4\main.py", line 7, in __init__    self.method()TypeError: SonClass.method() missing 1 required positional argument: 'son_value'This is father init</code></pre><p>如何进行解耦合呢？</p><pre><code class="language-python">class FatherClass(object):    __y = 'father class variable'    def __init__(self):        self.x = 'father variable'        print('This is father init')        self.__method()    def method(self):        print("This is a father method")    __method = method</code></pre><p>修改父类如上，使用名称改写来实现其解耦，子类无法直接调用到方法__y，实际上被替换为<code>_FatherClass__method()</code> ,不要没事调用他。</p><p>上面的示例即使在 <code>SonClass</code> 引入了一个 <code>__update</code> 标识符的情况下也不会出错，因为它会在 <code>FatherClass</code> 类中被替换为 <code>_FatherClass__update</code> 而在 <code>MappingSubclass</code> 类中被替换为 <code>_MappingSubclass__update</code>。</p><h2><span id="4dataclass">4.dataclass</span></h2><p>有时候需要一些数据类型类似C的struct结构的，需要糅合一部分数据在一起，Python提供了预实现模块<strong>dataclasses</strong>，</p><p>我们引用就可以了，举个例子：</p><pre><code class="language-python">from dataclasses import dataclass@dataclassclass Chinese:    name: str    money: str    appearance: str    theone:bool</code></pre><p>如何使用呢？</p><pre><code class="language-python">neonexus = Chinese('neonexus',money=0,appearance='normal',theone=False)print(neonexus.theone)</code></pre><p>输出结果：</p><pre><code class="language-python">&lt;super: &lt;class 'SonClass'&gt;, &lt;TestClass object&gt;&gt;False</code></pre><h1><span id="参考文章">参考文章：</span></h1><p><a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">Python’s super() considered super! | Deep Thoughts by Raymond Hettinger (wordpress.com)</a></p><p><a href="https://sixty-north.com/blog/pythons-super-not-as-simple-as-you-thought.html">Good With Computers (sixty-north.com)</a></p><p><a href="https://www.runoob.com/w3cnote/python-super-detail-intro.html">Python super 详解 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__">3. 数据模型 — Python 3.12.0 文档</a></p><p><a href="https://docs.python.org/zh-cn/2.7/reference/datamodel.html?highlight=__init__#object.__init__">3. 数据模型 — Python 2.7.18 文档</a></p><p><a href="https://docs.python.org/zh-cn/3/library/functions.html#super">内置函数 — Python 3.12.0 文档</a></p><p><a href="https://docs.python.org/zh-cn/3/tutorial/classes.html">9. 类 — Python 3.12.0 文档</a></p><p><a href="https://docs.python.org/zh-cn/2.7/tutorial/classes.html">9. 类 — Python 2.7.18 文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch——基础指北_壹</title>
      <link href="/2024/09/28/pytorch_1/"/>
      <url>/2024/09/28/pytorch_1/</url>
      
        <content type="html"><![CDATA[<h1><span id="pytorch基础指北_壹">Pytorch——基础指北_壹</span></h1><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><h2><span id="软件环境"><strong>软件环境：</strong></span></h2><ul><li><strong>pytorch 1.10</strong></li><li><strong>pycharm</strong></li><li><strong>CUDA 10.2</strong></li></ul><!-- toc --><ul><li><a href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">一些基础知识：</a><ul><li><a href="#python%E7%9A%84%E5%88%87%E7%89%87">python的切片</a></li><li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%87%E7%89%87">二维数组的切片</a></li></ul></li><li><a href="#tensor">Tensor:</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">如何使用</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="一些基础知识">一些基础知识：</span></h2><h3><span id="python的切片">python的切片</span></h3><p>一个完整的切片表达式包含两个“:”，用于分隔三个参数(start_index、end_index、step)。当只有一个“:”时，默认第三个参数step=1；当一个“:”也没有时，start_index=end_index，表示切取start_index指定的那个元素。</p><pre><code class="language-python">Array[start_index:end_index:step]</code></pre><p><strong>step</strong>：正负数均可，其绝对值大小决定了切取数据时的 ‘‘步长”，<strong>而正负号决定了“切取方向”</strong>，正表示 “<strong>从左往右</strong>”取值，负表示“<strong>从右往左</strong>”取值。当step省略时，默认为1，即从左往右以步长1取值。</p><p><strong>start_index</strong>：表示起始索引（包含该索引对应值）；该参数省略时，<strong>表示从对象“端点”开始取值</strong>，至于是从“起点”还是从“终点”开始，则由step参数的正负决定，step为正从“起点”开始，为负从“终点”开始。</p><p><strong>end_index</strong>：表示终止索引（不包含该索引对应值）；该参数省略时，表示一直取到<strong>数据“端点”</strong>，至于是到“起点”还是到“终点”，同样由step参数的正负决定，step为正时直到“终点”，为负时直到“起点”。</p><p>举例：</p><pre><code class="language-python">&gt;&gt;&gt; array([0,1,2,3,4,5,6,7,8,9])&gt;&gt;&gt; array[-1:-6:-1]&gt;&gt;&gt; [9, 8, 7, 6, 5]step=-1，从右往左取值，start_index=-1到end_index=-6同样是从右往左取值。</code></pre><h3><span id="二维数组的切片">二维数组的切片</span></h3><p>​多维的切片是在中括号中用逗号运算符, 将不同维上的操作分开，分割开后每个维度上单独操作即可。</p><pre><code class="language-python">&gt;&gt;&gt; array = np.array([[1,2,3,4],[5,6,7,8]])&gt;&gt;&gt; array[1:3,2:3]array([[7]])&gt;&gt;&gt; array[0:3,2:3]array([[3],       [7]])</code></pre><h2><span id="tensor">Tensor:</span></h2><p>在深度学习里，Tensor实际上就是一个多维数组（multidimensional array）。而Tensor的目的是能够创造更高维度的矩阵、向量。<br>作为初学者的一些想法：<a href="https://zhuanlan.zhihu.com/p/48982978">Tensor的描述</a></p><h3><span id="如何使用">如何使用</span></h3><p>例子 A:<br>随机生成一个<strong>张量</strong></p><pre><code class="language-python">import torcha = torch.rand(2,2);print(a)&gt;&gt;&gt; tensor([[0.8105, 0.5156],        [0.4006, 0.7924]])</code></pre><p>例子 B:</p><p>生成一个全是1的张量</p><pre><code class="language-PYTHON">b = torch.ones(2, 2)print(b)&gt;&gt;&gt; tensor([[1., 1.],        [1., 1.]])</code></pre><p>例子 C:</p><p>生成一个全是1的张量，且指定类型是<strong>double</strong></p><pre><code class="language-python">c = torch.ones(2, 2, dtype=torch.double)print(c)&gt;&gt;&gt; tensor([[1., 1.],        [1., 1.]], dtype=torch.float64)</code></pre><p>例子 D:</p><p>通过Python List 生成一个张量</p><pre><code class="language-python">d = torch.tensor([2.5, 0.1, 1, 1])print(d)&gt;&gt;&gt; tensor([2.5000, 0.1000, 1.0000, 1.0000])</code></pre><p>例子 E:</p><p>直接累加</p><pre><code class="language-python">e = torch.rand(2, 2)print(e)e.add_(b)print(e)&gt;&gt;&gt;tensor([[0.6713, 0.2451],        [0.5231, 0.4814]])tensor([[1.6713, 1.2451],        [1.5231, 1.4814]])</code></pre><p>例子 E_2:</p><p>直接累乘</p><pre><code class="language-python">e.mul_(a)print(e)&gt;&gt;&gt; tensor([[1.3954, 0.9191],        [0.4332, 0.2947]])</code></pre><p>例子 F:</p><p>对 张量 进行切片</p><pre><code class="language-PYTHON">f = e[:1, 0].item()print(f)&gt;&gt;&gt; 1.3954157829284668</code></pre><p>例子 G:</p><p>重构张量会根据重构大小自我调整 如下 <strong>2 * 2</strong>  变换为  <strong>1*4</strong></p><pre><code class="language-python">g = e.view(4)print(g)&gt;&gt;&gt; tensor([1.3954, 0.9191, 0.4332, 0.2947])</code></pre><p>例子 H:</p><p>将一个张量转换成numpy的一个list ，可以发现其指向的是同一个区域内存，修改其中一个另一个也会跟着改变。</p><pre><code class="language-python">h = g.numpy()print(type(h))print(h)g.add_(1)print(g)print(h)&gt;&gt;&gt;&lt;class 'numpy.ndarray'&gt;[1.3954158  0.91908276 0.4331597  0.29474875]tensor([2.3954, 1.9191, 1.4332, 1.2947])[2.3954158 1.9190828 1.4331597 1.2947488]</code></pre><p>例子 特殊:</p><p>torch 只支持在同一个设备内存下的运算，只有当默认情况下处于cpu状态的转换到GPU才可进行运算，转换是个很消耗时间的方法。值得一提的是numpy只允许在cpu内存运行。</p><pre><code class="language-python">if torch.cuda.is_available():    #numpy only support cpu    device = torch.device("cuda")    h = torch.ones(5, device=device)    i = torch.ones(5)    i = i.to(device)    i = i.add_(h)    print(i)&gt;&gt;&gt; tensor([2., 2., 2., 2., 2.], device='cuda:0')#转换至CUDA</code></pre><p>新补充：</p><p>torch.max</p><p>在分类问题中，通常需要使用<code>max()</code>函数对<code>softmax</code>函数的输出值进行操作，求出预测值索引，然后与标签进行比对，计算准确率。下面讲解一下<code>torch.max()</code>函数的输入及输出值都是什么，便于我们理解该函数。</p><pre><code>output = torch.max(input, dim)</code></pre><blockquote><p>输入</p><ul><li><code>input</code>是softmax函数输出的一个<code>tensor</code></li><li><code>dim</code>是max函数索引的维度<code>0/1</code>，<code>0</code>是每列的最大值，<code>1</code>是每行的最大值</li></ul></blockquote><blockquote><p>输出</p><ul><li>函数会返回两个<code>tensor</code>，第一个<code>tensor</code>是每行的最大值；第二个<code>tensor</code>是每行最大值的索引。</li></ul></blockquote><p>在多分类任务中我们并不需要知道各类别的预测概率，所以返回值的第一个<code>tensor</code>对分类任务没有帮助，而第二个<code>tensor</code>包含了预测最大概率的索引，所以在实际使用中我们仅获取第二个<code>tensor</code>即可。</p><p>例子：</p><p>输出每行的最大值和其</p><pre><code class="language-python">&gt;&gt;&gt;t1 = torch.tensor([[1,2,3,4],[5,6,7,8],[9,10,11,12]])&gt;&gt;&gt;print(t1.data.max(1,keepdim = True))torch.return_types.max(                        values=tensor([[4],                                [ 8],                                [12]]),                        indices=tensor([[3],                                [3],                                [3]]))</code></pre><p>运行一些操作可能会导致新结果分配到了新内存</p><p>参考文献：</p><p><a href="https://www.youtube.com/watch?v=c36lUUr864M">youtobe教程（需要科学上网）有需要搬运联系我 </a></p>]]></content>
      
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch--基础指北_叁</title>
      <link href="/2024/09/28/pytorch_3/"/>
      <url>/2024/09/28/pytorch_3/</url>
      
        <content type="html"><![CDATA[<h1><span id="pytorch基础指北_叁">Pytorch——基础指北_叁</span></h1><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><h2><span id="软件环境">软件环境：</span></h2><ul><li><strong>pytorch 1.10</strong></li><li><strong>pycharm</strong></li><li><strong>CUDA 10.2</strong></li></ul><!-- toc --><ul><li><a href="#%E7%A5%9E%E7%BB%8F%E5%85%83%E5%92%8C%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0">神经元和激活函数</a><ul><li><a href="#%E6%84%9F%E7%9F%A5%E6%9C%BA">感知机</a></li><li><a href="#%E5%A4%9A%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">多层神经网络</a></li><li><a href="#%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0">激活函数</a><ul><li><a href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98">非线性二分类问题</a></li><li><a href="#%E5%A4%9A%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-1">多层神经网络</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="神经元和激活函数">神经元和激活函数</span></h2><p>激活函数决定是否传递信号。在这种情况下，只需要带有一个参数（阈值）的简单阶梯函数。现在，当我们学习了一些新的东西（或未学习到什么）时，一些神经元的阈值和突触权值会发生改变。这使得神经元之间产生新的连接，大脑学会新的东西。</p><p>1943 年，McCulloch 和 Pitts 将上述情形抽象为上图所示的简单模型，这就是一直沿用至今的 <strong>M-P 神经元模型</strong>。把许多这样的神经元按一定的层次结构连接起来，就得到了神经网络。</p><p>一个简单的神经元如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/Pda1OKYh6Lf8rcV.png" alt="神经元"></p><p>其中：</p><ol><li>$a_1,a_2\dots a_n$ 为各个输入的分量</li><li>$w_1,w_2 \cdots w_n$ 为各个输入分量对应的权重参数</li><li>$b$ 为偏置</li><li>$f$ 为<strong>激活函数</strong>，常见的激活函数有tanh，sigmoid，relu</li><li>$t$ 为神经元的输出</li></ol><p>使用数学公式表示就是：<br>$$<br>t = f(W^TA+b)<br>$$<br>其中$W^T$是表示矩阵的转置，将矩阵的行列互换得到的新矩阵称为转置矩阵，转置矩阵的行列式不变。</p><p>转置矩阵有四个性质：<br>$$<br>(M^T)^T = M\<br>(M+N)^T = M^T + N^T\<br>(kM)^T = kM^T\<br>(MN)^T =N^TM^T<br>$$<br>可见，<strong>一个神经元的功能是求得输入向量与权向量的内积后，经一个非线性传递函数得到一个标量结果</strong>。这里的转置是为了保持点积结果。</p><h3><span id="感知机">感知机</span></h3><p>感知机由<strong>两层神经网</strong>络组成，<strong>输入层</strong>接收外界输入信号后传递给<strong>输出层（输出+1正例，-1反例）</strong>，输出层是 M-P 神经元。</p><p><img src="https://s2.loli.net/2024/09/29/xVQSYu7MWkFywem.png" alt="感知机"></p><p><strong>感知机的作用：</strong></p><p>把一个n维向量空间用一个超平面分割成两部分，给定一个输入向量，超平面可以判断出这个向量位于超平面的哪一边，得到输入时正类或者是反类，当输入只有$X1X2$的情况下（输入一个坐标点），<strong>其输出就是对应到2维空间就是通过一条直线把一个平面分为两个部分的判断结果（输出在哪一个部分）</strong>。这本质上就是一个二分类模型。</p><h3><span id="多层神经网络">多层神经网络</span></h3><p>多层神经网络就是由单层神经网络进行叠加之后得到的，所以就形成了<strong>层</strong>的概念，常见的多层神经网络有如下结构：</p><ul><li>输入层（Input layer），众多神经元（Neuron）接受大量输入消息。输入的消息称为输入向量。</li><li>输出层（Output layer），消息在神经元链接中传输、分析、权衡，形成输出结果。输出的消息称为输出向量。</li><li>隐藏层（Hidden layer），简称“隐层”，是输入层和输出层之间众多神经元和链接组成的各个层面。隐层可以有一层或多层。隐层的节点（神经元）数目不定，但数目越多神经网络的非线性越显著，从而神经网络的强健性（robustness）更显著。</li></ul><p>全连接层：</p><p>全连接层：当前一层和前一层每个神经元相互链接，我们称当前这一层为全连接层。</p><p>思考：假设第N-1层有m个神经元，第N层有n个神经元，当第N层是全连接层的时候，则N-1和N层之间有1，这些参数可以如何表示？</p><p><img src="https://s2.loli.net/2024/09/29/7JPy4DHw9TCIWez.png" alt="全连接层"></p><p>从上图可以看出，<strong>全连接层实际上就是进行一次$Y=Wx+b$的变化，并将其从N维变换到M维</strong>，</p><h3><span id="激活函数">激活函数</span></h3><h4><span id="非线性二分类问题">非线性二分类问题</span></h4><p>假设我们有这样一组数据，三角形和四边形，需要把他们分为两类</p><p><img src="https://s2.loli.net/2024/09/29/YpzwDkMPVKXSqH4.png" alt="激活函数1"></p><p>通过不带激活函数的感知机模型我们可以划出一条线, 把平面分割开</p><p><img src="https://s2.loli.net/2024/09/29/Cg3flkTIQ9MjYXt.png" alt="激活函数2"></p><p>假设我们确定了参数w和b之后，那么带入需要预测的数据，如果<strong>y&gt;0</strong>,我们认为这个点在直线的右边，也就是<strong>正类（三角形）</strong>，<strong>否则是在左边（四边形）</strong>。但实际上这样解决并不是完美的，有个别蓝色方块会被识别成三角形。</p><h4><span id="多层神经网络">多层神经网络</span></h4><p>如果一层网络没办法解决那么在前面的感知机模型中再增加一层会怎么样呢？</p><p>如图添加一层隐藏层：</p><p><img src="https://s2.loli.net/2024/09/29/thSqVGgwQB2CJuk.png" alt="激活函数3"></p><p>对上图中的等式进行合并，我们可以得到：<br>$$<br>y = (w_{1-11}w_{2-1}+\cdots)x_1+(w_{1-21}w_{2-1}+\cdots)x_2 + (w_{2-1}+\cdots)b_{1-1}<br>$$<br>实际上可以发现其还是保持得着线性的模式，这里需要补充一下什么是线性什么是非线性，</p><p><strong>线性：</strong></p><ol><li>可加性：L(x+t)=L(x)+L(t)</li><li>一次齐次性：L(mx)=mL(x)</li></ol><p>但是如果此时，我们在前面感知机的基础上加上<strong>非线性的激活函数</strong>之后，输出的结果就不在是一条直线。</p><p><img src="https://s2.loli.net/2024/09/29/KS1mIZYQ3q98tru.png" alt="激活函数4"></p><p>如上图，右边是sigmoid函数，对感知机的结果，通过sigmoid函数进行处理，如果给定合适的参数w和b，就可以得到合适的曲线，能够完成对最开始问题的非线性分割。所以激活函数很重要的一个<strong>作用</strong>就是<strong>增加模型的非线性分割能力</strong>。我们可以通过调整W和B的大小来实现目标曲线的样子，如果单一一层无法满足要求就需要增加多层来实现目标。</p><p>常见的激活函数有：</p><p><img src="https://s2.loli.net/2024/09/29/vOCSckqWXtLzrFB.jpg" alt="激活函数5"><br>$$<br>常用的三种激活函数：\<br>Sigmod \in (0,1)\<br>tanh \in (-1,1)\与Sigmod不同的是可以输出负数<br>ReLu \in (0,x)\<br>$$<br>当然激活函数含有这些效果</p><p>这些以后再说：</p><ul><li><strong>提高模型鲁棒性</strong></li><li><strong>缓解梯度消失问题</strong></li><li><strong>加速模型收敛等</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch--基础指北_肆</title>
      <link href="/2024/09/28/pytorch_4/"/>
      <url>/2024/09/28/pytorch_4/</url>
      
        <content type="html"><![CDATA[<h1><span id="pytorch-基础指北_肆">Pytorch ——基础指北_肆</span></h1><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><!-- toc --><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83">软件环境：</a></li><li><a href="#%E9%85%8D%E5%A5%97%E4%BB%A3%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80">配套代码下载地址：</a></li><li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识：</a><ul><li><a href="#%E4%B8%80%E7%82%B9python">一点Python</a><ul><li><a href="#python%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">Python的面向对象</a></li><li><a href="#python%E7%9A%84self%E5%85%B3%E9%94%AE%E5%AD%97">Python的self关键字</a></li><li><a href="#python%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1">Python创建实例对象</a></li><li><a href="#python%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">Python类的方法</a></li><li><a href="#python%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">Python访问类的属性和方法</a></li><li><a href="#python%E5%86%85%E7%BD%AE%E7%B1%BB%E5%92%8C%E5%B1%9E%E6%80%A7">Python内置类和属性</a></li><li><a href="#python%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95">Python基础方法</a></li><li><a href="#python%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%8Eself%E5%8F%82%E6%95%B0">Python类的实例化与self参数</a><ul><li><a href="#self%E5%8F%82%E6%95%B0">self参数</a></li><li><a href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95">实例化的初始化方法</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%80%BC">初始化的同时设置初始值</a></li></ul></li><li><a href="#pyhton%E7%9A%84%E7%BB%A7%E6%89%BF">Pyhton的继承</a></li><li><a href="#pthony%E7%9A%84__-call__%E6%96%B9%E6%B3%95">Pthony的__ call__方法</a></li><li><a href="#%E5%8D%95%E4%B8%8B%E5%88%92%E7%BA%BF-%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF-%E5%A4%B4%E5%B0%BE%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E8%AF%B4%E6%98%8E">单下划线、双下划线、头尾双下划线的说明</a></li></ul></li></ul></li><li><a href="#pytorch-api-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B">Pytorch API 实现基础模型</a><ul><li><a href="#nnmodule">nn.Module</a><ul><li><a href="#nnmodule%E7%9A%84%E4%BD%BF%E7%94%A8">nn.Module的使用</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFbatch_size%E4%BB%80%E4%B9%88%E6%98%AFfeatures">什么是batch_size，什么是features？</a></li><li><a href="#torchoptim%E7%B1%BB">torch.optim类</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0%E5%92%8C%E4%BD%BF%E7%94%A8optimizer">如何构造和使用optimizer？</a></li><li><a href="#model%E7%9A%84%E5%8F%82%E6%95%B0"><strong>model</strong>的参数：</a></li><li><a href="#optimizer%E7%9A%84%E4%BD%BF%E7%94%A8">optimizer的使用：</a></li><li><a href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8">损失函数类的使用</a></li><li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E7%9A%84loss%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97">如何使用内置的loss函数的类来进行计算？</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="软件环境">软件环境：</span></h2><ul><li><strong>pytorch 1.10</strong></li><li><strong>pycharm</strong></li></ul><h2><span id="配套代码下载地址">配套代码下载地址：</span></h2><p><a href="https://gitee.com/jszszzy/pytorch-study">gitee-pytorch</a></p><h2><span id="基础知识">基础知识：</span></h2><h3><span id="一点python">一点Python</span></h3><h4><span id="python的面向对象">Python的面向对象</span></h4><pre><code class="language-python">class ClassName:   '类的帮助信息'#类文档字符串   class_suite #类体</code></pre><p>类的帮助信息可以通过ClassName.__ doc __查看。</p><p><strong>class_suite</strong> 由类成员，方法，数据属性组成。</p><h4><span id="python的self关键字">Python的self关键字</span></h4><p><strong>self</strong>代表类的实例，而非类。常用于在类的定义中指代对象。</p><h4><span id="python创建实例对象">Python创建实例对象</span></h4><p>实例化类其他编程语言中一般用关键字 <strong>new</strong>，但是在 <strong>Python</strong> 中并没有这个关键字，类的实例化类似函数调用方式。以下使用类的名称 <strong>Employee</strong> 来实例化，并通过 <strong>init</strong> 方法接收参数。</p><pre><code class="language-python">对象变量 = 类名()</code></pre><h4><span id="python类的方法">Python类的方法</span></h4><p>在类的内部，使用 <strong>def</strong> 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数。</p><h4><span id="python访问类的属性和方法">Python访问类的属性和方法</span></h4><p>可以使用点号 <strong>.</strong> 来访问对象的属性。使用如下类的名称访问类变量:</p><pre><code class="language-python">emp1.displayEmployee()emp2.displayEmployee()print "Total Employee %d" % Employee.empCount</code></pre><h4><span id="python内置类和属性">Python内置类和属性</span></h4><ul><li><strong>dict</strong> : 类的属性（包含一个字典，由类的数据属性组成）</li><li><strong>doc</strong> :类的文档字符串</li><li><strong>name</strong>: 类名</li><li><strong>module</strong>: 类定义所在的模块（类的全名是’<strong>main</strong>.<strong>className</strong>’，如果类位于一个导入模块<strong>mymod</strong>中，那么<strong>className</strong>.<strong>module</strong> 等于 <strong>mymod</strong>）</li><li><strong>bases</strong> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</li></ul><h4><span id="python基础方法">Python基础方法</span></h4><table><thead><tr><th>序号</th><th>方法名</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td><code>__new__(self)</code></td><td>方法</td><td><strong>创建对象</strong>时，会被 <strong>自动</strong> 调用</td></tr><tr><td>02</td><td><code>__ init__ ( self [,args...] )</code></td><td>方法</td><td><strong>对象被初始化</strong>时，会被 <strong>自动</strong> 调用</td></tr><tr><td>03</td><td><code>__del__(self)</code></td><td>方法</td><td><strong>对象被从内存中销毁</strong>前，会被 <strong>自动</strong> 调用</td></tr><tr><td>04</td><td><code>__str__(self)</code></td><td>方法</td><td>返回<strong>对象的描述信息</strong>，<code>print</code> 函数输出使用</td></tr></tbody></table><h4><span id="python类的实例化与self参数">Python类的实例化与self参数</span></h4><h5><span id="self参数">self参数</span></h5><ul><li>在 <strong>类的外部</strong>，通过 <code>变量名.</code> 访问对象的 <strong>属性和方</strong></li><li><strong>调用方法时</strong>，程序员不需要传递 <code>self</code> 参数</li><li>在方法内部，<code>self</code> 就表示 <strong>当前调用方法的对象自己</strong>，可以通过 <code>self.</code> <strong>访问对象的属性和方法</strong></li></ul><h5><span id="实例化的初始化方法">实例化的初始化方法</span></h5><ul><li>当使用 <code>类名()</code> 创建对象时，会 自动执行以下操作：<ol><li>为对象在内存中 <strong>分配空间</strong> —— 创建对象</li><li>为对象的属性 <strong>设置初始值</strong> —— 初始化方法(<code>init</code>)</li></ol></li><li>这个 <strong>初始化方法</strong> 就是 <code>__init__</code> 方法，<code>__init__</code> 是对象的<strong>内置方法</strong></li></ul><h5><span id="初始化的同时设置初始值">初始化的同时设置初始值</span></h5><ul><li><p>在开发中，如果希望在 创建对象的同时，就设置对象的属性，可以对 初始化方法进行</p><p>改造：</p><ol><li>把希望设置的属性值，定义成 <code>__init__</code> 方法的参数</li><li>在方法内部使用 <code>self.属性 = 形参</code> 接收外部传递的参数</li><li>在创建对象时，使用 <code>类名(属性1, 属性2...)</code> 调用</li></ol></li></ul><h4><span id="pyhton的继承">Pyhton的继承</span></h4><p>继承的语法：</p><pre><code class="language-python">class 派生类名（基类名）</code></pre><p>子类不重写 <strong>__ init__</strong>，实例化子类时，会自动调用父类定义的 <strong>__ init__</strong>。</p><p>重写了**__ init__** 时，实例化子类，就不会调用父类已经定义的 <strong>__ init__</strong>，如果重写了要继承父类的方法时可以使用<strong>super</strong>关键字来继承：</p><pre><code class="language-python">super(子类，self).__init__(参数1，参数2，....)</code></pre><p>super并不是一个函数，是一个类名，形如super(B, self)事实上调用了super类的初始化函数，产生了一个super对象；</p><p>super类的初始化函数并没有做什么特殊的操作，只是简单记录了类类型和具体实例；</p><p>也可以这样：</p><pre><code class="language-python">父类名称.__init__(self,参数1，参数2，...)</code></pre><p>举个例子：</p><pre><code class="language-python">class Father(object):    def __init__(self, name):        self.name=name        print ( "name: %s" %( self.name))    def getName(self):        return 'Father ' + self.name class Son(Father):    def __init__(self, name):        super(Son, self).__init__(name)        print ("hi")        self.name =  name    def getName(self):        return 'Son '+self.name if __name__=='__main__':    son=Son('runoob')    print ( son.getName() )</code></pre><p>输出结果：</p><pre><code class="language-python">name: runoobhiSon runoob</code></pre><h4><span id="pthony的__-call__方法">Pthony的__ call__方法</span></h4><p><a href="http://c.biancheng.net/python/">Python</a> 类中一个非常特殊的实例方法，即 <strong>call</strong>()。该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。</p><h4><span id="单下划线-双下划线-头尾双下划线的说明">单下划线、双下划线、头尾双下划线的说明</span></h4><ul><li><strong>__ foo __</strong>: 定义的是特殊方法，一般是系统定义名字 ，类似 <strong>__ init__()</strong> 之类的。</li><li><strong>_ foo</strong>: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 <strong>from module import *</strong></li><li><strong>__foo</strong>: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</li></ul><h2><span id="pytorch-api-实现基础模型">Pytorch API 实现基础模型</span></h2><h3><span id="nnmodule">nn.Module</span></h3><p><code>nn.Module</code> 是<code>troch.nn</code>提供的一个类，是pytorch中我们自己定义网络的一个基类。通过整个基类来实现网络可以调用预先实现好的算法,不需要我们考虑太多就可以快速构建和训练。</p><h5><span id="nnmodule的使用">nn.Module的使用</span></h5><p>1、首先要继承，继承后需要调用super的init方法（重写父类初始化方法），通过调用super的init方法来继承父类中的init的参数</p><pre><code class="language-python">from torch import nnclass Lr(nn.Module):    def __init__(self):        super(Lr, self).__init__()  #继承父类init的参数        self.linear = nn.Linear(1, 1) </code></pre><p>2、<code>farward</code>方法必须实现，用来定义我们的网络的向前计算的过程。</p><pre><code class="language-python">def forward(self, x):        out = self.linear(x)        return out</code></pre><p>在讨论这一段代码前我们可以先考虑一个问题：</p><h5><span id="什么是batch_size什么是features">什么是batch_size，什么是features？</span></h5><ul><li>batc_size是指一次训练所取得样本数，每次经过一个batc_size就更新一次参数。</li><li>features这里指的是二维数组的列，指的是特征的数量。</li><li>样本数量：指的是二维数组的行，就是样本数量。</li></ul><p>如果一次送进去一列就是features=1，那么batch_size=样本数量。</p><p>回到我们的代码，<code>nn.Linear</code>为torch预定义好的线性模型（本质上是一个类），也被称为<strong>全链接层</strong>，传入的参数为输入的数量，输出的数量(in_features, out_features),你可以注意到输入的参数是不算batch_size的行大小，只考虑features的大小。</p><p>你可能会疑问，为什么 <strong>self.linear(x)</strong> 是直接调用的对象然后加一个括号？你如果学过<strong>java</strong>就知道方法属于实例，调用方法应该是这样的<code>linear.__ call__</code>,这里举例调用的<code>__call__</code>方法实际上就是等于<code>linear(x)</code>，没错你如果略过了上文的<strong>Pthony的__ call__方法</strong>回去一看便知。</p><p><code>nn.Module</code>定义了<code>__call__</code>方法，实现的就是调用<code>forward</code>方法，即<code>Lr</code>的实例，能够直接被传入参数调用，实际上调用的是<code>forward</code>方法并传入参数。</p><h5><span id="torchoptim类">torch.optim类</span></h5><p><strong>optimizer</strong>类的设计是为了针对<strong>nn.Module</strong>类来实现参数的更新而设计的，可以简单地理解为自动梯度下降器，自动对<strong>nn.Module</strong>中的参数来实现梯度下降等算法来进行更新。</p><h5><span id="如何构造和使用optimizer">如何构造和使用optimizer？</span></h5><p>要构造一个optimizer需要的参数（先拿常规的SGD来说）有两个分别是：</p><pre><code class="language-python">sgd = opt.SGD(params , lr)#params 是需要更新的参数，lr是学习率</code></pre><p>这样就完成了一个针对params的梯度下降优化器。那么如何使用这个梯度下降优化器呢？</p><p><strong>sgd</strong>的<strong>step</strong>方法就是起到参数更新的作用，当然在参数更新之前需要先将上一次的梯度置零，其同样也帮我们内置好了<strong>zero_grad</strong>方法，实现一键清零。具体的例子会在下边说明，读到这里你会有一个疑问model的参数怎么获取？</p><h5><span id="model的参数"><strong>model</strong>的参数：</span></h5><p>获取<strong>model</strong>的参数：</p><p>本文中所创建的<strong>model</strong>类型是基于其现有的线性模型所产生的，要获取模型的参数（这里就是<strong>w</strong>和<strong>b</strong>），直接调用<strong>model</strong>的<strong>parameters</strong>方法即可获取所需的参数。</p><h5><span id="optimizer的使用">optimizer的使用：</span></h5><pre><code class="language-python">myModel = MyLinear()#首先创建一个基于SGD的优化器，然后将上面的model的参数传入，完成初始化构造：optimizer = opt.SGD(myModel.parameters(), learningrate)# 参数更新前清零梯度optimizer.zero_grad()#参数更新optimizer.step()</code></pre><p>但你会发现其实缺少了一个步骤，在上一节中我们知道如果神经网络的结尾是一个loss函数就需要从loss开始反向转播来求取梯度，求出梯度以后再进行梯度下降，这里缺少了梯度下降的过程，那么如何计算出loss并进行梯度计算呢？这里就要介绍另一个类：loss。</p><h5><span id="损失函数类的使用">损失函数类的使用</span></h5><p>在torch中预置了许多loss的计算函数比如：</p><p>求取均方误差的：</p><pre><code class="language-python">nn.MSELoss()#常用于回归问题</code></pre><p>求取交叉熵损失的：</p><pre><code class="language-python">nn.CrossEntropyLoss()#常用于分类问题</code></pre><h5><span id="如何使用内置的loss函数的类来进行计算">如何使用内置的loss函数的类来进行计算？</span></h5><p>对于一个<strong>loss 函数</strong>类来说，需要知道的参数就是<strong>预测值</strong>和<strong>真实值</strong>，对于回归问题我们只需要传入这两个参数就可通过loss函数对象计算出loss函数的结果，其实本质上<strong>loss 函数类</strong>和前边的<strong>nn.Module</strong>一样都是一个类的实例化对象，<strong>nn.Moudule</strong>需要运行的时候（前向传播）调用的是其<code>__call__</code>方法， 通过<strong>call</strong>方法来调用<strong>forward</strong>方法实现前向传播，同理那么<strong>loss 函数类</strong>也是不是可以通过相同的办法实现呢？当然可以我们直接调用其对象传入参数就可以完成计算。当计算出<strong>loss</strong>以后如何进行反向传播呢？<strong>loss</strong>函数类返回的也是一个<strong>torch</strong>我们直接调用<strong>backward</strong>方法即可。</p><pre><code class="language-python">lossFun = nn.MSELoss() #构造一个loss类loss = lossFun(y, y_predicet) #计算lossloss.backward() #反向传播计算梯度</code></pre><p>通过这样完成了一次训练，根据训练次数和步长进行迭代训练，代码如下：</p><pre><code class="language-python">import torchimport torch.nn as nnimport torch.optim as optimport numpy as npimport matplotlib.pyplot as plt# 0、准备数据sample_number = 500learninGrate = 0.001trainTimes = 20000x = torch.rand([sample_number, 1])y = x * 3 + 0.8# 1、定义模型class MyLinear(nn.Module):    def __init__(self):        # 继承父类的init        super(MyLinear, self).__init__()        self.linear = nn.Linear(1, 1)    def forward(self, x):        out = self.linear(x)        return out# 2、实例模型，优化器类的实例myModel = MyLinear()optimizer = opt.SGD(myModel.parameters(), lr=learninGrate)lossFun = nn.MSELoss()# 3、训练for i in range(trainTimes):    y_predicet = myModel(x)    optimizer.zero_grad()    loss = lossFun(y, y_predicet)    loss.backward()    optimizer.step()    if (i % 100 == 0):        print(loss)        print("W :", list(myModel.parameters())[0])        print("B :", list(myModel.parameters())[1])</code></pre><p>有意思的W和B是generator类的，这样就无法直接获得，需要通过list强制转化，关于generator类会放在下节再将。</p><p>输出：</p><pre><code class="language-shell">loss：tensor(5.5467e-08, grad_fn=&lt;MseLossBackward0&gt;)W : Parameter containing:tensor([[2.9992]], requires_grad=True)B : Parameter containing:tensor([0.8004], requires_grad=True)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch ——基础指北_贰</title>
      <link href="/2024/09/28/pytorch_2/"/>
      <url>/2024/09/28/pytorch_2/</url>
      
        <content type="html"><![CDATA[<h1><span id="pytorch-基础指北_贰">Pytorch ——基础指北_贰</span></h1><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><h2><span id="软件环境">软件环境：</span></h2><ul><li>pytorch 1.10</li><li>pycharm</li></ul><!-- toc --><ul><li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识：</a><ul><li><a href="#0-%E6%96%B9%E5%90%91%E4%BD%99%E5%BC%A6%E4%B8%8E%E5%90%91%E9%87%8F%E5%8D%95%E4%BD%8D%E5%8C%96">0、方向余弦与向量单位化</a></li><li><a href="#1-%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E6%B1%82%E5%81%8F%E5%AF%BC">1、多元函数求偏导</a></li><li><a href="#2-%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0">2、方向导数：</a><ul><li><a href="#%E4%BB%8E%E4%BA%8C%E7%BB%B4-%E4%B8%89%E7%BB%B4%E5%85%A5%E6%89%8B">从二维、三维入手</a></li><li><a href="#%E4%B8%89%E7%BB%B4%E7%9A%84%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0">三维的方向导数</a></li></ul></li><li><a href="#3-%E6%A2%AF%E5%BA%A6">3、梯度：</a></li></ul></li><li><a href="#tensor%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD">Tensor的梯度与反向传播</a><ul><li><a href="#%E5%9B%9E%E9%A1%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">回顾机器学习</a></li><li><a href="#%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD">反向传播？</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E5%9B%BE">计算图</a></li></ul></li><li><a href="#%E5%AE%9E%E6%88%98%E6%BC%94%E7%A4%BA">实战演示：</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="基础知识">基础知识：</span></h2><p>要想训练一个网络，对于梯度的理解是必不可少的，下面首先介绍梯度的一些基础概念。</p><h3><span id="0-方向余弦与向量单位化">0、方向余弦与向量单位化</span></h3><p>方向余弦是一个在向量中很常见的概念，它用来标定某一个向量的方向，说起来可能会一头雾水，不过没关系，我们使用画图来理解一下。</p><p>举个例子，如下图有一个坐标系xoy，其效果如下所示：</p><p>其中包含了一个向量$\overrightarrow{l}$ ,向量的坐标为：$(a,b)$</p><p>那么上文中的向量就满足如下式子：</p><p>$$<br>(\frac{a}{\sqrt{a^2+b^2}},\frac{b}{\sqrt{a^2+b^2}})<br>$$<br>上文的式子实际上就是对向量进行单位化，此时新产生的向量，实际上就是我们常说的<strong>方向向量</strong>。</p><p>方向向量实际上还可以再优化一下，我们看到图上还有两个标明的角分别是$\alpha和\beta$，这两者的关系就不再多说，他们呢一对互余的角度，满足的条件就是相加等于90度。</p><p>此时我们就可以将这个式子转化成这样的形式：</p><p>$$<br>\frac{a}{\sqrt{a^2+b^2}} = \cos{\alpha}<br>$$<br>同理也有：</p><p>$$<br>\frac{b}{\sqrt{a^2+b^2}} = \cos{\beta}<br>$$<br>这样方向的向量的表达式，就可以写为：</p><p>$$<br>(\frac{a}{\sqrt{a^2+b^2}},\frac{b}{\sqrt{a^2+b^2}}) =(\cos{\alpha},sin{\alpha})<br>$$<br>实际因为角度互余上可以化为：</p><p>$$<br>(cos{\alpha},cos{\beta})<br>$$</p><h3><span id="1-多元函数求偏导">1、多元函数求偏导</span></h3><p>一元函数，即有一个自变量。类似$f(x)$</p><p>多元函数，即有多个自变量。类似$f(x,y,z),三个自变量x,y,z$</p><p>多元函数求偏导过程中：<strong>对某一个自变量求导，其他自变量当做常量即可</strong></p><p>例1：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/30/d6d4dc6d38b11466.png" alt="image-20220630001257856"></p><p>例2：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/30/c65c5f7264f1e788.png" alt="image-20220630001327339"></p><p>例3：</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/30/4f952d9017753c7b.png" alt="image-20220630001346638"></p><p><strong>练习：</strong></p><p>已知$J(a,b,c) = 3(a+bc),令u=a+v,v = bc$,求a，b，c各自的偏导数。</p><p><img src="https://s3.bmp.ovh/imgs/2022/06/30/8a418d0457b5cd45.png" alt="image-20220630001413984"></p><h3><span id="2-方向导数">2、方向导数：</span></h3><p>简单地说方向导数形容的是满足某个关系下(<strong>Y=KX+B</strong>)，对于各个方向上本关系数值变化率（<strong>Y</strong>的变化率）的量化表达式。</p><p>数学推导，可参考如下文章。但是我读完以后还是没办法一下就理解，它实际上不应该是一个这么难理解的内容，我们反过来想一想，能不能从前面的基础构建出来方向导数到底是什么。</p><p><a href="https://www.bilibili.com/video/BV13J411R7Cf">方向导数1 第一章</a></p><p><a href="https://zhuanlan.zhihu.com/p/362425719">方向导数2</a></p><h4><span id="从二维-三维入手">从二维、三维入手</span></h4><p>在二维关系中<strong>Y=KX+B</strong>中我们不太好理解什么是方向导数，我们知道对于一个函数来说，$y=kx+b$的导数实际上是这样的：</p><p>对于函数的某一点，导数等于切线在该点的斜率，他是一个极限概念。我们不妨这样来理解这个极限的过程：</p><p>下图是某个函数，其中包含三个点如下所示：</p><img src="https://s2.loli.net/2024/09/29/yEsZO4wvTSdbuCl.png" alt="image-20220629224749049" style="zoom:80%;"><p>其中A、B是函数上随机的两个点。其中A、B两点满足如下：<br>$$<br>A= (x_0,f(x_0))\<br>B= (x_0+\Delta x,f(x_0+\Delta))<br>$$<br>然后AB两点相连接，形成一个<strong>割线</strong>，割线的斜率满足如下条件：<br>$$<br>k_{AB} = \frac{f(x_0+\Delta x) - f(x_0)}{(x_0+\Delta x) - x_0} = \frac{f(x_0+\Delta x) - f(x_0)}{\Delta x}<br>$$<br><img src="https://s2.loli.net/2024/09/29/EVNmj8KdIpPl9bv.png" alt="image-20220629224926972" style="zoom:80%;"></p><p>当有如下情况的时候，就会产生切线和导数：</p><p>当B无限趋近于A的时候，即$\Delta x$无限趋近于0的时候，割线AB就会转化为切线，如下所示：</p><p><img src="https://s2.loli.net/2024/09/29/l2xTk5joY14OQNw.png" alt="image-20220629225141543"></p><p>满足的数学关系如下：<br>$$<br>k_{ab} = \varliminf_{\Delta x \to 0} \frac{f(x_0+\Delta x) - f(x_0)}{\Delta x}<br>$$<br>而我们知道切线的斜率就是导数的值，这是在二维的情况下。</p><h4><span id="三维的方向导数">三维的方向导数</span></h4><p>在二维的情况我们已经很了解了，我们来推广到到三维的情况下来试一试，举个例子：</p><p>我们先来下一个定义：</p><p>一般情况下的三位函数的方向导数实际上是平面XOY上一点$(x,y)$在三维函数的值$f(x,y)$，和其所代表的一点$（x,y,f(x,y)）$以向量l的方向向量为切面构成的曲线上（点(x,y)）的一条切线的值。</p><p>说起来很抽象，我们举个例子就好理解一点了：</p><p>其中三维函数圆形抛物面大致如下：<br>$$<br>Z = x^2+y^2<br>$$<br>如图所示:</p><img src="https://s2.loli.net/2024/09/29/wWFCYGVHJZvTaos.png" alt="image-20220629231525772" style="zoom:80%;"><p>图看起来很很复杂不过没关系，我们依靠颜色来分辨一下：</p><p>红色包含两部分内容：分别是在xy平面的点$(x,y)$和切面构成的曲线。</p><p>橙色包含两部分内容：$\overrightarrow{l}$ 是 $XOY$ 平面（笛卡尔坐标系）上以 $P(X_0,Y_0)$为始点的一条射线,$e_l = ( \cos \alpha , \cos \beta)$ 是与 L 同方向的单位向量。同时还包含一个由其方向向量构建出来的平面A。</p><p>蓝色部分包含一个内容：就是函数Z。</p><p>我们来解析一下这分别什么意思</p><p>当存在一个点c从点(x,y)出发沿着方向向量变化$t$的时候，其坐标满足如下：<br>$$<br>C = (x+tcos{\alpha},y+tcos{\beta}) （其中角度和上文中的是一样意义）<br>$$<br>这时候c点实际上就是黑色虚线在l上的点。这时候这个在向量上的变化轨迹就是一段向量，他的方向和l向量的方向向量是一样的，并且在函数上映射了一段曲线，如红色部分曲线所示，我们针对这一种曲线来考虑一种特殊情况，当满足这个条件的时候，曲线会如何变化？</p><p>没错就是上文中二维的情况：</p><p><img src="https://s2.loli.net/2024/09/29/l2xTk5joY14OQNw.png" alt="image-20220629225141543"></p><p>结果是一模一样的，只不过这里的切线是对应的在曲线上的切线，我们这里就引出方向导数的定义如下：<br>$$<br>\left. \frac{\partial f}{\partial l} \right|_ {\left(x_{0}, y_{0}\right)} = \lim_{t \rightarrow 0^{+}} \frac{f\left(x_{0} + t \cos \alpha, y_{0} + t \cos \beta \right) - f\left(x_{0}, y_{0}\right)}{t}<br>$$</p><p>从方向导数的定义可知，方向导数：$ \left. \frac{\partial f}{\partial l}\right|_ {\left(x_{0}, y_{0}\right)} $就是函数 $ f(x, y)  在点  P_{0}(x_{0}, y_{0})  $​​处沿方向 ( l ) 的变化率。</p><p>定理：</p><p>如果函数$f(x, y)$ 在点$P_{0}\left(x_{0}, y_{0}\right)$可微分,那么函数在该点沿任一方向 的方向导数存在,且有 :<br>$$<br>\left.\frac{\partial f}{\partial l}\right|_ {\left(x_{0}, y_{0}\right)}=f_{x}\left(x_{0}, y_{0}\right) \cos \alpha+f_{y}\left(x_{0}, y_{0}\right) \cos \beta<br>$$<br>注意里面为偏导 实际上就分解成了X Y轴上函数变化率。</p><p>其中, $\cos \alpha \text { 和 } \cos \beta$是向量$l$ 的方向余弦。</p><p>这里再说明一下方向导数和偏导数有什么区别呢？</p><p>偏导数实际上方向导数的特例，当向量取x的正轴的时候，此时方向导数就转变为了对于x的偏导数，推导如下：<br>$$<br>\left.\frac{\partial f}{\partial l}\right|_ {\left(x_{0}, y_{0}\right)} = \lim_ {t \rightarrow 0^{+}} \frac{f\left(x_{0}+t \cos \alpha, y _{0}\right)-f\left(x _{0}, y _{0}\right)}{t}<br>$$<br>如果你仔细看就会发现实际上这里的定义就是偏导数的定义，也就说是方向导数的一种情况。</p><p>其次再说明一下，这个式子的意义在哪里：<br>$$<br>\left.\frac{\partial f}{\partial l}\right|_ {\left(x_{0}, y_{0}\right)}=f_{x}\left(x_{0}, y_{0}\right) \cos \alpha+f_{y}\left(x_{0}, y_{0}\right) \cos \beta<br>$$<br>实际上，我们用来计算方向导数的时候就是使用这个式子，这个式子就是将对应的方向向量分解为x轴和y轴的方向余弦来进行计算，也就说方向向量实际上是由x轴和y轴的方向余弦构成的。</p><p>还有就是对于用同一个点，方向向量不同所构成的方向导数大小也不同，但是这些方向导数的方向始终会在一个平面内，这个平面就是这个点的切平面！</p><h3><span id="3-梯度">3、梯度：</span></h3><p>梯度是方向导数的特例：<br>$$<br>\operatorname{gradf}(x, y) = \frac{\partial f}{\partial x}\vec{i}+\frac{\partial f}{\partial y} \vec{j}<br>$$<br>已知在某个点有方向导数存在下列关系：<br>$$<br>\frac{\partial f}{\partial l} = \frac{\partial f}{\partial x} \cos \varphi + \frac{\partial f}{\partial y} \sin \varphi = \left\{\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\right\} \cdot \{\cos \varphi, \sin \varphi\}<br>$$</p><p>在方向 <strong>L</strong>上满足如下单位向量：<br>$$<br>\overrightarrow{\boldsymbol{e}}=\cos \varphi \overrightarrow { \boldsymbol{i}}+\sin \varphi \overrightarrow{ \vec{j} }<br>$$<br>则方向导数可转化成如下：<br>$$<br>\frac{\partial f}{\partial l}= \begin{equation}\operatorname{gradf}(x, y)\end{equation} * \overrightarrow{\boldsymbol{e}}<br>$$<br>点积就相当于做一个投影，方向导数 和 <strong>梯度</strong> 之间保持一定的夹角（做点积）来构成各个方向上的方向导数。什么时候方向向量最大呢？</p><p>很容易想到不存在夹角的时候就可以满足，因为此时点积最大即满足下列条件：<br>$$<br>\begin{equation}<br>\text { 只有当  } \cos (\operatorname{grad} f(x, y), \vec{e})=1 ， \frac{\partial f}{\partial l} \text {   才有最大值。 }<br>\end{equation}<br>$$<br>函数在某点的梯度是个向量，他的方向与方向导数最大值取值的方向一致，其大小正好是最大的方向导数。</p><p>​梯度概念理解：如下图所示，在p点放一个热源的等温线，则热源的辐射从里到外为10°、20°、30°、40°，若一个小蚂蚁在o点，要最快逃离热源，应该往oj方向逃离，若往om方向逃离则热源的变化率为0，即一直都是20°，也就是说蚂蚁一旦确定了某个逃离方向(0°,90°）方向角逃离，只要一直沿着该方向一直走，就是最快的热源降低的方向</p><img src="https://s2.loli.net/2024/09/29/KcGRkbTEFSofMq4.jpg" alt="蚂蚁" style="zoom:80%;"><p>对于一维线性函数其导数就是梯度。</p><p>各种函数的梯度与导数的关系：</p><p><a href="https://zhuanlan.zhihu.com/p/384175778">函数梯度</a></p><p>更详细的解释可以参考参考文献链接。</p><h2><span id="tensor的梯度与反向传播">Tensor的梯度与反向传播</span></h2><h3><span id="回顾机器学习">回顾机器学习</span></h3><p>收集数据$x$ ，构建机器学习模型$f$，得到$f(x,w) = Y_{predict}$</p><p>如何判断模型的好坏？判断模型好坏的方法:<br>$$<br>\begin{array}{ll}<br>\operatorname{loss}=\left(Y_{p r e d i c t}-Y_{\text {true }}\right)^{2} &amp; \text { (回归损失) } \<br>\operatorname{loss}=Y_{\text {true }} \cdot \log \left(Y_{\text {predict }}\right) &amp; \text { (分类损失) }<br>\end{array}<br>$$<br>通过最终 $loss$ 的输出，来反向传播计算梯度大小进而调整参数的大小实现最优解。</p><p>当 $loss$ 满足如图时候</p><img src="https://s2.loli.net/2024/09/29/W4R9x1FtkZsAiEC.png" alt="梯度1" style="zoom: 70%;"><p>计算出来梯度以后：朝着梯度变化的方向运算，随机选择一个起始点$w_0$,通过调整$w_0$，让 $loss$ 函数取到最小值。</p><img src="https://s2.loli.net/2024/09/29/EClJYh2BXamKyQO.png" alt="梯度2"><p><strong>$w$的更新方法</strong>：</p><ol><li>计算$w$的梯度（导数）</li></ol><p>$$<br>\nabla w = \frac{f(w+0.000001)-f(w-0.000001)}{2*0.000001}<br>$$</p><ol start="2"><li>更新$w$<br>$$<br>w = w - \alpha \nabla w<br>$$</li></ol><p>其中：</p><ol><li>$\nabla w &lt;0 $ ,意味着w将增大</li><li>$\nabla w &gt;0 $ ,意味着w将减小</li></ol><p>总结：梯度就是多元函数参数的变化趋势（参数学习的方向），只有一个自变量时称为<strong>导数</strong>，拥有多个时称为偏导数。</p><h3><span id="反向传播">反向传播？</span></h3><h4><span id="计算图">计算图</span></h4><p>为了方便描述，通过图的方式来描述函数。</p><p>$J(a,b,c) = 3(a+bc),令u=a+v,v = bc$,把它绘制成计算图可以表示为：</p><p><img src="https://s2.loli.net/2024/09/29/lkQODtN4rozTSJu.png" alt="计算图"></p><p>对每个节点求偏导可有：</p><p><img src="https://s2.loli.net/2024/09/29/eaZ9DKpLsuEwgcb.png" alt="计算梯度"></p><p>反向传播的过程就是一个上图的从右往左的过程，自变量$a,b,c$各自的偏导就是连线上的梯度的乘积：<br>$$<br>\begin{align*}<br>\frac{dJ}{da} &amp;= 3 \times 1 \<br>\frac{dJ}{db} &amp;= 3 \times 1 \times c \<br>\frac{dJ}{dc} &amp;= 3 \times 1 \times b<br>\end{align*}<br>$$</p><p><strong>为什么要算反向传播？</strong></p><p>因为要计算梯度。</p><h3><span id="实战演示">实战演示：</span></h3><p>接下来尝试计算一个简单结构的梯度，问题描述如下：</p><p>假设我们的基础模型就是<code>y = wx+b</code>，其中w和b均为参数，我们使用<code>y = 3x+0.8</code>来构造数据x、y，所以最后通过模型应该能够得出w和b应该分别接近3和0.8。</p><p>简单的来说就是拟合出满足<code>y = 3x+0.8</code>这个曲线。</p><p>步骤分为四步：</p><pre><code class="language-python"># 1 构造数据# 2 设计正向传播 和 反向传播函数 来训练网络# 3 训练# 4 画图画出拟合出来的曲线</code></pre><p>过程如下图：</p><p>从左向右是正向传播部分</p><p>从右向左是反向传播部分</p><img src="https://s2.loli.net/2024/09/29/MI6NE5hSpuQb9Ff.png" alt="数据集输入" style="zoom: 80%;"><p>对于<strong>W</strong>和<strong>B</strong>其计算类似这里单独说<strong>B</strong>即可</p><p>对于<strong>B</strong>的梯度满足下式，值得注意的是这里的<strong>Loos</strong>求取的是平均值实际上出来的是一个标量，对于标量的梯度计算实际上也是一个平均值（这里值得思考一下）。</p><p>$$<br>\frac{\partial Loss}{\partial B} = \sum_{i=0}^N 2*(y_i-y_{pi})/N<br>$$<br>反向传播后对B进行梯度下降：</p><p>$$<br>B = B - rate *\frac{\partial Loss}{\partial B}<br>$$<br>梯度下降以后再次进行正向传播即可，计算出来<strong>Y_p</strong>，最后计算出来<strong>Loss</strong>。</p><p>正向传播满足下式：<br>$$<br>Y_{predict (0…N)} =X_{predict (0…N)}* W + B<br>$$<br>代码如下：</p><pre><code class="language-python">import torchimport numpy as npimport matplotlib.pyplot as plt# 1 构造数据x_number = 50x = torch.rand([x_number, 1])y = 3 * x + 0.8rate = 0.01study_time = 3000# 2 正向传播 和 反向传播w = torch.rand([1, 1], requires_grad=True, dtype=torch.float32)b = torch.rand(1, requires_grad=True, dtype=torch.float32)y_preidct = torch.matmul(x, w) + bdef forward_propagation():    global x, w, b, y_preidct    y_preidct = torch.matmul(x, w) + b    # 计算 loss    loss = (y - y_preidct).pow(2).mean()    return lossdef back_propagation():    global x, w, b, loss, rate, y_preidct    test = 0.0    if w.grad is not None:        w.grad.data.zero_()    if b.grad is not None:        b.grad.data.zero_()    # 反向传播    loss.backward()    w.data -= w.grad * rate    b.data -= b.grad * rate    #此处为了验证b的梯度进行计算    # for j in range(x_number):    #   test += ((y[j] -y_preidct[j].item()) * 2)     # print("b:", b.grad)    # print("b_t:", test/x_number)# 3 训练部分for i in range(study_time):    loss = forward_propagation()    back_propagation()    if i % 10 == 0:        print("w,b,loss", w.item(), b.item(), loss.item())# 4 画图部分predict = x * w + b  # 使用训练后的w和b计算预测值plt.scatter(x.data, y.data, c="r")plt.plot(x.data.numpy(), predict.data.numpy())plt.show()</code></pre><p>红色的是数据集结果蓝色是训练出来的结果：</p><p>当训练次数比较少的时候拟合曲线不正确：</p><p><img src="https://s2.loli.net/2024/09/29/VMak4E2zHjSArfL.png" alt="image-20240929185524309"></p><p>当把学习率降低（变化范围减小），增加学习次数就可以得到很好的结果：</p><p><img src="https://s2.loli.net/2024/09/29/K56akOeYuqUFXAE.png" alt="myplot"></p><p>参考文献：</p><p><a href="https://www.bilibili.com/video/BV1CZ4y1w7mE?p=11">国内教程 偏理论 （10 -13 节）</a></p><p><a href="https://www.youtube.com/watch?v=c36lUUr864M">youtobe教程 （第三节）（需要科学上网）有需要搬运联系我 </a></p><p><a href="https://www.bilibili.com/video/BV13J411R7Cf">方向导数1</a></p><p><a href="https://zhuanlan.zhihu.com/p/362425719">方向导数2</a></p>]]></content>
      
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch--基础指北_柒</title>
      <link href="/2024/09/28/pytorch_7/"/>
      <url>/2024/09/28/pytorch_7/</url>
      
        <content type="html"><![CDATA[<h1><span id="pytorch-基础指北_柒使用线性网络实现数字识别">Pytorch ——基础指北_柒（使用线性网络实现数字识别）</span></h1><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><!-- toc --><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83">软件环境：</a></li><li><a href="#%E4%BD%BF%E7%94%A8mnist%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86">使用MNIST构建自己的数据集</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B">如何构建模型？</a><ul><li><a href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%84%E7%90%86">图像的扁平化处理</a></li><li><a href="#%E6%9E%84%E9%80%A0%E8%BE%93%E5%85%A5%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82">构造输入全连接层</a></li><li><a href="#%E8%BE%93%E5%87%BA%E5%B1%82%E7%9A%84%E6%9E%84%E9%80%A0">输出层的构造</a><ul><li><a href="#%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0">交叉熵损失函数</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="软件环境">软件环境：</span></h2><ul><li><strong>pytorch 1.10</strong></li><li><strong>pycharm</strong></li></ul><h2><span id="使用mnist构建自己的数据集">使用MNIST构建自己的数据集</span></h2><p>详细的可以参考：</p><p><a href="https://blog.csdn.net/qq_20540901/article/details/123657904?spm=1001.2014.3001.5502">构建一个自己的MNIST数据集</a>。</p><p>这里不再赘述，直接放上代码来说：</p><pre><code class="language-python">def MNIST_create_dataloader(train=True):    transforms_fn = Compose([ToTensor(), Normalize(mean=0.1307, std=0.3081)])    #这里是对数据集进行预处理，将普通图像转换成pytorch支持的图像，并对数据分布进行调整        MNIST_dataset = MNIST(root="./data", train=train, download=True, transform=transforms_fn)#导入官方的数据集，并转化成Dataset类        MNIST_dataloader = DataLoader(dataset=MNIST_dataset, batch_size=batch_size, drop_last=True, shuffle=True, )    #对Dataset类处理转化成DataLoader类        return MNIST_dataloader</code></pre><p>这样一个MNIST数据就完成了预处理等操作，很快就能构建好。</p><h2><span id="如何构建模型">如何构建模型？</span></h2><p>基础知识参考给于的链接。</p><p>我们使用<code>nn.Module</code>类来构建自己的模型，我们目前需要一个简单的模型层数不需要太多，只使用全连接层即可，因为是一个分类模型，所以需要通过激活函数来实现对0~9的分类，你可以注意到他并不是简单的二分类而是10分类模型，这样的话sigmod激活函数就没有办法使用了，我们这里就要使用relu来作为激活函数，最后配合权重loss实现10分类。整体网阔结构框架如下：</p><p><img src="https://s2.loli.net/2024/09/29/Sv1yV5kD8REcXL4.png" alt="1"></p><p>下面就来讲解如何实现这个小网络。</p><h3><span id="图像的扁平化处理">图像的扁平化处理</span></h3><p>首先我们关注网络开始的部分：</p><p><img src="https://s2.loli.net/2024/09/29/W3ZqneO1gbR9TfY.png" alt="2"></p><p>在构建完成数据集以后，我们可以看到数据在每个batch的时候，其实并不是一张图片，而是batch_size * image_size（这里的image_size就是28 * 28 *  1，单个图像包含的像素数量）见下图，网络在训练的时候我们并不是每次只送进去一张图像而是送进去多张图像，为了构建模型就要考虑到这些问题，我需要将每个batch内的图像再分开送入吗？当然不用！pytorch内置的全连接层只需要我们输入特征数量即可无需考虑batch_size,这为我们构建模型提供了很大的方便。</p><p>batch为1415的两张图片（两张图片代表的分别为1和0）和它们的的label（<code>(tensor([1, 0])</code>）转化成tensor的样子：</p><pre><code class="language-python">1415 [tensor([[[[-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          ...,          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242]]],        [[[-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          ...,          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242]]]]), tensor([1, 0])]</code></pre><p>首先对输入图像从二维进行扁平化处理：</p><p>所谓扁平化实际上就是把数据从2维降维到1维度，方便运算。</p><p>至于这里为什么要1维，我们先保留以后再进行讨论：</p><p>这里先介绍方法：</p><pre><code class="language-python">    def forward(self, input):        x = input.view(-1, 1 * 28 * 28)</code></pre><p>这里的foward方法就是前向传播的方法，首先要知道每一个batch内的数据是这样的：</p><p>[batch_size * [image_width * [image_height*[channel_num]]]]</p><p>可以看到实际上是四层的数据，也就是四维【图片3维+batch维度（有几张图片）】</p><p>pytorch对于其扁平化调用view方法即可，view方法及原理使用可参见：</p><p>注意这里不能调用permute方法，而应该是view方法,注意区别这两个的方法。</p><p>转化后数据就转变成二维的形状:</p><p>[batch_size,image_size]。</p><p>接下来就是如何构造第一个输入全连接层了。</p><h3><span id="构造输入全连接层">构造输入全连接层</span></h3><img src="https://s2.loli.net/2024/09/29/G7sYXjZmqJhFBtE.png" alt="3" style="zoom:80%;"><p>构建输入层，将数据变形从28*28个像素提取出来28个特征，这是输入层的目的。</p><p>但是为什么全连接层能将28*28的数据转化成28呢？全连接层的本质是什么呢？</p><p>看下边一张图：</p><img src="https://s2.loli.net/2024/09/29/7JPy4DHw9TCIWez.png" alt="全连接层"><p>​对于上图全连接层的描述可以变换成一个矩阵，图中左侧矩阵代表着每个连线上的权重参数W，右侧矩阵就是输入数据（已经一维化）。</p><p>对于目前的网络可以看如下解释：</p><p><img src="https://s2.loli.net/2024/09/29/RFDa3JeGYZjC7gr.png" alt="4"></p><p>输入数据矩阵：</p><p>[1,28 * 28* 1]</p><p>参数矩阵：</p><p>[28 * 28 ,28]</p><p>进行矩阵相乘以后就变成了 如下的[28 ,1 ]的向量。</p><img src="https://s2.loli.net/2024/09/29/9ysAB1eIwTScqJ5.png" alt="5" style="zoom:67%;"><p>那么如何在代码中实现呢？可以看到我先继承了<code>nn.Module</code>类并调用了父类的初始化，然后在模型中初始化了一个输入特征为：1* 28 * 28（扁平化化后的图片） ，输出特征为28的线性全连接层。</p><pre><code class="language-python">class Mymodule(nn.Module):    def __init__(self):        super(Mymodule, self).__init__()        self.fc1 = nn.Linear(1 * 28 * 28, 28)#初始化一个全连接层</code></pre><p>在前向传播方法中 如何使用设定好的全连接层呢？</p><p>很简单，调用你的全连接层传入输入参数即可：</p><pre><code class="language-python">    def forward(self, input):        x = input.view(-1, 1 * 28 * 28)        x = self.fc1(x)#调用全连接层</code></pre><p>完成了输入特征的提取就来到了激活函数层。</p><p>我们在这里选择了Relu作为激活函数，激活函数的作用很多，增加非线性分割能力，缓解梯度消失，增加收敛速度等。</p><p>RELU则是图像处理常用的函数，这里不再赘述，详情可看：</p><p><a href="https://www.cnblogs.com/adong7639/p/9213038.html">Relu的理解</a></p><p><a href="https://blog.csdn.net/jyl1999xxxx/article/details/51381012">Relu的理解2</a></p><p>这里只讨论用法：</p><pre><code class="language-python">import torch.nn.functional as Fclass Mymodule(nn.Module):    def __init__(self):        super(Mymodule, self).__init__()        self.fc1 = nn.Linear(1 * 28 * 28, 28)    def forward(self, input):        x = input.view(-1, 1 * 28 * 28)        x = self.fc1(x)        x = F.leaky_relu_(x)</code></pre><p>使用方法很简单直接调用即可：</p><p><code>x = F.leaky_relu_(x)</code></p><p>这样在前向传播的时候就相当于添加了一层激活函数层来进行运算。</p><img src="https://s2.loli.net/2024/09/29/9ysAB1eIwTScqJ5.png" alt="5" style="zoom:67%;"><p>激活后就要考虑如何构造输出层。</p><h3><span id="输出层的构造">输出层的构造</span></h3><p>前面我们讲到过对于输出层我们常用的loss函数就有两种：<br>$$<br>\begin{array}{ll}<br>\operatorname{loss}=\left(Y_{p r e d i c t}-Y_{\text {true }}\right)^{2} &amp; \text { (回归损失) } \<br>\operatorname{loss}=Y_{\text {true }} \cdot \log \left(Y_{\text {predict }}\right) &amp; \text { (分类损失) }<br>\end{array}<br>$$<br>我们需要明确，当前我们手写字体识别的问题是一个多分类的问题，所谓多分类对比的是之前学习的2分类，我们在逻辑回归中，我们使用sigmoid进行计算对数似然损失，来定义我们的2分类的损失。多分类和2分类中唯一的区别是我们不能够再使用sigmoid函数来计算当前样本属于某个类别的概率，而应该使用softmax函数。softmax和sigmoid的区别在于我们需要去计算样本属于每个类别的概率，需要计算多次，而sigmoid只需要计算一次</p><p><strong>softmax</strong>的公式如下：<br>$$<br>\sigma(z)<em>j = \frac{e^{z_j}}{\sum^K</em>{k=1}e^{z_K}}  ,j=1 \cdots k<br>$$<br>其中z代表的就是上一层的输出结果，本质上就是对其求指数化后再进行求和和总占比，这里不再赘述，输出的结果就是概率的大小。</p><p>这里我们不急着讲解怎么用，我们再来介绍一个内容：</p><h4><span id="交叉熵损失函数">交叉熵损失函数</span></h4><p>$$<br>\begin{equation}<br>H(y, y_p)=-\sum_{x}(y \log y_p)<br>\end{equation}<br>$$</p><p>其中<strong>y_p</strong>为预测结果,<strong>y</strong>为正确结果。如果你对他的求导感兴趣可以参考：<a href="https://zhuanlan.zhihu.com/p/35709485">交叉熵损失函数</a></p><p>为什么要把概率输出和损失函数一起介绍呢？</p><p>因为在Pytorch中有一个很方便的API可以直接构造一层softmax函数+交叉熵损失函数，方便我们训练。</p><p>这个API就是 :<code>nn.CrossEntropyLoss()</code></p><p>它的使用很简单，只需要实例化这个对象然后传入<strong>预测结果</strong>与<strong>真实目标值</strong>即可：</p><pre><code class="language-python">loss_fun = nn.CrossEntropyLoss()loss = loss_fun(output, target.to(device))</code></pre><p>当然值得注意的是loss函数并不是模型的一部分，所以loss的创建不要在nn.Module类下，最后完整的模型如下：</p><pre><code class="language-python">class Mymodule(nn.Module):    def __init__(self):        super(Mymodule, self).__init__()        self.fc1 = nn.Linear(1 * 28 * 28, 28)        self.fc2 = nn.Linear(28, 10)    def forward(self, input):        x = input.view(-1, 1 * 28 * 28)        x = self.fc1(x)        x = F.leaky_relu_(x)        x = self.fc2(x)        return x</code></pre><p>你会注意到这里多了一个线性层：</p><p><code>x = self.fc2(x)</code></p><p>这个线性层的是这样的：</p><p><img src="https://s2.loli.net/2024/09/29/Xp9P7tMzLDZ8bWc.png" alt="6"></p><p>你可以看到他前边有28个节点，后一层只有10个节点，你应该能想到，其实就是对28个特征再次进行变换将它压缩到10个特征，这十个就分别对应了需要识别的10个数字，最后配合交叉熵来进行训练，更新权重信息完成网络。</p><p>完整的训练代码如下：</p><pre><code class="language-python">batch_size = 2 #每批两个图像device = torch.device("cpu")#调用cpu作为设备使用def train(epoch):    mode = True    mymodule_net.to(device)    for times in range(epoch):        mydataloader = MNIST_create_dataloader(train=mode)        for index, (input, target) in enumerate(mydataloader):            myopt.zero_grad()#清零梯度信息            output = mymodule_net(input.to(device))#调用模型前向传播            loss_fun = nn.CrossEntropyLoss()#Loss函数初始化            loss = loss_fun(output, target.to(device))#计算loss            loss.backward()#反向传播计算梯度            myopt.step()#更新参数            if index % 100 == 0:#每一百次训练输出一下信息                print(times, index, loss.item())#训练次数，训练进度，loss信息</code></pre><p>最后输出信息如下：</p><pre><code class="language-python">9 28700 1.7881361600302625e-069 28800 0.0015524936607107529 28900 8.34461025078781e-069 29000 0.00308840442448854459 29100 0.00034785087336786099 29200 1.7881390590446244e-079 29300 1.7881390590446244e-079 29400 0.09 29500 0.120134606957435619 29600 1.06835520267486579 29700 0.000166924757650122059 29800 0.00135333801154047259 29900 2.264973545607063e-06</code></pre><p>可以看到第十次训练的时候，loss已经非常低了，说明还是比较成功的。完整代码请扫描二维码下载，<strong>请给个star</strong>！。</p>]]></content>
      
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch--基础指北_伍</title>
      <link href="/2024/09/28/pytorch_5/"/>
      <url>/2024/09/28/pytorch_5/</url>
      
        <content type="html"><![CDATA[<h1><span id="pytorch-基础指北_伍">Pytorch ——基础指北_伍</span></h1><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><!-- toc --><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83">软件环境：</a></li><li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识：</a><ul><li><a href="#python-%E7%9A%84%E5%BC%82%E5%B8%B8%E8%A7%A6%E5%8F%91">python 的异常触发</a></li><li><a href="#python-%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90">python 的列表解析</a></li><li><a href="#python%E7%9A%84dataframe">Python的DataFrame</a></li><li><a href="#python%E7%9A%84enumerate">Python的enumerate</a></li></ul></li><li><a href="#pytorch%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD">Pytorch的数据加载</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAdataset%E6%95%B0%E6%8D%AE%E9%9B%86">如何导入数据并转换为Dataset（数据集）？</a></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E8%BF%AD%E4%BB%A3%E4%B8%8E%E6%93%8D%E4%BD%9C">数据集的迭代与操作</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8dataloader%E5%91%A2">如何使用Dataloader呢？</a><br>* <a href="#%E5%88%B0%E8%BF%99%E9%87%8C%E6%89%80%E6%9C%89%E7%9A%84%E5%86%85%E5%AE%B9%E5%B0%B1%E9%83%BD%E5%AE%8C%E6%88%90%E4%BA%86">到这里所有的内容就都完成了。</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="软件环境">软件环境：</span></h2><ul><li><strong>pytorch 1.10</strong></li><li><strong>pycharm</strong></li></ul><h2><span id="基础知识">基础知识：</span></h2><h3><span id="python-的异常触发">python 的异常触发</span></h3><p>我们可以使用raise语句自己触发异常</p><p>raise语法格式如下：</p><pre><code>raise [Exception [, args [, traceback]]]</code></pre><p>语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。如果你不懂异常没关系，只要知道是主动的报告代码运行错误就可以。</p><h3><span id="python-的列表解析">python 的列表解析</span></h3><p>根据已有列表，高效创建新列表的方式。</p><p>列表解析（list comprehension）提供了一种优雅的生成列表的方法，能用一行代码代替十几行代码，而且不损失任何可读性。<strong>而且，性能还快很多很多</strong>（50%）。</p><p>它的基本结构是：</p><pre><code class="language-python">[expr for iter_var in iterable if cond_expr]#表达式+for循环+条件表达式</code></pre><p>构建完成后返回一个list列表，对于第一个表达式甚至可以加入 if else。</p><p>举个例子：</p><pre><code class="language-python">numbers = [1,2,3,4,5,6,11,12]&gt;&gt;&gt;max=10&gt;&gt;&gt;[ i for i in numbers if i &gt;max ]&gt;&gt;&gt;[11, 12]</code></pre><p>通过表达式返回大于10的所有数据。</p><pre><code class="language-python">PyDev console: starting.Python 3.8.12 (default, Oct 12 2021, 03:01:40) [MSC v.1916 64 bit (AMD64)] on win32&gt;&gt;&gt;numbers = [1,2,3,4,5,6,7,89]#返回大于5的构成的列表。&gt;&gt;&gt;[i if i &gt;5 else 0  for i in numbers]&gt;&gt;&gt;[0, 0, 0, 0, 0, 6, 7, 89]&gt;&gt;&gt;[i if i &gt;5 else None  for i in numbers]&gt;&gt;&gt;[None, None, None, None, None, 6, 7, 89]#小于5增加100返回[i if i &gt;5 else i+100  for i in numbers][101, 102, 103, 104, 105, 6, 7, 89]</code></pre><h3><span id="python的dataframe">Python的DataFrame</span></h3><p>DataFrame是一种表格型数据结构。通过行和列的索引可以快速定位数据位置。</p><p><img src="https://s2.loli.net/2024/09/29/D4921OnZizHMUTw.png" alt="img"></p><pre><code class="language-python">pandas.DataFrame( data, index, columns, dtype, copy)</code></pre><ul><li><strong>data</strong>：一组数据(ndarray、series, map, lists, dict 等类型)。</li><li><strong>index</strong>：索引值，或者可以称为行标签。</li><li><strong>columns</strong>：列标签，默认为 RangeIndex (0, 1, 2, …, n) 。</li><li><strong>dtype</strong>：数据类型。</li><li><strong>copy</strong>：拷贝数据，默认为 False。</li></ul><p>样例：</p><pre><code class="language-python">data = [['zzy', 3], ['jszszzy', 6], ['zzys', 4]]df = pd.DataFrame(data, columns=['name', 'length'])print(df)</code></pre><p>结果：</p><pre><code class="language-shell">      name  length0      zzy       31  jszszzy       62     zzys       4</code></pre><p>如果想访问行可以这样：</p><pre><code class="language-python">print(df.loc[0])</code></pre><p>访问某两行：</p><pre><code class="language-python">print(df.loc[[0, 1]])&gt;&gt;&gt;        name  length0      zzy       31  jszszzy       6#此时相当于一个小DataFrame</code></pre><p>访问某一列：</p><pre><code class="language-python">print(df["name"])&gt;&gt;&gt;0        zzy1    jszszzy2       zzys</code></pre><p>同时限定行和列：</p><pre><code class="language-python">print(df.iloc[0:1,0])&gt;&gt;&gt;0    zzyName: name, dtype: object</code></pre><p>可以看到同时支持列号和行号。</p><pre><code class="language-python">print(df.shape)&gt;&gt;&gt;(3, 2)</code></pre><p><a href="https://so.csdn.net/so/search?q=shape&amp;spm=1001.2101.3001.7020">shape</a>函数，返回的是元组（不可变的列表）</p><ul><li>hg.shape返回的是hg的行数和列数</li><li>hg.shape[0]返回的是hg的行数，有几行</li><li>hg.shape[1]返回的是hg的列数，有几列</li></ul><h3><span id="python的enumerate">Python的enumerate</span></h3><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><pre><code class="language-python">enumerate(sequence, [start=0])</code></pre><ul><li>sequence – 一个序列、迭代器或其他支持迭代对象。</li><li>start – 下标起始位置的值。</li></ul><p>我们需要输出下标的同时输出内容时可以使用它：</p><pre><code class="language-shell">&gt;&gt;&gt; seq = ['one', 'two', 'three']&gt;&gt;&gt; for i, element in enumerate(seq):...     print i, element...0 one1 two2 three</code></pre><h2><span id="pytorch的数据加载">Pytorch的数据加载</span></h2><p>为什么使用数据加载？在前面几节课我们知道函数关系的情况下可以随机生成数据集，每次训练的时候直接把所有数据都送进去进行加载是不现实的，当数据量巨大的时候你的显存可能撑不住，所以我们就需要一个工具类来实现对数据集的管理，<code>torch.utils.data.dataset，dataloader</code>就是这样的类，通过继承这个类并将里面的内容重写，我们能非常方便的实现对数据集的操作。</p><p>首先我们需要下载数据集：</p><p><a href="http://archive.ics.uci.edu/ml/datasets/SMS+Spam+Collection">数据集下载</a></p><p>下载解压后放到目录中：</p><p><img src="https://s2.loli.net/2024/09/29/TpkcJNUbgjiBznm.png" alt="1"></p><h4><span id="如何导入数据并转换为dataset数据集">如何导入数据并转换为Dataset（数据集）？</span></h4><p>首先我们需要将这个类引用过来：</p><pre><code class="language-python">from caffe2.python.dataset import Dataset</code></pre><p>引用以后还需要将其内部的三个方法实现以便于使用：</p><pre><code class="language-python">class Mydataset(Dataset):    def __init__(self):    #初始化构造数据集    def __getitem__(self,index):    #获取元素        def __len__(slef):    #获取数据总长度   </code></pre><p>下面展示一下如何实现一个<strong>Dataset</strong></p><p>首先是初始化数据集，实现内部三个方法：</p><p>首先是初始化：</p><pre><code class="language-python">    def __init__(self):        lines = open(data_path, "rb")        lines = [[i[:4].strip(), i[4:].strip()] for i in lines]#分割数据去除内部空格等冗余信息        self.df = pd.DataFrame(lines, columns=["label", "sms"])#调整行标</code></pre><p>​初始化的思路很简单就是将每组数据结合起来然后转化成DataFrame的形式。</p><p>再就是__ getitem__方法：</p><pre><code class="language-python">    def __getitem__(self, index):        item = self.df.iloc[index,:]        return item.values[0],item.values[1]    #这里是获取DataFrame的内容·，返回为字典，调用values分解</code></pre><p>最后是__ len__方法：</p><pre><code class="language-python">    def __len__(self):        return self.df.shape[0]    #这里使用了DataFrame的shape方法获取行数。</code></pre><h2><span id="数据集的迭代与操作">数据集的迭代与操作</span></h2><p>通过Dataset我们成功地将一个文本数据导入并对其进行了处理成功转化成一个通用的数据集类。但是我们还有很多操作没有实现：</p><ul><li>批处理数据（Batching the data）</li><li>打乱数据（Shuffling the data）</li><li>使用多线程 <code>multiprocessing</code> 并行加载数据。</li><li>对多余的数据进行处理<code>drop_last</code></li></ul><p>在pytorch中如何对数据集进行操作呢？</p><p>这就来到了Dataloader类：</p><h3><span id="如何使用dataloader呢">如何使用Dataloader呢？</span></h3><p>使用很简单：</p><pre><code class="language-python"> mydataloader = DataLoader(dataset=mydataset, batch_size=10, shuffle=True, num_workers=2)</code></pre><p>调用其类的初始化来实例化对象，产生一个mydataloader，在实例化的过程中通过参数来调整数据集。</p><p>dataset就是需要操作的dataset对象，</p><p>drop_last就是没批的数据大小，</p><p>shuffle是否进行随机打乱处理，</p><p>num_workers是多线程加载数据集的数量，</p><p>drop_last是是否进行丢去数据集的零头，因为数据数量对batch_size来说总不是一定能整除的最后一组可能并不能占满。</p><pre><code class="language-python">mydataloader = DataLoader(dataset=mydataset, batch_size=10, shuffle=True, num_workers=3, drop_last=True)</code></pre><p>那么我们该怎么查看修改后的数据集呢？</p><p>这里需要说明的是，在构造数据的时候我们采用的是两种为一组的方式，也就是：</p><p><strong>标签+数据内容</strong>，在迭代输出的时候也要将两个数据都取出来，你可以直接迭代：</p><pre><code class="language-python">    for label in mydataloader:        print(label)</code></pre><p>输出：</p><pre><code class="language-shell">[('ham', 'ham', 'ham', 'ham', 'ham', 'ham', 'spam', 'ham', 'spam', 'ham'), ('Only saturday and sunday holiday so its very difficult:)', "Oh right, ok. I'll make sure that i do loads of work during the day!  got a really nasty cough today and is dry n shot so that should really help it!", "That's one of the issues but california is okay. No snow so its manageable", "How have your little darlings been so far this week? Need a coffee run tomo?Can't believe it's that time of week already …", "Don't fret. I'll buy the ovulation test strips and send them to you. You wont get them til like march. Can you send me your postal address.u'll be alright.Okay.", 'Ok anyway no need to change with what you said', 'PRIVATE! Your 2004 Account Statement for 07742676969 shows 786 unredeemed Bonus Points. To claim call 08719180248 Identifier Code: 45239 Expires', "That's the trouble with classes that go well - you're due a dodgey one … Expecting mine tomo! See you for recovery, same time, same place", 'FREE for 1st week! No1 Nokia tone 4 ur mobile every week just txt NOKIA to 8077 Get txting and tell ur mates. www.getzed.co.uk POBox 36504 W45WQ 16+ norm150p/tone', 'After completed degree. There is no use in joining finance.')]****************************************************************************************************[('ham', 'ham', 'ham', 'ham', 'spam', 'spam', 'ham', 'ham', 'ham', 'ham'), ('I only work from mon to thurs but Sat i cant leh... Booked liao... Which other day u free?', 'Do I? I thought I put it back in the box', 'Dont search love, let love find U. Thats why its called falling in love, bcoz U dont force yourself, U just fall and U know there is smeone to hold U... BSLVYL', 'Long after I quit. I get on only like 5 minutes a day as it is.', 'URGENT! We are trying to contact U. Todays draw shows that you have won a £2000 prize GUARANTEED. Call 09058094507 from land line. Claim 3030. Valid 12hrs only', 'Camera - You are awarded a SiPix Digital Camera! call 09061221066 fromm landline. Delivery within 28 days.', 'Ok...', 'Tmrw. Im finishing 9 doors', 'Love it! The girls at the office may wonder why you are smiling but sore...', '"YEH I AM DEF UP4 SOMETHING SAT,JUST GOT PAYED2DAY &amp; I HAVBEEN GIVEN A£50 PAY RISE 4MY WORK &amp; HAVEBEEN MADE PRESCHOOLCO-ORDINATOR 2I AM FEELINGOOD LUV"')]****************************************************************************************************</code></pre><p>可以看到每一组数据其实分开了两部分并组合成一个list，list里面是根据batch_size 大小构成的两个元组。</p><p>当然你也可以这样迭代，就直接会拆分成两个元组，用起来很方便。</p><pre><code class="language-python">    for (label, sms) in mydataloader:        print(label, sms)        print("*" * 100)#分隔符</code></pre><h6><span id="到这里所有的内容就都完成了">到这里所有的内容就都完成了。</span></h6>]]></content>
      
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch--基础指北_陆</title>
      <link href="/2024/09/28/pytorch_6/"/>
      <url>/2024/09/28/pytorch_6/</url>
      
        <content type="html"><![CDATA[<h1><span id="pytorch-基础指北_陆">Pytorch ——基础指北_陆</span></h1><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><!-- toc --><ul><li><a href="#%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83">软件环境：</a></li><li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识：</a></li><li><a href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%AE%98%E6%96%B9%E6%95%B0%E6%8D%AE%E9%9B%86%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86">如何通过官方数据集构建自己的数据集？</a><ul><li><a href="#mnist%E6%95%B0%E6%8D%AE%E9%9B%86">MNIST数据集</a></li><li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8mnist%E6%95%B0%E6%8D%AE%E9%9B%86">如何使用MNIST数据集？</a></li><li><a href="#transforms%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">Transforms类的数据处理方法</a><ul><li><a href="#torchvisiontransformstotensor">torchvision.transforms.ToTensor</a></li><li><a href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BB%B4%E5%BA%A6%E5%8F%98%E6%8D%A2">图像的维度变换</a></li><li><a href="#%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8totensor%E6%96%B9%E6%B3%95%E5%91%A2">那么如何使用ToTensor方法呢？</a></li><li><a href="#torchvisiontransformsnormalizemean-std">torchvision.transforms.Normalize（mean ，std）</a></li><li><a href="#torchvisiontransformscomposetransforms">torchvision.transforms.Compose（transforms）</a></li></ul></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="软件环境">软件环境：</span></h2><ul><li><strong>pytorch 1.10</strong></li><li><strong>pycharm</strong></li></ul><h2><span id="基础知识">基础知识：</span></h2><p>本次混入讲解过程。</p><h2><span id="如何通过官方数据集构建自己的数据集">如何通过官方数据集构建自己的数据集？</span></h2><h3><span id="mnist数据集">MNIST数据集</span></h3><p>MNIST数据库是非常经典的一个数据集，就像你学编程起初写一个“Hello Word”的程序一样，学Deep Learning你就会写识别MNIST数据集的Model。</p><p>MNIST数据集是由0〜9手写数字图片和数字标签所组成的，由60000个训练样本和10000个测试样本组成，每个样本都是一张28 * 28像素的灰度手写数字图片。</p><h3><span id="如何使用mnist数据集">如何使用MNIST数据集？</span></h3><p>在Pytorch中你可以很方便的使用它，只需要下载后，就可以立即使用，下载方法很简单，首先引用针对MNIST数据集的类：<code>from torchvision.datasets import MNIST</code>。</p><p><img src="https://s2.loli.net/2024/09/29/k4hY8Xcu9dT2ipj.png" alt="1"></p><p>创建这个类的实例<code>MNIST_dataset = MNIST(root="./data",train=True,download=True,transform=None)</code>。</p><p>其中参数分别是</p><ul><li>root 存储位置；</li><li>train 是否为训练集；</li><li>download是否下载；</li><li>transform处理函数，下一个节点会具体介绍其作用；</li></ul><p>下载完成后我们可以输出一个看看一看是什么：</p><pre><code class="language-python">print(MNIST_dataset[0])</code></pre><p><img src="https://s2.loli.net/2024/09/29/BSZNAM5pWL3XTxh.png" alt="2"></p><p>可以看到由两部分组成：</p><p>图片+一个数字，这个数字就是标记好的数据集的label，指明了本张图片的内容。</p><p>值得注意的是MINST_dataset本身就是一个data包下的Dataset类，你从他的继承关系就可以看到：</p><p><img src="https://s2.loli.net/2024/09/29/M5yxA8pD7sLiX3Y.png" alt="3"></p><p>父类就是继承于Dataset。</p><p><img src="https://s2.loli.net/2024/09/29/rS94w53qaNlTsOu.png" alt="4"></p><h3><span id="transforms类的数据处理方法">Transforms类的数据处理方法</span></h3><h4><span id="torchvisiontransformstotensor">torchvision.transforms.ToTensor</span></h4><p>ToTensor是Pytorch内置的数据处理方法，常规的图像数据通常是这样的:</p><p><strong>[H,W,C]</strong></p><p>H代表了图像高度，也是H维度的大小；</p><p>W代表了图像宽度，也是W维度的大小；</p><p>C代表的是通道数，也就是每个像素点后的颜色通道大小，通常就是RGB，也就是3，你可以理解为每个像素点都是由这三个颜色在0-255之间混合起来的。</p><p>回到我们这个数据集来说，每张图片其实本身是黑白的，也就是说通道数只有一，每张图片的结构应该是**[28,28,1]**。</p><p>但是对于Pytorch很多处理函数来说并不支持这样的格式，而是支持 [C,H,W]  的格式，这就麻烦了，我们就需要做维度变换（视角变换）来变换数据格式，为什么这样说的呢？因为本身来说数据是固定的，我们只不过换了一种描述方式来对其进行新的描述，那么我们怎么把数据变换成[1,28,28]呢？很简单调用ToTensor这个方法就可以，我们把这个方法传入transforms，transforms会自动调用ToTensor来进行处理。</p><p>但是这里还是要讨论一下如果不是支持的格式，我们该怎么使用pytorch进行手动变换呢？</p><p>这就要介绍其内置的变换函数，具体使用规则可以参考第一篇所讲解的用法：，这里直接讲解理论。</p><h4><span id="图像的维度变换">图像的维度变换</span></h4><p>对于常规图像来说都是遵循这样的格式，**[W,H,C]<strong>或者</strong>[H,W,C]**但这样并不是通用的格式，便于理解但是不便于计算，如果我们设想有这样一张图片他的格式是这样的，[2,2,3]也就是一张2x2的图片，每个像素点三个通道分别是RGB，</p><p>把三个通道分解开就是这样：</p><p><img src="https://s2.loli.net/2024/09/29/LRSriZT4u9b8BqC.png" alt="5"></p><p>加上维度坐标系就是这样:</p><img src="https://s2.loli.net/2024/09/29/1xdMluNcE69ToWk.png" alt="6" style="zoom:80%;"><p>我们将数据填补进去，每个颜色在像素点的大小都是在0-255之间，这里就用[1-12]来替代看得更清楚：</p><img src="https://s2.loli.net/2024/09/29/UCO1qkrSXgHKAIB.png" alt="7"><p>你可能会好奇，如果使用**[W,H,C]**怎么表示这个图片呢？</p><p>可以展示一下：</p><pre><code class="language-python">&gt;&gt;&gt;t1&gt;&gt;&gt;tensor([[[ 1,  2,  3],           [ 4,  5,  6]],           [[ 7,  8,  9],           [10, 11, 12]]])</code></pre><p><strong>以最内的逗号最为z轴的分割，次外层作为y轴的分割，最外层的逗号作为x轴的分割</strong>，你可以看到：</p><img src="https://s2.loli.net/2024/09/29/gxathm2bo7NIT6l.png" alt="8" style="zoom:80%;"><p>可以看出来，最里边的括号就是代表一个像素点的三个通道，对于下标（0，0）的点，他三个通道的值就是1，2，3.从上图也可以看出。</p><p><strong>那为什么说轴变换就是视角变换呢？</strong></p><p>我们举个例子,在目前的情况下我们将图像从**[W,H,C]<strong>变换到</strong>[C,H,W]**,图像的样子会发生什么？</p><p>我们使用permute函数进行变换，T1的结果如下：</p><pre><code class="language-python">&gt;&gt;&gt;t1= t1.permute(2,1,0)#交换 0 和 2 维度&gt;&gt;&gt;t1&gt;&gt;&gt;tensor([[[ 1,  7],            [ 4, 10]],           [[ 2,  8],            [ 5, 11]],           [[ 3,  9],            [ 6, 12]]])</code></pre><p>我们同样以<strong>最内的逗号最为z轴的分割，次外层作为y轴的分割，最外层的逗号作为x轴的分割</strong>，再来把这样图画出来：</p><p>你可以发现坐标轴样子没有变，而代表轴的意思不同的了，相当于就是同一块数据使用了不同的视角来进行描述。</p><img src="https://s2.loli.net/2024/09/29/XVfWmcd2Lo7SZgr.png" alt="10" style="zoom:80%;"><p><strong>如果我们回到二维，你会发现这个操作其实就是矩阵的转置，而目前这个操作就可以叫三维矩阵的转置。</strong></p><p>最后补一张思考时候的手稿，大家先凑活着看吧。</p><img src="https://s2.loli.net/2024/09/29/kGTyPMmKZUJj3eN.png" alt="11" style="zoom:80%;"><p>总结一句话：</p><p><strong>ToTensor方法就是帮我们实现了 ”维度变换“ 这个操作。</strong></p><h4><span id="那么如何使用totensor方法呢">那么如何使用ToTensor方法呢？</span></h4><p>使用方法很简单，直接通过其类的call方法传入参数即可</p><p>举例：</p><pre><code class="language-python">from torchvision import transformsMNIST_dataset = MNIST(root="./data", train=True, download=True, transform=None)MNIST_tensor = transforms.ToTensor()(MNIST_dataset[0][0])print(MNIST_tensor)</code></pre><p>就可以打印出来刚才的图片5。当然实际上你看不出来这一堆数据到底相容的什么。你只要知道他是对</p><pre><code class="language-shell">tensor([[[0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0118, 0.0706, 0.0706, 0.0706,          0.4941, 0.5333, 0.6863, 0.1020, 0.6510, 1.0000, 0.9686, 0.4980,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.1176, 0.1412, 0.3686, 0.6039, 0.6667, 0.9922, 0.9922, 0.9922,          0.9922, 0.9922, 0.8824, 0.6745, 0.9922, 0.9490, 0.7647, 0.2510,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.1922,          0.9333, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922,          0.9922, 0.9843, 0.3647, 0.3216, 0.3216, 0.2196, 0.1529, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0706,          0.8588, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.7765, 0.7137,          0.9686, 0.9451, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.3137, 0.6118, 0.4196, 0.9922, 0.9922, 0.8039, 0.0431, 0.0000,          0.1686, 0.6039, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0549, 0.0039, 0.6039, 0.9922, 0.3529, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.5451, 0.9922, 0.7451, 0.0078, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0431, 0.7451, 0.9922, 0.2745, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.1373, 0.9451, 0.8824, 0.6275,          0.4235, 0.0039, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.3176, 0.9412, 0.9922,          0.9922, 0.4667, 0.0980, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.1765, 0.7294,          0.9922, 0.9922, 0.5882, 0.1059, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0627,          0.3647, 0.9882, 0.9922, 0.7333, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.9765, 0.9922, 0.9765, 0.2510, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.1804, 0.5098,          0.7176, 0.9922, 0.9922, 0.8118, 0.0078, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.1529, 0.5804, 0.8980, 0.9922,          0.9922, 0.9922, 0.9804, 0.7137, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0941, 0.4471, 0.8667, 0.9922, 0.9922, 0.9922,          0.9922, 0.7882, 0.3059, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0902, 0.2588, 0.8353, 0.9922, 0.9922, 0.9922, 0.9922, 0.7765,          0.3176, 0.0078, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0706, 0.6706,          0.8588, 0.9922, 0.9922, 0.9922, 0.9922, 0.7647, 0.3137, 0.0353,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.2157, 0.6745, 0.8863, 0.9922,          0.9922, 0.9922, 0.9922, 0.9569, 0.5216, 0.0431, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.5333, 0.9922, 0.9922, 0.9922,          0.8314, 0.5294, 0.5176, 0.0627, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000],         [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000,          0.0000, 0.0000, 0.0000, 0.0000]]])Process finished with exit code 0</code></pre><h4><span id="torchvisiontransformsnormalizemean-std">torchvision.transforms.Normalize（mean ，std）</span></h4><p>你可以看到这个方法也是在transforms包下的，说明他也是用来对数据集进行处理的预置方法，这个方法的作用很简单，就是标准化图像里面的数据，使用的时候只需要传入对应的mean（均值），std（标准差）即可，值得注意的是，标准差和方差都指的是图像每个通道的标准差与均值，假如RGB图像，你就应该传入一个（三位的list[a,b,c]）。</p><p>那么什么是标准化呢？</p><p>图像标准化是将数据通过去均值实现中心化的处理，根据凸优化理论与数据概率分布相关知识，数据中心化符合数据分布规律，更容易取得训练之后的泛化效果, 数据标准化是<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86&amp;spm=1001.2101.3001.7020">数据预处理</a>的常见方法之一</p><p>有公式：<br>$$<br>Normailized_{image} = \frac{(image - mean ) }{Std}\<br>其中\<br>Std =\sqrt{\sigma^{2}}=\sqrt{\frac{\sum_{i=1}^{N}\left(x_{i}-\mu\right)^{2}}{N}}(X_i是某像素的某一通道值)<br>$$</p><p>这一大波操作看的头皮发麻，实际上有一个更常用的公式：</p><p><img src="https://s2.loli.net/2024/09/29/wZBteI9X8urfVhy.png" alt="12"></p><p>你应该瞬间就明白了，就是把图像的数据分布转换成一个均值为0，标准差为1的分布。但是值得注意的是并不是一定为正态分布，取决于原来数据分布的情况。</p><p>使用方法同样也是调用call方法也就是在实例化对象后直接（）传入图像。</p><pre><code class="language-python">from torchvision.datasets import MNISTimport torchvisionfrom torchvision import transformsMNIST_dataset = MNIST(root="./data", train=True, download=True, transform=None)MNIST_tensor = transforms.ToTensor()(MNIST_dataset[0][0])MNIST_tensor_nom = transforms.Normalize(10, 10)(MNIST_tensor)print(MNIST_tensor_nom)</code></pre><p>值得注意的是，这里的(10, 10)并不是真正的标准差和均值，是我随意写的，主要是用来验证使用方法而已。</p><h4><span id="torchvisiontransformscomposetransforms">torchvision.transforms.Compose（transforms）</span></h4><p>这个就更简单了，将多个<code>transform</code>组合起来使用。</p><p>例如：</p><pre><code class="language-python">transforms.Compose(    [torchvision.transforms.ToTensor(), #先转化为Tensor     torchvision.transforms.Normalize(mean,std)] #在进行正则化     )</code></pre><p>可以看到传入的参数实际上是一个由多个transforms包下的处理类组成的List。</p><p>知道了这样，我们就可以改写一下上边所进行两个操作：</p><pre><code class="language-python">from torchvision.datasets import MNISTfrom torchvision.transforms import Compose, ToTensor, Normalizetransforms_fn = Compose([ToTensor(), Normalize(mean=(0.1307,), std=(0.3081,))])MNIST_dataset = MNIST(root="./data", train=True, download=True, transform=transforms_fn)print(MNIST_dataset)</code></pre><p>你如果看过**<a href="https://blog.csdn.net/qq_20540901/article/details/123531083?spm=1001.2014.3001.5502">上一篇</a>**关于数据集类的介绍，就知道Dataset类都是用来初始化数据集的，并不能对数据集做分批，打乱，等操作，所以对一个完整的数据集来说应该配合有对应的Dataloader类来进一步对数据集操作，并将数据送入网络。</p><p>结合Dataloader进行操作：</p><pre><code class="language-python">from torchvision.datasets import MNISTfrom torchvision.transforms import Compose, ToTensor, Normalizetransforms_fn = Compose([ToTensor(), Normalize(mean=(0.1307,), std=(0.3081,))])MNIST_dataset = MNIST(root="./data", train=True, download=True, transform=transforms_fn)#构建dataloaderMNIST_dataloader = DataLoader(dataset=MNIST_dataset, batch_size=2, drop_last=True, shuffle=True)</code></pre><p>这样基本的一个数据集就构建完成了，当然我们可以给他增加一些功能并整合成一个函数，可以通过MNIST_dataset的train参数来设置是训练集还是测试集，只要传入一个参数即可，最后让他返回制作好的Dataloader。</p><pre><code class="language-python">def MNIST_create_dataloader(train=True):    transforms_fn = Compose([ToTensor(), Normalize(mean=0.1307, std=0.3081)])    MNIST_dataset = MNIST(root="./data", train=train, download=True, transform=transforms_fn)    MNIST_dataloader = DataLoader(dataset=MNIST_dataset, batch_size=2, drop_last=True, shuffle=True)    return MNIST_dataloader</code></pre><p>我们来遍历一下制作好的Dataloader，完整代码如下：</p><pre><code class="language-python">import sysimport torchimport torch.nn as nnimport torch.optim as optimport numpy as npimport pandas as pdfrom torch.utils.data import Dataset, DataLoaderfrom torchvision.datasets import MNISTfrom torchvision.transforms import Compose, ToTensor, Normalizedef MNIST_create_dataloader(train=True):    transforms_fn = Compose([ToTensor(), Normalize(mean=0.1307, std=0.3081)])    MNIST_dataset = MNIST(root="./data", train=train, download=True, transform=transforms_fn)    MNIST_dataloader = DataLoader(dataset=MNIST_dataset, batch_size=2, drop_last=True, shuffle=True)    return MNIST_dataloaderdef get_MNIST_dataloader():    MNIST_dataloader = MNIST_create_dataloader(False)    for num, i in enumerate(MNIST_dataloader):        print(num, i)get_MNIST_dataloader()</code></pre><p>只看最后一batch的输出结果：</p><p>因为batch_size=2，每组就是由两张照片所组成的。</p><pre><code>29999 [tensor([[[[-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          ...,          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242]]],        [[[-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          ...,          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242],          [-0.4242, -0.4242, -0.4242,  ..., -0.4242, -0.4242, -0.4242]]]]), tensor([5, 8])]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从C过渡到C++(1)——GNU/Linux</title>
      <link href="/2024/09/28/%E4%BB%8EC%E8%BF%87%E6%B8%A1%E5%88%B0C++(1)--GNU&amp;Linux/"/>
      <url>/2024/09/28/%E4%BB%8EC%E8%BF%87%E6%B8%A1%E5%88%B0C++(1)--GNU&amp;Linux/</url>
      
        <content type="html"><![CDATA[<h1><span id="从c过渡到c1gnulinux">从C过渡到C++(1)——GNU/Linux</span></h1><img src="https://s2.loli.net/2024/09/29/g8NzUVm3C2h9uc1.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727589808872" style="zoom:50%;"><!-- toc --><ul><li><a href="#%E5%A4%A7%E5%90%8D%E9%BC%8E%E9%BC%8E%E7%9A%84gnulinux">大名鼎鼎的GNU/Linux</a><ul><li><a href="#gnu">GNU</a><ul><li><a href="#gnu%E7%9A%84%E7%BB%84%E6%88%90">GNU的组成</a></li><li><a href="#%E4%B8%80%E7%82%B9%E8%A1%A5%E5%85%85">一点补充</a></li><li><a href="#mingw">MinGW</a></li><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93">运行时库</a></li><li><a href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E5%86%85%E5%AE%B9">额外的内容</a></li></ul></li></ul></li><li><a href="#mingw%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85">MinGW的环境配置安装</a></li></ul><!-- tocstop --><p>[TOC]</p><p>文中使用软件的云盘下载地址：<a href="https://www.aliyundrive.com/s/juMJT9dBZgd%E3%80%82">https://www.aliyundrive.com/s/juMJT9dBZgd。</a></p><p>大多人学习C语言会有这样的经历，就是老师让下载一个IDE，比如VS或者Dev-C++,然后就直接开始写代码了，IDE确实很方便不过这些是在Windows下很舒服，直接打开就可以写，但是随着学习和工作变化，你会发现你不仅会使用到Windows，甚至在大多数生产环境下使用的都是Linux，这就很难受了，linux系统在某些特殊情况你使用的是不带有图行化的界面的发行版Linux（Ubuntu就是带有桌面系统的，有些Debian系统没有），如下图如所示：</p><p><img src="https://s2.loli.net/2022/08/12/YjEmXH2BQKz85t3.png" alt="202208120030266.png"></p><p>上图使用的就是不带有图形界面的Ubuntu(WSL2),这样的情况在嵌入式开发中很常见，甚至对于Web开发有些服务器上的Linux也是完全不带有图形界面的，这样就谈不上使用IDE了，在这样的环境下你该如何编写一个C语言程序，并将它编译呢？</p><p>为了解决这些问题我们不妨先去了解一下GNU/Linux到底是什么？</p><h2><span id="大名鼎鼎的gnulinux">大名鼎鼎的GNU/Linux</span></h2><p>如果你看过稚晖君的一篇文章，是关于STM32开发环境配置，但是不同于以往的IDE，稚晖君使用的是Clion，在配置过程中他下载了一个很特殊的配置软件叫MinGW：</p><p><img src="https://s2.loli.net/2022/08/12/AYMByUcNJC8eDbl.png" alt="202208120030488.png"></p><p>你可能会照着做做，但是不理解这些东西都是干什么的？或者说不理解这些东西是为什么而存在的，在理解之前我们不妨了解一下什么是GNU。</p><h3><span id="gnu">GNU</span></h3><p>GNU操作系统起源于<a href="https://zh.m.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83">GNU计划</a>，由<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>在<a href="https://zh.m.wikipedia.org/wiki/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%B8%E9%99%A2">麻省理工学院</a>人工智能实验室发起，希望发展出一套完整的开放源代码操作系统来取代Unix，计划中的操作系统，名为GNU。</p><p><img src="https://s2.loli.net/2022/08/12/jQLouxXq39ZigGR.png" alt="202208120031439.png"></p><p>GNU的商标是一个<a href="https://zh.m.wikipedia.org/wiki/%E7%89%9B%E7%BE%9A">牛羚</a>头。原先版本是Etienne Suvasa所设计，而今比较流行的粗体版本则是Aurelio Heckert所设计。</p><p><strong>GNU</strong>是一个<a href="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BB%9F%E9%AB%94">自由</a>的<a href="https://zh.m.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1">操作系统</a>，其内容软件完全以<a href="https://zh.m.wikipedia.org/wiki/GPL">GPL</a>方式发布。这个操作系统是<a href="https://zh.m.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83">GNU计划</a>的主要目标，名称来自GNU’s Not Unix!的<a href="https://zh.m.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E7%B8%AE%E5%AF%AB">递归缩写</a>，因为GNU的设计类似<a href="https://zh.m.wikipedia.org/wiki/Unix">Unix</a>，但它不包含具著作权的Unix代码。</p><p>你可能会难以理解，我从来没听说过GNU操作系统，像是Linux，Unix这种都是很有名的，但GNU到底是什么？</p><p>1983年9月27日，<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>在 net.unix-wizards 和 net.usoft<a href="https://zh.m.wikipedia.org/wiki/%E6%96%B0%E8%81%9E%E7%BE%A4%E7%B5%84">新闻组</a>中公布这项GNU计划。斯托曼的目标是成立一个完全自由的操作系统，他希望电脑用户是能够“自由使用”的。因为在20世纪60年代和70年代 - 大多数人都能自由学习软件的源代码，自由地与他人分享的软件，可自由修改软件的行为，自由发布的软件的修改后的版本。也就是说早些年软件几乎都是免费的，每个人都可以自由地使用和修改。</p><p>1984年1月5日，正式开始开发软件，为了防止这些软件将来可能被主张所有权，影响到自由软件的发展，斯托曼辞去了在实验室的工作。</p><p>理查德·斯托曼使用<a href="https://zh.m.wikipedia.org/w/index.php?title=%E4%B8%8D%E5%85%BC%E5%AE%B9%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1&amp;action=edit&amp;redlink=1">不兼容分时系统</a>（英语：<a href="https://en.wikipedia.org/wiki/Incompatible_Timesharing_System">Incompatible Timesharing System</a>） (ITS)[<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-intervention-6">6]</a>（一种早期的操作系统，使用<a href="https://zh.m.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">汇编语言</a>撰写，因其所运行的称为 <a href="https://zh.m.wikipedia.org/wiki/PDP-10">PDP-10</a>的电脑系统架构停止发展而变得过时）的经验，导致了需要一种可移植系统的决定。</p><p>因此，会议决定，将开发新的系统，并使用 <a href="https://zh.m.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">C</a> 和<a href="https://zh.m.wikipedia.org/wiki/Lisp">Lisp</a>作为系统编程语言。[<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-8">8]</a> 且GNU将与UNIX兼容。[<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-9">9]</a> 当时，UNIX已经是一个流行的专有操作系统。而Unix的设计是模块化的，所以它可以被逐步分块的实现。</p><p>Unix在学术机构和大型企业中得到了广泛的应用，当时的UNIX拥有者<a href="https://zh.m.wikipedia.org/wiki/AT%26T">AT&amp;T</a>公司以低廉甚至免费的许可将Unix源码授权给学术机构做研究或教学之用，许多机构在此源码基础上加以扩展和改进，形成了所谓的“Unix变种”，这些变种反过来也促进了Unix的发展。</p><p>后来<a href="https://zh.m.wikipedia.org/wiki/AT%26T">AT&amp;T</a>意识到了Unix的商业价值，不再将Unix源码授权给学术机构，并对之前的Unix及其变种声明了著作权权利。BSD在Unix的历史发展中具有相当大的影响力，被很多商业厂家采用，成为很多商用Unix的基础。其不断增大的影响力终于引起了AT&amp;T的关注，于是开始了一场持久的著作权官司，由此人们意识到我们需要一个完全免费的操作系统。</p><p>1984年，开始发展编辑器<a href="https://zh.m.wikipedia.org/wiki/Emacs">Emacs</a>等软件。1985年，发表<a href="https://zh.m.wikipedia.org/wiki/GNU%E5%AE%A3%E8%A8%80">GNU宣言</a>。1989年，发表<a href="https://zh.m.wikipedia.org/zh-cn/GNU_General_Public_License">GNU通用公共许可协议</a>。这个公共开源许可协议，你如果开源过项目一定见过，他叫GPL协议，GPL是<a href="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BB%9F%E4%BB%B6">自由软件</a>和<a href="https://zh.m.wikipedia.org/wiki/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6">开源软件</a>的最流行许可证[<a href="https://zh.m.wikipedia.org/zh-cn/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81#cite_note-18">18]</a>。到2004年4月，GPL已占<a href="https://zh.m.wikipedia.org/w/index.php?title=Freshmeat&amp;action=edit&amp;redlink=1&amp;variant=zh-cn">Freshmeat</a>（英语：<a href="https://en.wikipedia.org/wiki/Freshmeat">Freshmeat</a>）上所列的自由软件的约75%，<a href="https://zh.m.wikipedia.org/wiki/SourceForge">SourceForge</a>的约68%。类似的，2001年一项关于<a href="https://zh.m.wikipedia.org/wiki/Red_Hat_Linux">Red Hat Linux</a> 7.1的调查显示一般的代码都以GPL发布。著名的GPL自由软件包括EMACS，<a href="https://zh.m.wikipedia.org/wiki/Linux">Linux</a>核心（并非所有<a href="https://zh.m.wikipedia.org/wiki/Linux%E7%99%BC%E8%A1%8C%E7%89%88">Linux发行版</a>的核心都是开源的）和<a href="https://zh.m.wikipedia.org/wiki/GCC">GCC</a>。</p><p>我们回到GNU的操作系统来，因为许多必要的软件需要从零开始写起来，但是有很多已经存在的第三方组件如 <a href="https://zh.m.wikipedia.org/wiki/TeX">TeX</a>、<a href="https://zh.m.wikipedia.org/wiki/X_Window_System">X Window System</a>[<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-internethist-4">4]</a>和<a href="https://zh.m.wikipedia.org/wiki/Mach">Mach</a>微内核等等都可以进行利用，其中GNU最关键系统内核，是在<a href="https://zh.m.wikipedia.org/zh-cn/GNU_Mach">GNU Mach</a><a href="https://zh.m.wikipedia.org/wiki/%E5%BE%AE%E5%85%A7%E6%A0%B8">微内核</a>基础上进行开发，<strong>理查德·马修·斯托曼</strong>认为可以借此加速操作系统的开发，但因为一直不确定<a href="https://zh.m.wikipedia.org/wiki/%E5%8D%A1%E5%86%85%E5%9F%BA%E6%A2%85%E9%9A%86%E5%A4%A7%E5%AD%A6">卡内基梅隆大学</a>何时要将核心源代码发布，造成计划延宕三年。他在之后承认这是个错误。</p><p>下图是大佬的照片：</p><img src="https://s2.loli.net/2024/09/29/D7mEzKTJ8dWYyRo.png" alt="image-20240929134346203" style="zoom:67%;"><p>除了上述的第三方组件外，大多数的GNU软件是由许多志愿者，在他们的空闲时间，或由公司、教育机构和非营利性组织赞助下撰写。</p><p>到 1990 年代初期，操作系统中所需的许多程序（例如库、<a href="https://en.wikipedia.org/wiki/Compiler">编译器</a>、<a href="https://en.wikipedia.org/wiki/Text_editor">文本编辑器</a>、<a href="https://en.wikipedia.org/wiki/Shell_(computing)#Command-line_shells">命令行 shell</a>和<a href="https://en.wikipedia.org/wiki/Windowing_system">窗口系统</a>）已完成，尽管低级元素如称为<a href="https://en.wikipedia.org/wiki/GNU_Hurd">GNU Hurd的</a><a href="https://en.wikipedia.org/wiki/Device_driver">设备驱动程序</a>、<a href="https://en.wikipedia.org/wiki/Daemon_(computer_software)">守护进程</a>和<a href="https://en.wikipedia.org/wiki/Kernel_(computer_science)">内核</a>都停滞不前且不完整。</p><p>1991年，Linux出现。1993年，<a href="https://zh.m.wikipedia.org/wiki/FreeBSD">FreeBSD</a>发布。FreeBSD就是当年与Unix著作权持有公司达成协议，重写的免费版Unix，所有GNU计划中，运行于用户空间的软件，都可以在Linux或FreeBSD上使用。许多开发者转向于Linux或FreeBSD。其中，Linux成为常见的GNU计划软件运行平台。<a href="https://zh.m.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a>主张，Linux操作系统使用了许多GNU计划软件，应正名为<a href="https://zh.m.wikipedia.org/wiki/GNU/Linux">GNU/Linux</a>，但没有得到Linux社群的一致认同，形成<a href="https://zh.m.wikipedia.org/wiki/GNU/Linux%E5%91%BD%E5%90%8D%E7%88%AD%E8%AD%B0">GNU/Linux命名争议</a>。</p><p><a href="https://zh.m.wikipedia.org/wiki/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9">林纳斯·托瓦兹</a>（Linus）开始在<a href="https://zh.m.wikipedia.org/wiki/MINIX">MINIX</a>上开发<a href="https://zh.m.wikipedia.org/wiki/Linux%E5%85%A7%E6%A0%B8">Linux内核</a>，为<a href="https://zh.m.wikipedia.org/wiki/MINIX">MINIX</a>写的软件也可以在<a href="https://zh.m.wikipedia.org/wiki/Linux%E5%85%A7%E6%A0%B8">Linux内核</a>上使用。[<a href="https://zh.m.wikipedia.org/zh-cn/Linux#cite_note-16">16]</a>后来使用GNU软件代替MINIX的软件，因为使用从GNU系统来的源代码可以自由使用，这对Linux的发展有益。使用GNU GPL协议的源代码可以被其他项目所使用，只要这些项目使用同样的协议发布。</p><p>对于GNU来说没有构成自己的操作系统是失败的，但是这个失败确实促进了行业进步与发展，<a href="https://zh.m.wikipedia.org/zh-cn/%E6%9E%97%E7%B4%8D%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E8%8C%B2">林纳斯·托瓦兹</a>曾说过如果GNU内核在1991年时可以用，他不会自己去写一个。实际上现在GNU代指的是当年发展下来的一系列软件。</p><h4><span id="gnu的组成">GNU的组成</span></h4><p>该系统的基本组成包括GNU编译器套装（<a href="https://zh.m.wikipedia.org/wiki/GCC">GCC</a>）、GNU的C库（<a href="https://zh.m.wikipedia.org/wiki/Glibc">glibc</a>）、以及GNU核心工具组（<a href="https://zh.m.wikipedia.org/wiki/Coreutils">coreutils</a>），另外还有GNU调试器（<a href="https://zh.m.wikipedia.org/wiki/GDB">GDB</a>）、GNU<a href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">编程语言</a>工具程序（<a href="https://zh.m.wikipedia.org/wiki/Binutils">binutils</a>）、<a href="https://zh.m.wikipedia.org/w/index.php?title=GNU_Cash&amp;action=edit&amp;redlink=1">GNU Cash</a> shell中[<a href="https://zh.m.wikipedia.org/zh-cn/GNU#cite_note-linuxinterface-10">10]</a> 和GNOME桌面环境。GNU开发人员已经转向GNU应用程序和工具的Linux <a href="https://zh.m.wikipedia.org/wiki/%E7%A7%BB%E6%A4%8D_(%E8%BB%9F%E9%AB%94)">移植</a> ，现在也广泛应用在其它操作系统中使用，上文我们提到的MinGW实际上叫Minimalist GNU for Windows，也就是向Windows移植的GNU最小套件，是将<a href="https://zh.wikipedia.org/wiki/GCC">GCC</a>编译器和<a href="https://zh.wikipedia.org/wiki/GNU_Binutils">GNU Binutils</a>移植到Win32平台下的产物，包括一系列头文件（<a href="https://zh.wikipedia.org/wiki/Windows_API">Win32API</a>）、<a href="https://zh.wikipedia.org/wiki/%E9%9D%9C%E6%85%8B%E9%80%A3%E7%B5%90%E5%87%BD%E5%BC%8F%E5%BA%AB">库</a>和<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a>。另有可用于产生32位及64位Windows可执行文件的<a href="https://zh.wikipedia.org/wiki/Mingw-w64"><strong>MinGW-w64</strong></a>项目，是从原本MinGW产生的分支。</p><h4><span id="一点补充">一点补充</span></h4><p><strong>Binutils</strong>指的是一组二进制程序处理工具，包括：addr2line、ar、objcopy、objdump、as、ld、ldd、readelf、size等。这一组工具是开发和调试不可缺少的工具。</p><ul><li>addr2line：用来将程序地址转换成其所对应的程序源文件及所对应的代码行，也可以得到所对应的函数。该工具将帮助调试器在调试的过程中定位对应的源代码位置。</li><li>as：主要用于汇编。</li><li>ld：主要用于链接。</li><li>ar：主要用于创建静态库。</li><li>ldd：可以用于查看一个可执行程序依赖的共享库。</li><li>objcopy：将一种对象文件翻译成另一种格式，譬如将.bin转换成.elf、或者将.elf转换成.bin等。</li><li>objdump：主要的作用是反汇编。</li><li>readelf：显示有关ELF文件的信息。</li><li>size：列出可执行文件每个部分的尺寸和总尺寸，代码段、数据段、总大小等。</li></ul><h4><span id="mingw">MinGW</span></h4><p>GCC支持的语言大多在MinGW也受支持，其中涵盖<a href="https://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80">C</a>、<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>、<a href="https://zh.wikipedia.org/wiki/Objective-C">Objective-C</a>、<a href="https://zh.wikipedia.org/wiki/Fortran">Fortran</a>及<a href="https://zh.wikipedia.org/wiki/Ada">Ada</a>。对于C语言之外的语言，MinGW使用标准的GNU<a href="https://zh.wikipedia.org/wiki/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93">运行时库</a>，如C++使用GNU <a href="https://zh.wikipedia.org/wiki/Libstdc%2B%2B">libstdc++</a>。</p><p>但是MinGW使用Windows中的C<strong>运行时库</strong>。因此用MinGW开发的程序不需要额外的第三方<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93">DLL</a>支持就可以直接在Windows下运行，而且也不一定必须遵从<a href="https://zh.wikipedia.org/wiki/GPL">GPL</a>许可证。这同时造成了MinGW开发的程序只能使用Win32API和跨平台的第三方库，而缺少POSIX支持，大多数GNU软件无法在不修改源代码的情况下用MinGW编译。</p><h4><span id="运行时库">运行时库</span></h4><p>谈到运行时库，就不得不在讨论一下C标准，C 标准主要由两部分组成，一部分<strong>描述C的语法</strong>，另一部分<strong>描述C标准库</strong>（描述了一些C标准函数的原型，但是不提供实现）。<br>C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义。常见的C标准就是<strong>ANSI C</strong>；为了提高C语言的开发效率，C标准定义了一系列常用的函数，称为<strong>C标准库函数</strong>。应用程序开发者可以包含这些标准函数的头文件，来调用这些C标准函数，来开发应用，这样就可以屏蔽平台的差异；</p><p><strong>C标准库函数</strong>的实现留给了各个系统平台；这个实现就是<strong>C运行时库(C Run Time Libray) ，简称CRT</strong>；C运行库，是和平台相关的，即和操作系统相关的；<strong>C运行库（CRT）<strong>从某种程度上来讲是</strong>C语言的程序和不同操作系统平台之间的抽象层</strong>;接口是统一的标准，实现由各个平台自己实现；Linux和Windows平台下的两个主要C语言运行库分别为glibc(GNU C Library)和MSVCRT（Microsoft Visual C Run-time）。也就是说你如果在Linux下就可以使用glibc，如果使用Windos下的Microsoft Visual C俗称VC IDE，就是用的是<strong>MSVCRT</strong>。</p><p>值得注意的是，像线程操作这样的功能并不是标准的C语言运行库的一部分，但是glibc和MSVCRT都包含了线程操作的库函数。所以glibc和MSVCRT事实上是标准C语言运行库的超集，它们各自对C标准库进行了一些扩展。也就是说CRT实际上包含两部分，一部分实现是<strong>基于C标准库</strong>来的，一部分实现是<strong>根据平台自身开发的库</strong>；</p><p>某种程度上是<strong>C运行库是C标准库的一个扩展库</strong>，加了很多C标准库所没有的与平台相关的或者不相关的库接口函数。要在一个平台上支持C语言，不仅要实现符合平台的C编译器，还要实现C标准库，这样的实现才算符合C标准。</p><h4><span id="额外的内容">额外的内容</span></h4><p>MinGW使用Windows中的<strong>C运行时库</strong>，也就是默认链接到 Windows 操作系统组件库<a href="https://en.wikipedia.org/wiki/Microsoft_Windows_library_files#MSVCRT.DLL_and_MSVCPP.DLL">MSVCRT</a>，这句话其实还有更深一层含义，如果你涉及过windos下的UI界面开发就会知道还有一个东西叫<strong>Windows API</strong>，C语言要早于Windows出现，而且C语言实际标准制定的开始时间也要早于Windows（API概念出现的）系统的开发时间。所以Windows系统在开发的时候是完全可以使用C语言的。目前最多的说法是用C和汇编实现的。那么只要用C，就可能用C标准库。</p><p>一般情况下，我们说C运行库暗含的意思是哪种平台哪个开发平台的C运行库，CRT的实现是基于Windows API的，而WindowsAPI的开发也是基于C语言的，但不是或者不一定基于CRT（或者C标准库）的。</p><p>再深一步，虽然CRT是基于操作系统 API实现的，但并不代表所有的CRT封装了操作系统 API，如一些用户的权限控制，操作系统线程创建等都不属于C运行库，于是对于这些操作我们就不得不直接调用操作系统API或者其他库。</p><p><strong>总结一下，C标准库就是任何平台都可以使用的基本C语言库。而CRT除了将C标准库加入所属范围外，还扩展了与平台相关的接口库，这些接口实现根据不同平台调用不同平台的操作系统API，如下图所示，采用C标准库编写的程序可以应用到windows平台，也可以应用到linux平台；而用CRT另外与平台相关的库函数编写的应用程序不能跨平台运行。</strong></p><p><img src="https://s2.loli.net/2022/08/12/o95cNPU2zHdYtsp.jpg" alt="202208120030811.jpg"></p><p>我们接下来安装MinGW并使用目前全宇宙最好的文字编辑器，编写HelloWorld。最后我们再迁移到更舒服的Clion平台上，并完成环境配置。</p><h2><span id="mingw的环境配置安装">MinGW的环境配置安装</span></h2><p>地址如下：<a href="https://sourceforge.net/projects/mingw/%E3%80%82">https://sourceforge.net/projects/mingw/。</a></p><p>点击下载以后，会打开一个Mingw的安装器的安装，如下图：</p><p><img src="https://s2.loli.net/2022/08/12/4ets1C7JVcoZHha.png" alt="202208120030681.png"></p><p>打开exe进行安装，修改安装目录（最好不能有空格），安装完成后进行组件下载：</p><p>这一部分就不详细介绍，有兴趣的可以看<a href="https://zhuanlan.zhihu.com/p/145801160">稚晖君的博客</a>安装，我们在这里使用最新的MinGW64来配置，我个人是两个版本都进行了安装。</p><p>因为新版的MinGW64是完全开源的，只提供源码，需要你自己编译，不过我们还可以通过<strong>MSYS2这个工具来下载</strong>新版的MinGW64。</p><p><strong>MSYS2</strong>是一组工具和库，为您提供易于使用的环境，用于构建、安装和运行本机 Windows 软件。</p><p>它由一个名为 <a href="https://mintty.github.io/">mintty</a>的命令行终端、bash、git 和 subversion 等版本控制系统、tar 和 awk 等工具，甚至 autotools 等构建系统组成，所有这些都基于<a href="https://cygwin.com/">Cygwin</a>的修改版本。尽管其中一些核心部分基于 Cygwin，但 MSYS2 的主要重点是为本地 Windows 软件提供构建环境，并且使用 Cygwin 的部分保持在最低限度。MSYS2 为 GCC、mingw-w64、CPython、CMake、Meson、OpenSSL、FFmpeg、Rust、Ruby 等提供最新的原生构建。</p><p>准确的说是集成了<a href="https://baike.baidu.com/item/pacman">pacman</a>和<a href="https://baike.baidu.com/item/Mingw">Mingw</a>-w64的<a href="https://baike.baidu.com/item/Cygwin">Cygwin</a>升级版, 提供了<a href="https://baike.baidu.com/item/bash">bash</a> shell等<a href="https://baike.baidu.com/item/linux">linux</a>环境、<a href="https://baike.baidu.com/item/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E8%BD%AF%E4%BB%B6">版本控制软件</a>（git/hg）和MinGW-w64 工具链。简单的来说模拟Linux运行环境的技术，它的一个优点就在于利用pacman包管理器，我们可以比较轻松的使用Linux包管理器的方式来安装一整套可以在Windows上运行的Linux工具。如果你只是想要在Windows上简单运行一些Linux程序，那么msys2是一个很好的选择。不过我们这里不是想要完全模拟Linux而是我们想通过MSYS2来获取MinGW的工具链。</p><p>软件已经放到了开头的网盘里面，安装过程如下：</p><p><img src="https://s2.loli.net/2024/09/29/jk9JsqFoiSuvGE4.png" alt="image-20240929133950486"></p><p>一路下一步：</p><img src="https://s2.loli.net/2022/08/11/jyZnCUT4oIY8Asg.png" alt="202208111950851.png"><p><img src="https://s2.loli.net/2022/08/12/3YmqUIVcFWanOxM.png" alt="202208120027781.png"></p><p>这时候会打开一个终端，你会很眼熟这不是git那个bash吗？</p><p><img src="https://s2.loli.net/2022/08/12/QqMnmxUlWEtDjur.png" alt="202208120027705.png"></p><p>我们首先更新包数据库和基础包。</p><p>使用命令：<code>pacman -Syu</code></p><p><img src="https://s2.loli.net/2022/08/11/s5uw7zxcvhrEWVR.png" alt="202208112009322.png"></p><p>重新开启后记得在运行一下，完成安装。</p><p><img src="https://s2.loli.net/2022/08/11/pCoeSVWmXrKOEJI.png" alt="202208112012528.png"></p><p>更新完成后如下：</p><p><img src="https://s2.loli.net/2022/08/11/pMl4Bix6T5keDK2.png" alt="202208112018516.png"></p><p>使用pacman的命令 安装Mingw-W64全部工具链。下图你可以看到他把所有的工具都给你列出来了。</p><p><img src="https://s2.loli.net/2022/08/12/B1TJRIZONjECg5a.png" alt="202208121802836.png"></p><p>这里可能需要网络条件好一点，推荐一个魔法，便宜好用：<a href="https://jkcloud.net/#/register?code=e4IbbIwA">链接地址</a>。</p><p>下载完成：</p><p><img src="https://s2.loli.net/2022/08/11/zrE6vZmWTXOD8Nf.png" alt="202208112036892.png"></p><p>安装完成以后可以在开始栏里搜到一个神奇的东西：</p><p><img src="https://s2.loli.net/2022/08/12/ZQ8Ncx15qJXtlCd.png" alt="202208121802383.png"></p><p>在系统环境变量中添加如下内容：</p><p>如果使用的是MinGW32,同样也需要把对应的内容放到环境变量里面。我两个都进行了安装，整体十分方便，基本20mins就搞定了。</p><p><img src="https://s2.loli.net/2022/08/12/tdbTAhprQZSlDjK.png" alt="202208120037952.png"></p><p>我们在命令行中测试一下。</p><p><img src="https://s2.loli.net/2022/08/11/vguhQ5D8kKNnErq.png" alt="202208112045735.png"></p><p>在网盘里面你也可以找到VScode这里我就不再赘述，直接安装即可。</p><p>我们新建一个文件夹C++还有一个Projects文件夹和HelloWorld文件夹,右键通过code打开Helloworld文件夹。</p><p><img src="https://s2.loli.net/2022/08/12/7ktKbl3BxPgujfh.png" alt="202208121804786.png">)</p><p>注意下图是<strong>错误的</strong>，应该打开对应文件夹，为不是文件，因为VScode需要加入一些调试设置和编译指令：</p><p><img src="https://s2.loli.net/2022/08/11/Y7XhBnuQMcEyUwS.png" alt="202208112058609.png"></p><p>然后安装C/C++的插件：</p><p><img src="https://s2.loli.net/2022/08/12/hFvePdTBCiKY9WS.png" alt="202208121805542.png"></p><p>当然你也可以不安装直接调用gcc进行编译不过我们为了方便还是安装插件进行调试。插件为我们提供了debug和自动补齐功能：</p><p><img src="https://s2.loli.net/2022/08/11/dRL1n2hClckAS5a.png" alt="202208112101828.png"></p><p>我们将鼠标悬停到对象上就会有对象的详细介绍。</p><p><img src="https://s2.loli.net/2022/08/11/1h9GtKr38fS7qoV.png" alt="202208112342657.png"></p><p>想要运行的时候，就点击右上角的运行按钮：</p><p><img src="https://s2.loli.net/2022/08/11/Pd2RpeEh7GTSjsZ.png" alt="202208112124436.png"></p><p>这时候会让你选择编译器：</p><p><img src="https://s2.loli.net/2022/08/11/jYPG69uW4s8KtIw.png" alt="202208112342935.png"></p><p>选择完成以后他会直接编译并且运行：</p><p><img src="https://s2.loli.net/2022/08/11/GE7tPRHDkdnswyf.png" alt="202208112124162.png"></p><p>同时<strong>调试控制台</strong>也会输出GDB的信息，你会亲切的看到一个内容他叫GNU，由此你的C++之路就正式开始了。</p><p><img src="https://s2.loli.net/2022/08/11/vc6Gfo8FgEhebJ1.png" alt="202208112125733.png"></p><p>如果你仔细了解就会发现，你在选择完编译器以后，VSCode会产生一个文件夹，这是VSCode保存项目信息的文件夹，本着刨根问底的精神我们再来看看这个json文件是干什么的：</p><pre><code class="language-json">{    "tasks": [        {            "type": "cppbuild",            "label": "C/C++: g++.exe 生成活动文件",            "command": "C:\\msys64\\mingw64\\bin\\g++.exe",            "args": [                "-fdiagnostics-color=always",                "-g",                "${file}",                "-o",                "${fileDirname}\\${fileBasenameNoExtension}.exe"            ],            "options": {                "cwd": "${fileDirname}"            },            "problemMatcher": [                "$gcc"            ],            "group": {                "kind": "build",                "isDefault": true            },            "detail": "调试器生成的任务。"        }    ],    "version": "2.0.0"}</code></pre><p>tasks指的是当你点下按钮的时候会去执行的任务，  <code>"command"</code>设置指定了要运行的程序；在本例中是g++。<code>args</code>指定了将被传递给g++的命令行参数。这些参数必须按照编译器所期望的顺序指定。</p><p>这个任务告诉g++接收活动文件（ <code>${file}</code>），对其进行编译，并在当前目录（  <code>$ {fileDirname}</code>）下创建一个可执行文件，其名称与要编译的源码文件名称相同，但扩展名为.exe（${fileBasenameNoExtension}.exe），在我们的例子中产生其实产生了helloworld.exe。</p><p><code>"label"</code>值是你将在任务列表中看到的；你可以随心所欲地命名它。</p><p><code>"detail"</code>是你将在任务列表中作为任务的描述。强烈建议重命名这个值，以便将它与类似的任务区分开来。</p><p>从现在开始，播放按钮将从<code>tasks.json</code>中读取信息以确定如何构建和运行你的程序。你可以在<code>tasks.json</code>中定义多个编译任务，哪个任务被标记为默认任务，播放按钮就会使用哪个。如果你需要改变默认的编译器，你可以运行Tasks: 配置默认构建任务。或者，你可以修改tasks.json文件，通过替换以下这一段来删除默认任务。</p><pre><code class="language-json">    "group": {        "kind": "build",        "isDefault": true    },</code></pre><p>把上述任务就可以替换成:</p><pre><code class="language-json"> "group": "build",</code></pre><p>这样这项任务就不再是默认任务了，执行的时候如果存在多个任务就会让你选择：</p><p><img src="https://s2.loli.net/2022/08/11/qU3Gn5vaKYcXLge.png" alt="202208112342112.png"></p><p>如果你想要将这个文件夹下的所有CPP文件进行编译也很简单，我们直接修改args中的参数为：</p><pre><code class="language-json">"args": [    "-fdiagnostics-color=always",    "-g",    "${workspaceFolder}/*.cpp",\\修改这里    "-o",    "${fileDirname}\\Jszszzy.exe"]</code></pre><p>或者你想要修改对应的输出文件的名称，也很简单，修改对应参数如下：</p><pre><code class="language-json">"args": [    "-fdiagnostics-color=always",    "-g",    "${workspaceFolder}/*.cpp",    "-o",    "${fileDirname}\\Jszszzy.exe"\\修改这里]</code></pre><p>当然以上这种方式是最原始的，我们还有make、cmake等工具还没有介绍，以后有时间再详细介绍，此篇作为我C++的开篇，搭建好了一个C++的学习使用环境，随着时代变迁比如Clion这种内置CMake的IDE已经出现，更适合大工程，大项目，不过为了学习我们还是使用这种原汁原味的更加深理解。</p><p>关于Task的网上有很多介绍，这里不再多说，详情见<a href="https://www.cvmart.net/community/detail/5288">链接</a>。</p><p>我在这里简单演示一下如何同时编译处于两个不同文件夹的源码文件</p><p>文件结构如下：</p><p><img src="https://s2.loli.net/2022/08/11/GkjNtzD2v18hbXr.png" alt="202208112341690.png"></p><p>task.json配置如下：</p><pre><code class="language-json">{    "tasks": [        {            "type": "cppbuild",            "label": "build1",            "command": "C:\\msys64\\mingw64\\bin\\g++.exe",            "args": [                "-fdiagnostics-color=always",                "-g",                "${workspaceFolder}/1/*.cpp",                "-o",                "${workspaceFolder}/1\\1.exe"            ],            "options": {                "cwd": "${workspaceFolder}/1"            },            "problemMatcher": [                "$gcc"            ],            "detail": "调试器生成的任务1。"        },        {            "type": "cppbuild",            "label": "build2",            "command": "C:\\msys64\\mingw64\\bin\\g++.exe",            "args": [                "-fdiagnostics-color=always",                "-g",                "${workspaceFolder}/2/*.cpp",                "-o",                "${workspaceFolder}/2\\2.exe"            ],            "options": {                "cwd": "${workspaceFolder}/2"            },            "problemMatcher": [                "$gcc"            ],            "detail": "调试器生成的任务2。"        },        {//通过dependsOn来将两个任务合成一个任务            "label": "build",            "dependsOn": ["build2", "build1"],            "problemMatcher": [                "$gcc"            ],"group": {                "kind": "build",                "isDefault": true//设为默认任务            },            "presentation": {                  "echo": true,                  "reveal": "always",                  "focus": true, //这个就设置为true了，运行任务后将焦点聚集到终端，方便进行输入                  "panel": "new"              },            "command": "2/2.exe",//执行第二个任务        }    ],    "version": "2.0.0"}</code></pre><p>使用命令:</p><p><img src="https://s2.loli.net/2022/08/11/6wALGRdu1Hz8S9M.png" alt="202208112337867.png"></p><p>最后执行第二个任务：</p><p><img src="https://s2.loli.net/2022/08/11/QUFVSRN73X1zusg.png" alt="202208112338166.png"></p><p>参考文章如下：</p><p><a href="https://code.visualstudio.com/docs/cpp/config-mingw">https://code.visualstudio.com/docs/cpp/config-mingw</a></p><p><a href="https://www.zhihu.com/question/333560253">https://www.zhihu.com/question/333560253</a></p><p><a href="https://zh.wikipedia.org/wiki/C%2B%2B%E6%A8%99%E6%BA%96%E5%87%BD%E5%BC%8F%E5%BA%AB">https://zh.wikipedia.org/wiki/C%2B%2B標準函式庫</a></p><p><a href="https://zh.wikipedia.org/wiki/MinGW">https://zh.wikipedia.org/wiki/MinGW</a></p><p><a href="https://www.cnblogs.com/renyuan/p/5031100.html">https://www.cnblogs.com/renyuan/p/5031100.html</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> GNU </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BionetServer-No1使用说明-基础篇</title>
      <link href="/2024/09/21/Bionet-Server01%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/09/21/Bionet-Server01%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1><span id="bionetserver-no1使用说明-基础篇">BionetServer-No1使用说明-基础篇</span></h1><img src="https://s2.loli.net/2024/09/29/vNKRfOVDTng7wdL.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727547378732" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><p>Version:1.0</p><p>基础篇更新记录：</p><ul><li>V1.0 简化了文档的内容，拆分了文档分为入门和进阶使用。添加了Anaconda的使用介绍，方便入门。</li></ul><p>过往更新记录：</p><ul><li>V1.9 简化了文档的内容，拆分了文档分为入门和进阶使用，删除了容器Matlab的内容。</li><li>V1.8 新增了R使用说明，划分了端口和详细的版本，简单撰写了使用注意事项。</li><li>V1.7 新增了UI使用说明，同时请注意显卡使用。</li><li>V1.6 新增了Tensorflow专用的镜像，使用Tensorflow的可以使用新的镜像，运行速度提升两倍。</li><li>V1.5版本更新，修复Pytorch shm报错的问题，添加了新的镜像，新的镜像自带pytorch等常用python包，添加了Shared memory size的设置</li><li>V1.4版本更新，修复了桌面版的MATLAB的快捷方式，新增了防止桌面版使用休眠的设置指导，有长时间用桌面版跑代码的同学可以看看，容器不受影响。</li><li>V1.3更新了Matlab使用说明</li><li>V1.2更新了免密码登录，添加了用户修改密码的环节</li><li>V1.1更新代码补全、修正了conda的问题</li></ul><p>Date: 2024.06.07</p><p>Authors：NeoNeuxs</p><!-- toc --><ul><li><a href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%AF%87">系统信息篇</a><ul><li><a href="#%E7%B3%BB%E7%BB%9F%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA">系统硬盘分区</a></li><li><a href="#%E5%85%AC%E7%94%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8C%87%E5%8D%97">公用文件夹指南</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E4%BF%A1%E6%81%AF">网络端口信息</a></li><li><a href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BF%A1%E6%81%AF">软件安装信息</a></li><li><a href="#%E5%9F%BA%E4%BA%8Eui%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8">基于UI的方式远程连接服务器</a></li></ul></li><li><a href="#%E7%94%A8%E6%88%B7%E7%AF%87">用户篇</a><ul><li><a href="#%E9%80%89%E6%8B%A9%E8%87%AA%E5%B7%B1%E5%96%9C%E6%AC%A2%E7%9A%84%E6%A1%8C%E9%9D%A2%E6%9C%8D%E5%8A%A1">选择自己喜欢的桌面服务</a><ul><li><a href="#gnome">GNOME</a></li><li><a href="#xfce%E6%A1%8C%E9%9D%A2">Xfce桌面</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%80%80%E5%87%BA%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5">如何正确退出远程连接？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E9%94%81%E5%B1%8F%E5%8A%9F%E8%83%BD">如何关闭锁屏功能</a></li><li><a href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95">如何配置中文输入法</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">基本的开发工具</a></li><li><a href="#anaconda%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E">Anaconda使用说明</a><ul><li><a href="#anacondacondapip">Anaconda，conda，pip</a><ul><li><a href="#anaconda">Anaconda</a></li><li><a href="#conda">conda</a></li></ul></li></ul></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84anaconda%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">服务器端的Anaconda如何使用？</a></li><li><a href="#matlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E">Matlab使用说明</a><ul><li><a href="#%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86">报错处理</a></li></ul></li><li><a href="#r%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97">R语言使用指南</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h1><span id="系统信息篇">系统信息篇</span></h1><h2><span id="系统硬盘分区">系统硬盘分区</span></h2><p>目前系统是由这样的硬盘空间组成的,分为高速、中速、低速区：</p><p>顾名思义，每个区域速度不同，速度不同的同时稳定性也存在一定的差异，稳定性和速度正好相反：</p><p><code>Data_NAS(Datasets) &gt; Samsung 860evo 512G  &gt; GLOWAY YCQ4TNVMe-M.2</code></p><p>其中每一条格式如下：[分区名、挂载路径、分区大小]</p><pre class="mermaid">graph TB;  subgraph HighSpeed  nvme0n1("nvme0n1:GLOWAY YCQ4TNVMe-M.2")  nvme0n1 --&gt; nvme0n1p1("nvme0n1p1,[/home],2.5T")  nvme0n1 --&gt; nvme0n1p2("nvme0n1p2,[/],1T")  nvme0n1 --&gt; nvme0n1p3("nvme0n1p3,[swap],256G")  nvme0n1 --&gt; nvme0n1p4("nvme0n1p4,[/var],128G")  nvme0n1 --&gt; nvme0n1p5("nvme0n1p5,[/opt],128G")  nvme0n1 --&gt; nvme0n1p6("nvme0n1p6,[/tmp],50G")  end  HighSpeed --&gt; MiddleSpeed  subgraph MiddleSpeed  sda("sda:Samsung 860evo 512G")  sda --&gt; sda1["sda1,[/boot/efi],500MB"]  sda --&gt; sda2["sda2,[/boot],1GB"]  sda --&gt; empty["docker lvm[/var/lib/docker] 400G"]  end  MiddleSpeed --&gt; LowSpeed  subgraph LowSpeed  NAS --&gt; NFS1(NFS,/home/Data_NAS,16T)  NAS --&gt; NFS2(NFS,/home/Datasets,16T)  end</pre><h2><span id="公用文件夹指南">公用文件夹指南</span></h2><p><code>/home</code>文件夹：</p><img src="https://s2.loli.net/2024/04/01/fm4gUGQCToIbkv8.png" alt="image-20240401202923240" style="zoom:80%;"><p>这其中包含了共享文件夹和用户文件夹，如图共享文件夹使用红框标注，用来传递文件</p><p><img src="https://s2.loli.net/2024/05/13/hMrBjZOIpcC5Fgv.png" alt="image-20240513230049068"></p><p>一共包含六个文件夹：</p><ul><li><p>Datasets文件夹是用来放置公用数据集的，其命名需要遵循以下方式：<code>上传者_数据集名称_上传日期</code>。</p><ul><li>此文件夹使用详见：<a href="http://10.26.58.109/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">NAS服务器使用说明</a></li></ul></li><li><p>Data_NAS是直接连接到NAS的文件夹，其目录内容与Datasets保持一致，但是二者物理通道不同（挂载在不同的IP），使用起来是一模一样的。</p></li><li><p>PastData文件夹是过去硬盘中的所有数据，在三个月后将会自动删除，各位及时使用。【现在已经删除】</p></li><li><p>NCZone文件夹是没有做任何保护的文件夹，用户随时可写可删除，使用的时候需要小心删除，并避免写冲突问题（多人对同一个文件修改）</p></li><li><p>Some_scripts文件夹使用分享一个shell脚本的，用来管理系统方便的，使用需要管理员权限。</p></li><li><p>SoftWares文件夹比较特殊：</p></li></ul><p><img src="https://s2.loli.net/2024/04/01/dXxH8ARVvPUEf6r.png" alt="image-20240401205431946"></p><p>​里面包含了P_Share和R_Share,分别挂载到了对应的容器用来分享文件，容器使用的时候在部分情况下只可读，无法写入，需要通过桌面用户来写入文件（出于安全和权限管理的考虑，如果报错可以单独找我了解）。</p><p>P代指python容器，R代指R语言容器的存储空间。二者都被容器挂载。</p><h2><span id="网络端口信息">网络端口信息</span></h2><p><strong>端口的使用主要集中在容器。可以通过portainer来查看，portainer如何使用详见docker篇。</strong></p><h2><span id="软件安装信息">软件安装信息</span></h2><p>Anaconda：/home/anaconda</p><p>Matlab：/home/SoftWares/Matlab</p><p>Dcoker：/默认路径</p><p>Jetbrains IDEs：/home/SoftWares/Jetbrain</p><h2><span id="基于ui的方式远程连接服务器">基于UI的方式远程连接服务器</span></h2><p>首先我们要确认是否连接到了校园网，在系统命令行上使用命令：</p><pre><code class="language-bash">ping 10.26.58.61</code></pre><p>结果如下则证明你在校园网内。</p><img src="https://s2.loli.net/2024/05/13/Yts7QOiU1ymlfrS.png" alt="image-20240513224911484" style="zoom:67%;"><p>打开windos远程连接，在状态栏中搜索远程连接，对于Windows系统，家庭版往往没有此功能，需要升级至专业版，具体升级方法可以去某宝买一个激活码，价格在10元左右。询问店家如何激活升级。</p><img src="https://s2.loli.net/2024/05/13/yiS3oGNWZaUFMbz.png" alt="image-20240513224939223" style="zoom:80%;"><p>打开远程桌面输入远程地址，打开选项：</p><img src="https://s2.loli.net/2024/05/13/igJMIEtfhBOQC4Y.png" alt="image-20240513225154369" style="zoom:67%;"><p>打开选项之后，输入链接地址：10.26.58.61</p><p>然后点击显示选项，参照我这里修改：</p><img src="https://s2.loli.net/2024/05/13/sFaqp1WPLRJNeOx.png" alt="image-20240513225353292" style="zoom:67%;"><p>然后点击编辑，修改成你的用户名和密码，连接即可。</p><img src="https://s2.loli.net/2024/05/13/NhkFSiZEv8rxVgX.png" alt="image-20240513225650039" style="zoom:67%;"><p>输入你的用户名和密码：</p><img src="https://s2.loli.net/2024/05/13/AwEjJ9RDTV1qifg.png" alt="image-20240513225551955" style="zoom:67%;"><p>连接后进入桌面，即可开始使用，如遇到剪贴板不能互相传输、小文件不能传输，请关闭连接重开即可，文件传输依赖于NAS可以参考一下NAS篇介绍。</p><h1><span id="用户篇">用户篇</span></h1><h2><span id="选择自己喜欢的桌面服务">选择自己喜欢的桌面服务</span></h2><p>服务器升级之后存在两个桌面服务二者依托于XRDP实现</p><h3><span id="gnome">GNOME</span></h3><p>GNOME是Ubuntu原生的桌面，其优点是：</p><p>界面简洁优雅，是默认的桌面。</p><img src="https://s2.loli.net/2024/03/24/irtsMxvByUK31lm.png" alt="image-20240324173036063" style="zoom:80%;"><img src="https://s2.loli.net/2024/03/24/w4lICZTjE6FmzcR.png" alt="image-20240324173049733" style="zoom:80%;"><p>可个性化定制的比较多，简单来说就是好看~</p><h3><span id="xfce桌面">Xfce桌面</span></h3><img src="https://s2.loli.net/2024/03/24/DGACKf3BFswoix1.png" alt="image-20240324173242318" style="zoom:80%;"><p>相对轻量化一点，性能消耗少一点，二者差不多，关键点还是个人喜好问题。</p><p>二者如何切换？</p><p>在命令行中执行如下命令：</p><pre><code class="language-bash">echo xfce4-session &gt;~/.xsession</code></pre><p>此时Xdrp默认启动的桌面就改成 Xcfe4 如果你喜欢你的GNOME桌面可以再切换回去：</p><p>使用命令：</p><pre><code class="language-bash">rm ~/.xsession</code></pre><p><strong>退出登录之后，注意要退出登录</strong>不是关闭远程连接，重新登陆即可登录到新的桌面。不懂如何退出请看下一小节。</p><p>同时开多个个cpu消耗也比较少：</p><img src="https://s2.loli.net/2024/03/24/KIGeZmDfNarEt9U.png" alt="image-20240324173454858" style="zoom:67%;"><h2><span id="如何正确退出远程连接">如何正确退出远程连接？</span></h2><p>开启远程链接之后如果按照以下操作，会话将会保持运行，占用资源，正确退出方法如下：</p><img src="https://s2.loli.net/2024/03/25/mPSAMvcUsreYgQ7.png" alt="image-20240325115418950" style="zoom: 80%;"><h2><span id="如何关闭锁屏功能">如何关闭锁屏功能</span></h2><p>在这里找到设置：</p><img src="https://s2.loli.net/2024/04/20/Vv6n4ItDzgpUXsr.png" alt="image-20240420190046154" style="zoom:80%;"><img src="https://s2.loli.net/2024/04/20/LP43Aq8mX1I2ecb.png" alt="image-20240420190108244" style="zoom:67%;"><img src="https://s2.loli.net/2024/04/20/uIiRbpaY6Z2OBhx.png" alt="image-20240420190123305" style="zoom:67%;"><p>关闭即可。</p><h2><span id="如何配置中文输入法">如何配置中文输入法</span></h2><p>打开fctix 5：</p><p><img src="https://s2.loli.net/2024/03/26/HzeqfrZxGpQOcmj.png" alt="image-20240326205930890"></p><p>这里会提示运行fctix 5：</p><p><img src="https://s2.loli.net/2024/03/26/Eeza317wogSMcli.png" alt="image-20240326210030357"></p><p>在这里找到拼音：</p><img src="https://s2.loli.net/2024/03/26/PX9Gdk5ElF8VI4C.png" alt="image-20240326210056577" style="zoom: 80%;"><p>点击添加并应用：</p><img src="https://s2.loli.net/2024/03/26/8vgad9fEVwjA5yW.png" alt="image-20240326210139494" style="zoom:80%;"><p>找到语言设置：</p><p><img src="https://s2.loli.net/2024/03/26/cDq7MzyRkbVBadi.png" alt="image-20240326210306567"></p><p>更改设置如下，并登出，重新启动之后</p><p><img src="https://s2.loli.net/2024/03/26/bCHiPtZSow3vcmu.png" alt="image-20240326210336015"></p><img src="https://s2.loli.net/2024/03/26/tIrZ4owaCkPXvQc.png" alt="image-20240326210413055" style="zoom:80%;"><p>可以愉快使用：</p><p><strong>注意输入法切换要使用ctrl+空格键</strong></p><p><img src="https://s2.loli.net/2024/03/26/nIgFTsCrmcxbMzt.png" alt="image-20240326210456544"></p><h2><span id="基本的开发工具">基本的开发工具</span></h2><p>使用UI开发的基本工具都在：</p><img src="https://s2.loli.net/2024/05/13/bRqM8GFJT9Hjs3C.png" alt="image-20240513230203466" style="zoom:67%;"><p>PyCharm使用的介绍这里不赘述，网上有很多，需要提醒的是选择Python Inter（python解释器）的时候</p><h2><span id="anaconda使用说明">Anaconda使用说明</span></h2><p><strong>禁止事项：严禁在用户个人目录下私自安装Anaconda</strong></p><h3><span id="anacondacondapip">Anaconda，conda，pip</span></h3><h4><span id="anaconda">Anaconda</span></h4><p>The world’s most trusted open ecosystem for sourcing, building, and deploying data science and AI initiatives</p><p>和过去大家理解的Python和R语言的发行版，旨在简化包管理和部署的软件，不太相同了，全面拥抱AI，不仅仅是一个Python的发行版本了，提供了AI从数据到部署全部解决方案，不这里不会涉及到太多这些，毕竟这些方式在近些年还并不是最主流的，我们还有docker来部署，但是其作为Python的管理工具还是十分强大的。</p><h4><span id="conda">conda</span></h4><p>conda是Anaconda的核心组件，是其包管理器，Conda和pip都是Python的包管理工具，但是conda不仅仅能管理Python也能管理R语言，但是R语言自带了包管理器，Python也自带了包管理器，也就是Pip，那么为什么还需要conda呢?</p><p>Conda对比语言自己带的管理器有以下优势：</p><ul><li>Conda支持创建、保存、加载和更新隔离的环境，每个环境可以有不同的包和版本，非常适合多项目开发，换句话话说，conda可以创建虚拟环境，可以切换Python版本。</li><li>Conda支持pip安装的包的管理，pip往往和对应的python版本相绑定，而conda可以管理Python（不仅仅是Python的包，而是某个版本的Python），也就是说conda也能管理Pip及其安装的包，当你使用pip安装对应的包的时候conda也是能察觉到，并更新对应的信息，一同管理。</li><li>Conda有更强的包依赖处理能力，自动删除冲突的包版本并升级，且不会破坏已经存在的包环境，pip直到23.10版本才有此功能，在以前升级包会直接删除包，破环原来的以来环境。</li></ul><h2><span id="服务器端的anaconda如何使用">服务器端的Anaconda如何使用？</span></h2><p>Anaconda提供了UI版本和命令行版本，命令行版本较长使用，UI版本对于不熟悉命令行的用户来说非常好用，在服务器上，打开路径如下：</p><img src="https://s2.loli.net/2024/05/13/vtx3a7MOKqSThCI.png" alt="image-20240513230253640" style="zoom:67%;"><p>UI的简单介绍：</p><p><img src="https://s2.loli.net/2024/06/07/wnUkSLc8Gf2JDO7.png" alt="image-20240607214758652"></p><p>下图按钮来打开对应的环境的命令行：</p><img src="https://s2.loli.net/2024/06/07/Mz7qGjvorfnBcNX.png" alt="image-20240607215445757" style="zoom:80%;"><p>可以看到我们打开了对应的base环境的命令行，同时使用命令安装了numpy：</p><img src="https://s2.loli.net/2024/06/07/6IgulrWp2JxM3mP.png" alt="image-20240607215534456" style="zoom:67%;"><p>但是安装失败了：</p><img src="https://s2.loli.net/2024/06/07/lqnh3zaIOZVmKPA.png" alt="image-20240607215626411" style="zoom:67%;"><p>安装失败的原因很简单，base环境是每个用户都可以看到的，也就是说base环境是公用的，如果放开权限，base环境就会被不同的人使用，这样就有可能造成环境冲突，为了避免这个问题，我们首先要创建自己的环境：</p><p><img src="https://s2.loli.net/2024/06/07/T8hWORk4oVuUCZi.png" alt="image-20240607221044637"></p><img src="https://s2.loli.net/2024/06/07/z9cNV35Bkmbgxit.png" alt="image-20240607221425884" style="zoom:80%;"><p>打开命令行，安装numpy，注意这里使用的是pip来安装，目的是为验证conda是否能检测到当前环境安装了numpy：</p><img src="https://s2.loli.net/2024/06/07/1FUbQVSlwzh9aiX.png" alt="image-20240607221552326" style="zoom:67%;"><p>更新一下索引内容：</p><img src="https://s2.loli.net/2024/06/07/dPEouyVXQMnWgD2.png" alt="image-20240607221707744" style="zoom:80%;"><p>可以看到对应的numpy被检测到了：</p><p><img src="https://s2.loli.net/2024/06/07/U27RlTkrAwsF6SQ.png" alt="image-20240607221800965"></p><p>上文是Anaconda的图形化界面，当然你也可以使用shell当中的：</p><p>在命令行中使用命令：</p><pre><code class="language-bash"> conda activate base</code></pre><p><img src="https://s2.loli.net/2024/05/13/INaD3GAgvVC8TPy.png" alt="image-20240513230400329"></p><p>注意base环境不可以使用，请自己建立环境：</p><pre><code class="language-bash">conda create -n env_name python=3.10</code></pre><p>其中env_name为你想创建的环境的名字，python后边为创建的版本。</p><p>下载地址：</p><p><a href="https://www.anaconda.com/download">https://www.anaconda.com/download</a></p><h2><span id="matlab使用说明">Matlab使用说明</span></h2><p><strong>禁止事项：严禁在用户个人目录下私自安装Matlab</strong></p><p>matlab在路径：</p><pre><code class="language-bash">/home/SoftWares/MATLAB/bin</code></pre><p>再次目录下右键打开命令行，运行matlab即可</p><pre><code>./matlab</code></pre><p>或者快捷方式在：</p><img src="https://s2.loli.net/2024/06/07/TKCeJRObo98VyXQ.png" alt="image-20240607222500101" style="zoom:80%;"><img src="https://s2.loli.net/2024/06/07/vlaz2VtP8ZRCWsw.png" alt="image-20240607222559328" style="zoom:67%;"><p>**此命令行为matlab运行所使用，不要关闭。**开启后登陆个人matlab账号即可使用，安装的matlab皆为正版，需要根据学校引导来注册正版账号，引导内容在：<a href="https://zhengban.xmu.edu.cn/matlab.html%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7%E9%83%A8%E5%88%86%E4%BB%8B%E7%BB%8D%EF%BC%8C%E9%81%B5%E5%BE%AA%E6%8C%87%E5%8D%97%E3%80%82">https://zhengban.xmu.edu.cn/matlab.html，查看个人用户部分介绍，遵循指南。</a></p><h4><span id="报错处理">报错处理</span></h4><p><img src="https://s2.loli.net/2024/09/02/a2XJilmTOsoyQdU.png" alt="image-20240902193011563"></p><p>根据matlab官方指南，kill掉对应的进程即可，使用命令：</p><pre><code>ps -fU 用户名 | grep MathWorksServiceHost</code></pre><p><img src="https://s2.loli.net/2024/09/02/7Wz195ZHTEn3hwD.png" alt="image-20240902193935209"></p><p>使用<code>kill -9  1220267</code>对应的进程号码即可。</p><h2><span id="r语言使用指南">R语言使用指南</span></h2><p>为了方便R语言版本的切换，R语言通过Docker部署，详见Docker篇。</p>]]></content>
      
      
      <categories>
          
          <category> Bionet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bionet </tag>
            
            <tag> ops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+github+Markdown博客搭建</title>
      <link href="/2024/09/21/Hexo+github+Markdown%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/09/21/Hexo+github+Markdown%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1><span id="hexogithubmarkdown博客搭建">Hexo+github+Markdown博客搭建</span></h1><img src="https://s2.loli.net/2024/09/29/6Xo9VwZBhLIJ8Yk.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727549184424" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><!-- toc --><ul><li><a href="#%E7%89%B9%E6%80%A7">特性：</a></li><li><a href="#%E5%B7%A5%E5%85%B7">工具：</a></li></ul><ul><li><a href="#hexo%E5%B7%A5%E5%85%B7%E9%93%BE%E9%85%8D%E7%BD%AE">Hexo工具链配置</a></li><li><a href="#mermaid%E6%B7%BB%E5%8A%A0%E6%94%AF%E6%8C%81">mermaid添加支持</a></li><li><a href="#%E9%83%A8%E7%BD%B2%E5%9C%A8cortex-a7%E4%B9%8B%E4%B8%8A">部署在cortex-A7之上</a></li><li><a href="#%E5%AE%8C%E6%88%90%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5%E6%8E%A8%E9%80%81">完成多平台同步推送</a></li><li><a href="#%E6%B7%BB%E5%8A%A0math%E5%85%AC%E5%BC%8F%E6%94%AF%E6%8C%81">添加Math公式支持</a></li></ul><!-- tocstop --><p>[TOC]</p><h3><span id="特性">特性：</span></h3><ul><li>build工具链支持跨平台使用：linux &amp; windows</li><li>部署支持多平台：linux(32&amp;64)&amp;windows&amp;github&amp;docker</li><li>一次部署即可使用，支持markdown,mermaid,math公式，TOC目录等markdown特性。</li></ul><h3><span id="工具">工具：</span></h3><p>markdown工具：Typora</p><p>跨平台后端：Nginx</p><p>部署平台：orangepi R1 cortex-A7架构 32位双核 &amp; <a href="http://github.io">github.io</a></p><h2><span id="hexo工具链配置">Hexo工具链配置</span></h2><p>hexo工具包含npm，这里以linux系统为示例，其他系统操作类似：</p><p><a href="https://nodejs.org/zh-cn/download/package-manager">https://nodejs.org/zh-cn/download/package-manager</a></p><pre><code># installs nvm (Node Version Manager)curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash# download and install Node.js (you may need to restart the terminal)nvm install 20# verifies the right Node.js version is in the environmentnode -v # should print `v20.17.0`# verifies the right npm version is in the environmentnpm -v # should print `10.8.2`</code></pre><p>在curl导出环境变量之后记得重新打开命令行，执行下面的命令，安装效果如下：</p><img src="https://s2.loli.net/2024/09/28/nzrdGvXhjfElPOV.png" alt="image-20240928200056062" style="zoom:80%;"><p>安装hexo：</p><pre><code class="language-bash">npm install hexo-cli -g</code></pre><p>安装过程很慢，而且没有任何提示。安装完成之后效果如下：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~$ npm install hexo-cli -gadded 53 packages in 6s14 packages are looking for funding  run `npm fund` for details</code></pre><p>安装对应主题的插件，这里使用的是claudia,根据其文档效果如下：</p><p>hexo官方针对主题使用的文档：<a href="https://hexo.io/zh-cn/docs/themes">https://hexo.io/zh-cn/docs/themes</a>  理解theme需要先看看，后边不会太详细介绍。</p><p>我们需要将对应的主题clone到theme文件夹，然后再修改对应的<code>_config.yml</code>，包含项目的<code>_config.yml</code>和主题的<code>_config.yml</code>两者不一样，修改的时候要注意。</p><p>这里使用的cluadia主题在：<a href="https://github.com/Haojen/hexo-theme-Claudia">https://github.com/Haojen/hexo-theme-Claudia</a></p><p>根据主题要求安装包，效果如下：</p><pre><code class="language-bash">(base) neo@NeoNeuxs:~$ npm install hexo-renderer-pug added 52 packages in 7s13 packages are looking for funding  run `npm fund` for details(base) neo@NeoNeuxs:~$ npm install hexo-renderer-dartsassadded 6 packages, and audited 59 packages in 4s15 packages are looking for funding  run `npm fund` for detailsfound 0 vulnerabilities(base) neo@NeoNeuxs:~$ npm install hexo-generator-feedadded 43 packages, and audited 102 packages in 5s25 packages are looking for funding  run `npm fund` for detailsfound 0 vulnerabilities(base) neo@NeoNeuxs:~$ npm install hexo-filter-flowchart     added 3 packages, and audited 105 packages in 3s25 packages are looking for funding  run `npm fund` for detailsfound 0 vulnerabilities(base) neo@NeoNeuxs:~$ npm install hexo-renderer-mathjaxnpm warn deprecated ejs@1.0.0: Critical security bugs fixed in 2.5.5added 2 packages, and audited 107 packages in 4s25 packages are looking for funding  run `npm fund` for details2 critical severity vulnerabilitiesSome issues need review, and may require choosinga different dependency.Run `npm audit` for details.</code></pre><p>安装完成后，修改项目的配置文件，这里贴一下我自己的：</p><pre><code class="language-bash"># Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexosubtitle: ''description: ''keywords:author: NeoNexuslanguage: chinesetimezone: ''# URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: http://neonexusx.github.iopermalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks  trailing_html: true # Set to false to remove trailing '.html' from permalinks# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: ''filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truesyntax_highlighter: highlight.jshighlight:  line_number: false  auto_detect: false  tab_replace: ''  wrap: false  hljs: falseprismjs:  preprocess: false  line_number: false  tab_replace: ''# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator:  path: ''  per_page: 10  order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## updated_option supports 'mtime', 'date', 'empty'updated_option: 'mtime'# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the 'source/' folderinclude:exclude:ignore:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: claudia# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repository: git@github.com:######/#########github.io.git  branch: main # mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid  enable: true  # default true  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js    #startOnload: true  // default true</code></pre><p>主要关闭了代码高亮，添加了mermaid支持，修改主题为claudia，添加了一些信息，同时添加了部署的git信息，还有在对应的服务器上部署的文件信息，这样部署的时候只需要一条命令就能完成多平台的部署。</p><pre><code class="language-bash"># main menu navigationmenu:  Home: /  About: /about  Archive: /archiveswidgets:  - tag  - archive  - recent_posts  - category  - profile# social configsocial:  zhihu:  twitter: /  facebook: /  instagram: /  github: https://github.com/NeoNexusXuser:  name: NeoNexus  avatar:  location: XiaMen  description: YOU CAN REDO  footnotes: # footnotes# documents: https://github.com/utterance/utterances# API config: https://utteranc.es/comment_utteranc:  enable: true  repo: Haojen/Claudia-theme-blog # your blog repo# documents: https://valine.js.org/quickstart.htmlcomment_valine:  enable: true  appId: ############  appKey: #########comment_disqus:    enable: false    url:  # the url of your website main domain like this https://xxx.xxx/    name: # the short name in disqus# dark# light# user-can-setappearance: dark # Default value is auto# Miscellaneousfavicon: images/favicon.icofriend_links:  - title: Google    link: https://www.google.com/  - title: Github    link: https://www.github.com/# Google Analyticsga_track_id:ga_domain:# Baidu Analyticsba_track_id:# picture of about pageabout_pic: about.pngimage_zoom:  enable: true </code></pre><p>主题的设置文件隐藏了一些关键信息，所以没办法直接使用，主要修改在评论系统引入，一些关键信息修改。</p><h2><span id="mermaid添加支持">mermaid添加支持</span></h2><p>mermaid是常见的markdown流程图绘制语言，为了添加支持，我们的思路如下：</p><p>首先添加对应的npm包支持，然后引入对应的mermaid渲染js代码，调用对应的mermiad初始化函数，引入mermaid支持。</p><p>网上的教程思路都是大致如下，但是都是基于不同的主题来实现的，这里使用的claudia使用的模板语言和网上介绍的不一样，我们需要修改一下对应的的代码：</p><p>在此路经下<code>/blog_dev/themes/claudia/layout</code>存放着如下关于布局的文件内容：</p><p><img src="https://s2.loli.net/2024/09/28/cmNFy6QgAXV8jC9.png" alt="image-20240928213131729"></p><p>pug后缀代表着对应的模板语言，我们需要在对应的地方插入对应的js代码，同时还需要满足pug的语法要求。考虑到需要在所有内容初始化完成之后使用CDN将mermaid引入，我们选择比较靠后的布局文件，防止影响到其他部分的初始化，这里挑选post部分，添加代码如下：</p><pre><code class="language-pug">    script(src=`https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js` onload="initMermaid()")    script.      function initMermaid() {       console.log("fuck you");        if (window.mermaid) {          console.log("fuck you");          mermaid.initialize({ theme: 'forest' });        }      }</code></pre><p>其中版本部分本应该使用confiog文件的对象来获取，但是本人不是专业前端，这里引用不到对应的theme对象，没办法只能写死到这里。</p><p>添加之后，我们就可以使用了。</p><p>使用命令：</p><pre><code class="language-bash">(base) neo@Mark06-U:~/Desktop/blog_dev$ hexo generateINFO  Validating configINFO  Start processingINFO  Files loaded in 238 msINFO  Generated: 2024/09/27/hello-world/index.htmlINFO  Generated: archives/2024/index.htmlINFO  Generated: atom.xmlINFO  Generated: archives/2024/09/index.htmlINFO  Generated: 2024/09/28/Bionet-Server01使用说明/index.htmlINFO  Generated: archives/index.htmlINFO  Generated: index.htmlINFO  7 files generated in 14 ms</code></pre><p>构建成功之后使用：</p><pre><code class="language-bash">hexo s</code></pre><p>开启测试服务器。</p><pre><code class="language-bash">(base) neo@Mark06-U:~/Desktop/blog_dev$ hexo sINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</code></pre><h2><span id="部署在cortex-a7之上">部署在cortex-A7之上</span></h2><p>cortex-A7是一个很老的arm架构了，32位的性能很差，但是我有一个orangepi_r1没有用处，所以拿来部署在内网，关于部署到github.io的文章很多，这里不再赘述，主要关键点在于如何将两个平台的内容进行同步更新，这样方便后续内容的更新与维护。</p><p>首先我们要在ubuntu16.04上部署一个nginx服务器，没错H2+跑的是对应已经做好的镜像，这里我也不再赘述，每一个厂家都有做好的镜像来使用。</p><pre><code class="language-bash">sudo apt updatesudo apt install nginx</code></pre><p>使用命令：</p><pre><code class="language-bash">sudo systemctl status nginx</code></pre><p>如果没有报错，那说明成功了：</p><pre><code class="language-bash">orangepi@orangepir1:~$ sudo systemctl status nginx● nginx.service - A high performance web server and a reverse proxy server   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)   Active: active (running) since Fri 2021-04-02 07:51:53 UTC; 2h 54min ago  Process: 1192 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0  Process: 1101 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, Main PID: 1203 (nginx)   CGroup: /system.slice/nginx.service           ├─1203 nginx: master process /usr/sbin/nginx -g daemon on; master_process on           ├─1204 nginx: worker process                                      ├─1205 nginx: worker process                                      ├─1206 nginx: worker process                                      └─1207 nginx: worker process                           </code></pre><p>接下来我们需要将博客发布到这台服务器上，就需要修改nginx配置，然后转移到我们对应的文件夹，作为nginx的起始目录。</p><p>使用命令：</p><pre><code class="language-bash">cd /etc/nginx/sites-available/</code></pre><p>在这里我们修改default文件：</p><pre><code class="language-clike">server {        listen 80 default_server;        listen [::]:80 default_server;        root /home/orangepi/blogs;        # Add index.php to the list if you are using PHP        index index.html index.htm index.nginx-debian.html;        server_name blogs;        location / {                # First attempt to serve request as file, then                # as directory, then fall back to displaying a 404.                try_files $uri $uri/ =404;        }}</code></pre><p>每个修改的对象是什么意思我不再赘述，只需要知道修改了，根目录，location管理部分，其他没有修改。</p><p>然后我们重启nginx，让其重新载入设置;</p><pre><code class="language-bash">sudo systemctl reload nginxsudo systemctl restart nginx</code></pre><p>当然这里设置的blogs文件夹，需要你提前创建好，同时这个文件夹，在你本地电脑推送到服务器的时候也是要有一定的权限的，所以不要使用sudo来创建。</p><p>重启之后我们应该看见，这样一个博客就创建完成了～</p><img src="https://s2.loli.net/2024/09/28/PJL5cakTy9GQ6rK.png" alt="image-20240928225345569" style="zoom:67%;"><h2><span id="完成多平台同步推送">完成多平台同步推送</span></h2><p>多平台同步推送依赖于hexo的deploy功能，根据官方文档，我需要向git和一台服务器进行推送，为了满足这个要求，我们将项目的配置文件修改为如下形式：</p><pre><code class="language-yml">deploy:  - type: git    repository: git@github.com:NeoNexusX/NeoNexusX.github.io.git    branch: main  - type: rsync    host: 你的服务器ip    user: 你服务器user    root: /home/orangepi/blogs    port: 22    delete: true    verbose: true    ignore_errors: false  </code></pre><p>然后使用命令：</p><pre><code class="language-bash">hexo deploy</code></pre><p>实现推送，效果如下：</p><img src="https://s2.loli.net/2024/09/28/UrhAX79sebBWauf.png" alt="image-20240928231857713" style="zoom:67%;"><h2><span id="添加math公式支持">添加Math公式支持</span></h2><p>依据博客修改：</p><p><a href="https://pku-zyf.github.io/formula/">https://pku-zyf.github.io/formula/</a></p><p>将上文post.pug添加如下脚本内容：</p><pre><code class="language-pug">    if theme.mathjax.enable      script(type="text/x-mathjax-config").        MathJax.Hub.Config({          tex2jax: {            inlineMath: [ ['$','$'], ["\\(","\\)"] ],            processEscapes: true,            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']          }        });        MathJax.Hub.Queue(function() {          var all = MathJax.Hub.getAllJax(), i;          for(i=0; i &lt; all.length; i += 1) {            all[i].SourceElement().parentNode.className += ' has-jax';          }        });      script(type="text/javascript", src=theme.mathjax.cdn)</code></pre><p>注意缩进和空格，剩下完全和博客内容一致，不再赘述，只不过不需要打开MathJax开关部分内容。</p>]]></content>
      
      
      <categories>
          
          <category> Bionet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bionet </tag>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BionetServer-No1使用说明-进阶（Docker方式）</title>
      <link href="/2024/09/21/Bionet-Server01%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%20%E2%80%94%E2%80%94Docker%E7%AF%87/"/>
      <url>/2024/09/21/Bionet-Server01%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%20%E2%80%94%E2%80%94Docker%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1><span id="bionetserver-no1使用说明-进阶docker方式">BionetServer-No1使用说明-进阶（Docker方式）</span></h1><img src="https://s2.loli.net/2024/09/29/qWjluktz8hxAV4E.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1727547630579" style="zoom:50%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom: 50%;"><p>Version:1.2</p><p>Docker篇更新记录：</p><ul><li>解决了nohup在python缓冲区机制下print不输出的问题。By 戴珏泓</li><li>添加了关于RStudio账户密码的问题。</li><li>添加了关于存储配置使用的指南。</li><li>修改了关于R部分的存储配置的使用，现在不需要配置路径，直接就可以使用。</li></ul><p>Date: 2024.10.23</p><p>Authors：NeoNeuxs</p><!-- toc --><ul><li><a href="#%E5%BC%80%E5%8F%91%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">开发的最佳实践</a><ul><li><a href="#docker%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%9B%E5%BB%BA">Docker的使用与创建</a></li><li><a href="#image%E9%95%9C%E5%83%8F%E5%92%8Ccontainer%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB">image（镜像）和container（容器）的关系</a></li><li><a href="#docker%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%AE%89%E8%A3%85">Docker本身的安装</a></li><li><a href="#%E9%80%9A%E8%BF%87portainer%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%B9%E5%99%A8">通过portainer构建自己的容器</a><ul><li><a href="#images%E9%95%9C%E5%83%8F">Images（镜像）</a></li><li><a href="#container%E5%AE%B9%E5%99%A8">container（容器）</a></li><li><a href="#%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%A7%81%E8%AE%BE%E7%BD%AE">容器可见设置</a></li><li><a href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE">容器的配置</a><ul><li><a href="#%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AE">存储配置</a></li><li><a href="#%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">存储配置的最佳实践</a></li><li><a href="#lable%E9%85%8D%E7%BD%AE">lable配置</a></li><li><a href="#%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE">重启策略配置</a></li><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%85%8D%E7%BD%AE">运行时配置</a></li></ul></li><li><a href="#tensorflow%E4%BD%BF%E7%94%A8jupyter%E7%99%BB%E5%BD%95">Tensorflow使用Jupyter登录</a></li><li><a href="#%E4%BD%BF%E7%94%A8vscode%E8%BF%9E%E6%8E%A5%E5%AE%B9%E5%99%A8">使用VSCode连接容器</a></li><li><a href="#%E5%BC%80%E5%90%AF%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95">开启免密码登录</a></li><li><a href="#%E5%BC%80%E5%90%AF%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8">开启代码补全</a></li></ul></li><li><a href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BB%B4%E6%8A%A4">容器的维护</a></li></ul></li><li><a href="#r%E8%AF%AD%E8%A8%80%E8%BF%9E%E6%8E%A5%E5%8A%9E%E6%B3%95">R语言连接办法</a><ul><li><a href="#r%E7%9A%84%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB">R的文件共享</a></li></ul></li><li><a href="#qa">Q&amp;A：</a><ul><li><a href="#%E9%97%AE%E9%A2%98%E9%9B%B6-%E9%80%9A%E8%BF%87%E5%AE%B9%E5%99%A8%E5%86%99%E5%85%A5%E7%9A%84%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C">问题零 通过容器写入的文件无法运行？</a></li><li><a href="#%E9%97%AE%E9%A2%98%E4%B8%80-%E5%AE%B9%E5%99%A8%E9%87%8D%E5%90%AF%E4%B9%8B%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5">问题一 容器重启之后无法连接？</a></li><li><a href="#%E9%97%AE%E9%A2%98%E4%BA%8C-%E6%88%91%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAdocker%E5%A4%B1%E8%B4%A5%E4%B9%8B%E5%90%8E%E5%86%8D%E6%AC%A1%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%90%8C%E7%AB%AF%E5%8F%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A1%8C">问题二 我创建一个docker失败之后再次连接相同端口为什么不行？</a></li><li><a href="#%E9%97%AE%E9%A2%98%E4%B8%89-%E6%88%91%E5%85%B3%E9%97%AD%E4%BA%86vscode%E4%BB%A3%E7%A0%81%E5%B0%B1%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%E4%BA%86">问题三 我关闭了VSCode代码就停止运行了？</a></li><li><a href="#%E9%97%AE%E9%A2%98%E5%9B%9B-bad-owner-or-permissions-on">问题四 Bad owner or permissions on</a></li><li><a href="#%E9%97%AE%E9%A2%98%E4%BA%94-python%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8nohup%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E6%B2%A1%E6%9C%89%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9">问题五 Python脚本使用nohup运行时，指定文件没有输出内容</a></li><li><a href="#%E9%97%AE%E9%A2%98%E5%85%AD-r_studio%E6%89%93%E5%BC%80%E4%B9%8B%E5%90%8E%E6%B2%A1%E6%9C%89%E8%A7%81%E5%AF%B9%E5%BA%94%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9">问题六 R_studio打开之后没有见对应这两个文件夹</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><h2><span id="开发的最佳实践">开发的最佳实践</span></h2><p>开发的最佳实践基于docker来实现，使用docker已经成为世界上最流行最重要的开发模式，学习如何使用docker来进行开发，不管你走到哪里，是科研还是进入大厂，这一套开发方式的部署会让你受益无穷。下面将简单介绍一些基础概念，由于篇幅限制，介绍的不是很详细，但能帮你有一个初步的了解。</p><p><strong>使用Docker的优势：</strong></p><ul><li><strong>便于管理者管理环境</strong></li><li><strong>快速在多台部署有Docker基础环境的机器上运行，可以在不同的机器中迁移运行，无需重复部署开发环境。</strong></li><li><strong>支持集群部署</strong></li><li><strong>root权限</strong></li><li><strong>高性能的虚拟，容器部署30s内即可完成</strong></li></ul><p><strong>第一次查看此文档建议按照顺序看，第一创建成功之后建议使用模板方法快速创建。</strong></p><h3><span id="docker的使用与创建">Docker的使用与创建</span></h3><p>下图展示了Docker的基本运行原理，其运行在一个基本的操作系统上，并在一个Docker支持多个运行的基本环境。</p><img src="https://s2.loli.net/2024/01/25/TCh1nqvuyWL6Kp3.png" alt="282c3hci" style="zoom: 67%;"><p>下图展示了传统的VM（虚拟机）架构，是运行在硬件的抽象层之上的，并且每一个虚拟机都有一个操作系统的支持，就是对应的Guest Operating System。</p><img src="https://s2.loli.net/2024/01/26/qgLmakBI7VMjoS8.png" alt="7d2mwnd9" style="zoom: 67%;"><p>开发的最佳实践主要是在于使用docker来进行环境的配置和使用。</p><h3><span id="image镜像和container容器的关系">image（镜像）和container（容器）的关系</span></h3><p><strong>镜像（Image）</strong>：Docker镜像是一个静态文件，其中包含了应用程序运行所需的所有文件系统内容、库和配置。镜像是一个只读的模板。它可以用来创建一个或多个容器。</p><p><strong>可以简单理解镜像是一个制作好就无法修改的模板</strong></p><p><strong>容器（Container）</strong>：Docker容器是镜像的运行实例。它实际上是一个独立的、轻量级的、可执行的软件包，包含了运行应用程序所需的一切：代码、运行时、库、环境变量和配置文件。容器可以被创建、启动、停止、删除和移动。每个容器都是相互隔离的，具有自己的文件系统、网络和进程空间。</p><p><strong>容器可以看作一个镜像的动态转变，将其从静态唤醒变成一个应用，可以运行修改。</strong></p><p>下面的状态图，阐述了使用过程中的状态改变：</p><pre class="mermaid">graph TD;    A[Docker Image] -- 创建 --&gt; B[Docker Container]    B -- 基于 --&gt; A    B -- 运行 --&gt; C{应用运行中?}    C -- 是 --&gt; D{正常}    C -- 否 --&gt; E{已停止}    E -- 重启 --&gt; C    E -- 删除 --&gt; F[Destroyed Container]    D -- 删除 --&gt; F</pre><p>简单理解了容器和镜像的关系，我们可以尝试安装docker并在docker部署一个应用，这个应用可以是很多种类型，比如：部署一个Rstudio或者部署一个可以使用显卡的运行环境（依赖环境也是一种应用）。</p><h3><span id="docker本身的安装">Docker本身的安装</span></h3><p>这里不再赘述，可以参考另一篇维护的文章，当中Docker部署的部分。</p><h3><span id="通过portainer构建自己的容器">通过portainer构建自己的容器</span></h3><p>portainer部署在No1服务器上，portainer是用来管理所有docker的管理软件，同时也部署在docker之上，使用portainer来创建容器的目的是减少命令的输入，方便用户使用，降低docker的使用门槛，图形化的管理界面也比较直观的展现了所有容器的信息，减少创建过程的问题，同时Portainer具有服务器集群管理，节点拓展等功能，为以后实验室服务建设添砖加瓦。</p><p>首先登录你的<a href="https://10.26.58.61:9443/#!/auth">Portainer</a></p><p>每个人的账户已经创建好了，需要登陆密码私聊我即可。</p><p>目前被部署在：<a href="https://10.26.58.61:9443/">https://10.26.58.61:9443/</a></p><p><strong>注意端口号为9443</strong></p><p>登录页面如图：</p><img src="https://s2.loli.net/2024/03/31/xbPwe2hVuviBRaj.png" alt="image-20240331232840271" style="zoom: 50%;"><p>登录之后进入到管理界面：</p><img src="https://s2.loli.net/2024/03/31/iycUPfqC3osAXjT.png" alt="image-20240331233057783" style="zoom:150%;"><p>点击链接按钮之后，下图就是其管理界面：</p><img src="https://s2.loli.net/2024/03/31/3C6jqihDFOX8xug.png" alt="image-20240331232721281" style="zoom:150%;"><p>不过这里不是我们的主要目的，我们将目标放到右侧选项栏之中：</p><img src="https://s2.loli.net/2024/03/31/i2UTrdaMQuIoWR1.png" alt="image-20240331233820435" style="zoom:80%;"><p>对于使用者来说，右侧的状态栏我们只关心这四个内容，Containers、Images、NetWorks、Volumes，下边将简单介绍一下这四个内容并在介绍的同时创建一个属于你自己的世界（容器）。</p><h4><span id="images镜像">Images（镜像）</span></h4><p>我们先来看一下Images页面，images实际上就是镜像，镜像是一个已经制作好的某一个容器的copy，这个镜像在制作完之后和使用之前是无法更改的，也就是说镜像实际上就是某一套环境的固化版本、无法修改当中的内容，只能使用当中的内容。</p><img src="https://s2.loli.net/2024/03/31/UaTbB1pQetZsS6H.png" alt="image-20240331235234493" style="zoom:100%;"><p>可以看到我们有一个不太正规命名的pytorch镜像，这是我第一次制作的镜像，至于怎么制作镜像和为什么制作镜像请跳转到这一部分的最后一小节我们会在那里详细介绍，不过我们可以通过一个基本的镜像来详细介绍一下镜像如何使用和创建，我们使用这里最后一个镜像来在nvidia的cudnn运行环境来进行测试。</p><h4><span id="container容器">container（容器）</span></h4><p>容器就是镜像运行起来的状态，这时候镜像内容就由上文中不可修改的状态转变为可修改、可运行、可探查的状态，一个镜像包含了一套完整的运行所需依赖，并由一套自己的文件系统来支持运行，也就说容器和本地服务器是隔离开的、是互相不干扰的，是没有任何关系的（其实并不是，也有一定的逃逸方法，建议大家正常使用就不会遇到这些问题），</p><p>来到container页面：</p><p><img src="https://s2.loli.net/2024/04/01/MOICl5ZJnrahszp.png" alt="image-20240401002419124"></p><p>可以看到没有任何东西，这样我们就需要创建一个container，点右边的按钮来创建：</p><img src="https://s2.loli.net/2024/04/01/e6PQyo478sNWtnF.png" alt="image-20240401003226298" style="zoom:150%;"><p>虽然图片上是Nvidia官方的镜像，不过我们可以再打开<strong>images页面</strong>，看一下有什么镜像，选择你需要的镜像来使用即可，下图第一个是一个bionet实验室制作的镜像，里面包含了基础的miniconda，显卡运行环境，常用的linux工具等等，<strong>下图蓝色部分可以复制名字到刚才的位置</strong>。</p><p><img src="https://s2.loli.net/2024/04/26/cUmjzr1NZ8LFp2E.png" alt="image-20240426230614072"></p><p>上图的这个镜像完整安装了pytorch、numpy、pandas等，在base环境下，可以直接使用，属于是开箱即用的水准，没特殊情况推荐这个，拿不准可以来问我。下图是Tensorflow的专用镜像，有专门的介绍，可以跳转到Tensorflow章节。</p><p><img src="https://s2.loli.net/2024/04/26/GKwnTCg31FNaevx.png" alt="image-20240426230533650"></p><p>至于选用哪一个请自行参照上文选择。</p><p>设置主机和容器的端口号映射：</p><img src="https://s2.loli.net/2024/04/01/681u3F5fAKQvpmh.png" alt="image-20240401004019203"><p>主机可使用的端口号在10086-10199之间，每个人使用的数量不受限制，只需要选择没有占用的即可，这里我占用的是10086，所以别人也无法使用了，但是如何查看别人用了什么端口号呢,使用相同的端口号会导致创建失败。</p><p>容器需要使用的端口完全取决你的应用需要，比如R就需要8787端口就需要将R的端口映射到10086到10199之间任意一个，当你从你的电脑链接的时候只需要选择你当时映射的主机端口号即可，不需要连接的时候选择8787。</p><p>这里我建议你多留一个端口比如容器的10087来映射到10087来使用，这样万一有服务需要使用端口我们只需要重新映射一下服务即可，就不要再重新创建一个端口来使用了。</p><p><img src="https://s2.loli.net/2024/04/01/LpzZNdB4kwbmujS.png" alt="image-20240401005456274"></p><h4><span id="容器可见设置">容器可见设置</span></h4><p><strong>这里的设置不能跳过~</strong></p><p><img src="https://s2.loli.net/2024/04/01/uT37HjOhmNcnAqJ.png" alt="image-20240401005631022"></p><p>这里要选择完全，因为要公开使用的端口信息：</p><p><img src="https://s2.loli.net/2024/04/26/3qDMnVuG428Zlaj.png" alt="image-20240426190148253"></p><h4><span id="容器的配置">容器的配置</span></h4><p>最下面就是容器的详细配置了：</p><p><img src="https://s2.loli.net/2024/04/01/aAvQh2JOW1qe8rc.png" alt="image-20240401150858895"></p><p>关于容器的配置这一部分，需要说明的是，大多数容器的配置都是一致的，只需要修改名字即可，填写请按照我给出的内容来填写，第一部分需要配置的比较少，按照图上的内容配置即可。</p><h5><span id="存储配置">存储配置</span></h5><p>不要照着下面这张图片直接抄，请先看后边的内容：</p><p><img src="https://s2.loli.net/2024/04/02/zMe3tKOEyxlDAnr.png" alt="image-20240402225643545"></p><p><strong>Bind类型不要选错！</strong></p><p><code>bind</code>是绑定本机路径到容器上某个路径之下，实现对应路径的内容在主机和容器之间相互共享的方法。</p><p>举个例子：</p><p><code>type=bind,   source=/home/SoftWares/R_Share    ,    target=/home/R_Share,readonly \</code>指的是将主机：<code>/home/SoftWares/P_Share</code>目录内容绑定到容器的<code>/home/R_Share</code>路径，注意这里的sorce指的是你的服务器本机端、target指的是容器端。</p><p>这样这部分就可以互相共享文件，readonly指的是权限为可读，这样的设置当然是为防止你使用某一个数据集的时候有别人来篡改数据，造成你完全无法知晓跑出来的结果。</p><p><strong>同时因为容器是以root权限来运行的，如果不使用readonly来限制很有可能你一条rm命令将大家的数据都删除了，这将造成无法挽回的后果。</strong></p><p><code>type=bind,   source=修改这里/Share_Space,      target=/container/path/Share_Space \</code></p><p>就没有只读权限这样的担忧，因为这个主机端的文件夹只有你能访问，这个文件需要你修改<code>修改这里</code>这四个字改成你的个人home目录：'/home/Neo/Share_Space '举个例子：</p><img src="https://s2.loli.net/2024/04/01/4yWVJQOmj82FDXL.png" alt="image-20240401120000975" style="zoom:80%;"><h5><span id="存储配置的最佳实践">存储配置的最佳实践</span></h5><p>下图展示了存储配置的最佳实践，需要结合<strong>NAS使用指南</strong>和当前讲解来理解：</p><pre class="mermaid">graph LR;    A["容器(最高权限)"]     B["服务器主机A"]    F["服务器主机B(待建设)"]    C["NAS(网络附加存储)"]    D["你的本地电脑"]    E["外部网盘"]            A--"Datasets文件夹依赖于"---&gt;C    A--"运行依赖于"---&gt;B    A--"运行依赖于"---&gt;F    B--"Datasets文件夹依赖于"---&gt;C    F--"Datasets文件夹依赖于"---&gt;C    A--"NCZone、R_Share、P_Share文件夹直接存在于"---&gt;B    D =="Bionet(Datasets)文件夹依赖于"==&gt;C    D--"连接运行"---&gt;A    E--"数据"--&gt;D</pre><p>红色的路径为推荐的上传数据集的方式：详见NAS使用说明。</p><img src="https://s2.loli.net/2024/10/21/mZun6qNW3tvPTKB.png" alt="image-20241021232145477" style="zoom:80%;"><p>当你明白上述目录之后我们来填写上图中的内容，我已经简单写了一份出来，你只要复制其中的路径即可，不要搞错了主机和容器的区别。</p><pre><code class="language-dockerfile">host=/home/SoftWares/P_Sharecontainer= /home/P_Share,readonly host=/home/SoftWares/R_Sharecontainer= /home/R_Share,readonly host=/home/Datasetscontainer= /home/Datasets,readonly host=/home/NCZonecontainer= /home/NCZoneWritablehost=/home/Neo/Share_Spacecontainer= /home/Share_Space Writable</code></pre><p><strong>注意这里的host指的是你的服务器本机端、container指的是容器端</strong>，其他的内容按照图片选择即可。</p><p><img src="https://s2.loli.net/2024/04/03/z2ncGWk435IULyq.png" alt="image-20240403152905264"></p><p>使用Tensorflow的同学注意需要将上图container的home替换为tf，如下图所示：</p><img src="https://s2.loli.net/2024/06/07/n8V64twEjpBmN1W.png" alt="image-20240607233503172" style="zoom:80%;"><h5><span id="lable配置">lable配置</span></h5><p><img src="https://s2.loli.net/2024/04/01/4k6VCyMg3izb1JO.png" alt="image-20240401121448908"></p><h5><span id="重启策略配置">重启策略配置</span></h5><p><img src="https://s2.loli.net/2024/04/02/nmW72gZ9DJFeNaA.png" alt="image-20240401121532287"></p><h5><span id="运行时配置">运行时配置</span></h5><p>将页面切换到此处：</p><p><img src="https://s2.loli.net/2024/04/23/ZJtPe1Rhmwj9SV5.png" alt="image-20240423222756107"></p><p>shnm大小推荐至少2000MB，最大4000MB，使用的4090成员请在4000MB以上。</p><p>此处注意，因为有两组成员共用GPU，请bionet课题组使用如下配置：</p><p><img src="https://s2.loli.net/2024/05/13/tS7EbzL9iXdvw43.png" alt="image-20240513232522771"></p><p>另外的成员，请使用如下配置：</p><p><img src="https://s2.loli.net/2024/05/13/n2k1jOqLD9EgJwK.png" alt="image-20240513232551314"></p><p>最后一定要点击部署！容器才会生效~这个按钮就在基础部分。</p><p><img src="https://s2.loli.net/2024/04/02/MAe4yiPXOl1JLjN.png" alt="image-20240402211408290"></p><p>创建完成之后我们就来到这个页面，可以看到容器已经在运行了：</p><p><img src="https://s2.loli.net/2024/04/01/icNmxPz4K8sSJLB.png" alt="image-20240401130626984"></p><p>我们点击这里按道理是可以进入命令行的：</p><p><img src="https://s2.loli.net/2024/04/01/gXmcAYVQxflhp1O.png" alt="image-20240401151620031"></p><p><img src="https://s2.loli.net/2024/04/01/1RA7bZYBF5frCwU.png" alt="image-20240401151647884"></p><p>同时这里也有容器的监控信息：</p><p><img src="https://s2.loli.net/2024/04/01/CwEZghoUN46szK8.png" alt="image-20240401151726479"></p><p><img src="https://s2.loli.net/2024/04/01/TiVyZEqe8n13c2w.png" alt="image-20240401151713327"></p><h4><span id="tensorflow使用jupyter登录">Tensorflow使用Jupyter登录</span></h4><p>Tensorflow环境使用Jupyter来使用，在上述镜像建立完成之后，我们首先找到我们映射的端口信息</p><p><img src="https://s2.loli.net/2024/04/26/5Or2iPdILDE8yae.png" alt="image-20240426190845378"></p><p>点击镜像名字查看端口信息:</p><p><img src="https://s2.loli.net/2024/04/26/Gm7xojTqlBacEC5.png" alt="image-20240426190920611"></p><p>我们这里使用了32768端口来映射Jupyter的8888端口，我们打开浏览器输入：10.26.58.61:32768</p><p><img src="https://s2.loli.net/2024/04/26/Znamz7ysDEvIRt9.png" alt="image-20240426191155106"></p><p>建议第一次就设置好密码，输入密码，这样每次就不用单独去查找API_token了</p><p>接下来我们去命令行找到token：</p><p><img src="https://s2.loli.net/2024/04/26/lrjHS82MOPuAo1D.png" alt="image-20240426191252515"></p><p><img src="https://s2.loli.net/2024/04/26/yKVCXlfHNc3QGm5.png" alt="image-20240426191325862"></p><p>复制对应的token即可使用，也可以选择下边的修改密码来长久登录。Jupyter自带命令行，所以Portainer的界面的命令行无法使用们这里需要注意。</p><p>关于Jupyter的使用这里就不再赘述，下面是pytorch的vscode链接方法。</p><h4><span id="使用vscode连接容器">使用VSCode连接容器</span></h4><p>下载vscode：<a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a>。推荐使用新版。</p><p>在连接之前我们先来使用Portainer来重启一下SSH服务，优化conda内容，方便来链接：</p><p>我们使用Portainer自带的命令行：</p><p><img src="https://s2.loli.net/2024/04/02/XIogMAGRr7T68NC.png" alt="image-20240402202202138"></p><p>点击这里打开容器的命令行。输入以下命令：</p><pre><code class="language-bash">service ssh restart &amp;&amp; conda init &amp;&amp; passwd &amp;&amp; mkdir ~/.ssh &amp;&amp; touch ~/.ssh/authorized_keys &amp;&amp; chmod 700 ~/.ssh &amp;&amp; chmod 600 ~/.ssh/authorized_keys</code></pre><p><strong>命令行中粘贴快捷键为ctrl+shift+v</strong>，这里减一直接复制以后粘贴。</p><p>命令的效果是修改密码，并增加一些系统设置内容。</p><p>效果如下所示：</p><p><img src="https://s2.loli.net/2024/04/03/2BGjlk3HXq4owJp.png" alt="image-20240403165653496"></p><p>注意这里修改密码要输入两次才可以，如果有一次和上一次输入的不一致就会失败，如下图所示：</p><p><img src="https://s2.loli.net/2024/04/03/NweW3LbgRA7tfi6.png" alt="image-20240403165843033"></p><p>**不用紧张，再次输入上一个命令即可。**然后关闭这个页面。</p><p>使用最新版的VSCode，这里下载安装就不再赘述了，打开Vscode之后：</p><p>新版的vscoe自带remote链接如图所示：</p><p><img src="https://s2.loli.net/2024/04/01/TWKrERxcZo6lGh8.png" alt="image-20240401131807102"></p><p>如果没有的话，请去插件市场安装一个：</p><p>选择左侧<strong>Extensions</strong>选项卡，在输入框搜索<strong>ssh</strong>，选择安装<strong>Remote-SSH</strong>插件。这里我已经安装。</p><p><img src="https://s2.loli.net/2024/03/27/9PWEKZISgt6ip2O.png" alt="image-20240326113905983"></p><p>安装之后让我们打开远程连接：</p><img src="https://s2.loli.net/2024/04/01/Wlsw1fQi5GyCdIR.png" alt="image-20240401132035539" style="zoom:50%;"><p>可以看到有两种链接形式的存在：一个是tunnels另一个是SSH，这里选择SSH，点击加号创建新的连接：</p><p><img src="https://s2.loli.net/2024/04/01/H7pbtqXUFvjD9fC.png" alt="image-20240401132122934"></p><p>点击之后会让你输入命令：</p><p>端口号要更改~</p><pre><code class="language-bash">ssh root@10.26.58.61 -p 10086</code></pre><p><strong>这里的-p指代的是端口号，也就是上文中所设置的端口号映射号，SSH服务默认使用22端口号我们将容器的22端口映射到服务器本机的10086端口，所以这里就要使用10086端口作为链接方式，这样我们只需要连接10086端口就可以连接到容器，注意这里的端口号要和你的容器设置保持一致。</strong></p><p><strong>这里一定要修改成你的端口！！！！！！！！！！！！！！！！</strong></p><p><strong>你可能会好奇为什么会是root，而不是其他用户，这里使用的root命令，是因为容器里面的root和主机的root并不一致，这里的root是容器中的管理权限用户，和外边并不相关。</strong></p><p><strong>在你的容器里面你就是root！</strong></p><p><strong>然后按下回车：</strong></p><p><img src="https://s2.loli.net/2024/04/01/u9Sjoazd56pRAVq.png" alt="image-20240401132210185"></p><p><strong>一定要记住这个路径，万一有错误可以用到。</strong></p><p><img src="https://s2.loli.net/2024/04/01/kKQOC4yH7ftBgmj.png" alt="image-20240401132414740"></p><p>然后右下角会弹出链接提示，选择链接：</p><p><img src="https://s2.loli.net/2024/04/01/2vsnJu4chxUjqgm.png" alt="image-20240401132647734"></p><p>没有看到没有选择上也没关系，我们刷新一下列表就能看到链接信息了：</p><p><img src="https://s2.loli.net/2024/04/01/JWEOUhqfiLrxRKz.png" alt="image-20240401132818238"></p><p>点击链接，输入密码之后开始下载，就说明成功了，容器的root密码为通用的123456：</p><img src="https://s2.loli.net/2024/04/01/EpvNT7hSaFxJBlc.png" alt="image-20240401163918819" style="zoom:67%;"><img src="https://s2.loli.net/2024/04/01/ymKYnV8FsrICNWA.png" alt="image-20240401163649302" style="zoom:80%;"><p><img src="https://s2.loli.net/2024/04/01/fCKThcgtrZI6Gzd.png" alt="image-20240401163813111"></p><p>一般工作在home文件夹下：</p><img src="https://s2.loli.net/2024/04/01/j5YDfCvB91iPFcd.png" alt="image-20240401163834329" style="zoom:67%;"><p>可以看到刚才挂载的几个位置：</p><img src="https://s2.loli.net/2024/04/01/yfx5aT4sM6QhDUb.png" alt="image-20240401163853472" style="zoom:67%;"><p>我们在这里新建一个python脚本来测试：</p><img src="https://s2.loli.net/2024/04/01/vRESQnmKZ78dV6g.png" alt="image-20240401164016267" style="zoom: 80%;"><p>将以下内容插入：</p><pre><code class="language-python">import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimimport torch.backends.cudnn as cudnnfrom torchvision import datasets, transformsclass Net(nn.Module):    def __init__(self):        super(Net, self).__init__()        self.conv1 = nn.Conv2d(1, 10, kernel_size=5)        self.conv2 = nn.Conv2d(10, 20, kernel_size=5)        self.conv2_drop = nn.Dropout2d()        self.fc1 = nn.Linear(320, 50)        self.fc2 = nn.Linear(50, 10)    def forward(self, x):        x = F.relu(F.max_pool2d(self.conv1(x), 2))        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2))        x = x.view(-1, 320)        x = F.relu(self.fc1(x))        x = F.dropout(x, training=self.training)        x = self.fc2(x)        return F.log_softmax(x, dim=1)def train(model, device, train_loader, optimizer, epoch):    model.train()    for batch_idx, (data, target) in enumerate(train_loader):        data, target = data.to(device), target.to(device)        optimizer.zero_grad()        output = model(data)        loss = F.nll_loss(output, target)        loss.backward()        optimizer.step()        if batch_idx % 10 == 0:            print('Train Epoch: {} [{}/{} ({:.0f}%)]\tLoss: {:.6f}'.format(                epoch, batch_idx * len(data), len(train_loader.dataset),                       100. * batch_idx / len(train_loader), loss.item()))def main():    cudnn.benchmark = True    torch.manual_seed(1)    device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")    print("Using device: {}".format(device))    kwargs = {'num_workers': 1, 'pin_memory': True}    train_loader = torch.utils.data.DataLoader(        datasets.MNIST('./data', train=True, download=True,                       transform=transforms.Compose([                           transforms.ToTensor(),                           transforms.Normalize((0.1307,), (0.3081,))                       ])),        batch_size=64, shuffle=True, **kwargs)    model = Net().to(device)    optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5)    for epoch in range(1, 11):        train(model, device, train_loader, optimizer, epoch)if __name__ == '__main__':    main()</code></pre><p>新建之后会有右下角来提示安装对应的语言插件，没提示直接搜索也可以：</p><img src="https://s2.loli.net/2024/04/01/vknM61ilJ5fAdRL.png" alt="image-20240401164200647" style="zoom:80%;"><p>在插件市场搜索：</p><pre><code class="language-txt">@id:ms-python.python</code></pre><img src="https://s2.loli.net/2024/04/01/sbQwhgcJBERYHxm.png" alt="image-20240401164247045" style="zoom:80%;"><p>然后点击安装在远程即可。</p><h4><span id="开启免密码登录">开启免密码登录</span></h4><p>开启免密码登录方式如下：</p><p>首先打开你的ssh配置文件：</p><img src="https://s2.loli.net/2024/04/03/dgPwOnKMThcuGAq.png" alt="image-20240403170216864" style="zoom:67%;"><p>打开之后我们先放这里，等下再用。我们把这个路径叫做SSH配置路径，一定要记住这个路径，可以截图。</p><p>我们在windos文件管理器中打开这个文件夹：</p><img src="https://s2.loli.net/2024/04/03/v9sV2CIUkceziL1.png" alt="image-20240403170412513" style="zoom:80%;"><p>这里分为两种情况，一种是你已经有了上述<code>id_rsa.pub</code>文件，如上图红框所示。</p><p>另一种情况是没有这个文件，如下所示：</p><img src="https://s2.loli.net/2024/04/03/z48qTZJ75yNMaoL.png" alt="29c9f2a1ef1c58e7deeae3ac742c00f" style="zoom:80%;"><p>如果你没有，我们打开本地的系统命令行：</p><img src="https://s2.loli.net/2024/04/03/KenW8bEy1gwz9UI.png" alt="image-20240403170517802" style="zoom:80%;"><p>输入以下内容：</p><pre><code class="language-bash">ssh-keygen</code></pre><img src="https://s2.loli.net/2024/04/03/ivOr8YQgDAbcLq2.png" alt="image-20240403170800926" style="zoom:80%;"><p>这里会提示让你输入密钥文件保存在哪里，这里就要放在你刚才的那个路径的文件下面，就是在vscode设置中打开的路径。记住是文件夹，不是文件，文件夹通常名字为：“.ssh”。</p><p>输入之后一路回车下去直到看到这个图形生成：</p><img src="https://s2.loli.net/2024/04/03/WmeMaujYiO9Ix6G.png" alt="image-20240403171025319" style="zoom:67%;"><p>这里就结束了，然后我们回过头打开这个文件，使用vscode或者记事本都可以，同时我们也打开远程服务器的这个目录下的文件：</p><p>这路径全名是：</p><pre><code class="language-bash">/root/.ssh/authorized_keys</code></pre><img src="https://s2.loli.net/2024/04/03/fHrEOVRzybCqh3W.png" alt="image-20240403171155723" style="zoom:67%;"><p>打开之后我们将刚才打开的<code>id_rsa.pub</code>文件中的内容复制过来，通常如下图所示：</p><img src="https://s2.loli.net/2024/04/03/xXeDynObsMYK9Ez.png" alt="image-20240403171427044" style="zoom:80%;"><p>然后我们回到最初打开的ssh配置文件，在你的电脑SSH配置路径上，如果没打开的话，我们还是点击这里打开：</p><p><img src="https://s2.loli.net/2024/04/03/6TcAB2P7SVDQUuC.png" alt="image-20240403171545385"></p><p>添加一行内容：</p><pre><code class="language-bash">IdentityFile "C:\Users\NeoNexus\.ssh\id_rsa"  这里的路径要修改成你的配置路径，要记得这里的id_rsa文件并不带pub后缀因为这是私钥</code></pre><p>添加后效果如下：</p><p><img src="https://s2.loli.net/2024/04/03/sVCgWRw4FJBLZtj.png" alt="image-20240403171709698"></p><p>记得Ctrl+S保存修改</p><p>重启VSCode就可以愉快免密码直接使用了。</p><h4><span id="开启代码补全">开启代码补全</span></h4><p>由于默认的代码补全并不是很好用这里要修改一下设置：</p><p><img src="https://s2.loli.net/2024/04/02/bzmETWanVH6YZ49.png" alt="image-20240402224047196"></p><p>同时打开terminal来测试：</p><img src="https://s2.loli.net/2024/04/01/Zq1fXU98RvWlzYI.png" alt="image-20240401164322474" style="zoom: 67%;"><p>输入命令：<code>nvidia-smi</code></p><img src="https://s2.loli.net/2024/04/01/LdIuCHcFAz5Dxqo.png" alt="image-20240401164337512" style="zoom:67%;"><p>如图所示，四个显卡都能看见，则创建成功。</p><p>使用conda来创建环境，初始化codna：</p><pre><code class="language-bash">conda init</code></pre><p>重新开一个terminal：</p><p><img src="https://s2.loli.net/2024/04/01/qDS9gACboVTuacl.png" alt="image-20240401164542313"></p><p>可以看到cnoda已经成功启动了：</p><p><img src="https://s2.loli.net/2024/04/01/BiWUqm79ehoQdJw.png" alt="image-20240401164605751"></p><p>在安装之前我们来进行换源，我们将目录切换到这里：</p><img src="https://s2.loli.net/2024/04/01/Wom9RfSLKHzdqnl.png" alt="image-20240401165118181" style="zoom:80%;"><p>新建一个：</p><img src="https://s2.loli.net/2024/04/01/5oOPIieFVp7Xvm2.png" alt="image-20240401165149467" style="zoom: 67%;"><p>复制以下内容进去，记得ctrl+s保存：</p><pre><code class="language-bash">channels:  - defaultsshow_channel_urls: truedefault_channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/</code></pre><p><strong>最近清华源也不太稳定~</strong>，使用后无法下载删除文件恢复默认即可：</p><p>使用如下命令清除缓存（想要恢复默认也需要使用这个）</p><pre><code class="language-bash">conda clean -i</code></pre><p>然后，打开一个新的terminal ，看一下conda是否有更新：</p><p>使用命令：<code>conda info</code></p><p>结果应是如下：</p><p><img src="https://s2.loli.net/2024/04/01/L9oMIZgW6JEk1U5.png" alt="image-20240401165401775"></p><p>我们安装一个pytorch来试一试：</p><pre><code class="language-bash">conda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia</code></pre><p><img src="https://s2.loli.net/2024/04/01/aqHx1r2QAL4CDFR.png" alt="image-20240401172245221"></p><p>点击运行：</p><p>这里注意，你的当前目录不一定是你的文件夹，在运行之前要搞明白下方的命令行当前的目录在哪里是不是你想要的位置，因为在python中有很多相对路径要去处理，关于这点我们继续看下一张图：</p><p><img src="https://s2.loli.net/2024/04/01/QkYoVbXgyju13ZS.png" alt="image-20240401172544313"></p><p>这里我们使用ls命令：</p><p><img src="https://s2.loli.net/2024/04/01/cLyZJ8p2xjCgqbV.png" alt="image-20240401192341093"></p><p>这里MINIST数据集下载到当前文件夹下：</p><p><img src="https://s2.loli.net/2024/04/01/3MslfcPEINVeDFi.png" alt="image-20240401192455633"></p><p>那么相对路径是./此时的绝对路径是什么呢？</p><p>不错就是命令行前端这一部分，我们打开目录就可以看到，数聚集被下载到了这里：</p><img src="https://s2.loli.net/2024/04/01/EtfJeChiABw7r91.png" alt="image-20240401192634760" style="zoom:67%;"><p>需要注意的是我们在base环境下安装的pytorch，右下角可以切换当前的解释器：</p><p><img src="https://s2.loli.net/2024/04/01/5EJBFVPhxKejkSw.png" alt="image-20240401172633176"></p><p><strong>注意这里应是cuda</strong></p><p><img src="https://s2.loli.net/2024/04/01/1YRKaW4BApzJ2Fh.png" alt="image-20240401172730849"></p><p>可以看到显卡被占用了：</p><img src="https://s2.loli.net/2024/04/01/OjzRcpxnSM7F9v1.png" alt="image-20240401172940076" style="zoom:67%;"><h3><span id="容器的维护">容器的维护</span></h3><p>维护自身的容器也非常重要，在运行的时候我们可能建立多个bash，这些bash在切换路径的时候被vscode所遗忘，就会造成内存虚高，这对我们来说是不利的，在运行代码之前，记住一定是运行代码之前，要维护好自己的容器，就少删除一些垃圾bash，使用命令：</p><pre><code class="language-bash">ps -ef | grep shellIntegration-bash.sh</code></pre><p>命令显示了多少个bash在运行：</p><p><img src="https://s2.loli.net/2024/04/01/VTCxHhd95vN6iAB.png" alt="image-20240401193622108"></p><p>我们保留最后一个数字最大的（因为是当前正在使用的这个，数字越大，创建的时候越靠后）</p><p>使用命令杀掉前两个：</p><pre><code>kill -9 10970 11173</code></pre><p>瞬间清净了~</p><h2><span id="r语言连接办法">R语言连接办法</span></h2><p>注意事项：</p><p><strong>初始密码为账户名+123</strong>。登陆后请尽快修改密码，以防被攻击。否则后果自负。</p><p>登录R语言对应的版本的端口即可，需要注意的是，<strong>同时间之可以登录一个版本，切换另一个版本，请先退出此版本登录，再次登陆即可，或者使用两个不同的浏览器，同一个浏览器开启隐私模式也可以</strong>：</p><img src="https://s2.loli.net/2024/05/26/LHMhGuwoDRCaWYZ.png" alt="image-20240526145213656" style="zoom:67%;"><p>如图：</p><p><img src="https://s2.loli.net/2024/04/01/1VWdzcjkpoySsJu.png" alt="image-20240401202739165"></p><p><img src="https://s2.loli.net/2024/04/01/EIoPMnjNUqfLZWs.png" alt="image-20240401202839563"></p><p>目前版本对应关系：</p><ul><li>8787 --&gt; 4.3.2</li><li>10088 --&gt; 4.2.2</li></ul><h4><span id="r的文件共享">R的文件共享</span></h4><p>R的工作目录默认下应该能看到如下内容：</p><img src="https://s2.loli.net/2024/10/23/JtnciVDZ435kx8O.png" alt="image-20241023230045769" style="zoom:67%;"><p><strong>如果和上图不一致请转问题六</strong>。</p><p>host文件夹连接了主<strong>机的你个人的home文件夹</strong>。</p><img src="https://s2.loli.net/2024/10/23/QcDnkq6fMvNZJW1.png" alt="image-20241023233507171" style="zoom:67%;"><p>假设你主机上在你的</p><pre><code class="language-bash">/home/用户名/A（也就是～）</code></pre><p>文件夹下有文件A，你在R studio中调用的时候就是：</p><pre><code class="language-bash">/home/Neo/host/A</code></pre><p>简单来说就是将主机下：</p><pre><code class="language-bash">/home/用户名</code></pre><p>映射到了</p><pre><code class="language-bash">/home/Neo/host/</code></pre><p><strong>所有在主机上路径为<code>/home/用户名/</code>应替换为<code>/home/Neo/host/</code>。</strong></p><p>Datasets文件夹连接了NAS的数据中心，与主机上/home/Datasets文件夹是同一个文件夹。</p><p>假设你在主机上NAS数据中心路径是这样的：</p><pre><code class="language-bash">/home/Datasets/bionet/Dataset/A</code></pre><p>那么在R studio中，应该是：</p><pre><code class="language-bash">/home/个人用户名/Datasets/bionet/Dataset/A</code></pre><p>简单来讲明就是我们将主机上：</p><pre><code class="language-bash">/home/Datasets </code></pre><p>映射到了：</p><pre><code class="language-bash">/home/个人用户名/Datasets</code></pre><p>所有路径<code>/home/Datasets/应替换为</code>/home/个人用户名/Datasets`。</p><p>我们举个例子：</p><p>假设你上传了数据到了此路经下：</p><img src="https://s2.loli.net/2024/11/27/1xn5UVXD3p9NWH6.png" alt="image-20241127102259316" style="zoom:67%;"><img src="https://s2.loli.net/2024/11/27/eDyZOpgkLwXjKIn.png" alt="image-20241127102246110" style="zoom:80%;"><p>想要在R中引用，那么我们可以在R中看到这样的：</p><img src="https://s2.loli.net/2024/11/27/Em8BXquW9CUv5Td.png" alt="image-20241127102355410" style="zoom:67%;"><p>那么在R_Studio中，代码调用的路径应该是：</p><pre><code class="language-bash">/home/个人用户名/Datasets/bionet/Dataset/gl_XU</code></pre><h2><span id="qampa">Q&amp;A：</span></h2><h3><span id="问题零-通过容器写入的文件无法运行">问题零 通过容器写入的文件无法运行？</span></h3><p>容器的用户都是root身份，而UI登陆的是以用户的身份来登陆的，普通用户当然没有权限来操作root的内容，解决办法：</p><p>将文件修改成主机所有者，在容器的终端中使用命令</p><pre><code class="language-bash">sudo chown UID 文件/目录路径</code></pre><p>如果要修改某个文件夹的全部文件，可以使用：</p><pre><code class="language-bash">sudo chown -R UID 文件/目录路径</code></pre><p>UID信息在UI界面使用命令获取，比如：</p><p><img src="https://s2.loli.net/2024/06/07/dhEWOpuyINHF6SY.png" alt="image-20240607235021091"></p><p>打个比方，修改我在主机上：/Datasets/bionet/Dataset/A/ 文件夹的可以使用：</p><pre><code class="language-bash">sudo chown -R 1001 /Datasets/bionet/Dataset/A/</code></pre><p>这样这个文件夹下所有文件都可以正常使用。</p><p>R语言已经实现了UID的同步，所以没有这个问题。</p><p>这里放一个在Jupyter中修改权限的的例子：</p><pre><code class="language-bash"># ls -alhtotal 8.0Kdrwxr-xr-x 2 root root 4.0K Apr 18  2022 .drwxr-xr-x 1 root root 4.0K Jun  7 15:51 ..# cd /tf 首先要到对应的文件夹下来操作文件# ls -alhtotal 6.9Mdrwxrwxrwx  1 root root 4.0K Jun  7 15:51 .drwxr-xr-x  1 root root 4.0K Jun  7 15:51 ..drwxrwxrwx 11 1001 1002   14 Jun  5 05:03 Datasetsdrwxrwxrwx  6 root root 6.8M May 26 06:23 NCZonedrwxrwxr--  6 1001 1001 4.0K Jun  7 15:30 Share_Spacedrwxrwxrwx  1 root root 4.0K Sep  2  2023 tensorflow-tutorials# cd Share_Space# ls -alhtotal 28Kdrwxrwxr-- 6 1001 1001 4.0K Jun  7 15:30 .drwxrwxrwx 1 root root 4.0K Jun  7 15:51 ..drwx------ 4 root root 4.0K Jun  7 15:30 .Trash-0drwxr-xr-x 2 root root 4.0K Jun  7 15:30 .ipynb_checkpointsdrwxrwxr-- 6 root root 4.0K May  4 11:07 PTMdrwxrwxr-- 2 1000 1000 4.0K Jun  7 09:13 TEST-rwxrwxr-- 1 root root 2.2K Apr 23 15:11 test.py# pwd/tf/Share_Space# sudo chown 1001 TEST# ls -alhtotal 28Kdrwxrwxr-- 6 1001 1001 4.0K Jun  7 15:30 .drwxrwxrwx 1 root root 4.0K Jun  7 15:51 ..drwx------ 4 root root 4.0K Jun  7 15:30 .Trash-0drwxr-xr-x 2 root root 4.0K Jun  7 15:30 .ipynb_checkpointsdrwxrwxr-- 6 root root 4.0K May  4 11:07 PTMdrwxrwxr-- 2 1001 1000 4.0K Jun  7 09:13 TEST-rwxrwxr-- 1 root root 2.2K Apr 23 15:11 test.py</code></pre><h3><span id="问题一-容器重启之后无法连接">问题一 容器重启之后无法连接？</span></h3><p>容器重启之后ssh服务被中断，需要手动重启，打开portainer输入以下命令：</p><pre><code class="language-bash"> service ssh restart</code></pre><p>即可重新连接。</p><p><img src="https://s2.loli.net/2024/04/26/uPmNqxek4pWlFCa.png" alt="image-20240426194356414"></p><h3><span id="问题二-我创建一个docker失败之后再次连接相同端口为什么不行">问题二 我创建一个docker失败之后再次连接相同端口为什么不行？</span></h3><p>因为ssh有校验措施，只能连接到同一台物理设备，当你的设备失效以后就无法使用，删除过去的key即可重新连接：</p><img src="https://s2.loli.net/2024/04/01/yJDmalXE2xfwLR6.png" alt="image-20240401160821511" style="zoom:80%;"><h3><span id="问题三-我关闭了vscode代码就停止运行了">问题三 我关闭了VSCode代码就停止运行了？</span></h3><p>实际上是这样的，SSH需要保持连接才能运行，不过不要紧我们使用命令来将代码任务注册到后台来持久运行，这样你的代码只需要在默认模式下调整好之后，在再使用如下命令即可保持运行：</p><p>当我们运行的代码的时候实际上就是在命令行中调用了命令：</p><p><img src="https://s2.loli.net/2024/04/01/fdlr9SjuFY2qiZx.png" alt="image-20240401192019401"></p><p>我们需要将这个命令和nohup来结合实现运行不掉线：</p><p>同见问题五正确更新</p><p>按方向键盘的上键可以找到上一次运行的命令，当然运行之前要确认当前目录在哪里，是不是你想要的目录？</p><pre><code class="language-bash">(base) root@77d5769f235a:/# cd /home/Share_Space/                          (base) root@77d5769f235a:/home/Share_Space# lsdata  test.py(base) root@77d5769f235a:/home/Share_Space# /opt/conda/bin/python /home/Share_Space/test.py</code></pre><p>下面我们来使用nohup将任务保持在后台，格式如下：</p><pre><code class="language-sh">nohup 你的运行命令 &gt; output.file 2&gt;&amp;1 &amp;</code></pre><p>结合上边的命令，效果如下：</p><pre><code class="language-bash">nohup /opt/conda/bin/python /home/Share_Space/test.py &gt; output.file 2&gt;&amp;1 &amp;</code></pre><p>我们来运行一下：</p><p><img src="https://s2.loli.net/2024/04/01/5ui9UFh6DjNaqpd.png" alt="image-20240401195117010"></p><p>同时可以看到，这里有了对应的输出文件，输出文件保存了所有输出：</p><p><img src="https://s2.loli.net/2024/04/01/9tsvoN1ZgQEAajJ.png" alt="image-20240401195140188"></p><img src="https://s2.loli.net/2024/04/01/5ZuA7HsbzYXVJD3.png" alt="image-20240401195202219" style="zoom: 80%;"><p>当然运行完成之后文件显示的更加准确~</p><h3><span id="问题四-bad-owner-or-permissions-on">问题四 Bad owner or permissions on</span></h3><p>如果出现**Bad owner or permissions on C:\Users\Administrator/.ssh/config &gt; 过程试图写入的管道不存在。 &gt;**的问题，该问题是config文件权限高，vscode不能修改造成的，两种解决办法第一种是修改原来C:盘的config文件权限；第二种是在其他盘新建一个config文件，用于存储远程连接用户，地址等基本信息。</p><p><strong>第一种解决办法</strong></p><p>a.找到.ssh文件夹。它通常位于C:\Users</p><img src="https://pic2.zhimg.com/80/v2-00510cb6ff02667327ab74cf045e0475_720w.webp" alt="img" style="zoom:80%;"><p>b.右键单击.ssh文件夹，然后单击“属性”，选择“安全”</p><img src="https://pic4.zhimg.com/80/v2-403dcc44b073590af68d8350a8d29733_720w.webp" alt="img" style="zoom:80%;"><p>c.单击“高级”。 单击“禁用继承”，单击“确定”。 将出现警告弹出窗口。单击“从此对象中删除所有继承的权限”。</p><p>d.此时所有用户都将被删除。添加所有者。在同一窗口中，单击“编辑”按钮，单击“添加”以显示“选择用户或组”窗口。</p><img src="https://pic1.zhimg.com/80/v2-830693015d51071061ff59f4f57d0220_720w.webp" alt="img" style="zoom: 80%;"><p>e.单击“高级”，然后单击“立即查找”按钮。应显示用户结果列表。 选择用户帐户。</p><img src="https://pic2.zhimg.com/80/v2-c68f57ffd916d49e56d985c730ccd039_720w.webp" alt="img" style="zoom:80%;"><p>f.后面一路点击确定便可。</p><p><strong>记得重启电脑来刷新设置。</strong></p><p><strong>第二种解决办法</strong></p><p>在除了C盘以外的文件夹新建config文件（空的就可以），在romote-SSH插件的扩展设置中，修改config文件的路径。</p><p><img src="https://s2.loli.net/2024/03/27/xgGATnRrw852BNW.png" alt="image-20240326115205575"></p><h3><span id="问题五-python脚本使用nohup运行时指定文件没有输出内容">问题五 Python脚本使用nohup运行时，指定文件没有输出内容</span></h3><p><strong>此问题由戴珏泓发现</strong></p><p>实际上为Python的缓存机制带来的问题，log存在缓存区中没有及时更新：</p><p>可以看到运行之后没有对应的输出;</p><img src="https://s2.loli.net/2024/10/21/OfvYEPxVqanH67c.png" alt="image-20241021235853305" style="zoom: 80%;"><p>解决方法：</p><p>cd进入脚本所在目录执行nohup命令，在命令的python路径与脚本路径之间加-u，强制输出不通过缓存直接打印</p><p>例如：</p><pre><code class="language-shell">nohup /opt/conda/bin/python /home/Share_Space/metrics_ml/GA_xgboost.py 2&gt;&amp;1  &amp;</code></pre><p>改为：</p><pre><code class="language-shell">nohup /opt/conda/bin/python -u /home/Share_Space/metrics_ml/GA_xgboost.py 2&gt;&amp;1  &amp;</code></pre><h3><span id="问题六-r_studio打开之后没有见对应这两个文件夹">问题六 R_studio打开之后没有见对应这两个文件夹</span></h3><p>如打开之后没有见到这两个文件夹，可以先将默认目录设置到~</p><p>使用命令：</p><pre><code class="language-R">setwd("~")</code></pre><p>效果如图：</p><p><img src="https://s2.loli.net/2024/11/27/ZcEwh3GUDMXkOKj.png" alt="image-20241127114234957"></p><p>然后刷新一下页面，一定要刷新一下。然后结果：应该是这样：</p><p><img src="https://s2.loli.net/2024/11/27/MLvFi62cVBoDnwu.png" alt="image-20241127114538542"></p><p>如果还不行，可以打开命令行使用如下命令：</p><p><img src="https://s2.loli.net/2024/10/23/gHJXbLxNn9UBS4d.png" alt="image-20241023232258889"></p><p>使用命令：</p><pre><code class="language-bash"># 创建从 /home/user1/host 到 /home/host/R_Share/user1 的软链接ln -s /home/host/R_Share/user1 /home/user1/host# 创建从 /home/user1/Datasets 到 /home/host/Datasets 的软链接ln -s /home/host/Datasets /home/user1/Datasets</code></pre><p>user1需要替换的你的用户名，比如我的是Neo：</p><img src="https://s2.loli.net/2024/10/23/JjGr1sMXhbpDVWQ.png" alt="image-20241023232512786" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> Bionet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bionet </tag>
            
            <tag> ops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何构建一台机器学习服务器</title>
      <link href="/2024/09/21/%E6%9E%84%E5%BB%BA%E4%B8%80%E5%8F%B0%E5%85%88%E8%BF%9B%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/09/21/%E6%9E%84%E5%BB%BA%E4%B8%80%E5%8F%B0%E5%85%88%E8%BF%9B%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1><span id="如何构建一台机器学习服务器">如何构建一台机器学习服务器</span></h1><p>Version：V1.0</p><p>Author：NeoNexus</p><p>Date：2024.03.26</p><p>服务器设计要求：高性能、满足同时多人开发的需求、架构清晰、后期方便维护。因此写下此文档。</p><p>基于 最先进的架构、最先进硬件。</p><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="标准监督" style="zoom:67%;"><h2><span id="监修中敬告">监修中敬告</span></h2><img src="https://s2.loli.net/2023/12/09/LBTPhiN6luzHw7Q.jpg" alt="标准监修中" style="zoom:67%;"><p><strong>本文处于Preview阶段，不对文章内容负任何责任，如有意见探讨欢迎留言。</strong></p><p><strong>联系方式——绿泡泡：NeoNexusX</strong></p><!-- toc --><ul><li><a href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF">系统信息</a><ul><li><a href="#%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85">系统安装</a></li></ul></li><li><a href="#%E7%A1%AC%E4%BB%B6%E9%85%8D%E7%BD%AE">硬件配置：</a><ul><li><a href="#%E7%A1%AC%E4%BB%B6%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97">硬件安装指南</a></li><li><a href="#cpu">CPU</a></li><li><a href="#gpu">GPU</a></li><li><a href="#%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E7%BB%93%E6%9E%9C">硬盘分区结果</a></li><li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%92%8Cip%E8%AE%BE%E7%BD%AE">以太网和IP设置</a></li></ul></li><li><a href="#%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E9%85%8D%E7%BD%AE">基础内容配置</a><ul><li><a href="#jetbrain-ide-vscode%E5%AE%89%E8%A3%85">Jetbrain IDE &amp; VSCode安装</a><ul><li><a href="#jetbrains-shell-scripts%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">Jetbrains shell scripts有什么用？</a></li></ul></li><li><a href="#matlab%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE">Matlab安装与配置</a></li><li><a href="#r-studio-server%E5%AE%89%E8%A3%85">R Studio Server安装</a></li><li><a href="#vscode%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE">VSCode安装与配置</a></li><li><a href="#%E5%B0%86%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8Fdesktop%E9%80%81%E5%88%B0%E7%94%A8%E6%88%B7%E6%A1%8C%E9%9D%A2">将软件快捷方式（desktop）送到用户桌面</a></li><li><a href="#%E5%86%85%E7%BD%91%E7%A3%81%E7%9B%98%E6%98%A0%E5%B0%84">内网磁盘映射</a><ul><li><a href="#%E4%BD%BF%E7%94%A8samba%E6%9C%8D%E5%8A%A1">使用SAMBA服务</a></li></ul></li><li><a href="#%E5%AE%89%E8%A3%85git">安装Git</a></li><li><a href="#%E7%94%A8%E6%88%B7%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86">用户与用户组管理</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90">查看文件权限</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7">查看当前用户</a></li></ul></li><li><a href="#docker%E9%83%A8%E7%BD%B2">Docker部署</a></li></ul></li><li><a href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3">深度学习配置相关</a><ul><li><a href="#%E5%AE%89%E8%A3%85python%E5%92%8Cpip">安装Python和Pip</a></li><li><a href="#%E5%AE%89%E8%A3%85cuda-toolkit">安装CUDA Toolkit</a></li><li><a href="#%E5%AE%89%E8%A3%85cudnn">安装cuDNN</a></li><li><a href="#%E5%AE%89%E8%A3%85anaconda%E7%8E%AF%E5%A2%83">安装Anaconda环境</a></li><li><a href="#pytorch%E5%AE%89%E8%A3%85">Pytorch安装</a></li><li><a href="#nvidia-container-toolkit">NVIDIA Container Toolkit</a><ul><li><a href="#%E8%BF%90%E8%A1%8Cdocker%E9%83%A8%E7%BD%B2%E6%B5%8B%E8%AF%95">运行docker部署测试</a></li><li><a href="#%E6%AD%A4%E5%A4%84%E5%BA%94%E4%BD%BF%E7%94%A8dockerfile%E6%9D%A5%E9%85%8D%E7%BD%AE%E5%90%8E%E7%BB%AD%E6%9B%B4%E6%96%B0%E5%85%88%E6%89%8B%E5%8A%A8"><strong>此处应使用dockerfile来配置，后续更新，先手动。</strong></a></li><li><a href="#%E9%80%89%E9%85%8Drootless%E6%9D%A5%E6%93%8D%E4%BD%9Cdocker-daemon">选配：rootless来操作docker daemon</a></li></ul></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">参考文章</a></li></ul><!-- tocstop --><p>[TOC]</p><h1><span id="系统信息">系统信息</span></h1><h2><span id="系统安装">系统安装</span></h2><p>系统安装这里就不再赘述，推荐使用ventory作为PE盘，来安装系统，这样方便快捷，可同时包含多个镜像，无需重复制作，需要注意的是在安装系统的时候需要手动进行分区，我们可以看一下我的分区结果：</p><p><img src="https://s2.loli.net/2024/04/02/sQPGFI2a9SgNR3Y.png" alt="image-20240402012233365"></p><p>目前系统是由这样的硬盘空间组成的,分为高速、中速、低速区：</p><pre class="mermaid">graph TB;  subgraph HighSpeed  nvme0n1("nvme0n1:GLOWAY YCQ4TNVMe-M.2")  nvme0n1 --&gt; nvme0n1p1("nvme0n1p1,[/home],2.5T")  nvme0n1 --&gt; nvme0n1p2("nvme0n1p2,[/],1T")  nvme0n1 --&gt; nvme0n1p3("nvme0n1p3,[swap],256G")  nvme0n1 --&gt; nvme0n1p4("nvme0n1p4,[/var],128G")  nvme0n1 --&gt; nvme0n1p5("nvme0n1p5,[/opt],128G")  nvme0n1 --&gt; nvme0n1p6("nvme0n1p6,[/tmp],50G")  end  HighSpeed --&gt; MiddleSpeed  subgraph MiddleSpeed  sda("sda:Samsung 860evo 512G")  sda --&gt; sda1["sda1,[/boot/efi],500MB"]  sda --&gt; sda2["sda2,[/boot],1GB"]  sda --&gt; empty["empty 500G"]  end  MiddleSpeed --&gt; LowSpeed  subgraph LowSpeed  sdc["sdc,[/home/pastdata]"]  sdb["sdc,[/home/pastdata]"]  end</pre><p>在安装系统之后请先确认系统版本等内容和预想一致，使用命令：</p><pre><code class="language-bash">uname -m &amp;&amp; cat /etc/*release</code></pre><p>结果：</p><pre><code class="language-bash">x86_64DISTRIB_ID=UbuntuDISTRIB_RELEASE=22.04DISTRIB_CODENAME=jammyDISTRIB_DESCRIPTION="Ubuntu 22.04.3 LTS"PRETTY_NAME="Ubuntu 22.04.3 LTS"NAME="Ubuntu"VERSION_ID="22.04"VERSION="22.04.3 LTS (Jammy Jellyfish)"VERSION_CODENAME=jammyID=ubuntuID_LIKE=debianHOME_URL="https://www.ubuntu.com/"SUPPORT_URL="https://help.ubuntu.com/"BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"UBUNTU_CODENAME=jammy</code></pre><p>GCC版本：</p><pre><code class="language-bash">gcc --version</code></pre><pre><code class="language-bash">bionet@Bionet:/usr/local/cuda-12.4$ gcc --versiongcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0Copyright (C) 2021 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><p>由于后边要配置cuda信息，这里就直接先把需求放上来，各位要看符不符合要求：</p><p>下图由CUDA官方文档发布：<a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html">1. Introduction — Installation Guide for Linux 12.4 documentation (nvidia.com)</a></p><img src="https://s2.loli.net/2024/03/23/734rQdhOzfJWxTD.png" alt="image-20240323212858242" style="zoom:80%;"><h1><span id="硬件配置">硬件配置：</span></h1><h2><span id="硬件安装指南">硬件安装指南</span></h2><p>由于服务器上存在几个残缺的pcie插槽，什么叫残缺的呢？如下图：</p><img src="https://s2.loli.net/2024/03/26/UZIauqwEWxQCepl.png" alt="image-20240326234211574" style="zoom:80%;"><p>不适合安装显卡，所以通过转接版来安装PCIE下的NVME协议M.2接口固态硬盘，其优点是稳定，速度快。</p><p>相比普通的SATA顺序读写快上5倍~10倍，测试效果如下：</p><p><img src="https://s2.loli.net/2024/03/26/CnUOb7MFvJdcYQe.png" alt="image-20240326234855494"></p><h2><span id="cpu">CPU</span></h2><pre><code class="language-bash">bionet@Bionet:~$ lscpuArchitecture:            x86_64  CPU op-mode(s):        32-bit, 64-bit  Address sizes:         46 bits physical, 48 bits virtual  Byte Order:            Little EndianCPU(s):                  32  On-line CPU(s) list:   0-31Vendor ID:               GenuineIntel  Model name:            Intel(R) Xeon(R) CPU E5-2620 v4 @ 2.10GHz    CPU family:          6    Model:               79    Thread(s) per core:  2    Core(s) per socket:  8    Socket(s):           2    Stepping:            1    CPU max MHz:         3000.0000    CPU min MHz:         1200.0000    BogoMIPS:            4199.71NUMA:                      NUMA node(s):          2  NUMA node0 CPU(s):     0-7,16-23  NUMA node1 CPU(s):     8-15,24-31</code></pre><h2><span id="gpu">GPU</span></h2><pre><code class="language-bash">bionet@Bionet:~$ nvidia-smiSat Mar 23 19:30:36 2024       +---------------------------------------------------------------------------------------+| NVIDIA-SMI 535.161.07             Driver Version: 535.161.07   CUDA Version: 12.2     ||-----------------------------------------+----------------------+----------------------+| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC || Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. ||                                         |                      |               MIG M. ||=========================================+======================+======================||   0  NVIDIA GeForce RTX 2080 Ti     Off | 00000000:04:00.0 Off |                  N/A ||  0%   27C    P8              16W / 300W |      1MiB / 11264MiB |      0%      Default ||                                         |                      |                  N/A |+-----------------------------------------+----------------------+----------------------+|   1  NVIDIA GeForce RTX 4090        Off | 00000000:09:00.0 Off |                  Off ||  0%   29C    P8              20W / 450W |      1MiB / 24564MiB |      0%      Default ||                                         |                      |                  N/A |+-----------------------------------------+----------------------+----------------------+|   2  NVIDIA GeForce RTX 2080 Ti     Off | 00000000:86:00.0 Off |                  N/A ||  0%   28C    P8              13W / 300W |      1MiB / 11264MiB |      0%      Default ||                                         |                      |                  N/A |+-----------------------------------------+----------------------+----------------------+|   3  NVIDIA GeForce RTX 3090        Off | 00000000:8A:00.0 Off |                  N/A ||  0%   23C    P8               7W / 370W |      1MiB / 24576MiB |      0%      Default ||                                         |                      |                  N/A |+-----------------------------------------+----------------------+----------------------++---------------------------------------------------------------------------------------+| Processes:                                                                            ||  GPU   GI   CI        PID   Type   Process name                            GPU Memory ||        ID   ID                                                             Usage      ||=======================================================================================||  No running processes found                                                           |+---------------------------------------------------------------------------------------+</code></pre><p>简单查询：</p><pre><code class="language-bash">bionet@Bionet:~$ nvidia-smi --query-gpu=index,name,uuid,serial --format=csvindex, name, uuid, serial0, NVIDIA GeForce RTX 2080 Ti, GPU-2fdf7ca3-be62-5646-3d62-2e2db057e8b2, [N/A]1, NVIDIA GeForce RTX 4090, GPU-3d19dd88-2507-8278-5045-9f68011b7ce0, [N/A]2, NVIDIA GeForce RTX 2080 Ti, GPU-6384bfe4-3e8a-18a2-2132-fc5e686d1404, [N/A]3, NVIDIA GeForce RTX 3090, GPU-d91f3e9a-e7d0-4f91-2798-1d8b05587fb6, [N/A]</code></pre><p>验证显卡速率正常：</p><pre><code class="language-bash">nvidia-smi -i 0 -q</code></pre><p>指定GPUID来实现，0为0号设备，再输出信息中找到：</p><p>16x带宽为正常</p><img src="https://s2.loli.net/2024/03/23/8VJdjM35sNW6FwL.png" alt="image-20240323194150217" style="zoom: 80%;"><h2><span id="硬盘分区结果">硬盘分区结果</span></h2><img src="https://s2.loli.net/2024/03/23/fIqMHlWtZJ4X1Uo.png" alt="image-20240323192410929" style="zoom: 80%;"><h2><span id="以太网和ip设置">以太网和IP设置</span></h2><p>使用命令查看目前已安装的，能检测到对应的驱动的网卡信息：</p><pre><code class="language-bash">bionet@Bionet:~$ lspci | grep -i 'eth'</code></pre><p>结果如下：</p><pre><code class="language-bash">81:00.0 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)81:00.1 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)#双千兆网口</code></pre><h1><span id="基础内容配置">基础内容配置</span></h1><h2><span id="jetbrain-ide-amp-vscode安装">Jetbrain IDE &amp; VSCode安装</span></h2><p>Jetbrain系IDE针对在校大学生都是免费的，该如何申请JetBrian系的IDE呢？</p><p>详见此文，申请后就拥有了一个免费的JetBrain全家桶账号，非常方便，可以使用他们家的全部IDE，关于IDE的使用和优化，可以参考我的专栏：<a href="https://www.cnblogs.com/NeoNexus/category/2353180.html">Jetbrain入门指南 - 文章分类 - NeoNexus - 博客园 (cnblogs.com)</a></p><p>为了方便管理和使用IDE这里使用Toolbox来操作IDE：</p><p>首先下载ToolBox：</p><img src="https://s2.loli.net/2024/03/24/5iwrMZOUXonm6Sp.png" alt="image-20240324153451737" style="zoom:67%;"><p>下载之后是一个.tar.gz的压缩包，我们使用命令解压即可：</p><pre><code class="language-bash">tar -zxvf 文件名.tar.gz</code></pre><p>其中，-z 表示使用 gzip 解压缩，-x 表示解压缩，-v 表示显示详细信息，-f 表示指定文件名。</p><pre><code class="language-bash">(base) bionet@Bionet:~/Downloads$ tar -zxvf ./jetbrains-toolbox-2.2.3.20090.tar.gz </code></pre><p>如下图所示解压之后效果如下：</p><pre><code class="language-bash">jetbrains-toolbox-2.2.3.20090/jetbrains-toolbox-2.2.3.20090/jetbrains-toolbox(base) bionet@Bionet:~/Downloads$ lsAnaconda3-2024.02-1-Linux-x86_64.sh                jetbrains-toolbox-2.2.3.20090cudnn-local-repo-ubuntu2204-9.0.0_1.0-1_amd64.deb  jetbrains-toolbox-2.2.3.20090.tar.gz</code></pre><p>将解压过后的文件夹的内容迁移到我们规定的目录，命令执行如下：</p><pre><code class="language-bash">base) bionet@Bionet:~/Downloads$ sudo mv jetbrains-toolbox-2.2.3.20090 jetbrain-toolbox-2.2.3[sudo] password for bionet: (base) bionet@Bionet:~/Downloads$ lsAnaconda3-2024.02-1-Linux-x86_64.sh                jetbrains-toolbox-2.2.3.20090.tar.gzcudnn-local-repo-ubuntu2204-9.0.0_1.0-1_amd64.deb  jetbrain-toolbox-2.2.3(base) bionet@Bionet:~/Downloads$ sudo mv ./jetbrain-toolbox-2.2.3 /home/jetbrain-toolbox-2.2.3(base) bionet@Bionet:~/Downloads$ cd /home/(base) bionet@Bionet:/home$ lsanaconda3  bionet  jetbrain-toolbox-2.2.3  lost+found  Neo</code></pre><p>同时将其添加到启动项中：</p><img src="https://s2.loli.net/2024/03/24/ZJrUOk1RewSPxHI.png" alt="image-20240324160813034" style="zoom: 80%;"><img src="https://s2.loli.net/2024/03/24/BJcwkxNFEnDIv5S.png" alt="image-20240324161010897" style="zoom:67%;"><p>添加即可：</p><p><img src="https://s2.loli.net/2024/03/24/MY5XPsRQOkH8g3e.png" alt="image-20240324161237620"></p><p>用户登录之后toolbox就可以启动：</p><p>登录过程稍微有点慢，慢慢等就行。</p><img src="https://s2.loli.net/2024/03/24/vqTteIGOnsmBjxX.png" alt="image-20240324161356269" style="zoom:67%;"><p>当然选择之后登陆即可下载对应的IDE：</p><p><img src="https://s2.loli.net/2024/03/24/7n2CIQrYWqJBa1L.png" alt="image-20240324161446694"></p><p>效果如下：</p><img src="https://s2.loli.net/2024/03/24/MCyk1QFanAWEJh5.png" alt="image-20240324161716126" style="zoom:80%;"><p>需要注意的是我们需要修改安装路径到指定位置：</p><img src="https://s2.loli.net/2024/03/24/CMXpz96h4lVIWdE.png" alt="image-20240324161828077" style="zoom:80%;"><p>我们在管理用户的Home下创建一个文件夹来专门存放IDE，这样每个用户就不需要重复下载IDE了，同时需要有一个环境变量的路径来存放安装的IDE的运行脚本：</p><p>向全局变量中导入一个PATH：</p><pre><code class="language-bash">(base) bionet@Bionet:~/Desktop$ sudo vim /etc/profile</code></pre><p>打开后在最下面添加一个PATH：</p><pre><code class="language-bash">export PATH="/home/SoftWares/JetBrains/Scripts:$PATH"</code></pre><p>注意这里的路径要放在有权限的地方，大家都有权限可以使用才可以。</p><p>工具安装位置也要放置到大家都能使用的位置，如下图所示（隔了一个命令）。</p><p>让环境变量生效：</p><pre><code class="language-bash">source /etc/profile</code></pre><p>这时候你会发现shell scripts location还是会报错，不过没关系，我们只需要将此用户重新登出再登入即可：</p><img src="https://s2.loli.net/2024/03/24/xaTC3sAcEPJfGMQ.png" alt="image-20240324222348356" style="zoom:80%;"><h3><span id="jetbrains-shell-scripts有什么用">Jetbrains shell scripts有什么用？</span></h3><p>让我们先安装一个IDE在讨论这个问题：</p><img src="https://s2.loli.net/2024/03/24/YFaQmTulzcMWNqw.png" alt="image-20240324164321949" style="zoom: 80%;"><p>打开一个IDE设置：</p><img src="https://s2.loli.net/2024/03/24/OTGClBNVSrQLEtK.png" alt="image-20240324164457014" style="zoom:80%;"><p>我们拉到最下面：</p><img src="https://s2.loli.net/2024/03/24/L78aSMAlx5F3Hds.png" alt="image-20240324164846866" style="zoom:80%;"><p>随便写个缩写名字,比如:</p><p><img src="https://s2.loli.net/2024/03/24/Tq65rbFGP8DRYmz.png" alt="image-20240324164943952"></p><p>打开命令行直接执行PCP，可以发现直接运行了~</p><img src="https://s2.loli.net/2024/03/24/ujVRG8dJ6bwIkhP.png" alt="image-20240324165119297" style="zoom:80%;"><p>需要注意的是JetbrainToolBox只能让一个用户来使用！每个用户如果要使用ToolBox的话需要单独安装，这里只给root用户安装，是为了方便管理。</p><h2><span id="matlab安装与配置">Matlab安装与配置</span></h2><p>MATLAB学校购买了正版，这里需要按照学校的安装步骤来走：</p><img src="https://s2.loli.net/2024/03/24/XOTPBYd1JkG4mz8.png" alt="image-20240324235018812" style="zoom:80%;"><p>我们直接跳转到下载的步骤：</p><img src="https://s2.loli.net/2024/03/24/ZY9ANqGh2kTaM5P.png" alt="image-20240324235053576" style="zoom:80%;"><p>登录之后下载，在之后是一个安装包：</p><p>注意要解决安装路径的问题我们可以把他放在我们建立好的SoftWare目录之下：</p><p>参照官方教程安装：<a href="https://ww2.mathworks.cn/help/install/ug/install-products-with-internet-connection.html">下载并安装 MATLAB - MATLAB &amp; Simulink - MathWorks 中国</a></p><p>注意这一步只需要执行这个既可：</p><p><img src="https://s2.loli.net/2024/03/25/3WTQKorstmXL2jO.png" alt="image-20240325001102684"></p><p>一路安装下去即可：</p><img src="https://s2.loli.net/2024/03/25/RcIiet74sdYJkBn.png" alt="image-20240325001426614" style="zoom:80%;"><p>勾选全部内容：</p><img src="https://s2.loli.net/2024/03/25/7IDRPKZgpeWLOB8.png" alt="image-20240325001517608" style="zoom:80%;"><p>注意下一页需要将脚本映射到合理位置，这里映射到了如下路径,就不放图了：</p><pre><code class="language-bash">/home/SoftWares/MATLAB/MATLABScripts</code></pre><img src="https://s2.loli.net/2024/03/25/AM35wUlOh1tG7ba.png" alt="image-20240325003117797" style="zoom: 80%;"><p>在对应安装目录下运行一下：</p><p><img src="https://s2.loli.net/2024/03/25/bvjCq79QFYDzAin.png" alt="image-20240325004145626"></p><p>效果如下：</p><p><img src="https://s2.loli.net/2024/03/25/RFh1fZXWOQEg6zm.png" alt="image-20240325004206345"></p><h2><span id="r-studio-server安装">R Studio Server安装</span></h2><p>R使用过Docker来部署的：</p><p>R-studio server版本的镜像都在这里：<a href="https://hub.docker.com/r/rocker/rstudio/tags">rocker/rstudio Tags | Docker Hub</a></p><p>我们直接创建一个容器：</p><pre><code class="language-bash">docker run -d -p 8787:8787 -p 8788:22\  -v /home/SoftWares/R_Share:/home/rstudio/R_Share \  -v /etc/timezone:/etc/timezone \  -v /etc/localtime:/etc/localtime \  --name R_422 \  rocker/rstudio:4.2.2</code></pre><p><code>-v /etc/timezone:/etc/timezone \ -v /etc/localtime:/etc/localtime \</code>为时间同步命令</p><p><code>-v /home/SoftWares/R_Share:/home/rstudio/R_Share \</code>将对应的文件挂载到系统上某个盘</p><p><code>--name R_422 \</code>名字命名为R422</p><p><code>rocker/rstudio:4.2.2</code>拉去这个版本的镜像</p><p><code>-p 8787:8787 -p 8788:22</code>端口映射命令 主机的8788映射到22端口</p><p>进入容器里面：</p><pre><code class="language-bash">docker exec -it R_422 /bin/bash</code></pre><p>R_422是容器的名字。可根据需要切换</p><p>我们安装一些必要的内容，来保证容器的运行：</p><p>首先设置密码：</p><pre><code class="language-sh">passwd root</code></pre><p>设置完毕之后需要安装ssh，来方便管理，使用命令：</p><pre><code class="language-bash">sudo apt updatesudo apt-get install -y vim openssh-serversudo apt upgrade</code></pre><p>配置容器内的SSH：</p><pre><code class="language-sh">echo "PermitRootLogin yes"&gt;&gt;/etc/ssh/sshd_configecho "export VISIBLE=now" &gt;&gt;/etc/profile</code></pre><p><code>echo "PermitRootLogin yes"&gt;&gt;/etc/ssh/sshd_config</code>添加一段信息到sshd_config中。</p><p><code>echo "export VISIBLE=now" &gt;&gt; /etc/profile</code>：向 <code>/etc/profile</code> 文件中添加一行 <code>export VISIBLE=now</code>，这个设置使得 SSH 会话可以在登录时创建 <code>utmp</code> 记录，使得用户能够在 <code>w</code> 或 <code>who</code> 命令中看到 SSH 登录的用户信息。</p><p>然后运行重启：</p><pre><code class="language-shell">service ssh restart</code></pre><p>这时候你如果打开另一个宿主机命令行运行以下命令可以看到：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ docker port pytorch 220.0.0.0:10003[::]:10003</code></pre><p>这时候我们打开一个远程的命令行来来连接一下容器：</p><p><img src="C:%5CUsers%5CNeoNexus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240326230313082.png" alt="image-20240326230313082"></p><p>输入后正常登录即可。</p><p>为什么要添加用户呢因为RStudio默认不允许root用户登录，我们需要添加一些用户进来，这里可以使用我的脚本，来批量添加用户，我们直接运行即可：</p><pre><code class="language-shell">sudo ./createuser4R.sh</code></pre><p>默认密码为名字+123即 名字123.</p><p>登录之后可以看到：</p><p><img src="https://s2.loli.net/2024/03/26/3f2JtQ4rSYeE7OC.png" alt="image-20240326231825010"></p><h2><span id="vscode安装与配置">VSCode安装与配置</span></h2><p>首先下载VsCode安装包，在官网这里：<a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a></p><p>然后使用命令：</p><pre><code class="language-bash">(base) bionet@Bionet:~/Desktop$ sudo dpkg -i code_1.87.2-1709912201_amd64.deb </code></pre><p>进行安装，效果如下：</p><p><img src="https://s2.loli.net/2024/03/25/ub1CoS3lHrJKLmz.png" alt="image-20240325003045185"></p><p>报错了不要慌，实际上是传输过来的时候安装包损坏了，也就是无法通过校验。</p><p><img src="https://s2.loli.net/2024/03/25/KpsmUYXflR8DZr7.png" alt="image-20240325003455964"></p><p>安装完成之后就可以在目录中看到了：</p><p><img src="https://s2.loli.net/2024/03/25/OrEwUaFhgA6zI4b.png" alt="image-20240325004401181"></p><h2><span id="将软件快捷方式desktop送到用户桌面">将软件快捷方式（desktop）送到用户桌面</span></h2><p>到这里还没结束呢，安装完成之后我们还需要再把快捷方式丢去每个用户的目录，这里提示一下，每个创建的用户都需要在这个目录下有对应的文件才能看到应用程序，或者直接将软件丢去此目录也可以这里展示其中一个比较通用的方式：</p><p>一般桌面的软件的快捷方式都在此文件夹下：</p><pre><code class="language-bash">/usr/share/applications/</code></pre><p>用户安装的软件目录在：</p><pre><code class="language-bash">~/.local/share/applications/</code></pre><p>我们需要将安装软件的用户的目录下的图标迁移到此目录下，使用如下命令：</p><pre><code class="language-bash">sudo cp -r  ~/.local/share/applications/.  /usr/share/applications/ </code></pre><p>r如果无法执行，需要切换到对应的用户，这里安装的用户就是bonet所以可以使用bionet的，如果还不行的话只能使用root来实现，输入以下命令之后安装：</p><pre><code class="language-bash">sudo -i</code></pre><p>这样后来的用户都可以看到安装的软件了。</p><h2><span id="内网磁盘映射">内网磁盘映射</span></h2><p>虽然目前已经实现了文件的传输，直接复制粘贴就可以，但是对于一些稍微大一点的文件，还是不靠谱，所以通过另一个服务将服务器上的磁盘映射过来：</p><h3><span id="使用samba服务">使用SAMBA服务</span></h3><p>安装SAMBA：</p><pre><code class="language-bash">sudo apt-get install samba samba-common-bin</code></pre><p>配置SAMBA：</p><pre><code class="language-bash">sudo gedit /etc/samba/smb.conf</code></pre><p>在最下面加入一行：</p><pre><code class="language-bash"># 共享文件夹显示的名称[Storge]# 说明信息comment = Bionet No1 WorkStation Storage# 可以访问的用户valid users = Neo,root,Bionet# 共享文件的路径path = /home/SAMBA/Storge/# 可被其他人看到资源名称（非内容）browseable = yes# 可写writable = yes# 新建文件的权限为 664create mask = 0664# 新建目录的权限为 775directory mask = 0775</code></pre><p>运行以下命令来测试：</p><pre><code class="language-bash">bionet@Bionet:~$ testparm</code></pre><p>结果如下：</p><pre><code class="language-bash">Load smb config files from /etc/samba/smb.confLoaded services file OK.Weak crypto is allowedServer role: ROLE_STANDALONEPress enter to see a dump of your service definitions# Global parameters[global]log file = /var/log/samba/log.%mlogging = filemap to guest = Bad Usermax log size = 1000obey pam restrictions = Yespam password change = Yespanic action = /usr/share/samba/panic-action %dpasswd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .passwd program = /usr/bin/passwd %userver role = standalone serverserver string = %h server (Samba, Ubuntu)unix password sync = Yesusershare allow guests = Yesidmap config * : backend = tdb[printers]browseable = Nocomment = All Printerscreate mask = 0700path = /var/spool/sambaprintable = Yes[print$]comment = Printer Driverspath = /var/lib/samba/printers[Storge]comment = Bionet No1 WorkStation Storagecreate mask = 0664directory mask = 0775path = /home/SAMBA/Storge/read only = Novalid users = Neo root Bionet</code></pre><p>添加SMB用户（必须是已经创建了的linux用户）：</p><pre><code class="language-bash">bionet@Bionet:~$ sudo smbpasswd -a NeoNew SMB password:Retype new SMB password:Added user Neo.</code></pre><p>这里由于学校网络分割，这一部分暂且搁置</p><h2><span id="安装git">安装Git</span></h2><p>使用命令：</p><pre><code class="language-shell"> sudo apt install git</code></pre><p>版本：</p><pre><code class="language-bash">bionet@Bionet:~$ git --versiongit version 2.34.1</code></pre><p>git本身需要设置用户名等内容，这里建议先设置一个全局的通用的用户名和账号，个人用户有需求再用个人的key来进行代码同步，这里就简单说一下，详细内容敬请百度。</p><pre><code>git config --global user.name "Your Name"git config --global user.email "youremail@yourdomain.com"</code></pre><p>配置完成以后验证一下：</p><pre><code class="language-bash">bionet@Bionet:/usr/local/cuda-12.4$ git config --global user.name "Bionet"bionet@Bionet:/usr/local/cuda-12.4$ git config --global user.email "Bionet@xmu.edu.cn"bionet@Bionet:/usr/local/cuda-12.4$ git config --listuser.name=Bionetuser.email=Bionet@xmu.edu.cn</code></pre><p>注册一个Github账号（实验室已经有账号了，详询老大）：</p><img src="https://s2.loli.net/2024/03/23/JLCDzv8N3UlMBsf.png" alt="image-20240323210820829" style="zoom:67%;"><p>生成密钥：</p><pre><code class="language-bash">bionet@Bionet:/usr/local/cuda-12.4$ ssh-keygen -t ed25519 -C "BioNet@xmu.edu.cn"Generating public/private ed25519 key pair.Enter file in which to save the key (/home/bionet/.ssh/id_ed25519): Created directory '/home/bionet/.ssh'.Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/bionet/.ssh/id_ed25519Your public key has been saved in /home/bionet/.ssh/id_ed25519.pub</code></pre><p>然后添加到咱们的账户中即可，如果重装的话，此处就要把原来的删除掉，在生成一个新的来作为验证。</p><p>没有添加密钥，验证失败结果如下：</p><pre><code class="language-bash">bionet@Bionet:/usr/local/cuda-12.4$ ssh -T git@github.comgit@github.com: Permission denied (publickey).</code></pre><p>等待添加密钥即可</p><pre><code class="language-bash">(base) bionet@Bionet:~/Desktop$ ssh -T git@github.comHi NeoNexusX! You've successfully authenticated, but GitHub does not provide shell access.</code></pre><h2><span id="用户与用户组管理">用户与用户组管理</span></h2><p>管理用户及用户组的权限是十分重要的，合理的权限分配能大大的减少后期维护成本。这里简单介绍一下linux文件权限的内容，并由此来介绍一下如何配用户组的权限。</p><p>Linux系统一般将文件可存/取访问的<strong>身份</strong>分为3个类别：owner、group、others，且3种身份各有read、write、execute等权限。在<strong>多用户</strong>（可以不同时）计算机系统的管理中，权限是指<strong>某个特定的用户具有特定的系统资源使用权力</strong>，像是文件夹、特定系统指令的使用。</p><ul><li><p>读权限：</p><p>对于文件夹来说，读权限影响用户是否能够列出目录结构<br>对于文件来说，读权限影响用户是否可以查看文件内容</p></li><li><p>写权限：</p><p>对文件夹来说，写权限影响用户是否可以在文件夹下“创建/删除/复制到/移动到”文档<br>对于文件来说，写权限影响用户是否可以编辑文件内容</p></li><li><p>执行权限：</p><p>一般都是对于文件来说，特别脚本文件</p></li></ul><p>上述说了身份也分为很多种，下面是详细介绍：</p><ul><li>Owner身份：文件所有者，默认为文档的创建者</li><li>Group身份：与文件所有者同组的用户</li><li>Others身份：其他人，相对于所有者所在组</li><li>Root用户：超级用户，管理着普通用户，具有所有权限</li></ul><h3><span id="查看文件权限">查看文件权限</span></h3><p>使用命令如下可以查看当前文件下的文件的权限：</p><p><img src="https://s2.loli.net/2024/03/24/Tk5GZMtNqE8VrHC.png" alt="image-20240324211325591"></p><p>权限区一共有10个字母，每个的内容意思是：</p><p><img src="https://s2.loli.net/2024/03/24/oRCPZhtelAB8xuX.png" alt="image-20240324211953007"></p><p>上图中权限为：<code>-rwxr-xr-x</code> 意思是 文件(-)、在bionet用户下有全部权限(rwx)、在所属用户组下有除了写的全部权限(r-x)、其他用户有除了写的全部权限(r-x)。</p><h3><span id="查看当前用户">查看当前用户</span></h3><p>使用命令：</p><pre><code class="language-bash">Neo@Bionet:/home/jetbrain-toolbox-2.2.3$ getent passwd</code></pre><img src="https://s2.loli.net/2024/03/24/nr1ldGAc5sNThqu.png" alt="image-20240324210427485" style="zoom:80%;"><p>上述内容表达为：<code>用户名:密码(x):用户ID:组ID:描述信息(无用):HOME目录:执行终端(默认bash)</code></p><p>查看当前用户组：</p><pre><code class="language-bash">getent group</code></pre><img src="https://s2.loli.net/2024/03/24/tEP1hJfdBqwFWam.png" alt="image-20240324210905590" style="zoom: 67%;"><p>在我们划分的时候需要将所有core组成员公用的地方加上权限，效果如下：</p><img src="https://s2.loli.net/2024/03/26/u1SaOYPkzHmRlZ7.png" alt="image-20240326232226188" style="zoom:67%;"><p>红框的三个文件夹都是公用的所以要加上权限</p><pre><code class="language-shell">sudo chown -R :core /path/to/folder</code></pre><pre><code class="language-shell">sudo chmod -R 770 /path/to/folder</code></pre><h2><span id="docker部署">Docker部署</span></h2><p>Docker也是虚拟化环境的神器，前面说的conda虽然可以提供python的虚拟环境并方便地切换，但是有的时候我们的开发环境并不只是用到python，比如有的native库需要对应gcc版本的编译环境，或者进行交叉编译时哟啊安装很多工具链等等。如果这些操作都在服务器本地上进行，那时间久了就会让服务器的文件系统非常杂乱，而且还会遇到各种软件版本冲突问题。</p><p>简单理解Docker为一个轻量化的虚拟机即可，但是其并不是虚拟机，虚拟机需要提供操作系统等，Docker只需要提供程序运行所需要的环境，对与常规开发流程来说一般是：</p><pre class="mermaid">graph TB;A("本地docker环境搭建")--&gt; B("代码编写测试") --&gt; C("打包镜像") --&gt; D("部署到服务器运行")</pre><p>这里主要考虑服务器环境搭建和运行</p><p>docker官方教程：<a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu | Docker Docs</a></p><p>首先设置docker的apt仓库信息：</p><pre><code class="language-bash"># Add Docker's official GPG key:sudo apt-get updatesudo apt-get install ca-certificates curlsudo install -m 0755 -d /etc/apt/keyringssudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.ascsudo chmod a+r /etc/apt/keyrings/docker.asc# Add the repository to Apt sources:echo \  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \  $(. /etc/os-release &amp;&amp; echo "$VERSION_CODENAME") stable" | \  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt-get update</code></pre><p>命令一条一条复制，比较安全。</p><p>安装docker：</p><pre><code class="language-bash">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre><p><img src="https://s2.loli.net/2024/03/25/fdDPS1hzF5j3v9U.png" alt="image-20240325141511920"></p><p>运行测试的镜像：</p><pre><code class="language-bash">sudo docker run hello-world</code></pre><p><img src="https://s2.loli.net/2024/03/25/CgZedvBxkL61IcV.png" alt="image-20240325143800000"></p><p>运行版本信息查看一下：</p><p><img src="https://s2.loli.net/2024/03/25/O7WUMoAcYS6hkJa.png" alt="image-20240325144047989"></p><p>为了方便后边Docker设置：我们先来创建一个用户组，因为对于后面使用docker来说，其守护进程使用的是Unix socket，并不是TCP socket，Docker的守护进程通常只能运行在root权限用户下，因此我们只能创建一个docker用户组来专门赋予权限，我们先看看是否有docker用户组，已经被创建好了，因为在某些发行版的linux下，安装完成docker后会自行创建：</p><p>使用命令：</p><pre><code>getent group</code></pre><p><img src="https://s2.loli.net/2024/03/25/b6xaBAJolPy1I2g.png" alt="image-20240325145438859"></p><p>果然有！所以我们就需要把当前的需要使用docker的用户加入到这个用户组里面去，这样运行的时候就不需要sudo权限了。</p><pre><code class="language-shell">sudo usermod -aG docker $USER</code></pre><p><code>-aG</code>：这是 <code>usermod</code> 命令的选项之一，其中：</p><ul><li><code>-a</code> 表示“追加”，它告诉 <code>usermod</code> 命令将用户添加到指定的组，而不是覆盖原有的组成员资格。</li><li><code>-G</code> 表示“组”，它指定要操作的组。</li></ul><p>登出后重新登录这个账户，并输入以下内容：</p><pre><code class="language-bash">newgrp docker</code></pre><p>重新再来验证一下，目前是否能使用了</p><p><img src="https://s2.loli.net/2024/03/25/lrAoBRVNweg38yI.png" alt="image-20240325150823273"></p><p>设置开机自启动：</p><pre><code class="language-sh">Neo@Bionet:~/Desktop$ sudo systemctl enable docker.servicesudo systemctl enable containerd.service[sudo] password for Neo: Synchronizing state of docker.service with SysV service script with /lib/systemd/systemd-sysv-install.Executing: /lib/systemd/systemd-sysv-install enable docker</code></pre><p>如果需要关闭请使用：</p><pre><code class="language-bash">sudo systemctl disable docker.servicesudo systemctl disable containerd.service</code></pre><p>到此完成docker的基本部署，接下来安装Nvida的docker，这部分在深度学习配置最后。</p><h1><span id="深度学习配置相关">深度学习配置相关</span></h1><p>安装NVIDIA驱动，由于新的版Ubuntu可以在管理器中直接安装，这里就不再赘述，只需要点击即可，新的显卡使用较新的驱动是最好的了：</p><p><img src="https://s2.loli.net/2024/03/23/SXtZomEUCzbgjDM.png" alt="image-20240323202228201"></p><h2><span id="安装python和pip">安装Python和Pip</span></h2><p>使用命令</p><pre><code class="language-bash">sudo apt install python3sudo apt install python3-pip</code></pre><p>安装完成之后，替换python的pip源</p><pre><code class="language-bash">bionet@Bionet:~$ cd ~bionet@Bionet:~$ mkdir .pipbionet@Bionet:~$ sudo gedit ~/.pip/pip.conf</code></pre><p>其中gedit是ubuntu自带的图形化文本编辑器，如果你喜欢vim那么可以替换成：</p><pre><code class="language-bash">bionet@Bionet:~$ sudo vim ~/.pip/pip.conf</code></pre><p>将以下内容填入：</p><pre><code class="language-conf">[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple/ [install]trusted-host = pypi.tuna.tsinghua.edu.cn</code></pre><p>测试一下：</p><pre><code class="language-bash">bionet@Bionet:~$ python3Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0] on linuxType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; quit();</code></pre><h2><span id="安装cuda-toolkit">安装CUDA Toolkit</span></h2><p>这里选择最新的CUDA Toolkit12.4，在<a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=22.04&amp;target_type=runfile_local">网页</a>上按我的选择如下：</p><p><img src="https://s2.loli.net/2024/03/23/mOPwalncxsRDruI.png" alt="image-20240323202435763"></p><p>复制对应的命令后下载下来：</p><pre><code class="language-bash">bionet@Bionet:~$ wget https://developer.download.nvidia.com/compute/cuda/12.4.0/local_installers/cuda_12.4.0_550.54.14_linux.runSaving to: ‘cuda_12.4.0_550.54.14_linux.run’cuda_12.4.0_550.54.14_linux.run              100%[==============================================================================================&gt;]   4.15G  89.4MB/s    in 57s     2024-03-23 20:26:43 (73.9 MB/s) - ‘cuda_12.4.0_550.54.14_linux.run’ saved [4454353277/4454353277]bionet@Bionet:~$ lscuda_12.4.0_550.54.14_linux.run  Desktop  Documents  Downloads  matlab  Music  Pictures  Public  snap  Templates  thinclient_drives  Videos</code></pre><p>使用命令执行：</p><pre><code class="language-bash">sudo sh cuda_12.4.0_550.54.14_linux.run</code></pre><p>注意进入选择模式之后，不要选择驱动，我们已经打了新驱动了，无需在安装一次：</p><p>至于这里选择不选择新驱动要看这个图：</p><img src="https://s2.loli.net/2024/03/26/QY2W4txbGJ1zgBv.png" alt="image-20240326131315726" style="zoom:80%;"><p><strong>如果你不满足对应的驱动条件我建议可以打上新驱动。</strong></p><img src="https://s2.loli.net/2024/03/23/DVEkXiT4hLeIZAz.png" alt="image-20240323204149764" style="zoom:67%;"><p>根据提示我们需要套件的内容添加到环境变量里面：</p><pre><code class="language-bash">bionet@Bionet:~$ sudo gedit ~/.bashrc</code></pre><p>环境变量如下：</p><pre><code class="language-bash">export CUDA_HOME=/usr/local/cuda-12.4export LD_LIBRARY_PATH=${CUDA_HOME}/lib64export PATH=${CUDA_HOME}/bin:${PATH}</code></pre><p>使其生效：</p><pre><code class="language-bash">bionet@Bionet:~$ source ~/.bashrc</code></pre><p>使用命令测试：</p><pre><code class="language-bash">bionet@Bionet:~$ nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2024 NVIDIA CorporationBuilt on Tue_Feb_27_16:19:38_PST_2024Cuda compilation tools, release 12.4, V12.4.99Build cuda_12.4.r12.4/compiler.33961263_0</code></pre><p>到这一步并不代表成功了，要成功运行cuda才说明环境没有问题：</p><p>自从11.7之后cuda不再单独提供测试样例，我们可以从github上克隆下来，直接编译后运行即可：</p><pre><code class="language-bash">cd /usr/local/cuda-12.4/git clone https://github.com/NVIDIA/cuda-samples.gitcd /cuda-samples/Samples/1_Utilities/deviceQuerymake./deviceQuery</code></pre><p>结果如下：</p><pre><code class="language-bash">bionet@Bionet:/usr/local/cuda-12.4/cuda-samples/Samples/1_Utilities/deviceQuery$ ./deviceQuery ./deviceQuery Starting... CUDA Device Query (Runtime API) version (CUDART static linking)Detected 4 CUDA Capable device(s)Device 0: "NVIDIA GeForce RTX 4090"  CUDA Driver Version / Runtime Version          12.2 / 12.4  CUDA Capability Major/Minor version number:    8.9  Total amount of global memory:                 24217 MBytes (25393692672 bytes)  (128) Multiprocessors, (128) CUDA Cores/MP:    16384 CUDA Cores  GPU Max Clock rate:                            2580 MHz (2.58 GHz)  Memory Clock rate:                             10501 Mhz  Memory Bus Width:                              384-bit  L2 Cache Size:                                 75497472 bytes  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers  Total amount of constant memory:               65536 bytes  Total amount of shared memory per block:       49152 bytes  Total shared memory per multiprocessor:        102400 bytes  Total number of registers available per block: 65536  Warp size:                                     32  Maximum number of threads per multiprocessor:  1536  Maximum number of threads per block:           1024  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)  Maximum memory pitch:                          2147483647 bytes  Texture alignment:                             512 bytes  Concurrent copy and kernel execution:          Yes with 2 copy engine(s)  Run time limit on kernels:                     No  Integrated GPU sharing Host Memory:            No  Support host page-locked memory mapping:       Yes  Alignment requirement for Surfaces:            Yes  Device has ECC support:                        Disabled  Device supports Unified Addressing (UVA):      Yes  Device supports Managed Memory:                Yes  Device supports Compute Preemption:            Yes  Supports Cooperative Kernel Launch:            Yes  Supports MultiDevice Co-op Kernel Launch:      Yes  Device PCI Domain ID / Bus ID / location ID:   0 / 9 / 0  Compute Mode:     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;Device 1: "NVIDIA GeForce RTX 3090"  CUDA Driver Version / Runtime Version          12.2 / 12.4  CUDA Capability Major/Minor version number:    8.6  Total amount of global memory:                 24260 MBytes (25438126080 bytes)  (082) Multiprocessors, (128) CUDA Cores/MP:    10496 CUDA Cores  GPU Max Clock rate:                            1755 MHz (1.75 GHz)  Memory Clock rate:                             9751 Mhz  Memory Bus Width:                              384-bit  L2 Cache Size:                                 6291456 bytes  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers  Total amount of constant memory:               65536 bytes  Total amount of shared memory per block:       49152 bytes  Total shared memory per multiprocessor:        102400 bytes  Total number of registers available per block: 65536  Warp size:                                     32  Maximum number of threads per multiprocessor:  1536  Maximum number of threads per block:           1024  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)  Maximum memory pitch:                          2147483647 bytes  Texture alignment:                             512 bytes  Concurrent copy and kernel execution:          Yes with 2 copy engine(s)  Run time limit on kernels:                     No  Integrated GPU sharing Host Memory:            No  Support host page-locked memory mapping:       Yes  Alignment requirement for Surfaces:            Yes  Device has ECC support:                        Disabled  Device supports Unified Addressing (UVA):      Yes  Device supports Managed Memory:                Yes  Device supports Compute Preemption:            Yes  Supports Cooperative Kernel Launch:            Yes  Supports MultiDevice Co-op Kernel Launch:      Yes  Device PCI Domain ID / Bus ID / location ID:   0 / 138 / 0  Compute Mode:     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;Device 2: "NVIDIA GeForce RTX 2080 Ti"  CUDA Driver Version / Runtime Version          12.2 / 12.4  CUDA Capability Major/Minor version number:    7.5  Total amount of global memory:                 11012 MBytes (11546394624 bytes)  (068) Multiprocessors, (064) CUDA Cores/MP:    4352 CUDA Cores  GPU Max Clock rate:                            1650 MHz (1.65 GHz)  Memory Clock rate:                             7000 Mhz  Memory Bus Width:                              352-bit  L2 Cache Size:                                 5767168 bytes  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers  Total amount of constant memory:               65536 bytes  Total amount of shared memory per block:       49152 bytes  Total shared memory per multiprocessor:        65536 bytes  Total number of registers available per block: 65536  Warp size:                                     32  Maximum number of threads per multiprocessor:  1024  Maximum number of threads per block:           1024  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)  Maximum memory pitch:                          2147483647 bytes  Texture alignment:                             512 bytes  Concurrent copy and kernel execution:          Yes with 3 copy engine(s)  Run time limit on kernels:                     No  Integrated GPU sharing Host Memory:            No  Support host page-locked memory mapping:       Yes  Alignment requirement for Surfaces:            Yes  Device has ECC support:                        Disabled  Device supports Unified Addressing (UVA):      Yes  Device supports Managed Memory:                Yes  Device supports Compute Preemption:            Yes  Supports Cooperative Kernel Launch:            Yes  Supports MultiDevice Co-op Kernel Launch:      Yes  Device PCI Domain ID / Bus ID / location ID:   0 / 4 / 0  Compute Mode:     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;Device 3: "NVIDIA GeForce RTX 2080 Ti"  CUDA Driver Version / Runtime Version          12.2 / 12.4  CUDA Capability Major/Minor version number:    7.5  Total amount of global memory:                 11012 MBytes (11546394624 bytes)  (068) Multiprocessors, (064) CUDA Cores/MP:    4352 CUDA Cores  GPU Max Clock rate:                            1650 MHz (1.65 GHz)  Memory Clock rate:                             7000 Mhz  Memory Bus Width:                              352-bit  L2 Cache Size:                                 5767168 bytes  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers  Total amount of constant memory:               65536 bytes  Total amount of shared memory per block:       49152 bytes  Total shared memory per multiprocessor:        65536 bytes  Total number of registers available per block: 65536  Warp size:                                     32  Maximum number of threads per multiprocessor:  1024  Maximum number of threads per block:           1024  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)  Maximum memory pitch:                          2147483647 bytes  Texture alignment:                             512 bytes  Concurrent copy and kernel execution:          Yes with 3 copy engine(s)  Run time limit on kernels:                     No  Integrated GPU sharing Host Memory:            No  Support host page-locked memory mapping:       Yes  Alignment requirement for Surfaces:            Yes  Device has ECC support:                        Disabled  Device supports Unified Addressing (UVA):      Yes  Device supports Managed Memory:                Yes  Device supports Compute Preemption:            Yes  Supports Cooperative Kernel Launch:            Yes  Supports MultiDevice Co-op Kernel Launch:      Yes  Device PCI Domain ID / Bus ID / location ID:   0 / 134 / 0  Compute Mode:     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;&gt; Peer access from NVIDIA GeForce RTX 4090 (GPU0) -&gt; NVIDIA GeForce RTX 3090 (GPU1) : No&gt; Peer access from NVIDIA GeForce RTX 4090 (GPU0) -&gt; NVIDIA GeForce RTX 2080 Ti (GPU2) : No&gt; Peer access from NVIDIA GeForce RTX 4090 (GPU0) -&gt; NVIDIA GeForce RTX 2080 Ti (GPU3) : No&gt; Peer access from NVIDIA GeForce RTX 3090 (GPU1) -&gt; NVIDIA GeForce RTX 4090 (GPU0) : No&gt; Peer access from NVIDIA GeForce RTX 3090 (GPU1) -&gt; NVIDIA GeForce RTX 2080 Ti (GPU2) : No&gt; Peer access from NVIDIA GeForce RTX 3090 (GPU1) -&gt; NVIDIA GeForce RTX 2080 Ti (GPU3) : No&gt; Peer access from NVIDIA GeForce RTX 2080 Ti (GPU2) -&gt; NVIDIA GeForce RTX 4090 (GPU0) : No&gt; Peer access from NVIDIA GeForce RTX 2080 Ti (GPU2) -&gt; NVIDIA GeForce RTX 3090 (GPU1) : No&gt; Peer access from NVIDIA GeForce RTX 2080 Ti (GPU2) -&gt; NVIDIA GeForce RTX 2080 Ti (GPU3) : No&gt; Peer access from NVIDIA GeForce RTX 2080 Ti (GPU3) -&gt; NVIDIA GeForce RTX 4090 (GPU0) : No&gt; Peer access from NVIDIA GeForce RTX 2080 Ti (GPU3) -&gt; NVIDIA GeForce RTX 3090 (GPU1) : No&gt; Peer access from NVIDIA GeForce RTX 2080 Ti (GPU3) -&gt; NVIDIA GeForce RTX 2080 Ti (GPU2) : NodeviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 12.2, CUDA Runtime Version = 12.4, NumDevs = 4Result = PAS</code></pre><p>可以看到4090的ECC没有开启不过问题不大，这个以后再处理。</p><p>同样可以再跑一个BandwidthTest，编译后结果如下</p><img src="https://s2.loli.net/2024/03/23/iT1SDxWPe5Yvs6g.png" alt="image-20240323215326894" style="zoom: 80%;"><pre><code class="language-bash">bionet@Bionet:/usr/local/cuda-12.4/cuda-samples/Samples/1_Utilities/bandwidthTest$ ./bandwidthTest [CUDA Bandwidth Test] - Starting...Running on... Device 0: NVIDIA GeForce RTX 4090 Quick Mode Host to Device Bandwidth, 1 Device(s) PINNED Memory Transfers   Transfer Size (Bytes)Bandwidth(GB/s)   3200000011.9 Device to Host Bandwidth, 1 Device(s) PINNED Memory Transfers   Transfer Size (Bytes)Bandwidth(GB/s)   3200000013.2 Device to Device Bandwidth, 1 Device(s) PINNED Memory Transfers   Transfer Size (Bytes)Bandwidth(GB/s)   320000003627.5Result = PASSNOTE: The CUDA Samples are not meant for performance measurements. Results may vary when GPU Boost is enabled.</code></pre><h2><span id="安装cudnn">安装cuDNN</span></h2><p>cuDNN是nvidia专门用来加速深度学习的一些库，需要注意的是安装的时候要和你的cuda版本对应</p><img src="https://s2.loli.net/2024/03/23/tedrqYc2GHNjak6.png" alt="image-20240323215837575" style="zoom:67%;"><p>这里是网页下载途径，但是网有墙，很烂，推荐使用这个<a href="https://developer.nvidia.com/cudnn-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=22.04&amp;target_type=deb_local">页面</a>下载，选择对应的命令即可，我这里是cuda12所以要用cuda12的内容：</p><img src="https://s2.loli.net/2024/03/23/76MqebZXjNEic9p.png" alt="image-20240323221544281" style="zoom:67%;"><p>注意这个和网上的不太一样，这里使用的是系统原生的包管理器来进行安装，详见：<a href="https://docs.nvidia.com/deeplearning/cudnn/installation/linux.html">Installing cuDNN on Linux — NVIDIA cuDNN 9.0.0 documentation</a>。</p><h2><span id="安装anaconda环境">安装Anaconda环境</span></h2><p>从清华镜像站下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&amp;O=D">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&amp;O=D</a></p><img src="https://s2.loli.net/2024/03/23/Fqe3SIQMdvUXp59.png" alt="image-20240323223642952" style="zoom:80%;"><pre><code class="language-shell">bionet@Bionet:~/Downloads$ chmod +x Anaconda3-2024.02-1-Linux-x86_64.sh bionet@Bionet:~/Downloads$ sudo ./Anaconda3-2024.02-1-Linux-x86_64.sh </code></pre><p>注意这里我修改到了home目录下,home很大，我就喜欢整整齐齐的</p><img src="https://s2.loli.net/2024/03/23/FBHezfQ3X9UpawE.png" alt="image-20240323224007486" style="zoom:67%;"><img src="https://s2.loli.net/2024/03/23/l7CS91emGqt6ZQF.png" alt="image-20240323224112452" style="zoom:67%;"><p>安装完成之后再输入一个yes，最后会给你显示目前安装的内容：</p><img src="https://s2.loli.net/2024/03/23/E6P9C2sb4rcuVgG.png" alt="image-20240323224126302" style="zoom:67%;"><p>你安装完成以后发现不行啊没有conda的环境变量，其实并不是，他只是把环境变量写到了root的shell里面，这就很尴尬了。</p><p>所以我们需要手动baroot里面的内容复制过来：</p><img src="https://s2.loli.net/2024/03/23/ERfHxMYudmF3GI2.png" alt="image-20240323230739401" style="zoom:67%;"><p>这里下边打个样：</p><pre><code class="language-sh"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;# !! Contents within this block are managed by 'conda init' !!__conda_setup="$('/home/anaconda3/bin/conda' 'shell.bash' 'hook' 2&gt; /dev/null)"if [ $? -eq 0 ]; then    eval "$__conda_setup"else    if [ -f "/home/anaconda3/etc/profile.d/conda.sh" ]; then        . "/home/anaconda3/etc/profile.d/conda.sh"    else        export PATH="/home/anaconda3/bin:$PATH"    fifiunset __conda_setup# &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</code></pre><p>不同的系统需要的路径也不一样，这里需要注意下。</p><p>使用的命令如下：</p><pre><code class="language-bash">bionet@Bionet:~/Desktop$ sudo vim ~/.bashrcbionet@Bionet:~/Desktop$ source ~/.bashrc</code></pre><p>可以看到使用后的结果：</p><p><img src="https://s2.loli.net/2024/03/23/XN4tJWkhMyVZTOC.png" alt="image-20240323231141009"></p><p>你以为到这里就结束了吗？当然不可能对于我一个目录洁癖的人来说，肯定不止于此，我们要设置其包的路径，来保证整洁。</p><p>在开始之前先完成换源：</p><pre><code class="language-bash">(base) bionet@Bionet:~$ sudo vim ~/.condarc </code></pre><p>替换成如下内容：</p><pre><code class="language-bash">channels:  - defaultsshow_channel_urls: truedefault_channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/</code></pre><p><img src="https://s2.loli.net/2024/03/23/ilpDM1PsCfrLSvo.png" alt="image-20240323231634153"></p><p>我们检查一下当前路径结果：</p><pre><code class="language-bash">(base) bionet@Bionet:~$ conda info     active environment : base    active env location : /home/anaconda3            shell level : 1       user config file : /home/bionet/.condarc populated config files : /home/bionet/.condarc          conda version : 24.1.2    conda-build version : 24.1.2         python version : 3.11.7.final.0                 solver : libmamba (default)       virtual packages : __archspec=1=broadwell                          __conda=24.1.2=0                          __cuda=12.2=0                          __glibc=2.35=0                          __linux=6.5.0=0                          __unix=0=0       base environment : /home/anaconda3  (read only)      conda av data dir : /home/anaconda3/etc/conda  conda av metadata url : None           channel URLs : https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64                          https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/noarch                          https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r/linux-64                          https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r/noarch                          https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2/linux-64                          https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2/noarch          package cache : /home/anaconda3/pkgs                          /home/bionet/.conda/pkgs       envs directories : /home/bionet/.conda/envs                          /home/anaconda3/envs</code></pre><p>发现目录正好不用改都在/home下，注意这里的路径是/home不是用户的home。</p><h2><span id="pytorch安装">Pytorch安装</span></h2><p>终于到了这一步了，我们在conda上创建一个新环境：</p><pre><code class="language-bash">conda create --name test python=3.10conda activate test</code></pre><p>在pytorch官网中找到合适的版本：<a href="https://pytorch.org/">PyTorch</a></p><p><img src="https://s2.loli.net/2024/03/23/nzDTKOdvbeHfWoY.png" alt="image-20240323232757248"></p><p>复制命令下载：</p><pre><code>conda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia</code></pre><p>随便写一个脚本，然后运行一下看看：</p><pre><code class="language-bash">sudo vim test.py</code></pre><p>脚本内容如下：</p><pre><code class="language-python">import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimimport torch.backends.cudnn as cudnnfrom torchvision import datasets, transformsclass Net(nn.Module):    def __init__(self):        super(Net, self).__init__()        self.conv1 = nn.Conv2d(1, 10, kernel_size=5)        self.conv2 = nn.Conv2d(10, 20, kernel_size=5)        self.conv2_drop = nn.Dropout2d()        self.fc1 = nn.Linear(320, 50)        self.fc2 = nn.Linear(50, 10)    def forward(self, x):        x = F.relu(F.max_pool2d(self.conv1(x), 2))        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2))        x = x.view(-1, 320)        x = F.relu(self.fc1(x))        x = F.dropout(x, training=self.training)        x = self.fc2(x)        return F.log_softmax(x, dim=1)def train(model, device, train_loader, optimizer, epoch):    model.train()    for batch_idx, (data, target) in enumerate(train_loader):        data, target = data.to(device), target.to(device)        optimizer.zero_grad()        output = model(data)        loss = F.nll_loss(output, target)        loss.backward()        optimizer.step()        if batch_idx % 10 == 0:            print('Train Epoch: {} [{}/{} ({:.0f}%)]\tLoss: {:.6f}'.format(                epoch, batch_idx * len(data), len(train_loader.dataset),                       100. * batch_idx / len(train_loader), loss.item()))def main():    cudnn.benchmark = True    torch.manual_seed(1)    device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")    print("Using device: {}".format(device))    kwargs = {'num_workers': 1, 'pin_memory': True}    train_loader = torch.utils.data.DataLoader(        datasets.MNIST('./data', train=True, download=True,                       transform=transforms.Compose([                           transforms.ToTensor(),                           transforms.Normalize((0.1307,), (0.3081,))                       ])),        batch_size=64, shuffle=True, **kwargs)    model = Net().to(device)    optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5)    for epoch in range(1, 11):        train(model, device, train_loader, optimizer, epoch)if __name__ == '__main__':    main()</code></pre><p>运行后没有报错的话就因该是这样的：</p><pre><code class="language-bash">test) bionet@Bionet:~$ python  test.py                                                                                                        Using device: cuda                                                                                                                               Downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz                                                                          Downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz to ./data/MNIST/raw/train-images-idx3-ubyte.gz                        100.0%                                                                                                                                           Extracting ./data/MNIST/raw/train-images-idx3-ubyte.gz to ./data/MNIST/raw                                                             100.0%Extracting ./data/MNIST/raw/t10k-labels-idx1-ubyte.gz to ./data/MNIST/rawTrain Epoch: 1 [0/60000 (0%)]Loss: 2.327492Train Epoch: 1 [640/60000 (1%)]Loss: 2.328194Train Epoch: 1 [1280/60000 (2%)]Loss: 2.278235Train Epoch: 1 [1920/60000 (3%)]Loss: 2.281009省略一部分Train Epoch: 10 [56320/60000 (94%)]Loss: 0.196389Train Epoch: 10 [56960/60000 (95%)]Loss: 0.387766Train Epoch: 10 [57600/60000 (96%)]Loss: 0.109143Train Epoch: 10 [58240/60000 (97%)]Loss: 0.077670Train Epoch: 10 [58880/60000 (98%)]Loss: 0.182428Train Epoch: 10 [59520/60000 (99%)]Loss: 0.392815</code></pre><p>**注意这里的device一定要是cuda。**别急，这是裸机部分，但我们真正需要的是Docker！</p><h2><span id="nvidia-container-toolkit">NVIDIA Container Toolkit</span></h2><p>英伟达虚拟化环境技术分类：</p><p><a href="https://blog.csdn.net/yjy420/article/details/132305356">nvidia docker, nvidia docker2, nvidia container toolkits三者的区别-CSDN博客</a></p><p>不扯没用的，我们直接上最新的nvidia-container-toolkits</p><p>NVIDIA Container Toolkit 的目的是为了能够创造一个合适的环境来运行显卡的程序。同时有一定的自由度，可以切换CUDA版本等操作，最重要的是实现在不同机器上、不同硬件上无需提前配置相同环境就可以直接运行。</p><p>官方教程：<a href="https://github.com/NVIDIA/nvidia-container-toolkit?tab=readme-ov-file">NVIDIA/nvidia-container-toolkit: Build and run containers leveraging NVIDIA GPUs (github.com)</a></p><p><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html">Installing the NVIDIA Container Toolkit — NVIDIA Container Toolkit 1.14.5 documentation</a></p><p><img src="https://s2.loli.net/2024/03/25/sTH5thkGBKiJvdy.png" alt="docker"></p><p>NVIDIA 容器工具包允许用nvidai户构建和运行 GPU 加速容器。该工具包包括一个容器运行时<a href="https://github.com/NVIDIA/libnvidia-container">库</a>和实用程序，用于自动配置容器以利用 NVIDIA GPU。产品文档（包括体系结构概述、平台支持以及安装和使用指南）可以在<a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html">文档存储库</a>中找到。</p><p>需要注意的是，这里的使用的docker无需安装Nvidia Toolkit，但是需要在宿主机上安装Nvidia的驱动来支撑运行，</p><p>首先需要配置仓库信息：</p><pre><code class="language-bash">curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \  &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \    sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \    sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list</code></pre><p>这里把命令行拉的长一点看的清楚一点：</p><p><img src="https://s2.loli.net/2024/03/25/IMOomtcPW7uUZJl.png" alt="image-20240325151700669"></p><p>使用如下命令：</p><pre><code class="language-bash">sudo apt-get update</code></pre><p><img src="https://s2.loli.net/2024/03/25/BOImxtPeWRpTZ9G.png" alt="image-20240325153736177"></p><p>开始安装：</p><pre><code class="language-sh">sudo apt-get install -y nvidia-container-toolkit</code></pre><p>安装完成之后开始配置部分：</p><p>使用nvidia-ctk命令修改docker在宿主机上的配置文件，来让Docker能使用 NVIDIA Container Runtime：</p><pre><code class="language-sh">sudo nvidia-ctk runtime configure --runtime=docker</code></pre><p><img src="https://s2.loli.net/2024/03/25/AXYErZSMo6tBGxK.png" alt="image-20240325154515232"></p><h3><span id="运行docker部署测试">运行docker部署测试</span></h3><p>先跑一个简单一点的测试：</p><p>使用命令创建一个Ubuntu的镜像，并输出容器内GPU的信息</p><pre><code class="language-sh">Neo@Bionet:~/Desktop$ docker run --rm --runtime=nvidia --gpus all ubuntu nvidia-smi</code></pre><p>结果如下：</p><pre><code class="language-sh">Neo@Bionet:~/Desktop$ docker run --rm --runtime=nvidia --gpus all ubuntu nvidia-smiMon Mar 25 09:15:30 2024       +---------------------------------------------------------------------------------------+| NVIDIA-SMI 535.161.07             Driver Version: 535.161.07   CUDA Version: 12.2     ||-----------------------------------------+----------------------+----------------------+| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC || Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. ||                                         |                      |               MIG M. ||=========================================+======================+======================||   0  NVIDIA GeForce RTX 2080 Ti     Off | 00000000:04:00.0 Off |                  N/A ||  0%   28C    P8              17W / 300W |      1MiB / 11264MiB |      0%      Default ||                                         |                      |                  N/A |+-----------------------------------------+----------------------+----------------------+|   1  NVIDIA GeForce RTX 4090        Off | 00000000:09:00.0 Off |                  Off ||  0%   31C    P8              34W / 450W |      1MiB / 24564MiB |      0%      Default ||                                         |                      |                  N/A |+-----------------------------------------+----------------------+----------------------+|   2  NVIDIA GeForce RTX 2080 Ti     Off | 00000000:86:00.0 Off |                  N/A ||  0%   28C    P8              12W / 300W |      1MiB / 11264MiB |      0%      Default ||                                         |                      |                  N/A |+-----------------------------------------+----------------------+----------------------+|   3  NVIDIA GeForce RTX 3090        Off | 00000000:8A:00.0 Off |                  N/A ||  0%   27C    P8              20W / 370W |      1MiB / 24576MiB |      0%      Default ||                                         |                      |                  N/A |+-----------------------------------------+----------------------+----------------------+                                                                                         +---------------------------------------------------------------------------------------+| Processes:                                                                            ||  GPU   GI   CI        PID   Type   Process name                            GPU Memory ||        ID   ID                                                             Usage      ||=======================================================================================||  No running processes found                                                           |+---------------------------------------------------------------------------------------+</code></pre><p>接着测试代码任务，使用命令安装一个镜像，然后配置环境之后打包成新的镜像保存下来供大家使用：</p><p>执行以下命令之前需要使用，命令：</p><pre><code class="language-bash">newgrp docker</code></pre><p>来刷新一下用户组信息，当然前提是你的账户已经被添加到用户组了，否则需要联系管理员处理。</p><pre><code class="language-sh">docker run  -it -p 10003:22 -p 10004:10002 --name pytorch \ -v /etc/timezone:/etc/timezone \ -v /etc/localtime:/etc/localtime \ -v /home/Neo/WorkSpace/_Share:/home/workspace/_share  \ --gpus all nvidia/cuda:12.2.2-cudnn8-runtime-ubuntu22.04</code></pre><p><code>-v /etc/timezone:/etc/timezone</code> 和 <code>-v /etc/localtime:/etc/localtime</code>：这两个选项用于将宿主机的 <code>/etc/timezone</code> 和 <code>/etc/localtime</code> 文件挂载到容器内对应的位置，以确保容器内的时间设置与宿主机一致。</p><p><code>-v /home/Neo/WorkSpace/_Share:/home/workspace/_share</code>：这个选项将宿主机上的 <code>/home/Neo/WorkSpace/_Share</code> 目录挂载到容器内的 <code>/home/workspace/_share</code> 目录，以实现宿主机和容器之间的共享文件。</p><p>每个标签都具有以下格式：</p><p><strong>11.4.0-base-ubuntu20.04</strong>docker</p><ul><li>11.4.0 – CUDA version.</li><li>base – Image flavor.  <strong>Image的变种类型，常见有base runtime等，有不同功能。</strong></li><li>ubuntu20.04 – Operating system version.</li></ul><p>目前有什么Tags，请参考：</p><p><a href="https://hub.docker.com/r/nvidia/cuda/tags">nvidia/cuda Tags | Docker Hub</a></p><p>这里需要注意的是：cuda tollkit的版本要和驱动的版本匹配：</p><p>详见：<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">1. CUDA 12.4 Release Notes — Release Notes 12.4 documentation (nvidia.com)</a></p><img src="https://s2.loli.net/2024/03/26/QY2W4txbGJ1zgBv.png" alt="image-20240326131315726" style="zoom:80%;"><p>同时需要把对应的端口映射出来，SSH端口是22，从容器中映射出来，映射到主机的10001端口。同时保留一个10002端口以备不时之需。</p><img src="https://s2.loli.net/2024/04/02/nVM3ioc69xewlbF.png" alt="image-20240325173154854" style="zoom: 80%;"><p>此时就进入了docker之中，可以愉快的运行了~</p><img src="https://s2.loli.net/2024/03/25/UGgEQ1p2wmIt8TC.png" alt="image-20240325221935676" style="zoom:80%;"><p>我们把裸机的例子拿来再跑一遍看看有什么效果~</p><pre><code class="language-shell">root@54990fb612d5:/# nvidia-smi</code></pre><p>你如果仔细看这张图就看到了docker的真正优点：在于CUDA版本的切换！这里的cuda版本成功切换到12.3版本~</p><img src="https://s2.loli.net/2024/03/25/ReDn2iNISfszZxm.png" alt="image-20240325173527240" style="zoom:80%;"><p>当然你在容器里面随便操作也不会太影响其他人，这是最棒的优点。</p><h3><span id="此处应使用dockerfile来配置后续更新先手动"><strong>此处应使用dockerfile来配置，后续更新，先手动。</strong></span></h3><p>接下来安装一些必要的工具来方便后边的开发：</p><pre><code class="language-sh">apt updateapt-get install sudosudo apt-get install -y vim git curl unzip net-tools openssh-server</code></pre><p>修改源：</p><pre><code class="language-bash">sudo vim /etc/apt/sources.list</code></pre><p>将以下内容填入：</p><p>适用 22.04：</p><pre><code class="language-bash">deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse# deb https://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse# deb-src https://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</code></pre><p>适用 20.04：</p><pre><code class="language-bash">deb https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse# deb https://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse# deb-src https://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</code></pre><p>记得再次升级：</p><pre><code class="language-sh">sudo apt updatesudo apt upgrade</code></pre><p>当然别忘记设置密码：</p><pre><code class="language-sh">root@49906fdf69a6:/# passwd rootNew password: Retype new password: passwd: password updated successfully</code></pre><p>配置容器内的SSH：</p><pre><code class="language-sh">echo "PermitRootLogin yes"&gt;&gt;/etc/ssh/sshd_configecho "export VISIBLE=now" &gt;&gt;/etc/profile</code></pre><p><code>echo "PermitRootLogin yes"&gt;&gt;/etc/ssh/sshd_config</code>添加一段信息到sshd_config中。</p><p><code>echo "export VISIBLE=now" &gt;&gt; /etc/profile</code>：向 <code>/etc/profile</code> 文件中添加一行 <code>export VISIBLE=now</code>，这个设置使得 SSH 会话可以在登录时创建 <code>utmp</code> 记录，使得用户能够在 <code>w</code> 或 <code>who</code> 命令中看到 SSH 登录的用户信息。</p><p>然后运行重启：</p><pre><code class="language-shell">service ssh restart</code></pre><p>这时候你如果打开另一个宿主机命令行运行以下命令可以看到：</p><pre><code class="language-bash">Neo@Bionet:~/Desktop$ docker port pytorch 220.0.0.0:10003[::]:10003</code></pre><p>这时候我们打开一个远程的命令行来来连接一下容器：</p><pre><code class="language-bash">ssh root@10.26.58.61 -p 10003</code></pre><img src="https://s2.loli.net/2024/03/25/OGcCnmvXyBYQMlT.png" alt="image-20240325224800133" style="zoom: 80%;"><p>这时候我们就成功进入啦，到这里已经完成一个镜像的50%了，我们还需要安装python环境，这里选择miniconda来作为虚拟Python环境运行，或者你觉得麻烦，直接用pip也可以，这里不赘述pip方案，这里选择conda 方案。</p><p>额外注意如果你出现以下报错：</p><pre><code class="language-bash">PS C:\Users\NeoNexus\Desktop&gt; ssh root@10.26.58.61 -p 10003@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ED25519 key sent by the remote host isSHA256:8jZY1c5+1VHkr9H0HoLXl6dV6c/oGj1i6HlsPsUCjPA.Please contact your system administrator.Add correct host key in C:\\Users\\NeoNexus/.ssh/known_hosts to get rid of this message.Offending ECDSA key in C:\\Users\\NeoNexus/.ssh/known_hosts:9Host key for [10.26.58.61]:10003 has changed and you have requested strict checking.</code></pre><p>同样的问题在vscode中报错如下：</p><p><img src="https://s2.loli.net/2024/03/26/4KidMqgxcREQInX.png" alt="image-20240326125312882"></p><p>请按照下图删除对应内容即可</p><p><img src="https://s2.loli.net/2024/03/26/cg56lzJjRbsOVW2.png" alt="image-20240326125202797"></p><p>再来安装miniconda：</p><p>首先去官网下载好miniconda的安装包，地址如下：</p><p><a href="https://docs.anaconda.com/free/miniconda/index.html">Miniconda — Anaconda documentation</a></p><p><img src="https://s2.loli.net/2024/03/26/vSbVclCLysOPtIh.png" alt="image-20240326100332914"></p><p>这里就安装在默认的位置，这样好安排一点，就不做路径修改了。</p><pre><code class="language-bash">root@6ee3c0747be2:/# echo "PermitRootLogin yes"&gt;&gt;/etc/ssh/sshd_configroot@6ee3c0747be2:/# echo "export VISIBLE=now" &gt;&gt;/etc/profileroot@6ee3c0747be2:/# service ssh restart * Restarting OpenBSD Secure Shell server sshd                                                                                                                                                         [ OK ] root@6ee3c0747be2:/# cd /home/workspace/_share/root@6ee3c0747be2:/home/workspace/_share# chmod +x Miniconda3-latest-Linux-x86_64.sh root@6ee3c0747be2:/home/workspace/_share# sudo ./Miniconda3-latest-Linux-x86_64.sh </code></pre><p><img src="https://s2.loli.net/2024/03/26/GDHy16CMAheYm9R.png" alt="image-20240326101023244"></p><p><img src="https://s2.loli.net/2024/03/26/2LlMjI9KXRaTzdq.png" alt="image-20240326101132042"></p><p><img src="https://s2.loli.net/2024/03/26/uTxGIA75yfitWJL.png" alt="image-20240326101254365"></p><p>安装完成之后我们可以使用了，这时候需要推出一下容器的命令行然后再进入：</p><pre><code class="language-bash">root@49906fdf69a6:/home/workspace/_share# exitexitNeo@Bionet:~/Desktop$ docker ps -aCONTAINER ID   IMAGE                                    COMMAND                  CREATED        STATUS        PORTS                                                                                    NAMES49906fdf69a6   nvidia/cuda:12.3.2-runtime-ubuntu22.04   "/opt/nvidia/nvidia_…"   12 hours ago   Up 12 hours   0.0.0.0:10003-&gt;22/tcp, :::10003-&gt;22/tcp, 0.0.0.0:10004-&gt;10002/tcp, :::10004-&gt;10002/tcp   pytorchNeo@Bionet:~/Desktop$ docker exec -it pytorch /bin/bash#这时候就会看到conda的启动，我们直接安装pytorch来运行一下上边的测试代码，不同的是我们这次使用vscode来远程连接docker。(base) root@49906fdf69a6:/# (base) root@49906fdf69a6:/# </code></pre><p>vscode通过SSH连接之后我们创建一个test文件夹在这里，同时把测试代码复制过来：</p><img src="https://s2.loli.net/2024/03/26/4h2sKfOWkv7zARq.png" alt="image-20240326102200378" style="zoom: 80%;"><p>将推荐的插件安装一下：</p><img src="https://s2.loli.net/2024/03/26/QVI764NsxBRSdi1.png" alt="image-20240326102347258" style="zoom:80%;"><p>选择方才的conda来使用：</p><img src="https://s2.loli.net/2024/03/26/1ceMju2y48dNrqw.png" alt="image-20240326102527175" style="zoom:80%;"><p><img src="https://s2.loli.net/2024/03/26/PMwArnD9lWTUb1a.png" alt="image-20240326102657022"></p><p>选择完成之后会自动帮你创建一个新的虚拟环境：</p><p><img src="https://s2.loli.net/2024/03/26/AQ6iHkPvRcGJqtD.png" alt="image-20240326102742908"></p><p>我们来打开terminal来安装一下pytorh环境：</p><p><img src="https://s2.loli.net/2024/03/26/N8Bou4eOazdYyit.png" alt="image-20240326102842940"></p><p>使用命令如下：</p><pre><code class="language-bash">conda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia</code></pre><img src="https://s2.loli.net/2024/03/26/ym1x8NOrXRBJt9s.png" alt="image-20240326102939664" style="zoom:80%;"><p>在其下载的同时我们来看一下性能的消耗：</p><img src="https://s2.loli.net/2024/03/26/QVdepj3Bok8PsAY.png" alt="image-20240326103216672" style="zoom:80%;"><p>点击右上角直接执行，运行结果如下：</p><img src="https://s2.loli.net/2024/03/26/ShvL5FToCAB2K37.png" alt="image-20240326103713020" style="zoom:80%;"><p>你仔细看会看到这里实际上运行的设备是cpu！这是不对的，因为cuda版本驱动版本不匹配导致的，修改后（就是上边的命令已经修改好了，你正常安装应该是我下边的结果）：</p><p><img src="https://s2.loli.net/2024/03/26/fqHr6MlpiGsvg5h.png" alt="image-20240326134143504"></p><p>我们将镜像打包一下方便以后用：</p><p>命令格式：</p><pre><code class="language-bash">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></pre><pre><code class="language-bash">docker commit  -a Neo -m "first commit" pytorch pytorch221_cuda122</code></pre><p>打包完成之后使用docker images查看：</p><img src="https://s2.loli.net/2024/03/26/XbuxyQOUsipekVH.png" alt="image-20240326111101210" style="zoom:80%;"><p>打包成镜像以后，要保存成tar方便传输：</p><pre><code class="language-bash">docker save [OPTIONS] IMAGE [IMAGE...]</code></pre><p>示例：</p><pre><code class="language-bash">docker save -o pytorch221_cuda122 pytorch</code></pre><h3><span id="选配rootless来操作docker-daemon">选配：rootless来操作docker daemon</span></h3><p>根据提示restart一下docker：</p><pre><code class="language-sh">systemctl --user restart docker</code></pre><pre><code>Neo@Bionet:~/Desktop$ systemctl --user restart dockerFailed to restart docker.service: Unit docker.service not found.</code></pre><img src="https://s2.loli.net/2024/03/25/wFPKalfxHhJSZYO.png" alt="image-20240325165138808" style="zoom:80%;"><p>实际上只是添加了几个参数：</p><img src="https://s2.loli.net/2024/03/25/RjUeq6KVMvuT7OZ.png" alt="image-20240325165226532" style="zoom:67%;"><p>这里暂停，因为服务器权限不开放，所以暂停这样使用。</p><h1><span id="参考文章">参考文章</span></h1><p><a href="https://www.cnblogs.com/citrus/p/13385176.html">Ubuntu - 测试硬盘读写速度 - Citrusliu - 博客园 (cnblogs.com)</a></p><p><a href="https://www.weizhiyong.com/archives/1436">Ubuntu 20.04安装XRDP远程桌面服务及xfce轻量桌面 – 技术什锦派 (weizhiyong.com)</a></p><p><a href="https://juejin.cn/post/7275977439657377844">Ubuntu 20.04 安装xfce4桌面、Xrdp远程桌面 - 掘金 (juejin.cn)</a></p><p><a href="https://www.myfreax.com/how-to-install-xrdp-on-ubuntu-20-04/">如何在 Ubuntu 20.04 安装 Xrdp 服务器 | myfreax</a></p><p><a href="https://www.helpwire.app/blog/remote-desktop-transfer-files/">How To Transfer Files Over Remote Desktop (All You Need To Know) (helpwire.app)</a></p><p>[debian 关闭gnome-掘金 (<a href="http://juejin.cn">juejin.cn</a>)](<a href="https://juejin.cn/s/debian">https://juejin.cn/s/debian</a> 关闭gnome)</p><p><a href="https://zhuanlan.zhihu.com/p/336429888">【保姆级教程】个人深度学习工作站配置指南 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/467200809">linux之用户和权限管理（干货） - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/xdx_dili/article/details/132733472">Linux——用户和权限、用户组管理、权限管理_用户权限跟组权限的关系linux-CSDN博客</a></p><p><a href="https://www.cnblogs.com/cwp-bg/p/8257843.html">/etc/profile、/etc/bashrc、~/.bash_profile、~/.bashrc 文件的作用 - 倥偬时光 - 博客园 (cnblogs.com)</a></p><p><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html">1. Introduction — Installation Guide for Linux 12.4 documentation (nvidia.com)</a></p><p><a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=22.04&amp;target_type=runfile_local">CUDA Toolkit 12.4 Downloads | NVIDIA Developer</a></p><p><a href="https://hub.docker.com/r/nvidia/cuda/tags">nvidia/cuda Tags | Docker Hub</a></p><p><a href="https://blog.csdn.net/tangjiahao10/article/details/125225786">【Linux】CUDA Toolkit和cuDNN版本对应关系（更新至2022年6月，附官网永久更新链接）_cuda12.0对应cudnn-CSDN博客</a></p><p><a href="https://www.cnblogs.com/yaoqingzhuan/p/10889718.html">linux添加环境变量 - ilovetesting - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/jingzh/p/17397843.html">Anaconda下载与安装详解 - 上善若泪 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/u014636245/article/details/83933402">【anaconda】激活环境失败-bash: activate:No such file/没有那个文件或目录_bash: activate: no such file or directory-CSDN博客</a></p><p><a href="https://circleci.com/blog/ssh-into-docker-container/">How to SSH into Docker containers | CircleCI</a></p><p><a href="https://blog.csdn.net/winter2121/article/details/118223637">ssh连接docker容器；docker容器设置root密码_docker容器root用户密码-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_33259057/article/details/124737659">使用Docker容器配置ssh服务，远程直接进入容器_ssh连接docker容器 群晖-CSDN博客</a></p><p><a href="https://circleci.com/blog/ssh-into-docker-container/">如何通过 SSH 连接到 Docker 容器 |CircleCI的</a></p><p><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu | Docker Docs</a></p><p><a href="https://docs.docker.com/engine/install/linux-postinstall/">Linux post-installation steps for Docker Engine | Docker Docs</a></p><p><a href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository">Install Docker Engine on Ubuntu | Docker Docs</a></p><p><a href="https://docs.docker.com/engine/security/rootless/">Run the Docker daemon as a non-root user (Rootless mode) | Docker Docs</a></p>]]></content>
      
      
      <categories>
          
          <category> Bionet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bionet </tag>
            
            <tag> ops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm使用技巧（1）——编辑基础部分</title>
      <link href="/2023/10/21/PyCharm%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/"/>
      <url>/2023/10/21/PyCharm%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1><span id="pycharm使用技巧1编辑基础部分">PyCharm使用技巧（1）——编辑基础部分</span></h1><h2><span id="提示图床在国外且动图比较多的情况下需要时间加载">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2><h2><span id="目录">目录：</span></h2><!-- toc --><ul><li><a href="#%E7%BC%96%E8%BE%91%E5%9F%BA%E7%A1%80">编辑基础</a><ul><li><a href="#context-action-%E4%B8%8A%E4%B8%8B%E6%96%87%E8%81%94%E6%83%B3%E5%8A%A8%E4%BD%9C-keymapalt-enter">Context action (上下文联想动作)  KeyMap：ALT + ENTER</a></li><li><a href="#expand-and-shrink-the-code-selection%E6%89%A9%E5%B1%95%E5%92%8C%E7%BC%A9%E5%B0%8F%E4%BB%A3%E7%A0%81%E9%80%89%E6%8B%A9-keymapctrl-w">Expand and shrink the code selection（扩展和缩小代码选择） KeyMap：CTRL +  W</a></li><li><a href="#duplicate-and-delete-lines%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E5%92%8C%E5%88%A0%E9%99%A4%E8%A1%8Ckeymapctrl-d">Duplicate and delete lines（快速复制和删除行）KeyMap：CTRL + D</a></li><li><a href="#move-code-fragments%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8-keymapalt-ctrl-shift">Move code fragments（代码片段快速移动） KeyMap：ALT / CTRL  +  Shift  +  ⬇ / ⬆</a></li><li><a href="#surround-and-unwrap-%E7%8E%AF%E7%BB%95%E6%A8%A1%E6%9D%BF%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E6%80%A7%E5%88%A0%E9%99%A4keymapalt-t-ctrl-shift-delete">Surround and unwrap （环绕模板与代码结构性删除）KeyMap：ALT + T /  CTRL + Shift + Delete</a></li><li><a href="#multiple-selection-%E5%A4%9A%E9%87%8D%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9keymap-alt-j-ctrl-alt-shift-j">Multiple selection （多重快速选择）KeyMap ：ALT + J  /  CTRL  +  ALT  +  Shift  +  J</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><img src="https://s2.loli.net/2023/10/23/UvSq4AxVNdbzeWC.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1698049838504" style="zoom:67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1695021721029" style="zoom:67%;"><h2><span id="编辑基础">编辑基础</span></h2><h3><span id="context-action-上下文联想动作-keymapalt-enter">Context action (上下文联想动作)  KeyMap：ALT + ENTER</span></h3><p>你可以在几乎任何上下文中调用<strong>Context action</strong>。比如在下面代码中：</p><pre><code class="language-python">def method_with_unused_parameter(used, redundant):    print("It is used parameter: " + str(used))def intention_example(a, b):    if not (a and b):        return 1    return 2method_with_unused_parameter("first", "second")method_with_unused_parameter("used", "unused")intention_example(True, False)</code></pre><p>针对上边的代码按下<code>ALT</code> + <code>ENTER</code>此时PyCharm会根据上下文环境来推测你想要的行动，<img src="https://s2.loli.net/2023/10/22/Wm1EDKLAzbFH4i2.png" alt="image-20231022221515732" style="zoom:150%;"></p><p>这里就推测出第二个参数没有什么用会自动帮你移除第二个参数.</p><p>可以看到整个代码部分对应的无用参数都被移除了：</p><p><img src="https://s2.loli.net/2023/10/22/tEnWoFUckKyagmA.png" alt="image-20231022221913479"></p><p>同时Context action也能提供逻辑优化等操作：</p><p>还是上边的代码，我们注重这一行：</p><p><img src="https://s2.loli.net/2023/10/22/cQ3byIvaHGo8fkB.png" alt="image-20231022222939162"></p><p>我们在and这里使用快捷键<code>ALT</code> + <code>ENTER</code>：根据德摩根法则其可以优化成：</p><p><img src="https://s2.loli.net/2023/10/22/93obW4BqQEcOtRe.png" alt="image-20231022222733594"></p><h3><span id="expand-and-shrink-the-code-selection扩展和缩小代码选择-keymapctrl-w">Expand and shrink the code selection（扩展和缩小代码选择） KeyMap：CTRL +  W</span></h3><p>有如下代码：</p><pre><code class="language-python">def some_method(first, second, third):    print(first, second, third)def example_method(condition):    if condition:        print("Begin of the work")        some_method("first string", "This is a long string that you can select for refactoring", "third string")        print("End of the work")    print("The end")</code></pre><p>你想选择<code>that</code>单词，常规做法是双击，在这里你可以使用<code>CTRL + W</code>来实现操作：</p><p><img src="https://s2.loli.net/2023/10/22/68gRUyi2tFfehSV.png" alt="image-20231022223705647"></p><p>效果如下：</p><p><img src="https://s2.loli.net/2023/10/23/K5Np9UElIOzZwYP.png" alt="image-20231022223859938"></p><p>此时你需要选择整个字符串，无需动鼠标，<code>CTRL+W</code>即可实现对应操作：</p><p><img src="https://s2.loli.net/2023/10/22/oVF3ZNhwjx7QDMn.png" alt="image-20231022224043310"></p><p>当然你连续按下三次<code>CTRL+W</code>，你就可选择整个引用内容，包含引号：</p><p><img src="https://s2.loli.net/2023/10/22/CEWYKtswjuA6Pcb.png" alt="image-20231022231031499"></p><p>当然你连续按下四次<code>CTRL+W</code>，你就可选择整个调用内容：</p><p><img src="https://s2.loli.net/2023/10/22/KyXmx9pB3IZhACa.png" alt="image-20231022231548555"></p><p>当然有时候会有不小心按错，使用快捷键<code>CTRL+Shift+W</code>就可以回退：</p><p><img src="https://s2.loli.net/2023/10/22/qO2Cj7UDyYV1cNv.png" alt="image-20231022232010023"></p><p>在if后边，两次CTRL+W就可以选择整个if表达，十分快捷：</p><p><img src="https://s2.loli.net/2023/10/22/n81dtaj2uXmOQlW.png" alt="image-20231022232157648"></p><h3><span id="duplicate-and-delete-lines快速复制和删除行keymapctrl-d">Duplicate and delete lines（快速复制和删除行）KeyMap：CTRL + D</span></h3><p>当你想快速复制某一行代码的时候，如下所示：</p><p><img src="https://s2.loli.net/2023/10/22/hxuCcEXa7es9k5Z.png" alt="image-20231022233258128"></p><p>将光标放在此处按下 CTRL+D，快速复制此行：</p><p><img src="https://s2.loli.net/2023/10/22/1lzJn3ySCUhR9NL.png" alt="image-20231022233542868"></p><p>当你需要复制多行的时候：</p><p><img src="https://s2.loli.net/2023/10/22/fUzrZhDaXqdQVYW.png" alt="image-20231022233522113"></p><p>完成复制：<img src="https://s2.loli.net/2023/10/22/i2AxcjtTroqQm61.png" alt="image-20231022233701314"></p><p>快速删除行的时候使用<code>CTRL+Y</code>快捷键实现行删除。</p><h3><span id="move-code-fragments代码片段快速移动-keymapalt-ctrl-shift">Move code fragments（代码片段快速移动） KeyMap：ALT / CTRL  +  Shift  +  ⬇ / ⬆</span></h3><p>重新排序代码往往需要两个过程，剪切和粘贴，而通过Pycharm可以快速实现代码的重排序：</p><p>如下代码片段，我们想将输出放到代码更新后：</p><p><img src="https://s2.loli.net/2023/10/23/mxWQFl7pPgheBYA.gif" alt="2"></p><p>到这里你也许会感觉有点鸡肋，但是如果他能整个方法，整个结构一起移动呢？</p><p>我们将光标放到方法名称前，然后按下快捷键<code>CTRL + Shift +  ⬆</code>，实现整个方法的迁移：</p><p><img src="https://s2.loli.net/2023/10/23/LiNvx31OsGTWReQ.gif" alt="1"></p><h3><span id="surround-and-unwrap-环绕模板与代码结构性删除keymapalt-t-ctrl-shift-delete">Surround and unwrap （环绕模板与代码结构性删除）KeyMap：ALT + T /  CTRL + Shift + Delete</span></h3><p>通常对结构化的代码如<code>if</code>等，需要在外围添加<code>while</code>或者<code>trycatch</code>通常需要进行多步操作，通过环绕代码模板可以快速进行填充，同时也可以使用结构性抹除进行删减，如下面代码：</p><p><img src="https://s2.loli.net/2023/10/23/GBq8xD9aFpMhiOW.gif" alt="3"></p><h3><span id="multiple-selection-多重快速选择keymap-alt-j-ctrl-alt-shift-j">Multiple selection （多重快速选择）KeyMap ：ALT + J  /  CTRL  +  ALT  +  Shift  +  J</span></h3><p>通常我们在使用Pycharm的时候也会有需求去处理HTML等非常标签化的语言，修改的时候需要前后标签一起修改，鼠标移动的话非正常不方便，Pycharm提供了较为方便的操作多重选择，多重选择后直接进入了编辑模式可以对多个对象同时编辑，见如下代码：</p><p><img src="https://s2.loli.net/2023/10/23/MOfGU7n2ovBZayc.gif" alt="4"></p>]]></content>
      
      
      <categories>
          
          <category> Pycharm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm使用技巧（2）——代码补全</title>
      <link href="/2023/10/21/PyCharm%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8/"/>
      <url>/2023/10/21/PyCharm%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1><span id="pycharm使用技巧2代码补全">PyCharm使用技巧（2）——代码补全</span></h1><h2><span id="提示图床在国外且动图比较多的情况下需要时间加载">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2><h2><span id="目录">目录：</span></h2><!-- toc --><ul><li><a href="#%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8">代码补全</a><ul><li><a href="#basic-completion-%E5%9F%BA%E6%9C%AC%E8%A1%A5%E5%85%A8-keymapalt-a">Basic completion （基本补全）  KeyMap：ALT + A</a><ul><li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li></ul></li><li><a href="#tab-completion-tab%E8%A1%A5%E5%85%A8-keymapalt-a-tab-enter">Tab completion （Tab补全）  KeyMap：ALT + A  + Tab  /  Enter</a><ul><li><a href="#%E6%B3%A8%E6%84%8F-1">注意</a></li></ul></li><li><a href="#postfix-completion-%E5%90%8E%E7%BC%80%E8%A1%A5%E5%85%A8-keymap">Postfix Completion  （后缀补全）   KeyMap：.</a></li><li><a href="#type-matching-completion-%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E8%A1%A5%E5%85%A8-keymap-ctrl-shift-space-%E7%A9%BA%E6%A0%BC">Type-matching completion  （类型匹配补全） KeyMap: Ctrl + Shift + Space (空格)</a></li><li><a href="#f-string-completion-f-string%E8%A1%A5%E5%85%A8-keymapnone">F-string completion  F-string补全  KeyMap:None</a></li></ul></li></ul><!-- tocstop --><p>[TOC]</p><img src="https://s2.loli.net/2023/11/23/wy1u6H7pXNJfIdx.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1700749534081" style="zoom:67%;"><img src="https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg" alt="[lab.magiconch.com][福音戰士標題生成器]-1695021721029" style="zoom:67%;"><h2><span id="代码补全">代码补全</span></h2><h3><span id="basic-completion-基本补全-keymapalt-a">Basic completion （基本补全）  KeyMap：ALT + A</span></h3><p>默认情况下PyCharm会自动给你进行提示，当日输入内容的时候就会进行补全，但是某些情况下并不会立马给你提示，尤其是在你没有输入的时候，那么如何主动唤醒补全呢？</p><p>在我的设置中可以使用快捷键<code>ALT + A</code> 来实现主动唤醒，效果如下：</p><p><img src="https://s2.loli.net/2023/11/23/M13iBtAVOxPEb2u.gif" alt="4"></p><h4><span id="注意">注意</span></h4><p>注意这里和编辑基础的<strong>Context action (上下文联想动作)</strong>  KeyMap：ALT + ENTER 并不一样，Context action 推测的是动作，补全针对的是内容。</p><p>下图展示了如果使用Context action 的效果：</p><p><img src="https://s2.loli.net/2023/11/23/7ec5LU648ZRwqQO.png" alt="image-20231123210159827"></p><h3><span id="tab-completion-tab补全-keymapalt-a-tab-enter">Tab completion （Tab补全）  KeyMap：ALT + A  + Tab  /  Enter</span></h3><p>在基本补全产生的浮空标签页中，我们不仅可以针对需要写的内容进行补全，也可以对已经存在的某一个或者某一类对象进行修改，下图展示了如何针对已存在对象进行补全：</p><p>下图为了修改<code>current</code>为<code>total</code>我们使用主动唤醒补全来实现，然后按下<code>ALT + A  + Tab</code> 来实现替换，但是并不着急，这里并不是说只能实现替换功能，我们也可以通过<code>ALT + A  + Enter</code>来实现插入功能，正如动图前边的内容所展示的插入操作：</p><p><img src="https://s2.loli.net/2023/11/23/qsJceV6GCdyubzp.gif" alt="4"></p><h4><span id="注意">注意</span></h4><p>注意光标所在位置所产生的影响，动图的中也展示了光标进行左右移动的时候浮空标签页所展示内容也是不同的。</p><h3><span id="postfix-completion-后缀补全-keymap">Postfix Completion  （后缀补全）   KeyMap：.</span></h3><p>后缀补全，后翎补全有助于在写代码时成少向前转光标您可以根据添加的后绍、表达式的类型及其上下文，将已键入的表达式转换成另一种形式在图括号后面罐入<code>.</code>以查看建议列表。</p><p>下图展示了如何从表达式后边直接修改表达式内容。</p><p><img src="https://s2.loli.net/2023/11/23/ZMPthgbOIFC7sW3.gif" alt="5"></p><h3><span id="type-matching-completion-类型匹配补全-keymap-ctrl-shift-space-空格">Type-matching completion  （类型匹配补全） KeyMap: Ctrl + Shift + Space (空格)</span></h3><p>我最讨厌的PyCharm的就是整个教程讲的一点也不清楚，但是至少他还给你做个教程，属实难绷，下面这里就是让人最理解的地方：</p><p>这里引入了Type-matching completion，虽然名字叫这个，但实际上在教程上起了一个更加迷惑的名字叫<strong>Smart Completion</strong>，当使用Basic completion 基本补全无效的时候，也就是说无法直接获取对象的信息的时候，可以使用<code>Ctrl + Shift + Space</code>来实现通过上下文信息推断内容，这里不是很好用，仅限在于基本补全无法使用的时候比较好用。</p><p><img src="https://s2.loli.net/2023/11/23/qBFgcLrAEolTs4t.png" alt="image-20231123215819686"></p><p>具体操作见下图：</p><p><img src="https://s2.loli.net/2023/11/23/BrvsjOzaLp3FVwt.gif" alt="6"></p><h3><span id="f-string-completion-f-string补全-keymapnone">F-string completion  F-string补全  KeyMap:None</span></h3><p>PyCharm已经实现了支持F-string的补全，F-string是什么？</p><p>详见：<a href="https://docs.python.org/3/tutorial/inputoutput.html#tut-f-strings">7. Input and Output — Python 3.12.0 documentation</a></p><p>理解了F-string这里就不赘述了。</p><p><img src="https://s2.loli.net/2023/11/23/ErUegW1pAoX7l3c.gif" alt="7"></p>]]></content>
      
      
      <categories>
          
          <category> Pycharm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
